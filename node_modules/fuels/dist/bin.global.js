#!/usr/bin/env node
"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require2 = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require3() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter3) => {
    __accessCheck(obj, member, "read from private field");
    return getter3 ? getter3.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };

  // ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports, module) {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert2 = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      module.exports = convert2;
      for (const model of Object.keys(convert2)) {
        if (!("channels" in convert2[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert2[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert2[model].labels.length !== convert2[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const { channels, labels } = convert2[model];
        delete convert2[model].channels;
        delete convert2[model].labels;
        Object.defineProperty(convert2[model], "channels", { value: channels });
        Object.defineProperty(convert2[model], "labels", { value: labels });
      }
      convert2.rgb.hsl = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const min = Math.min(r, g, b);
        const max2 = Math.max(r, g, b);
        const delta = max2 - min;
        let h;
        let s;
        if (max2 === min) {
          h = 0;
        } else if (r === max2) {
          h = (g - b) / delta;
        } else if (g === max2) {
          h = 2 + (b - r) / delta;
        } else if (b === max2) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        const l = (min + max2) / 2;
        if (max2 === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max2 + min);
        } else {
          s = delta / (2 - max2 - min);
        }
        return [h, s * 100, l * 100];
      };
      convert2.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h;
        let s;
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const v = Math.max(r, g, b);
        const diff = v - Math.min(r, g, b);
        const diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = 0;
          s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert2.rgb.hwb = function(rgb) {
        const r = rgb[0];
        const g = rgb[1];
        let b = rgb[2];
        const h = convert2.rgb.hsl(rgb)[0];
        const w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert2.rgb.cmyk = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const k = Math.min(1 - r, 1 - g, 1 - b);
        const c = (1 - r - k) / (1 - k) || 0;
        const m = (1 - g - k) / (1 - k) || 0;
        const y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
      }
      convert2.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert2.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert2.rgb.xyz = function(rgb) {
        let r = rgb[0] / 255;
        let g = rgb[1] / 255;
        let b = rgb[2] / 255;
        r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
        g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
        b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert2.rgb.lab = function(rgb) {
        const xyz = convert2.rgb.xyz(rgb);
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.hsl.rgb = function(hsl) {
        const h = hsl[0] / 360;
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        const t1 = 2 * l - t2;
        const rgb = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert2.hsl.hsv = function(hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100;
        let l = hsl[2] / 100;
        let smin = s;
        const lmin = Math.max(l, 0.01);
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v = (l + s) / 2;
        const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert2.hsv.rgb = function(hsv) {
        const h = hsv[0] / 60;
        const s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6;
        const f2 = h - Math.floor(h);
        const p = 255 * v * (1 - s);
        const q = 255 * v * (1 - s * f2);
        const t = 255 * v * (1 - s * (1 - f2));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t];
          case 3:
            return [p, q, v];
          case 4:
            return [t, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert2.hsv.hsl = function(hsv) {
        const h = hsv[0];
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const vmin = Math.max(v, 0.01);
        let sl;
        let l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert2.hwb.rgb = function(hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f2;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i = Math.floor(6 * h);
        const v = 1 - bl;
        f2 = 6 * h - i;
        if ((i & 1) !== 0) {
          f2 = 1 - f2;
        }
        const n = wh + f2 * (v - wh);
        let r;
        let g;
        let b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert2.cmyk.rgb = function(cmyk) {
        const c = cmyk[0] / 100;
        const m = cmyk[1] / 100;
        const y = cmyk[2] / 100;
        const k = cmyk[3] / 100;
        const r = 1 - Math.min(1, c * (1 - k) + k);
        const g = 1 - Math.min(1, m * (1 - k) + k);
        const b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.rgb = function(xyz) {
        const x = xyz[0] / 100;
        const y = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r;
        let g;
        let b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.lab = function(xyz) {
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.lab.xyz = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let x;
        let y;
        let z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        const y2 = y ** 3;
        const x2 = x ** 3;
        const z2 = z ** 3;
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert2.lab.lch = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let h;
        const hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        const c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert2.lch.lab = function(lch) {
        const l = lch[0];
        const c = lch[1];
        const h = lch[2];
        const hr = h / 360 * 2 * Math.PI;
        const a = c * Math.cos(hr);
        const b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert2.rgb.ansi16 = function(args, saturation = null) {
        const [r, g, b] = args;
        let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert2.hsv.ansi16 = function(args) {
        return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
      };
      convert2.rgb.ansi256 = function(args) {
        const r = args[0];
        const g = args[1];
        const b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert2.ansi16.rgb = function(args) {
        let color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r = (color & 1) * mult * 255;
        const g = (color >> 1 & 1) * mult * 255;
        const b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert2.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        let rem;
        const r = Math.floor(args / 36) / 5 * 255;
        const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        const b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert2.rgb.hex = function(args) {
        const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string2 = integer.toString(16).toUpperCase();
        return "000000".substring(string2.length) + string2;
      };
      convert2.hex.rgb = function(args) {
        const match3 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match3) {
          return [0, 0, 0];
        }
        let colorString = match3[0];
        if (match3[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r = integer >> 16 & 255;
        const g = integer >> 8 & 255;
        const b = integer & 255;
        return [r, g, b];
      };
      convert2.rgb.hcg = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const max2 = Math.max(Math.max(r, g), b);
        const min = Math.min(Math.min(r, g), b);
        const chroma = max2 - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max2 === r) {
          hue = (g - b) / chroma % 6;
        } else if (max2 === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert2.hsl.hcg = function(hsl) {
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
        let f2 = 0;
        if (c < 1) {
          f2 = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f2 * 100];
      };
      convert2.hsv.hcg = function(hsv) {
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const c = s * v;
        let f2 = 0;
        if (c < 1) {
          f2 = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f2 * 100];
      };
      convert2.hcg.rgb = function(hcg) {
        const h = hcg[0] / 360;
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        const pure = [0, 0, 0];
        const hi = h % 1 * 6;
        const v = hi % 1;
        const w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert2.hcg.hsv = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        let f2 = 0;
        if (v > 0) {
          f2 = c / v;
        }
        return [hcg[0], f2 * 100, v * 100];
      };
      convert2.hcg.hsl = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const l = g * (1 - c) + 0.5 * c;
        let s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert2.hcg.hwb = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert2.hwb.hcg = function(hwb) {
        const w = hwb[1] / 100;
        const b = hwb[2] / 100;
        const v = 1 - b;
        const c = v - w;
        let g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert2.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert2.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert2.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert2.gray.hsl = function(args) {
        return [0, 0, args[0]];
      };
      convert2.gray.hsv = convert2.gray.hsl;
      convert2.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert2.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert2.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert2.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string2 = integer.toString(16).toUpperCase();
        return "000000".substring(string2.length) + string2;
      };
      convert2.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
  var require_route = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports, module) {
      var conversions = require_conversions();
      function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i = 0; i < len; i++) {
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph) {
        const path5 = [graph[toModel].parent, toModel];
        let fn = conversions[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path5.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path5;
        return fn;
      }
      module.exports = function(fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i = 0; i < len; i++) {
          const toModel = models[i];
          const node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports, module) {
      var conversions = require_conversions();
      var route = require_route();
      var convert2 = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          const result = fn(args);
          if (typeof result === "object") {
            for (let len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach((fromModel) => {
        convert2[fromModel] = {};
        Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert2[fromModel][toModel] = wrapRounded(fn);
          convert2[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert2;
    }
  });

  // ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
  var require_ansi_styles = __commonJS({
    "../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports, module) {
      "use strict";
      var wrapAnsi16 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `\x1B[${code + offset}m`;
      };
      var wrapAnsi256 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `\x1B[${38 + offset};5;${code}m`;
      };
      var wrapAnsi16m = (fn, offset) => (...args) => {
        const rgb = fn(...args);
        return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      var ansi2ansi = (n) => n;
      var rgb2rgb = (r, g, b) => [r, g, b];
      var setLazyProperty = (object2, property, get) => {
        Object.defineProperty(object2, property, {
          get: () => {
            const value = get();
            Object.defineProperty(object2, property, {
              value,
              enumerable: true,
              configurable: true
            });
            return value;
          },
          enumerable: true,
          configurable: true
        });
      };
      var colorConvert;
      var makeDynamicStyles = (wrap2, targetSpace, identity2, isBackground) => {
        if (colorConvert === void 0) {
          colorConvert = require_color_convert();
        }
        const offset = isBackground ? 10 : 0;
        const styles = {};
        for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
          const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
          if (sourceSpace === targetSpace) {
            styles[name] = wrap2(identity2, offset);
          } else if (typeof suite === "object") {
            styles[name] = wrap2(suite[targetSpace], offset);
          }
        }
        return styles;
      };
      function assembleStyles() {
        const codes = /* @__PURE__ */ new Map();
        const styles = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            // Bright color
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.gray = styles.color.blackBright;
        styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
        styles.color.grey = styles.color.blackBright;
        styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles)) {
          for (const [styleName, style] of Object.entries(group)) {
            styles[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
          });
        }
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
        styles.color.close = "\x1B[39m";
        styles.bgColor.close = "\x1B[49m";
        setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
        setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
        return styles;
      }
      Object.defineProperty(module, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    }
  });

  // ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
  var require_has_flag = __commonJS({
    "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module) {
      "use strict";
      module.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    }
  });

  // ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
  var require_supports_color = __commonJS({
    "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
      "use strict";
      var os2 = __require2("os");
      var tty = __require2("tty");
      var hasFlag = require_has_flag();
      var { env } = process;
      var forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        forceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = 1;
      }
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min = forceColor || 0;
        if (env.TERM === "dumb") {
          return min;
        }
        if (process.platform === "win32") {
          const osRelease = os2.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version2 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        return min;
      }
      function getSupportLevel(stream2) {
        const level = supportsColor(stream2, stream2 && stream2.isTTY);
        return translateLevel(level);
      }
      module.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel(supportsColor(true, tty.isatty(1))),
        stderr: translateLevel(supportsColor(true, tty.isatty(2)))
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/util.js
  var require_util = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/util.js"(exports, module) {
      "use strict";
      var stringReplaceAll = (string2, substring, replacer) => {
        let index = string2.indexOf(substring);
        if (index === -1) {
          return string2;
        }
        const substringLength = substring.length;
        let endIndex = 0;
        let returnValue = "";
        do {
          returnValue += string2.substr(endIndex, index - endIndex) + substring + replacer;
          endIndex = index + substringLength;
          index = string2.indexOf(substring, endIndex);
        } while (index !== -1);
        returnValue += string2.substr(endIndex);
        return returnValue;
      };
      var stringEncaseCRLFWithFirstIndex = (string2, prefix, postfix, index) => {
        let endIndex = 0;
        let returnValue = "";
        do {
          const gotCR = string2[index - 1] === "\r";
          returnValue += string2.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
          endIndex = index + 1;
          index = string2.indexOf("\n", endIndex);
        } while (index !== -1);
        returnValue += string2.substr(endIndex);
        return returnValue;
      };
      module.exports = {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/templates.js
  var require_templates = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/templates.js"(exports, module) {
      "use strict";
      var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = /* @__PURE__ */ new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", "\x1B"],
        ["a", "\x07"]
      ]);
      function unescape2(c) {
        const u = c[0] === "u";
        const bracket = c[1] === "{";
        if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        if (u && bracket) {
          return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      function parseArguments(name, arguments_) {
        const results = [];
        const chunks = arguments_.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          const number4 = Number(chunk);
          if (!Number.isNaN(number4)) {
            results.push(number4);
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
          }
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1];
          if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([name].concat(args));
          } else {
            results.push([name]);
          }
        }
        return results;
      }
      function buildStyle(chalk3, styles) {
        const enabled = {};
        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk3;
        for (const [styleName, styles2] of Object.entries(enabled)) {
          if (!Array.isArray(styles2)) {
            continue;
          }
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
        }
        return current;
      }
      module.exports = (chalk3, temporary) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
          if (escapeCharacter) {
            chunk.push(unescape2(escapeCharacter));
          } else if (style) {
            const string2 = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? string2 : buildStyle(chalk3, styles)(string2));
            styles.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk3, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
          } else {
            chunk.push(character);
          }
        });
        chunks.push(chunk.join(""));
        if (styles.length > 0) {
          const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMessage);
        }
        return chunks.join("");
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/index.js
  var require_source = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/index.js"(exports, module) {
      "use strict";
      var ansiStyles = require_ansi_styles();
      var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
      var {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      } = require_util();
      var levelMapping = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
      ];
      var styles = /* @__PURE__ */ Object.create(null);
      var applyOptions = (object2, options = {}) => {
        if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
          throw new Error("The `level` option should be an integer from 0 to 3");
        }
        const colorLevel = stdoutColor ? stdoutColor.level : 0;
        object2.level = options.level === void 0 ? colorLevel : options.level;
      };
      var ChalkClass = class {
        constructor(options) {
          return chalkFactory(options);
        }
      };
      var chalkFactory = (options) => {
        const chalk4 = {};
        applyOptions(chalk4, options);
        chalk4.template = (...arguments_) => chalkTag(chalk4.template, ...arguments_);
        Object.setPrototypeOf(chalk4, Chalk.prototype);
        Object.setPrototypeOf(chalk4.template, chalk4);
        chalk4.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        };
        chalk4.template.Instance = ChalkClass;
        return chalk4.template;
      };
      function Chalk(options) {
        return chalkFactory(options);
      }
      for (const [styleName, style] of Object.entries(ansiStyles)) {
        styles[styleName] = {
          get() {
            const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
            Object.defineProperty(this, styleName, { value: builder });
            return builder;
          }
        };
      }
      styles.visible = {
        get() {
          const builder = createBuilder(this, this._styler, true);
          Object.defineProperty(this, "visible", { value: builder });
          return builder;
        }
      };
      var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const model of usedModels) {
        styles[model] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      for (const model of usedModels) {
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      var proto = Object.defineProperties(() => {
      }, {
        ...styles,
        level: {
          enumerable: true,
          get() {
            return this._generator.level;
          },
          set(level) {
            this._generator.level = level;
          }
        }
      });
      var createStyler = (open, close, parent) => {
        let openAll;
        let closeAll;
        if (parent === void 0) {
          openAll = open;
          closeAll = close;
        } else {
          openAll = parent.openAll + open;
          closeAll = close + parent.closeAll;
        }
        return {
          open,
          close,
          openAll,
          closeAll,
          parent
        };
      };
      var createBuilder = (self2, _styler, _isEmpty) => {
        const builder = (...arguments_) => {
          return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
        };
        Object.setPrototypeOf(builder, proto);
        builder._generator = self2;
        builder._styler = _styler;
        builder._isEmpty = _isEmpty;
        return builder;
      };
      var applyStyle = (self2, string2) => {
        if (self2.level <= 0 || !string2) {
          return self2._isEmpty ? "" : string2;
        }
        let styler = self2._styler;
        if (styler === void 0) {
          return string2;
        }
        const { openAll, closeAll } = styler;
        if (string2.indexOf("\x1B") !== -1) {
          while (styler !== void 0) {
            string2 = stringReplaceAll(string2, styler.close, styler.open);
            styler = styler.parent;
          }
        }
        const lfIndex = string2.indexOf("\n");
        if (lfIndex !== -1) {
          string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
        }
        return openAll + string2 + closeAll;
      };
      var template;
      var chalkTag = (chalk4, ...strings) => {
        const [firstString] = strings;
        if (!Array.isArray(firstString)) {
          return strings.join(" ");
        }
        const arguments_ = strings.slice(1);
        const parts = [firstString.raw[0]];
        for (let i = 1; i < firstString.length; i++) {
          parts.push(
            String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
            String(firstString.raw[i])
          );
        }
        if (template === void 0) {
          template = require_templates();
        }
        return template(chalk4, parts.join(""));
      };
      Object.defineProperties(Chalk.prototype, styles);
      var chalk3 = Chalk();
      chalk3.supportsColor = stdoutColor;
      chalk3.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
      chalk3.stderr.supportsColor = stderrColor;
      module.exports = chalk3;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/error.js
  var require_error = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/error.js"(exports) {
      var CommanderError2 = class extends Error {
        /**
         * Constructs the CommanderError class
         * @param {number} exitCode suggested exit code which could be used with process.exit
         * @param {string} code an id string representing the error
         * @param {string} message human-readable description of the error
         * @constructor
         */
        constructor(exitCode, code, message) {
          super(message);
          Error.captureStackTrace(this, this.constructor);
          this.name = this.constructor.name;
          this.code = code;
          this.exitCode = exitCode;
          this.nestedError = void 0;
        }
      };
      var InvalidArgumentError2 = class extends CommanderError2 {
        /**
         * Constructs the InvalidArgumentError class
         * @param {string} [message] explanation of why argument is invalid
         * @constructor
         */
        constructor(message) {
          super(1, "commander.invalidArgument", message);
          Error.captureStackTrace(this, this.constructor);
          this.name = this.constructor.name;
        }
      };
      exports.CommanderError = CommanderError2;
      exports.InvalidArgumentError = InvalidArgumentError2;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/argument.js
  var require_argument = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/argument.js"(exports) {
      var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var Argument2 = class {
        /**
         * Initialize a new command argument with the given name and description.
         * The default is that the argument is required, and you can explicitly
         * indicate this with <> around the name. Put [] around the name for an optional argument.
         *
         * @param {string} name
         * @param {string} [description]
         */
        constructor(name, description) {
          this.description = description || "";
          this.variadic = false;
          this.parseArg = void 0;
          this.defaultValue = void 0;
          this.defaultValueDescription = void 0;
          this.argChoices = void 0;
          switch (name[0]) {
            case "<":
              this.required = true;
              this._name = name.slice(1, -1);
              break;
            case "[":
              this.required = false;
              this._name = name.slice(1, -1);
              break;
            default:
              this.required = true;
              this._name = name;
              break;
          }
          if (this._name.length > 3 && this._name.slice(-3) === "...") {
            this.variadic = true;
            this._name = this._name.slice(0, -3);
          }
        }
        /**
         * Return argument name.
         *
         * @return {string}
         */
        name() {
          return this._name;
        }
        /**
         * @api private
         */
        _concatValue(value, previous) {
          if (previous === this.defaultValue || !Array.isArray(previous)) {
            return [value];
          }
          return previous.concat(value);
        }
        /**
         * Set the default value, and optionally supply the description to be displayed in the help.
         *
         * @param {any} value
         * @param {string} [description]
         * @return {Argument}
         */
        default(value, description) {
          this.defaultValue = value;
          this.defaultValueDescription = description;
          return this;
        }
        /**
         * Set the custom handler for processing CLI command arguments into argument values.
         *
         * @param {Function} [fn]
         * @return {Argument}
         */
        argParser(fn) {
          this.parseArg = fn;
          return this;
        }
        /**
         * Only allow argument value to be one of choices.
         *
         * @param {string[]} values
         * @return {Argument}
         */
        choices(values) {
          this.argChoices = values.slice();
          this.parseArg = (arg, previous) => {
            if (!this.argChoices.includes(arg)) {
              throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
            }
            if (this.variadic) {
              return this._concatValue(arg, previous);
            }
            return arg;
          };
          return this;
        }
        /**
         * Make argument required.
         */
        argRequired() {
          this.required = true;
          return this;
        }
        /**
         * Make argument optional.
         */
        argOptional() {
          this.required = false;
          return this;
        }
      };
      function humanReadableArgName(arg) {
        const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
        return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
      }
      exports.Argument = Argument2;
      exports.humanReadableArgName = humanReadableArgName;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/help.js
  var require_help = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/help.js"(exports) {
      var { humanReadableArgName } = require_argument();
      var Help2 = class {
        constructor() {
          this.helpWidth = void 0;
          this.sortSubcommands = false;
          this.sortOptions = false;
        }
        /**
         * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
         *
         * @param {Command} cmd
         * @returns {Command[]}
         */
        visibleCommands(cmd) {
          const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
          if (cmd._hasImplicitHelpCommand()) {
            const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
            const helpCommand = cmd.createCommand(helpName).helpOption(false);
            helpCommand.description(cmd._helpCommandDescription);
            if (helpArgs)
              helpCommand.arguments(helpArgs);
            visibleCommands.push(helpCommand);
          }
          if (this.sortSubcommands) {
            visibleCommands.sort((a, b) => {
              return a.name().localeCompare(b.name());
            });
          }
          return visibleCommands;
        }
        /**
         * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
         *
         * @param {Command} cmd
         * @returns {Option[]}
         */
        visibleOptions(cmd) {
          const visibleOptions = cmd.options.filter((option) => !option.hidden);
          const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
          const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
          if (showShortHelpFlag || showLongHelpFlag) {
            let helpOption;
            if (!showShortHelpFlag) {
              helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
            } else if (!showLongHelpFlag) {
              helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
            } else {
              helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
            }
            visibleOptions.push(helpOption);
          }
          if (this.sortOptions) {
            const getSortKey = (option) => {
              return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
            };
            visibleOptions.sort((a, b) => {
              return getSortKey(a).localeCompare(getSortKey(b));
            });
          }
          return visibleOptions;
        }
        /**
         * Get an array of the arguments if any have a description.
         *
         * @param {Command} cmd
         * @returns {Argument[]}
         */
        visibleArguments(cmd) {
          if (cmd._argsDescription) {
            cmd._args.forEach((argument) => {
              argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
            });
          }
          if (cmd._args.find((argument) => argument.description)) {
            return cmd._args;
          }
          return [];
        }
        /**
         * Get the command term to show in the list of subcommands.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        subcommandTerm(cmd) {
          const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
          return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
          (args ? " " + args : "");
        }
        /**
         * Get the option term to show in the list of options.
         *
         * @param {Option} option
         * @returns {string}
         */
        optionTerm(option) {
          return option.flags;
        }
        /**
         * Get the argument term to show in the list of arguments.
         *
         * @param {Argument} argument
         * @returns {string}
         */
        argumentTerm(argument) {
          return argument.name();
        }
        /**
         * Get the longest command term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestSubcommandTermLength(cmd, helper) {
          return helper.visibleCommands(cmd).reduce((max2, command) => {
            return Math.max(max2, helper.subcommandTerm(command).length);
          }, 0);
        }
        /**
         * Get the longest option term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestOptionTermLength(cmd, helper) {
          return helper.visibleOptions(cmd).reduce((max2, option) => {
            return Math.max(max2, helper.optionTerm(option).length);
          }, 0);
        }
        /**
         * Get the longest argument term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestArgumentTermLength(cmd, helper) {
          return helper.visibleArguments(cmd).reduce((max2, argument) => {
            return Math.max(max2, helper.argumentTerm(argument).length);
          }, 0);
        }
        /**
         * Get the command usage to be displayed at the top of the built-in help.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        commandUsage(cmd) {
          let cmdName = cmd._name;
          if (cmd._aliases[0]) {
            cmdName = cmdName + "|" + cmd._aliases[0];
          }
          let parentCmdNames = "";
          for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
            parentCmdNames = parentCmd.name() + " " + parentCmdNames;
          }
          return parentCmdNames + cmdName + " " + cmd.usage();
        }
        /**
         * Get the description for the command.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        commandDescription(cmd) {
          return cmd.description();
        }
        /**
         * Get the subcommand summary to show in the list of subcommands.
         * (Fallback to description for backwards compatiblity.)
         *
         * @param {Command} cmd
         * @returns {string}
         */
        subcommandDescription(cmd) {
          return cmd.summary() || cmd.description();
        }
        /**
         * Get the option description to show in the list of options.
         *
         * @param {Option} option
         * @return {string}
         */
        optionDescription(option) {
          const extraInfo = [];
          if (option.argChoices) {
            extraInfo.push(
              // use stringify to match the display of the default value
              `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
            );
          }
          if (option.defaultValue !== void 0) {
            const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
            if (showDefault) {
              extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
            }
          }
          if (option.presetArg !== void 0 && option.optional) {
            extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
          }
          if (option.envVar !== void 0) {
            extraInfo.push(`env: ${option.envVar}`);
          }
          if (extraInfo.length > 0) {
            return `${option.description} (${extraInfo.join(", ")})`;
          }
          return option.description;
        }
        /**
         * Get the argument description to show in the list of arguments.
         *
         * @param {Argument} argument
         * @return {string}
         */
        argumentDescription(argument) {
          const extraInfo = [];
          if (argument.argChoices) {
            extraInfo.push(
              // use stringify to match the display of the default value
              `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
            );
          }
          if (argument.defaultValue !== void 0) {
            extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
          }
          if (extraInfo.length > 0) {
            const extraDescripton = `(${extraInfo.join(", ")})`;
            if (argument.description) {
              return `${argument.description} ${extraDescripton}`;
            }
            return extraDescripton;
          }
          return argument.description;
        }
        /**
         * Generate the built-in help text.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {string}
         */
        formatHelp(cmd, helper) {
          const termWidth = helper.padWidth(cmd, helper);
          const helpWidth = helper.helpWidth || 80;
          const itemIndentWidth = 2;
          const itemSeparatorWidth = 2;
          function formatItem(term, description) {
            if (description) {
              const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
              return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
            }
            return term;
          }
          function formatList(textArray) {
            return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
          }
          let output3 = [`Usage: ${helper.commandUsage(cmd)}`, ""];
          const commandDescription = helper.commandDescription(cmd);
          if (commandDescription.length > 0) {
            output3 = output3.concat([commandDescription, ""]);
          }
          const argumentList = helper.visibleArguments(cmd).map((argument) => {
            return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
          });
          if (argumentList.length > 0) {
            output3 = output3.concat(["Arguments:", formatList(argumentList), ""]);
          }
          const optionList = helper.visibleOptions(cmd).map((option) => {
            return formatItem(helper.optionTerm(option), helper.optionDescription(option));
          });
          if (optionList.length > 0) {
            output3 = output3.concat(["Options:", formatList(optionList), ""]);
          }
          const commandList = helper.visibleCommands(cmd).map((cmd2) => {
            return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
          });
          if (commandList.length > 0) {
            output3 = output3.concat(["Commands:", formatList(commandList), ""]);
          }
          return output3.join("\n");
        }
        /**
         * Calculate the pad width from the maximum term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        padWidth(cmd, helper) {
          return Math.max(
            helper.longestOptionTermLength(cmd, helper),
            helper.longestSubcommandTermLength(cmd, helper),
            helper.longestArgumentTermLength(cmd, helper)
          );
        }
        /**
         * Wrap the given string to width characters per line, with lines after the first indented.
         * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
         *
         * @param {string} str
         * @param {number} width
         * @param {number} indent
         * @param {number} [minColumnWidth=40]
         * @return {string}
         *
         */
        wrap(str, width, indent2, minColumnWidth = 40) {
          if (str.match(/[\n]\s+/))
            return str;
          const columnWidth = width - indent2;
          if (columnWidth < minColumnWidth)
            return str;
          const leadingStr = str.slice(0, indent2);
          const columnText = str.slice(indent2);
          const indentString = " ".repeat(indent2);
          const regex = new RegExp(".{1," + (columnWidth - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g");
          const lines = columnText.match(regex) || [];
          return leadingStr + lines.map((line, i) => {
            if (line.slice(-1) === "\n") {
              line = line.slice(0, line.length - 1);
            }
            return (i > 0 ? indentString : "") + line.trimRight();
          }).join("\n");
        }
      };
      exports.Help = Help2;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/option.js
  var require_option = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/option.js"(exports) {
      var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var Option2 = class {
        /**
         * Initialize a new `Option` with the given `flags` and `description`.
         *
         * @param {string} flags
         * @param {string} [description]
         */
        constructor(flags, description) {
          this.flags = flags;
          this.description = description || "";
          this.required = flags.includes("<");
          this.optional = flags.includes("[");
          this.variadic = /\w\.\.\.[>\]]$/.test(flags);
          this.mandatory = false;
          const optionFlags = splitOptionFlags(flags);
          this.short = optionFlags.shortFlag;
          this.long = optionFlags.longFlag;
          this.negate = false;
          if (this.long) {
            this.negate = this.long.startsWith("--no-");
          }
          this.defaultValue = void 0;
          this.defaultValueDescription = void 0;
          this.presetArg = void 0;
          this.envVar = void 0;
          this.parseArg = void 0;
          this.hidden = false;
          this.argChoices = void 0;
          this.conflictsWith = [];
          this.implied = void 0;
        }
        /**
         * Set the default value, and optionally supply the description to be displayed in the help.
         *
         * @param {any} value
         * @param {string} [description]
         * @return {Option}
         */
        default(value, description) {
          this.defaultValue = value;
          this.defaultValueDescription = description;
          return this;
        }
        /**
         * Preset to use when option used without option-argument, especially optional but also boolean and negated.
         * The custom processing (parseArg) is called.
         *
         * @example
         * new Option('--color').default('GREYSCALE').preset('RGB');
         * new Option('--donate [amount]').preset('20').argParser(parseFloat);
         *
         * @param {any} arg
         * @return {Option}
         */
        preset(arg) {
          this.presetArg = arg;
          return this;
        }
        /**
         * Add option name(s) that conflict with this option.
         * An error will be displayed if conflicting options are found during parsing.
         *
         * @example
         * new Option('--rgb').conflicts('cmyk');
         * new Option('--js').conflicts(['ts', 'jsx']);
         *
         * @param {string | string[]} names
         * @return {Option}
         */
        conflicts(names) {
          this.conflictsWith = this.conflictsWith.concat(names);
          return this;
        }
        /**
         * Specify implied option values for when this option is set and the implied options are not.
         *
         * The custom processing (parseArg) is not called on the implied values.
         *
         * @example
         * program
         *   .addOption(new Option('--log', 'write logging information to file'))
         *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
         *
         * @param {Object} impliedOptionValues
         * @return {Option}
         */
        implies(impliedOptionValues) {
          this.implied = Object.assign(this.implied || {}, impliedOptionValues);
          return this;
        }
        /**
         * Set environment variable to check for option value.
         *
         * An environment variable is only used if when processed the current option value is
         * undefined, or the source of the current value is 'default' or 'config' or 'env'.
         *
         * @param {string} name
         * @return {Option}
         */
        env(name) {
          this.envVar = name;
          return this;
        }
        /**
         * Set the custom handler for processing CLI option arguments into option values.
         *
         * @param {Function} [fn]
         * @return {Option}
         */
        argParser(fn) {
          this.parseArg = fn;
          return this;
        }
        /**
         * Whether the option is mandatory and must have a value after parsing.
         *
         * @param {boolean} [mandatory=true]
         * @return {Option}
         */
        makeOptionMandatory(mandatory = true) {
          this.mandatory = !!mandatory;
          return this;
        }
        /**
         * Hide option in help.
         *
         * @param {boolean} [hide=true]
         * @return {Option}
         */
        hideHelp(hide = true) {
          this.hidden = !!hide;
          return this;
        }
        /**
         * @api private
         */
        _concatValue(value, previous) {
          if (previous === this.defaultValue || !Array.isArray(previous)) {
            return [value];
          }
          return previous.concat(value);
        }
        /**
         * Only allow option value to be one of choices.
         *
         * @param {string[]} values
         * @return {Option}
         */
        choices(values) {
          this.argChoices = values.slice();
          this.parseArg = (arg, previous) => {
            if (!this.argChoices.includes(arg)) {
              throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
            }
            if (this.variadic) {
              return this._concatValue(arg, previous);
            }
            return arg;
          };
          return this;
        }
        /**
         * Return option name.
         *
         * @return {string}
         */
        name() {
          if (this.long) {
            return this.long.replace(/^--/, "");
          }
          return this.short.replace(/^-/, "");
        }
        /**
         * Return option name, in a camelcase format that can be used
         * as a object attribute key.
         *
         * @return {string}
         * @api private
         */
        attributeName() {
          return camelcase(this.name().replace(/^no-/, ""));
        }
        /**
         * Check if `arg` matches the short or long flag.
         *
         * @param {string} arg
         * @return {boolean}
         * @api private
         */
        is(arg) {
          return this.short === arg || this.long === arg;
        }
        /**
         * Return whether a boolean option.
         *
         * Options are one of boolean, negated, required argument, or optional argument.
         *
         * @return {boolean}
         * @api private
         */
        isBoolean() {
          return !this.required && !this.optional && !this.negate;
        }
      };
      var DualOptions = class {
        /**
         * @param {Option[]} options
         */
        constructor(options) {
          this.positiveOptions = /* @__PURE__ */ new Map();
          this.negativeOptions = /* @__PURE__ */ new Map();
          this.dualOptions = /* @__PURE__ */ new Set();
          options.forEach((option) => {
            if (option.negate) {
              this.negativeOptions.set(option.attributeName(), option);
            } else {
              this.positiveOptions.set(option.attributeName(), option);
            }
          });
          this.negativeOptions.forEach((value, key) => {
            if (this.positiveOptions.has(key)) {
              this.dualOptions.add(key);
            }
          });
        }
        /**
         * Did the value come from the option, and not from possible matching dual option?
         *
         * @param {any} value
         * @param {Option} option
         * @returns {boolean}
         */
        valueFromOption(value, option) {
          const optionKey = option.attributeName();
          if (!this.dualOptions.has(optionKey))
            return true;
          const preset = this.negativeOptions.get(optionKey).presetArg;
          const negativeValue = preset !== void 0 ? preset : false;
          return option.negate === (negativeValue === value);
        }
      };
      function camelcase(str) {
        return str.split("-").reduce((str2, word) => {
          return str2 + word[0].toUpperCase() + word.slice(1);
        });
      }
      function splitOptionFlags(flags) {
        let shortFlag;
        let longFlag;
        const flagParts = flags.split(/[ |,]+/);
        if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
          shortFlag = flagParts.shift();
        longFlag = flagParts.shift();
        if (!shortFlag && /^-[^-]$/.test(longFlag)) {
          shortFlag = longFlag;
          longFlag = void 0;
        }
        return { shortFlag, longFlag };
      }
      exports.Option = Option2;
      exports.splitOptionFlags = splitOptionFlags;
      exports.DualOptions = DualOptions;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/suggestSimilar.js
  var require_suggestSimilar = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/suggestSimilar.js"(exports) {
      var maxDistance = 3;
      function editDistance(a, b) {
        if (Math.abs(a.length - b.length) > maxDistance)
          return Math.max(a.length, b.length);
        const d = [];
        for (let i = 0; i <= a.length; i++) {
          d[i] = [i];
        }
        for (let j = 0; j <= b.length; j++) {
          d[0][j] = j;
        }
        for (let j = 1; j <= b.length; j++) {
          for (let i = 1; i <= a.length; i++) {
            let cost = 1;
            if (a[i - 1] === b[j - 1]) {
              cost = 0;
            } else {
              cost = 1;
            }
            d[i][j] = Math.min(
              d[i - 1][j] + 1,
              // deletion
              d[i][j - 1] + 1,
              // insertion
              d[i - 1][j - 1] + cost
              // substitution
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
            }
          }
        }
        return d[a.length][b.length];
      }
      function suggestSimilar(word, candidates) {
        if (!candidates || candidates.length === 0)
          return "";
        candidates = Array.from(new Set(candidates));
        const searchingOptions = word.startsWith("--");
        if (searchingOptions) {
          word = word.slice(2);
          candidates = candidates.map((candidate) => candidate.slice(2));
        }
        let similar = [];
        let bestDistance = maxDistance;
        const minSimilarity = 0.4;
        candidates.forEach((candidate) => {
          if (candidate.length <= 1)
            return;
          const distance = editDistance(word, candidate);
          const length = Math.max(word.length, candidate.length);
          const similarity = (length - distance) / length;
          if (similarity > minSimilarity) {
            if (distance < bestDistance) {
              bestDistance = distance;
              similar = [candidate];
            } else if (distance === bestDistance) {
              similar.push(candidate);
            }
          }
        });
        similar.sort((a, b) => a.localeCompare(b));
        if (searchingOptions) {
          similar = similar.map((candidate) => `--${candidate}`);
        }
        if (similar.length > 1) {
          return `
(Did you mean one of ${similar.join(", ")}?)`;
        }
        if (similar.length === 1) {
          return `
(Did you mean ${similar[0]}?)`;
        }
        return "";
      }
      exports.suggestSimilar = suggestSimilar;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/command.js
  var require_command = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/command.js"(exports) {
      var EventEmitter3 = __require2("events").EventEmitter;
      var childProcess = __require2("child_process");
      var path5 = __require2("path");
      var fs4 = __require2("fs");
      var process2 = __require2("process");
      var { Argument: Argument2, humanReadableArgName } = require_argument();
      var { CommanderError: CommanderError2 } = require_error();
      var { Help: Help2 } = require_help();
      var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
      var { suggestSimilar } = require_suggestSimilar();
      var Command2 = class extends EventEmitter3 {
        /**
         * Initialize a new `Command`.
         *
         * @param {string} [name]
         */
        constructor(name) {
          super();
          this.commands = [];
          this.options = [];
          this.parent = null;
          this._allowUnknownOption = false;
          this._allowExcessArguments = true;
          this._args = [];
          this.args = [];
          this.rawArgs = [];
          this.processedArgs = [];
          this._scriptPath = null;
          this._name = name || "";
          this._optionValues = {};
          this._optionValueSources = {};
          this._storeOptionsAsProperties = false;
          this._actionHandler = null;
          this._executableHandler = false;
          this._executableFile = null;
          this._executableDir = null;
          this._defaultCommandName = null;
          this._exitCallback = null;
          this._aliases = [];
          this._combineFlagAndOptionalValue = true;
          this._description = "";
          this._summary = "";
          this._argsDescription = void 0;
          this._enablePositionalOptions = false;
          this._passThroughOptions = false;
          this._lifeCycleHooks = {};
          this._showHelpAfterError = false;
          this._showSuggestionAfterError = true;
          this._outputConfiguration = {
            writeOut: (str) => process2.stdout.write(str),
            writeErr: (str) => process2.stderr.write(str),
            getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
            getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
            outputError: (str, write) => write(str)
          };
          this._hidden = false;
          this._hasHelpOption = true;
          this._helpFlags = "-h, --help";
          this._helpDescription = "display help for command";
          this._helpShortFlag = "-h";
          this._helpLongFlag = "--help";
          this._addImplicitHelpCommand = void 0;
          this._helpCommandName = "help";
          this._helpCommandnameAndArgs = "help [command]";
          this._helpCommandDescription = "display help for command";
          this._helpConfiguration = {};
        }
        /**
         * Copy settings that are useful to have in common across root command and subcommands.
         *
         * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
         *
         * @param {Command} sourceCommand
         * @return {Command} `this` command for chaining
         */
        copyInheritedSettings(sourceCommand) {
          this._outputConfiguration = sourceCommand._outputConfiguration;
          this._hasHelpOption = sourceCommand._hasHelpOption;
          this._helpFlags = sourceCommand._helpFlags;
          this._helpDescription = sourceCommand._helpDescription;
          this._helpShortFlag = sourceCommand._helpShortFlag;
          this._helpLongFlag = sourceCommand._helpLongFlag;
          this._helpCommandName = sourceCommand._helpCommandName;
          this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
          this._helpCommandDescription = sourceCommand._helpCommandDescription;
          this._helpConfiguration = sourceCommand._helpConfiguration;
          this._exitCallback = sourceCommand._exitCallback;
          this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
          this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
          this._allowExcessArguments = sourceCommand._allowExcessArguments;
          this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
          this._showHelpAfterError = sourceCommand._showHelpAfterError;
          this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
          return this;
        }
        /**
         * Define a command.
         *
         * There are two styles of command: pay attention to where to put the description.
         *
         * @example
         * // Command implemented using action handler (description is supplied separately to `.command`)
         * program
         *   .command('clone <source> [destination]')
         *   .description('clone a repository into a newly created directory')
         *   .action((source, destination) => {
         *     console.log('clone command called');
         *   });
         *
         * // Command implemented using separate executable file (description is second parameter to `.command`)
         * program
         *   .command('start <service>', 'start named service')
         *   .command('stop [service]', 'stop named service, or all if no name supplied');
         *
         * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
         * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
         * @param {Object} [execOpts] - configuration options (for executable)
         * @return {Command} returns new command for action handler, or `this` for executable command
         */
        command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
          let desc = actionOptsOrExecDesc;
          let opts = execOpts;
          if (typeof desc === "object" && desc !== null) {
            opts = desc;
            desc = null;
          }
          opts = opts || {};
          const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
          const cmd = this.createCommand(name);
          if (desc) {
            cmd.description(desc);
            cmd._executableHandler = true;
          }
          if (opts.isDefault)
            this._defaultCommandName = cmd._name;
          cmd._hidden = !!(opts.noHelp || opts.hidden);
          cmd._executableFile = opts.executableFile || null;
          if (args)
            cmd.arguments(args);
          this.commands.push(cmd);
          cmd.parent = this;
          cmd.copyInheritedSettings(this);
          if (desc)
            return this;
          return cmd;
        }
        /**
         * Factory routine to create a new unattached command.
         *
         * See .command() for creating an attached subcommand, which uses this routine to
         * create the command. You can override createCommand to customise subcommands.
         *
         * @param {string} [name]
         * @return {Command} new command
         */
        createCommand(name) {
          return new Command2(name);
        }
        /**
         * You can customise the help with a subclass of Help by overriding createHelp,
         * or by overriding Help properties using configureHelp().
         *
         * @return {Help}
         */
        createHelp() {
          return Object.assign(new Help2(), this.configureHelp());
        }
        /**
         * You can customise the help by overriding Help properties using configureHelp(),
         * or with a subclass of Help by overriding createHelp().
         *
         * @param {Object} [configuration] - configuration options
         * @return {Command|Object} `this` command for chaining, or stored configuration
         */
        configureHelp(configuration) {
          if (configuration === void 0)
            return this._helpConfiguration;
          this._helpConfiguration = configuration;
          return this;
        }
        /**
         * The default output goes to stdout and stderr. You can customise this for special
         * applications. You can also customise the display of errors by overriding outputError.
         *
         * The configuration properties are all functions:
         *
         *     // functions to change where being written, stdout and stderr
         *     writeOut(str)
         *     writeErr(str)
         *     // matching functions to specify width for wrapping help
         *     getOutHelpWidth()
         *     getErrHelpWidth()
         *     // functions based on what is being written out
         *     outputError(str, write) // used for displaying errors, and not used for displaying help
         *
         * @param {Object} [configuration] - configuration options
         * @return {Command|Object} `this` command for chaining, or stored configuration
         */
        configureOutput(configuration) {
          if (configuration === void 0)
            return this._outputConfiguration;
          Object.assign(this._outputConfiguration, configuration);
          return this;
        }
        /**
         * Display the help or a custom message after an error occurs.
         *
         * @param {boolean|string} [displayHelp]
         * @return {Command} `this` command for chaining
         */
        showHelpAfterError(displayHelp = true) {
          if (typeof displayHelp !== "string")
            displayHelp = !!displayHelp;
          this._showHelpAfterError = displayHelp;
          return this;
        }
        /**
         * Display suggestion of similar commands for unknown commands, or options for unknown options.
         *
         * @param {boolean} [displaySuggestion]
         * @return {Command} `this` command for chaining
         */
        showSuggestionAfterError(displaySuggestion = true) {
          this._showSuggestionAfterError = !!displaySuggestion;
          return this;
        }
        /**
         * Add a prepared subcommand.
         *
         * See .command() for creating an attached subcommand which inherits settings from its parent.
         *
         * @param {Command} cmd - new subcommand
         * @param {Object} [opts] - configuration options
         * @return {Command} `this` command for chaining
         */
        addCommand(cmd, opts) {
          if (!cmd._name) {
            throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
          }
          opts = opts || {};
          if (opts.isDefault)
            this._defaultCommandName = cmd._name;
          if (opts.noHelp || opts.hidden)
            cmd._hidden = true;
          this.commands.push(cmd);
          cmd.parent = this;
          return this;
        }
        /**
         * Factory routine to create a new unattached argument.
         *
         * See .argument() for creating an attached argument, which uses this routine to
         * create the argument. You can override createArgument to return a custom argument.
         *
         * @param {string} name
         * @param {string} [description]
         * @return {Argument} new argument
         */
        createArgument(name, description) {
          return new Argument2(name, description);
        }
        /**
         * Define argument syntax for command.
         *
         * The default is that the argument is required, and you can explicitly
         * indicate this with <> around the name. Put [] around the name for an optional argument.
         *
         * @example
         * program.argument('<input-file>');
         * program.argument('[output-file]');
         *
         * @param {string} name
         * @param {string} [description]
         * @param {Function|*} [fn] - custom argument processing function
         * @param {*} [defaultValue]
         * @return {Command} `this` command for chaining
         */
        argument(name, description, fn, defaultValue) {
          const argument = this.createArgument(name, description);
          if (typeof fn === "function") {
            argument.default(defaultValue).argParser(fn);
          } else {
            argument.default(fn);
          }
          this.addArgument(argument);
          return this;
        }
        /**
         * Define argument syntax for command, adding multiple at once (without descriptions).
         *
         * See also .argument().
         *
         * @example
         * program.arguments('<cmd> [env]');
         *
         * @param {string} names
         * @return {Command} `this` command for chaining
         */
        arguments(names) {
          names.split(/ +/).forEach((detail) => {
            this.argument(detail);
          });
          return this;
        }
        /**
         * Define argument syntax for command, adding a prepared argument.
         *
         * @param {Argument} argument
         * @return {Command} `this` command for chaining
         */
        addArgument(argument) {
          const previousArgument = this._args.slice(-1)[0];
          if (previousArgument && previousArgument.variadic) {
            throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
          }
          if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
            throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
          }
          this._args.push(argument);
          return this;
        }
        /**
         * Override default decision whether to add implicit help command.
         *
         *    addHelpCommand() // force on
         *    addHelpCommand(false); // force off
         *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
         *
         * @return {Command} `this` command for chaining
         */
        addHelpCommand(enableOrNameAndArgs, description) {
          if (enableOrNameAndArgs === false) {
            this._addImplicitHelpCommand = false;
          } else {
            this._addImplicitHelpCommand = true;
            if (typeof enableOrNameAndArgs === "string") {
              this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
              this._helpCommandnameAndArgs = enableOrNameAndArgs;
            }
            this._helpCommandDescription = description || this._helpCommandDescription;
          }
          return this;
        }
        /**
         * @return {boolean}
         * @api private
         */
        _hasImplicitHelpCommand() {
          if (this._addImplicitHelpCommand === void 0) {
            return this.commands.length && !this._actionHandler && !this._findCommand("help");
          }
          return this._addImplicitHelpCommand;
        }
        /**
         * Add hook for life cycle event.
         *
         * @param {string} event
         * @param {Function} listener
         * @return {Command} `this` command for chaining
         */
        hook(event, listener) {
          const allowedValues = ["preSubcommand", "preAction", "postAction"];
          if (!allowedValues.includes(event)) {
            throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
          }
          if (this._lifeCycleHooks[event]) {
            this._lifeCycleHooks[event].push(listener);
          } else {
            this._lifeCycleHooks[event] = [listener];
          }
          return this;
        }
        /**
         * Register callback to use as replacement for calling process.exit.
         *
         * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
         * @return {Command} `this` command for chaining
         */
        exitOverride(fn) {
          if (fn) {
            this._exitCallback = fn;
          } else {
            this._exitCallback = (err) => {
              if (err.code !== "commander.executeSubCommandAsync") {
                throw err;
              } else {
              }
            };
          }
          return this;
        }
        /**
         * Call process.exit, and _exitCallback if defined.
         *
         * @param {number} exitCode exit code for using with process.exit
         * @param {string} code an id string representing the error
         * @param {string} message human-readable description of the error
         * @return never
         * @api private
         */
        _exit(exitCode, code, message) {
          if (this._exitCallback) {
            this._exitCallback(new CommanderError2(exitCode, code, message));
          }
          process2.exit(exitCode);
        }
        /**
         * Register callback `fn` for the command.
         *
         * @example
         * program
         *   .command('serve')
         *   .description('start service')
         *   .action(function() {
         *      // do work here
         *   });
         *
         * @param {Function} fn
         * @return {Command} `this` command for chaining
         */
        action(fn) {
          const listener = (args) => {
            const expectedArgsCount = this._args.length;
            const actionArgs = args.slice(0, expectedArgsCount);
            if (this._storeOptionsAsProperties) {
              actionArgs[expectedArgsCount] = this;
            } else {
              actionArgs[expectedArgsCount] = this.opts();
            }
            actionArgs.push(this);
            return fn.apply(this, actionArgs);
          };
          this._actionHandler = listener;
          return this;
        }
        /**
         * Factory routine to create a new unattached option.
         *
         * See .option() for creating an attached option, which uses this routine to
         * create the option. You can override createOption to return a custom option.
         *
         * @param {string} flags
         * @param {string} [description]
         * @return {Option} new option
         */
        createOption(flags, description) {
          return new Option2(flags, description);
        }
        /**
         * Add an option.
         *
         * @param {Option} option
         * @return {Command} `this` command for chaining
         */
        addOption(option) {
          const oname = option.name();
          const name = option.attributeName();
          if (option.negate) {
            const positiveLongFlag = option.long.replace(/^--no-/, "--");
            if (!this._findOption(positiveLongFlag)) {
              this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
            }
          } else if (option.defaultValue !== void 0) {
            this.setOptionValueWithSource(name, option.defaultValue, "default");
          }
          this.options.push(option);
          const handleOptionValue = (val, invalidValueMessage, valueSource) => {
            if (val == null && option.presetArg !== void 0) {
              val = option.presetArg;
            }
            const oldValue = this.getOptionValue(name);
            if (val !== null && option.parseArg) {
              try {
                val = option.parseArg(val, oldValue);
              } catch (err) {
                if (err.code === "commander.invalidArgument") {
                  const message = `${invalidValueMessage} ${err.message}`;
                  this.error(message, { exitCode: err.exitCode, code: err.code });
                }
                throw err;
              }
            } else if (val !== null && option.variadic) {
              val = option._concatValue(val, oldValue);
            }
            if (val == null) {
              if (option.negate) {
                val = false;
              } else if (option.isBoolean() || option.optional) {
                val = true;
              } else {
                val = "";
              }
            }
            this.setOptionValueWithSource(name, val, valueSource);
          };
          this.on("option:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "cli");
          });
          if (option.envVar) {
            this.on("optionEnv:" + oname, (val) => {
              const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
              handleOptionValue(val, invalidValueMessage, "env");
            });
          }
          return this;
        }
        /**
         * Internal implementation shared by .option() and .requiredOption()
         *
         * @api private
         */
        _optionEx(config, flags, description, fn, defaultValue) {
          if (typeof flags === "object" && flags instanceof Option2) {
            throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
          }
          const option = this.createOption(flags, description);
          option.makeOptionMandatory(!!config.mandatory);
          if (typeof fn === "function") {
            option.default(defaultValue).argParser(fn);
          } else if (fn instanceof RegExp) {
            const regex = fn;
            fn = (val, def) => {
              const m = regex.exec(val);
              return m ? m[0] : def;
            };
            option.default(defaultValue).argParser(fn);
          } else {
            option.default(fn);
          }
          return this.addOption(option);
        }
        /**
         * Define option with `flags`, `description` and optional
         * coercion `fn`.
         *
         * The `flags` string contains the short and/or long flags,
         * separated by comma, a pipe or space. The following are all valid
         * all will output this way when `--help` is used.
         *
         *     "-p, --pepper"
         *     "-p|--pepper"
         *     "-p --pepper"
         *
         * @example
         * // simple boolean defaulting to undefined
         * program.option('-p, --pepper', 'add pepper');
         *
         * program.pepper
         * // => undefined
         *
         * --pepper
         * program.pepper
         * // => true
         *
         * // simple boolean defaulting to true (unless non-negated option is also defined)
         * program.option('-C, --no-cheese', 'remove cheese');
         *
         * program.cheese
         * // => true
         *
         * --no-cheese
         * program.cheese
         * // => false
         *
         * // required argument
         * program.option('-C, --chdir <path>', 'change the working directory');
         *
         * --chdir /tmp
         * program.chdir
         * // => "/tmp"
         *
         * // optional argument
         * program.option('-c, --cheese [type]', 'add cheese [marble]');
         *
         * @param {string} flags
         * @param {string} [description]
         * @param {Function|*} [fn] - custom option processing function or default value
         * @param {*} [defaultValue]
         * @return {Command} `this` command for chaining
         */
        option(flags, description, fn, defaultValue) {
          return this._optionEx({}, flags, description, fn, defaultValue);
        }
        /**
        * Add a required option which must have a value after parsing. This usually means
        * the option must be specified on the command line. (Otherwise the same as .option().)
        *
        * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
        *
        * @param {string} flags
        * @param {string} [description]
        * @param {Function|*} [fn] - custom option processing function or default value
        * @param {*} [defaultValue]
        * @return {Command} `this` command for chaining
        */
        requiredOption(flags, description, fn, defaultValue) {
          return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
        }
        /**
         * Alter parsing of short flags with optional values.
         *
         * @example
         * // for `.option('-f,--flag [value]'):
         * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
         * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
         *
         * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
         */
        combineFlagAndOptionalValue(combine = true) {
          this._combineFlagAndOptionalValue = !!combine;
          return this;
        }
        /**
         * Allow unknown options on the command line.
         *
         * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
         * for unknown options.
         */
        allowUnknownOption(allowUnknown = true) {
          this._allowUnknownOption = !!allowUnknown;
          return this;
        }
        /**
         * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
         *
         * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
         * for excess arguments.
         */
        allowExcessArguments(allowExcess = true) {
          this._allowExcessArguments = !!allowExcess;
          return this;
        }
        /**
         * Enable positional options. Positional means global options are specified before subcommands which lets
         * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
         * The default behaviour is non-positional and global options may appear anywhere on the command line.
         *
         * @param {Boolean} [positional=true]
         */
        enablePositionalOptions(positional = true) {
          this._enablePositionalOptions = !!positional;
          return this;
        }
        /**
         * Pass through options that come after command-arguments rather than treat them as command-options,
         * so actual command-options come before command-arguments. Turning this on for a subcommand requires
         * positional options to have been enabled on the program (parent commands).
         * The default behaviour is non-positional and options may appear before or after command-arguments.
         *
         * @param {Boolean} [passThrough=true]
         * for unknown options.
         */
        passThroughOptions(passThrough = true) {
          this._passThroughOptions = !!passThrough;
          if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
            throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
          }
          return this;
        }
        /**
          * Whether to store option values as properties on command object,
          * or store separately (specify false). In both cases the option values can be accessed using .opts().
          *
          * @param {boolean} [storeAsProperties=true]
          * @return {Command} `this` command for chaining
          */
        storeOptionsAsProperties(storeAsProperties = true) {
          this._storeOptionsAsProperties = !!storeAsProperties;
          if (this.options.length) {
            throw new Error("call .storeOptionsAsProperties() before adding options");
          }
          return this;
        }
        /**
         * Retrieve option value.
         *
         * @param {string} key
         * @return {Object} value
         */
        getOptionValue(key) {
          if (this._storeOptionsAsProperties) {
            return this[key];
          }
          return this._optionValues[key];
        }
        /**
         * Store option value.
         *
         * @param {string} key
         * @param {Object} value
         * @return {Command} `this` command for chaining
         */
        setOptionValue(key, value) {
          return this.setOptionValueWithSource(key, value, void 0);
        }
        /**
          * Store option value and where the value came from.
          *
          * @param {string} key
          * @param {Object} value
          * @param {string} source - expected values are default/config/env/cli/implied
          * @return {Command} `this` command for chaining
          */
        setOptionValueWithSource(key, value, source) {
          if (this._storeOptionsAsProperties) {
            this[key] = value;
          } else {
            this._optionValues[key] = value;
          }
          this._optionValueSources[key] = source;
          return this;
        }
        /**
          * Get source of option value.
          * Expected values are default | config | env | cli | implied
          *
          * @param {string} key
          * @return {string}
          */
        getOptionValueSource(key) {
          return this._optionValueSources[key];
        }
        /**
         * Get user arguments from implied or explicit arguments.
         * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
         *
         * @api private
         */
        _prepareUserArgs(argv, parseOptions) {
          if (argv !== void 0 && !Array.isArray(argv)) {
            throw new Error("first parameter to parse must be array or undefined");
          }
          parseOptions = parseOptions || {};
          if (argv === void 0) {
            argv = process2.argv;
            if (process2.versions && process2.versions.electron) {
              parseOptions.from = "electron";
            }
          }
          this.rawArgs = argv.slice();
          let userArgs;
          switch (parseOptions.from) {
            case void 0:
            case "node":
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
              break;
            case "electron":
              if (process2.defaultApp) {
                this._scriptPath = argv[1];
                userArgs = argv.slice(2);
              } else {
                userArgs = argv.slice(1);
              }
              break;
            case "user":
              userArgs = argv.slice(0);
              break;
            default:
              throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
          }
          if (!this._name && this._scriptPath)
            this.nameFromFilename(this._scriptPath);
          this._name = this._name || "program";
          return userArgs;
        }
        /**
         * Parse `argv`, setting options and invoking commands when defined.
         *
         * The default expectation is that the arguments are from node and have the application as argv[0]
         * and the script being run in argv[1], with user parameters after that.
         *
         * @example
         * program.parse(process.argv);
         * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
         * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
         *
         * @param {string[]} [argv] - optional, defaults to process.argv
         * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
         * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
         * @return {Command} `this` command for chaining
         */
        parse(argv, parseOptions) {
          const userArgs = this._prepareUserArgs(argv, parseOptions);
          this._parseCommand([], userArgs);
          return this;
        }
        /**
         * Parse `argv`, setting options and invoking commands when defined.
         *
         * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
         *
         * The default expectation is that the arguments are from node and have the application as argv[0]
         * and the script being run in argv[1], with user parameters after that.
         *
         * @example
         * await program.parseAsync(process.argv);
         * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
         * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
         *
         * @param {string[]} [argv]
         * @param {Object} [parseOptions]
         * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
         * @return {Promise}
         */
        async parseAsync(argv, parseOptions) {
          const userArgs = this._prepareUserArgs(argv, parseOptions);
          await this._parseCommand([], userArgs);
          return this;
        }
        /**
         * Execute a sub-command executable.
         *
         * @api private
         */
        _executeSubCommand(subcommand, args) {
          args = args.slice();
          let launchWithNode = false;
          const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
          function findFile(baseDir, baseName) {
            const localBin = path5.resolve(baseDir, baseName);
            if (fs4.existsSync(localBin))
              return localBin;
            if (sourceExt.includes(path5.extname(baseName)))
              return void 0;
            const foundExt = sourceExt.find((ext2) => fs4.existsSync(`${localBin}${ext2}`));
            if (foundExt)
              return `${localBin}${foundExt}`;
            return void 0;
          }
          this._checkForMissingMandatoryOptions();
          this._checkForConflictingOptions();
          let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
          let executableDir = this._executableDir || "";
          if (this._scriptPath) {
            let resolvedScriptPath;
            try {
              resolvedScriptPath = fs4.realpathSync(this._scriptPath);
            } catch (err) {
              resolvedScriptPath = this._scriptPath;
            }
            executableDir = path5.resolve(path5.dirname(resolvedScriptPath), executableDir);
          }
          if (executableDir) {
            let localFile = findFile(executableDir, executableFile);
            if (!localFile && !subcommand._executableFile && this._scriptPath) {
              const legacyName = path5.basename(this._scriptPath, path5.extname(this._scriptPath));
              if (legacyName !== this._name) {
                localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
              }
            }
            executableFile = localFile || executableFile;
          }
          launchWithNode = sourceExt.includes(path5.extname(executableFile));
          let proc2;
          if (process2.platform !== "win32") {
            if (launchWithNode) {
              args.unshift(executableFile);
              args = incrementNodeInspectorPort(process2.execArgv).concat(args);
              proc2 = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
            } else {
              proc2 = childProcess.spawn(executableFile, args, { stdio: "inherit" });
            }
          } else {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc2 = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
          }
          if (!proc2.killed) {
            const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
            signals.forEach((signal) => {
              process2.on(signal, () => {
                if (proc2.killed === false && proc2.exitCode === null) {
                  proc2.kill(signal);
                }
              });
            });
          }
          const exitCallback = this._exitCallback;
          if (!exitCallback) {
            proc2.on("close", process2.exit.bind(process2));
          } else {
            proc2.on("close", () => {
              exitCallback(new CommanderError2(process2.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
            });
          }
          proc2.on("error", (err) => {
            if (err.code === "ENOENT") {
              const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
              const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
              throw new Error(executableMissing);
            } else if (err.code === "EACCES") {
              throw new Error(`'${executableFile}' not executable`);
            }
            if (!exitCallback) {
              process2.exit(1);
            } else {
              const wrappedError = new CommanderError2(1, "commander.executeSubCommandAsync", "(error)");
              wrappedError.nestedError = err;
              exitCallback(wrappedError);
            }
          });
          this.runningCommand = proc2;
        }
        /**
         * @api private
         */
        _dispatchSubcommand(commandName, operands, unknown2) {
          const subCommand = this._findCommand(commandName);
          if (!subCommand)
            this.help({ error: true });
          let hookResult;
          hookResult = this._chainOrCallSubCommandHook(hookResult, subCommand, "preSubcommand");
          hookResult = this._chainOrCall(hookResult, () => {
            if (subCommand._executableHandler) {
              this._executeSubCommand(subCommand, operands.concat(unknown2));
            } else {
              return subCommand._parseCommand(operands, unknown2);
            }
          });
          return hookResult;
        }
        /**
         * Check this.args against expected this._args.
         *
         * @api private
         */
        _checkNumberOfArguments() {
          this._args.forEach((arg, i) => {
            if (arg.required && this.args[i] == null) {
              this.missingArgument(arg.name());
            }
          });
          if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
            return;
          }
          if (this.args.length > this._args.length) {
            this._excessArguments(this.args);
          }
        }
        /**
         * Process this.args using this._args and save as this.processedArgs!
         *
         * @api private
         */
        _processArguments() {
          const myParseArg = (argument, value, previous) => {
            let parsedValue = value;
            if (value !== null && argument.parseArg) {
              try {
                parsedValue = argument.parseArg(value, previous);
              } catch (err) {
                if (err.code === "commander.invalidArgument") {
                  const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
                  this.error(message, { exitCode: err.exitCode, code: err.code });
                }
                throw err;
              }
            }
            return parsedValue;
          };
          this._checkNumberOfArguments();
          const processedArgs = [];
          this._args.forEach((declaredArg, index) => {
            let value = declaredArg.defaultValue;
            if (declaredArg.variadic) {
              if (index < this.args.length) {
                value = this.args.slice(index);
                if (declaredArg.parseArg) {
                  value = value.reduce((processed, v) => {
                    return myParseArg(declaredArg, v, processed);
                  }, declaredArg.defaultValue);
                }
              } else if (value === void 0) {
                value = [];
              }
            } else if (index < this.args.length) {
              value = this.args[index];
              if (declaredArg.parseArg) {
                value = myParseArg(declaredArg, value, declaredArg.defaultValue);
              }
            }
            processedArgs[index] = value;
          });
          this.processedArgs = processedArgs;
        }
        /**
         * Once we have a promise we chain, but call synchronously until then.
         *
         * @param {Promise|undefined} promise
         * @param {Function} fn
         * @return {Promise|undefined}
         * @api private
         */
        _chainOrCall(promise, fn) {
          if (promise && promise.then && typeof promise.then === "function") {
            return promise.then(() => fn());
          }
          return fn();
        }
        /**
         *
         * @param {Promise|undefined} promise
         * @param {string} event
         * @return {Promise|undefined}
         * @api private
         */
        _chainOrCallHooks(promise, event) {
          let result = promise;
          const hooks = [];
          getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
            hookedCommand._lifeCycleHooks[event].forEach((callback) => {
              hooks.push({ hookedCommand, callback });
            });
          });
          if (event === "postAction") {
            hooks.reverse();
          }
          hooks.forEach((hookDetail) => {
            result = this._chainOrCall(result, () => {
              return hookDetail.callback(hookDetail.hookedCommand, this);
            });
          });
          return result;
        }
        /**
         *
         * @param {Promise|undefined} promise
         * @param {Command} subCommand
         * @param {string} event
         * @return {Promise|undefined}
         * @api private
         */
        _chainOrCallSubCommandHook(promise, subCommand, event) {
          let result = promise;
          if (this._lifeCycleHooks[event] !== void 0) {
            this._lifeCycleHooks[event].forEach((hook) => {
              result = this._chainOrCall(result, () => {
                return hook(this, subCommand);
              });
            });
          }
          return result;
        }
        /**
         * Process arguments in context of this command.
         * Returns action result, in case it is a promise.
         *
         * @api private
         */
        _parseCommand(operands, unknown2) {
          const parsed = this.parseOptions(unknown2);
          this._parseOptionsEnv();
          this._parseOptionsImplied();
          operands = operands.concat(parsed.operands);
          unknown2 = parsed.unknown;
          this.args = operands.concat(unknown2);
          if (operands && this._findCommand(operands[0])) {
            return this._dispatchSubcommand(operands[0], operands.slice(1), unknown2);
          }
          if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
            if (operands.length === 1) {
              this.help();
            }
            return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
          }
          if (this._defaultCommandName) {
            outputHelpIfRequested(this, unknown2);
            return this._dispatchSubcommand(this._defaultCommandName, operands, unknown2);
          }
          if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
            this.help({ error: true });
          }
          outputHelpIfRequested(this, parsed.unknown);
          this._checkForMissingMandatoryOptions();
          this._checkForConflictingOptions();
          const checkForUnknownOptions = () => {
            if (parsed.unknown.length > 0) {
              this.unknownOption(parsed.unknown[0]);
            }
          };
          const commandEvent = `command:${this.name()}`;
          if (this._actionHandler) {
            checkForUnknownOptions();
            this._processArguments();
            let actionResult;
            actionResult = this._chainOrCallHooks(actionResult, "preAction");
            actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
            if (this.parent) {
              actionResult = this._chainOrCall(actionResult, () => {
                this.parent.emit(commandEvent, operands, unknown2);
              });
            }
            actionResult = this._chainOrCallHooks(actionResult, "postAction");
            return actionResult;
          }
          if (this.parent && this.parent.listenerCount(commandEvent)) {
            checkForUnknownOptions();
            this._processArguments();
            this.parent.emit(commandEvent, operands, unknown2);
          } else if (operands.length) {
            if (this._findCommand("*")) {
              return this._dispatchSubcommand("*", operands, unknown2);
            }
            if (this.listenerCount("command:*")) {
              this.emit("command:*", operands, unknown2);
            } else if (this.commands.length) {
              this.unknownCommand();
            } else {
              checkForUnknownOptions();
              this._processArguments();
            }
          } else if (this.commands.length) {
            checkForUnknownOptions();
            this.help({ error: true });
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        }
        /**
         * Find matching command.
         *
         * @api private
         */
        _findCommand(name) {
          if (!name)
            return void 0;
          return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
        }
        /**
         * Return an option matching `arg` if any.
         *
         * @param {string} arg
         * @return {Option}
         * @api private
         */
        _findOption(arg) {
          return this.options.find((option) => option.is(arg));
        }
        /**
         * Display an error message if a mandatory option does not have a value.
         * Called after checking for help flags in leaf subcommand.
         *
         * @api private
         */
        _checkForMissingMandatoryOptions() {
          for (let cmd = this; cmd; cmd = cmd.parent) {
            cmd.options.forEach((anOption) => {
              if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
                cmd.missingMandatoryOptionValue(anOption);
              }
            });
          }
        }
        /**
         * Display an error message if conflicting options are used together in this.
         *
         * @api private
         */
        _checkForConflictingLocalOptions() {
          const definedNonDefaultOptions = this.options.filter(
            (option) => {
              const optionKey = option.attributeName();
              if (this.getOptionValue(optionKey) === void 0) {
                return false;
              }
              return this.getOptionValueSource(optionKey) !== "default";
            }
          );
          const optionsWithConflicting = definedNonDefaultOptions.filter(
            (option) => option.conflictsWith.length > 0
          );
          optionsWithConflicting.forEach((option) => {
            const conflictingAndDefined = definedNonDefaultOptions.find(
              (defined) => option.conflictsWith.includes(defined.attributeName())
            );
            if (conflictingAndDefined) {
              this._conflictingOption(option, conflictingAndDefined);
            }
          });
        }
        /**
         * Display an error message if conflicting options are used together.
         * Called after checking for help flags in leaf subcommand.
         *
         * @api private
         */
        _checkForConflictingOptions() {
          for (let cmd = this; cmd; cmd = cmd.parent) {
            cmd._checkForConflictingLocalOptions();
          }
        }
        /**
         * Parse options from `argv` removing known options,
         * and return argv split into operands and unknown arguments.
         *
         * Examples:
         *
         *     argv => operands, unknown
         *     --known kkk op => [op], []
         *     op --known kkk => [op], []
         *     sub --unknown uuu op => [sub], [--unknown uuu op]
         *     sub -- --unknown uuu op => [sub --unknown uuu op], []
         *
         * @param {String[]} argv
         * @return {{operands: String[], unknown: String[]}}
         */
        parseOptions(argv) {
          const operands = [];
          const unknown2 = [];
          let dest = operands;
          const args = argv.slice();
          function maybeOption(arg) {
            return arg.length > 1 && arg[0] === "-";
          }
          let activeVariadicOption = null;
          while (args.length) {
            const arg = args.shift();
            if (arg === "--") {
              if (dest === unknown2)
                dest.push(arg);
              dest.push(...args);
              break;
            }
            if (activeVariadicOption && !maybeOption(arg)) {
              this.emit(`option:${activeVariadicOption.name()}`, arg);
              continue;
            }
            activeVariadicOption = null;
            if (maybeOption(arg)) {
              const option = this._findOption(arg);
              if (option) {
                if (option.required) {
                  const value = args.shift();
                  if (value === void 0)
                    this.optionMissingArgument(option);
                  this.emit(`option:${option.name()}`, value);
                } else if (option.optional) {
                  let value = null;
                  if (args.length > 0 && !maybeOption(args[0])) {
                    value = args.shift();
                  }
                  this.emit(`option:${option.name()}`, value);
                } else {
                  this.emit(`option:${option.name()}`);
                }
                activeVariadicOption = option.variadic ? option : null;
                continue;
              }
            }
            if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
              const option = this._findOption(`-${arg[1]}`);
              if (option) {
                if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                  this.emit(`option:${option.name()}`, arg.slice(2));
                } else {
                  this.emit(`option:${option.name()}`);
                  args.unshift(`-${arg.slice(2)}`);
                }
                continue;
              }
            }
            if (/^--[^=]+=/.test(arg)) {
              const index = arg.indexOf("=");
              const option = this._findOption(arg.slice(0, index));
              if (option && (option.required || option.optional)) {
                this.emit(`option:${option.name()}`, arg.slice(index + 1));
                continue;
              }
            }
            if (maybeOption(arg)) {
              dest = unknown2;
            }
            if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown2.length === 0) {
              if (this._findCommand(arg)) {
                operands.push(arg);
                if (args.length > 0)
                  unknown2.push(...args);
                break;
              } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
                operands.push(arg);
                if (args.length > 0)
                  operands.push(...args);
                break;
              } else if (this._defaultCommandName) {
                unknown2.push(arg);
                if (args.length > 0)
                  unknown2.push(...args);
                break;
              }
            }
            if (this._passThroughOptions) {
              dest.push(arg);
              if (args.length > 0)
                dest.push(...args);
              break;
            }
            dest.push(arg);
          }
          return { operands, unknown: unknown2 };
        }
        /**
         * Return an object containing local option values as key-value pairs.
         *
         * @return {Object}
         */
        opts() {
          if (this._storeOptionsAsProperties) {
            const result = {};
            const len = this.options.length;
            for (let i = 0; i < len; i++) {
              const key = this.options[i].attributeName();
              result[key] = key === this._versionOptionName ? this._version : this[key];
            }
            return result;
          }
          return this._optionValues;
        }
        /**
         * Return an object containing merged local and global option values as key-value pairs.
         *
         * @return {Object}
         */
        optsWithGlobals() {
          return getCommandAndParents(this).reduce(
            (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
            {}
          );
        }
        /**
         * Display error message and exit (or call exitOverride).
         *
         * @param {string} message
         * @param {Object} [errorOptions]
         * @param {string} [errorOptions.code] - an id string representing the error
         * @param {number} [errorOptions.exitCode] - used with process.exit
         */
        error(message, errorOptions) {
          this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
          if (typeof this._showHelpAfterError === "string") {
            this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
          } else if (this._showHelpAfterError) {
            this._outputConfiguration.writeErr("\n");
            this.outputHelp({ error: true });
          }
          const config = errorOptions || {};
          const exitCode = config.exitCode || 1;
          const code = config.code || "commander.error";
          this._exit(exitCode, code, message);
        }
        /**
         * Apply any option related environment variables, if option does
         * not have a value from cli or client code.
         *
         * @api private
         */
        _parseOptionsEnv() {
          this.options.forEach((option) => {
            if (option.envVar && option.envVar in process2.env) {
              const optionKey = option.attributeName();
              if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
                if (option.required || option.optional) {
                  this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
                } else {
                  this.emit(`optionEnv:${option.name()}`);
                }
              }
            }
          });
        }
        /**
         * Apply any implied option values, if option is undefined or default value.
         *
         * @api private
         */
        _parseOptionsImplied() {
          const dualHelper = new DualOptions(this.options);
          const hasCustomOptionValue = (optionKey) => {
            return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
          };
          this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
            Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
              this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
            });
          });
        }
        /**
         * Argument `name` is missing.
         *
         * @param {string} name
         * @api private
         */
        missingArgument(name) {
          const message = `error: missing required argument '${name}'`;
          this.error(message, { code: "commander.missingArgument" });
        }
        /**
         * `Option` is missing an argument.
         *
         * @param {Option} option
         * @api private
         */
        optionMissingArgument(option) {
          const message = `error: option '${option.flags}' argument missing`;
          this.error(message, { code: "commander.optionMissingArgument" });
        }
        /**
         * `Option` does not have a value, and is a mandatory option.
         *
         * @param {Option} option
         * @api private
         */
        missingMandatoryOptionValue(option) {
          const message = `error: required option '${option.flags}' not specified`;
          this.error(message, { code: "commander.missingMandatoryOptionValue" });
        }
        /**
         * `Option` conflicts with another option.
         *
         * @param {Option} option
         * @param {Option} conflictingOption
         * @api private
         */
        _conflictingOption(option, conflictingOption) {
          const findBestOptionFromValue = (option2) => {
            const optionKey = option2.attributeName();
            const optionValue = this.getOptionValue(optionKey);
            const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
            const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
            if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
              return negativeOption;
            }
            return positiveOption || option2;
          };
          const getErrorMessage = (option2) => {
            const bestOption = findBestOptionFromValue(option2);
            const optionKey = bestOption.attributeName();
            const source = this.getOptionValueSource(optionKey);
            if (source === "env") {
              return `environment variable '${bestOption.envVar}'`;
            }
            return `option '${bestOption.flags}'`;
          };
          const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
          this.error(message, { code: "commander.conflictingOption" });
        }
        /**
         * Unknown option `flag`.
         *
         * @param {string} flag
         * @api private
         */
        unknownOption(flag) {
          if (this._allowUnknownOption)
            return;
          let suggestion = "";
          if (flag.startsWith("--") && this._showSuggestionAfterError) {
            let candidateFlags = [];
            let command = this;
            do {
              const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
              candidateFlags = candidateFlags.concat(moreFlags);
              command = command.parent;
            } while (command && !command._enablePositionalOptions);
            suggestion = suggestSimilar(flag, candidateFlags);
          }
          const message = `error: unknown option '${flag}'${suggestion}`;
          this.error(message, { code: "commander.unknownOption" });
        }
        /**
         * Excess arguments, more than expected.
         *
         * @param {string[]} receivedArgs
         * @api private
         */
        _excessArguments(receivedArgs) {
          if (this._allowExcessArguments)
            return;
          const expected = this._args.length;
          const s = expected === 1 ? "" : "s";
          const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
          const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
          this.error(message, { code: "commander.excessArguments" });
        }
        /**
         * Unknown command.
         *
         * @api private
         */
        unknownCommand() {
          const unknownName = this.args[0];
          let suggestion = "";
          if (this._showSuggestionAfterError) {
            const candidateNames = [];
            this.createHelp().visibleCommands(this).forEach((command) => {
              candidateNames.push(command.name());
              if (command.alias())
                candidateNames.push(command.alias());
            });
            suggestion = suggestSimilar(unknownName, candidateNames);
          }
          const message = `error: unknown command '${unknownName}'${suggestion}`;
          this.error(message, { code: "commander.unknownCommand" });
        }
        /**
         * Set the program version to `str`.
         *
         * This method auto-registers the "-V, --version" flag
         * which will print the version number when passed.
         *
         * You can optionally supply the  flags and description to override the defaults.
         *
         * @param {string} str
         * @param {string} [flags]
         * @param {string} [description]
         * @return {this | string} `this` command for chaining, or version string if no arguments
         */
        version(str, flags, description) {
          if (str === void 0)
            return this._version;
          this._version = str;
          flags = flags || "-V, --version";
          description = description || "output the version number";
          const versionOption = this.createOption(flags, description);
          this._versionOptionName = versionOption.attributeName();
          this.options.push(versionOption);
          this.on("option:" + versionOption.name(), () => {
            this._outputConfiguration.writeOut(`${str}
`);
            this._exit(0, "commander.version", str);
          });
          return this;
        }
        /**
         * Set the description.
         *
         * @param {string} [str]
         * @param {Object} [argsDescription]
         * @return {string|Command}
         */
        description(str, argsDescription) {
          if (str === void 0 && argsDescription === void 0)
            return this._description;
          this._description = str;
          if (argsDescription) {
            this._argsDescription = argsDescription;
          }
          return this;
        }
        /**
         * Set the summary. Used when listed as subcommand of parent.
         *
         * @param {string} [str]
         * @return {string|Command}
         */
        summary(str) {
          if (str === void 0)
            return this._summary;
          this._summary = str;
          return this;
        }
        /**
         * Set an alias for the command.
         *
         * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
         *
         * @param {string} [alias]
         * @return {string|Command}
         */
        alias(alias) {
          if (alias === void 0)
            return this._aliases[0];
          let command = this;
          if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
            command = this.commands[this.commands.length - 1];
          }
          if (alias === command._name)
            throw new Error("Command alias can't be the same as its name");
          command._aliases.push(alias);
          return this;
        }
        /**
         * Set aliases for the command.
         *
         * Only the first alias is shown in the auto-generated help.
         *
         * @param {string[]} [aliases]
         * @return {string[]|Command}
         */
        aliases(aliases) {
          if (aliases === void 0)
            return this._aliases;
          aliases.forEach((alias) => this.alias(alias));
          return this;
        }
        /**
         * Set / get the command usage `str`.
         *
         * @param {string} [str]
         * @return {String|Command}
         */
        usage(str) {
          if (str === void 0) {
            if (this._usage)
              return this._usage;
            const args = this._args.map((arg) => {
              return humanReadableArgName(arg);
            });
            return [].concat(
              this.options.length || this._hasHelpOption ? "[options]" : [],
              this.commands.length ? "[command]" : [],
              this._args.length ? args : []
            ).join(" ");
          }
          this._usage = str;
          return this;
        }
        /**
         * Get or set the name of the command.
         *
         * @param {string} [str]
         * @return {string|Command}
         */
        name(str) {
          if (str === void 0)
            return this._name;
          this._name = str;
          return this;
        }
        /**
         * Set the name of the command from script filename, such as process.argv[1],
         * or require.main.filename, or __filename.
         *
         * (Used internally and public although not documented in README.)
         *
         * @example
         * program.nameFromFilename(require.main.filename);
         *
         * @param {string} filename
         * @return {Command}
         */
        nameFromFilename(filename) {
          this._name = path5.basename(filename, path5.extname(filename));
          return this;
        }
        /**
         * Get or set the directory for searching for executable subcommands of this command.
         *
         * @example
         * program.executableDir(__dirname);
         * // or
         * program.executableDir('subcommands');
         *
         * @param {string} [path]
         * @return {string|Command}
         */
        executableDir(path6) {
          if (path6 === void 0)
            return this._executableDir;
          this._executableDir = path6;
          return this;
        }
        /**
         * Return program help documentation.
         *
         * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
         * @return {string}
         */
        helpInformation(contextOptions) {
          const helper = this.createHelp();
          if (helper.helpWidth === void 0) {
            helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
          }
          return helper.formatHelp(this, helper);
        }
        /**
         * @api private
         */
        _getHelpContext(contextOptions) {
          contextOptions = contextOptions || {};
          const context2 = { error: !!contextOptions.error };
          let write;
          if (context2.error) {
            write = (arg) => this._outputConfiguration.writeErr(arg);
          } else {
            write = (arg) => this._outputConfiguration.writeOut(arg);
          }
          context2.write = contextOptions.write || write;
          context2.command = this;
          return context2;
        }
        /**
         * Output help information for this command.
         *
         * Outputs built-in help, and custom text added using `.addHelpText()`.
         *
         * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
         */
        outputHelp(contextOptions) {
          let deprecatedCallback;
          if (typeof contextOptions === "function") {
            deprecatedCallback = contextOptions;
            contextOptions = void 0;
          }
          const context2 = this._getHelpContext(contextOptions);
          getCommandAndParents(this).reverse().forEach((command) => command.emit("beforeAllHelp", context2));
          this.emit("beforeHelp", context2);
          let helpInformation = this.helpInformation(context2);
          if (deprecatedCallback) {
            helpInformation = deprecatedCallback(helpInformation);
            if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
              throw new Error("outputHelp callback must return a string or a Buffer");
            }
          }
          context2.write(helpInformation);
          this.emit(this._helpLongFlag);
          this.emit("afterHelp", context2);
          getCommandAndParents(this).forEach((command) => command.emit("afterAllHelp", context2));
        }
        /**
         * You can pass in flags and a description to override the help
         * flags and help description for your command. Pass in false to
         * disable the built-in help option.
         *
         * @param {string | boolean} [flags]
         * @param {string} [description]
         * @return {Command} `this` command for chaining
         */
        helpOption(flags, description) {
          if (typeof flags === "boolean") {
            this._hasHelpOption = flags;
            return this;
          }
          this._helpFlags = flags || this._helpFlags;
          this._helpDescription = description || this._helpDescription;
          const helpFlags = splitOptionFlags(this._helpFlags);
          this._helpShortFlag = helpFlags.shortFlag;
          this._helpLongFlag = helpFlags.longFlag;
          return this;
        }
        /**
         * Output help information and exit.
         *
         * Outputs built-in help, and custom text added using `.addHelpText()`.
         *
         * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
         */
        help(contextOptions) {
          this.outputHelp(contextOptions);
          let exitCode = process2.exitCode || 0;
          if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
            exitCode = 1;
          }
          this._exit(exitCode, "commander.help", "(outputHelp)");
        }
        /**
         * Add additional text to be displayed with the built-in help.
         *
         * Position is 'before' or 'after' to affect just this command,
         * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
         *
         * @param {string} position - before or after built-in help
         * @param {string | Function} text - string to add, or a function returning a string
         * @return {Command} `this` command for chaining
         */
        addHelpText(position, text) {
          const allowedValues = ["beforeAll", "before", "after", "afterAll"];
          if (!allowedValues.includes(position)) {
            throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
          }
          const helpEvent = `${position}Help`;
          this.on(helpEvent, (context2) => {
            let helpStr;
            if (typeof text === "function") {
              helpStr = text({ error: context2.error, command: context2.command });
            } else {
              helpStr = text;
            }
            if (helpStr) {
              context2.write(`${helpStr}
`);
            }
          });
          return this;
        }
      };
      function outputHelpIfRequested(cmd, args) {
        const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
        if (helpOption) {
          cmd.outputHelp();
          cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
        }
      }
      function incrementNodeInspectorPort(args) {
        return args.map((arg) => {
          if (!arg.startsWith("--inspect")) {
            return arg;
          }
          let debugOption;
          let debugHost = "127.0.0.1";
          let debugPort = "9229";
          let match3;
          if ((match3 = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
            debugOption = match3[1];
          } else if ((match3 = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
            debugOption = match3[1];
            if (/^\d+$/.test(match3[3])) {
              debugPort = match3[3];
            } else {
              debugHost = match3[3];
            }
          } else if ((match3 = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
            debugOption = match3[1];
            debugHost = match3[3];
            debugPort = match3[4];
          }
          if (debugOption && debugPort !== "0") {
            return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
          }
          return arg;
        });
      }
      function getCommandAndParents(startCommand) {
        const result = [];
        for (let command = startCommand; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      exports.Command = Command2;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/index.js
  var require_commander = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/index.js"(exports, module) {
      var { Argument: Argument2 } = require_argument();
      var { Command: Command2 } = require_command();
      var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var { Help: Help2 } = require_help();
      var { Option: Option2 } = require_option();
      exports = module.exports = new Command2();
      exports.program = exports;
      exports.Argument = Argument2;
      exports.Command = Command2;
      exports.CommanderError = CommanderError2;
      exports.Help = Help2;
      exports.InvalidArgumentError = InvalidArgumentError2;
      exports.InvalidOptionArgumentError = InvalidArgumentError2;
      exports.Option = Option2;
    }
  });

  // ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
      "use strict";
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
  var require_brace_expansion = __commonJS({
    "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module) {
      var balanced = require_balanced_match();
      module.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand2(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand2(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m)
          return [str];
        var pre = m.pre;
        var post = m.post.length ? expand2(m.post, false) : [""];
        if (/\$$/.test(m.pre)) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
          }
        } else {
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
              str = m.pre + "{" + m.body + escClose + m.post;
              return expand2(str);
            }
            return [str];
          }
          var n;
          if (isSequence) {
            n = m.body.split(/\.\./);
          } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
              n = expand2(n[0], false).map(embrace);
              if (n.length === 1) {
                return post.map(function(p) {
                  return m.pre + n[0] + p;
                });
              }
            }
          }
          var N;
          if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
              incr *= -1;
              test = gte;
            }
            var pad3 = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
              var c;
              if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\")
                  c = "";
              } else {
                c = String(i);
                if (pad3) {
                  var need = width - c.length;
                  if (need > 0) {
                    var z = new Array(need + 1).join("0");
                    if (i < 0)
                      c = "-" + z + c.slice(1);
                    else
                      c = z + c;
                  }
                }
              }
              N.push(c);
            }
          } else {
            N = [];
            for (var j = 0; j < n.length; j++) {
              N.push.apply(N, expand2(n[j], false));
            }
          }
          for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + N[j] + post[k];
              if (!isTop || isSequence || expansion)
                expansions.push(expansion);
            }
          }
        }
        return expansions;
      }
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js
  var require_opts_arg = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js"(exports, module) {
      var { promisify } = __require2("util");
      var fs4 = __require2("fs");
      var optsArg = (opts) => {
        if (!opts)
          opts = { mode: 511, fs: fs4 };
        else if (typeof opts === "object")
          opts = { mode: 511, fs: fs4, ...opts };
        else if (typeof opts === "number")
          opts = { mode: opts, fs: fs4 };
        else if (typeof opts === "string")
          opts = { mode: parseInt(opts, 8), fs: fs4 };
        else
          throw new TypeError("invalid options argument");
        opts.mkdir = opts.mkdir || opts.fs.mkdir || fs4.mkdir;
        opts.mkdirAsync = promisify(opts.mkdir);
        opts.stat = opts.stat || opts.fs.stat || fs4.stat;
        opts.statAsync = promisify(opts.stat);
        opts.statSync = opts.statSync || opts.fs.statSync || fs4.statSync;
        opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs4.mkdirSync;
        return opts;
      };
      module.exports = optsArg;
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js
  var require_path_arg = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js"(exports, module) {
      var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
      var { resolve: resolve4, parse: parse3 } = __require2("path");
      var pathArg = (path5) => {
        if (/\0/.test(path5)) {
          throw Object.assign(
            new TypeError("path must be a string without null bytes"),
            {
              path: path5,
              code: "ERR_INVALID_ARG_VALUE"
            }
          );
        }
        path5 = resolve4(path5);
        if (platform === "win32") {
          const badWinChars = /[*|"<>?:]/;
          const { root } = parse3(path5);
          if (badWinChars.test(path5.substr(root.length))) {
            throw Object.assign(new Error("Illegal characters in path."), {
              path: path5,
              code: "EINVAL"
            });
          }
        }
        return path5;
      };
      module.exports = pathArg;
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js
  var require_find_made = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js"(exports, module) {
      var { dirname } = __require2("path");
      var findMade = (opts, parent, path5 = void 0) => {
        if (path5 === parent)
          return Promise.resolve();
        return opts.statAsync(parent).then(
          (st) => st.isDirectory() ? path5 : void 0,
          // will fail later
          (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : void 0
        );
      };
      var findMadeSync = (opts, parent, path5 = void 0) => {
        if (path5 === parent)
          return void 0;
        try {
          return opts.statSync(parent).isDirectory() ? path5 : void 0;
        } catch (er) {
          return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : void 0;
        }
      };
      module.exports = { findMade, findMadeSync };
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js
  var require_mkdirp_manual = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js"(exports, module) {
      var { dirname } = __require2("path");
      var mkdirpManual = (path5, opts, made) => {
        opts.recursive = false;
        const parent = dirname(path5);
        if (parent === path5) {
          return opts.mkdirAsync(path5, opts).catch((er) => {
            if (er.code !== "EISDIR")
              throw er;
          });
        }
        return opts.mkdirAsync(path5, opts).then(() => made || path5, (er) => {
          if (er.code === "ENOENT")
            return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path5, opts, made2));
          if (er.code !== "EEXIST" && er.code !== "EROFS")
            throw er;
          return opts.statAsync(path5).then((st) => {
            if (st.isDirectory())
              return made;
            else
              throw er;
          }, () => {
            throw er;
          });
        });
      };
      var mkdirpManualSync = (path5, opts, made) => {
        const parent = dirname(path5);
        opts.recursive = false;
        if (parent === path5) {
          try {
            return opts.mkdirSync(path5, opts);
          } catch (er) {
            if (er.code !== "EISDIR")
              throw er;
            else
              return;
          }
        }
        try {
          opts.mkdirSync(path5, opts);
          return made || path5;
        } catch (er) {
          if (er.code === "ENOENT")
            return mkdirpManualSync(path5, opts, mkdirpManualSync(parent, opts, made));
          if (er.code !== "EEXIST" && er.code !== "EROFS")
            throw er;
          try {
            if (!opts.statSync(path5).isDirectory())
              throw er;
          } catch (_) {
            throw er;
          }
        }
      };
      module.exports = { mkdirpManual, mkdirpManualSync };
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js
  var require_mkdirp_native = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js"(exports, module) {
      var { dirname } = __require2("path");
      var { findMade, findMadeSync } = require_find_made();
      var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
      var mkdirpNative = (path5, opts) => {
        opts.recursive = true;
        const parent = dirname(path5);
        if (parent === path5)
          return opts.mkdirAsync(path5, opts);
        return findMade(opts, path5).then((made) => opts.mkdirAsync(path5, opts).then(() => made).catch((er) => {
          if (er.code === "ENOENT")
            return mkdirpManual(path5, opts);
          else
            throw er;
        }));
      };
      var mkdirpNativeSync = (path5, opts) => {
        opts.recursive = true;
        const parent = dirname(path5);
        if (parent === path5)
          return opts.mkdirSync(path5, opts);
        const made = findMadeSync(opts, path5);
        try {
          opts.mkdirSync(path5, opts);
          return made;
        } catch (er) {
          if (er.code === "ENOENT")
            return mkdirpManualSync(path5, opts);
          else
            throw er;
        }
      };
      module.exports = { mkdirpNative, mkdirpNativeSync };
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js
  var require_use_native = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js"(exports, module) {
      var fs4 = __require2("fs");
      var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
      var versArr = version2.replace(/^v/, "").split(".");
      var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
      var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs4.mkdir;
      var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs4.mkdirSync;
      module.exports = { useNative, useNativeSync };
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js
  var require_mkdirp = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js"(exports, module) {
      var optsArg = require_opts_arg();
      var pathArg = require_path_arg();
      var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
      var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
      var { useNative, useNativeSync } = require_use_native();
      var mkdirp3 = (path5, opts) => {
        path5 = pathArg(path5);
        opts = optsArg(opts);
        return useNative(opts) ? mkdirpNative(path5, opts) : mkdirpManual(path5, opts);
      };
      var mkdirpSync = (path5, opts) => {
        path5 = pathArg(path5);
        opts = optsArg(opts);
        return useNativeSync(opts) ? mkdirpNativeSync(path5, opts) : mkdirpManualSync(path5, opts);
      };
      mkdirp3.sync = mkdirpSync;
      mkdirp3.native = (path5, opts) => mkdirpNative(pathArg(path5), optsArg(opts));
      mkdirp3.manual = (path5, opts) => mkdirpManual(pathArg(path5), optsArg(opts));
      mkdirp3.nativeSync = (path5, opts) => mkdirpNativeSync(pathArg(path5), optsArg(opts));
      mkdirp3.manualSync = (path5, opts) => mkdirpManualSync(pathArg(path5), optsArg(opts));
      module.exports = mkdirp3;
    }
  });

  // ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
  var require_old = __commonJS({
    "../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js"(exports) {
      var pathModule = __require2("path");
      var isWindows = process.platform === "win32";
      var fs4 = __require2("fs");
      var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
      function rethrow() {
        var callback;
        if (DEBUG) {
          var backtrace = new Error();
          callback = debugCallback;
        } else
          callback = missingCallback;
        return callback;
        function debugCallback(err) {
          if (err) {
            backtrace.message = err.message;
            err = backtrace;
            missingCallback(err);
          }
        }
        function missingCallback(err) {
          if (err) {
            if (process.throwDeprecation)
              throw err;
            else if (!process.noDeprecation) {
              var msg = "fs: missing callback " + (err.stack || err.message);
              if (process.traceDeprecation)
                console.trace(msg);
              else
                console.error(msg);
            }
          }
        }
      }
      function maybeCallback(cb) {
        return typeof cb === "function" ? cb : rethrow();
      }
      var normalize5 = pathModule.normalize;
      if (isWindows) {
        nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
      } else {
        nextPartRe = /(.*?)(?:[\/]+|$)/g;
      }
      var nextPartRe;
      if (isWindows) {
        splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
      } else {
        splitRootRe = /^[\/]*/;
      }
      var splitRootRe;
      exports.realpathSync = function realpathSync2(p, cache3) {
        p = pathModule.resolve(p);
        if (cache3 && Object.prototype.hasOwnProperty.call(cache3, p)) {
          return cache3[p];
        }
        var original = p, seenLinks = {}, knownHard = {};
        var pos;
        var current;
        var base;
        var previous;
        start();
        function start() {
          var m = splitRootRe.exec(p);
          pos = m[0].length;
          current = m[0];
          base = m[0];
          previous = "";
          if (isWindows && !knownHard[base]) {
            fs4.lstatSync(base);
            knownHard[base] = true;
          }
        }
        while (pos < p.length) {
          nextPartRe.lastIndex = pos;
          var result = nextPartRe.exec(p);
          previous = current;
          current += result[0];
          base = previous + result[1];
          pos = nextPartRe.lastIndex;
          if (knownHard[base] || cache3 && cache3[base] === base) {
            continue;
          }
          var resolvedLink;
          if (cache3 && Object.prototype.hasOwnProperty.call(cache3, base)) {
            resolvedLink = cache3[base];
          } else {
            var stat = fs4.lstatSync(base);
            if (!stat.isSymbolicLink()) {
              knownHard[base] = true;
              if (cache3)
                cache3[base] = base;
              continue;
            }
            var linkTarget = null;
            if (!isWindows) {
              var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
              if (seenLinks.hasOwnProperty(id)) {
                linkTarget = seenLinks[id];
              }
            }
            if (linkTarget === null) {
              fs4.statSync(base);
              linkTarget = fs4.readlinkSync(base);
            }
            resolvedLink = pathModule.resolve(previous, linkTarget);
            if (cache3)
              cache3[base] = resolvedLink;
            if (!isWindows)
              seenLinks[id] = linkTarget;
          }
          p = pathModule.resolve(resolvedLink, p.slice(pos));
          start();
        }
        if (cache3)
          cache3[original] = p;
        return p;
      };
      exports.realpath = function realpath2(p, cache3, cb) {
        if (typeof cb !== "function") {
          cb = maybeCallback(cache3);
          cache3 = null;
        }
        p = pathModule.resolve(p);
        if (cache3 && Object.prototype.hasOwnProperty.call(cache3, p)) {
          return process.nextTick(cb.bind(null, null, cache3[p]));
        }
        var original = p, seenLinks = {}, knownHard = {};
        var pos;
        var current;
        var base;
        var previous;
        start();
        function start() {
          var m = splitRootRe.exec(p);
          pos = m[0].length;
          current = m[0];
          base = m[0];
          previous = "";
          if (isWindows && !knownHard[base]) {
            fs4.lstat(base, function(err) {
              if (err)
                return cb(err);
              knownHard[base] = true;
              LOOP();
            });
          } else {
            process.nextTick(LOOP);
          }
        }
        function LOOP() {
          if (pos >= p.length) {
            if (cache3)
              cache3[original] = p;
            return cb(null, p);
          }
          nextPartRe.lastIndex = pos;
          var result = nextPartRe.exec(p);
          previous = current;
          current += result[0];
          base = previous + result[1];
          pos = nextPartRe.lastIndex;
          if (knownHard[base] || cache3 && cache3[base] === base) {
            return process.nextTick(LOOP);
          }
          if (cache3 && Object.prototype.hasOwnProperty.call(cache3, base)) {
            return gotResolvedLink(cache3[base]);
          }
          return fs4.lstat(base, gotStat);
        }
        function gotStat(err, stat) {
          if (err)
            return cb(err);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache3)
              cache3[base] = base;
            return process.nextTick(LOOP);
          }
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              return gotTarget(null, seenLinks[id], base);
            }
          }
          fs4.stat(base, function(err2) {
            if (err2)
              return cb(err2);
            fs4.readlink(base, function(err3, target) {
              if (!isWindows)
                seenLinks[id] = target;
              gotTarget(err3, target);
            });
          });
        }
        function gotTarget(err, target, base2) {
          if (err)
            return cb(err);
          var resolvedLink = pathModule.resolve(previous, target);
          if (cache3)
            cache3[base2] = resolvedLink;
          gotResolvedLink(resolvedLink);
        }
        function gotResolvedLink(resolvedLink) {
          p = pathModule.resolve(resolvedLink, p.slice(pos));
          start();
        }
      };
    }
  });

  // ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js
  var require_fs = __commonJS({
    "../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js"(exports, module) {
      module.exports = realpath2;
      realpath2.realpath = realpath2;
      realpath2.sync = realpathSync2;
      realpath2.realpathSync = realpathSync2;
      realpath2.monkeypatch = monkeypatch;
      realpath2.unmonkeypatch = unmonkeypatch;
      var fs4 = __require2("fs");
      var origRealpath = fs4.realpath;
      var origRealpathSync = fs4.realpathSync;
      var version2 = process.version;
      var ok = /^v[0-5]\./.test(version2);
      var old = require_old();
      function newError(er) {
        return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
      }
      function realpath2(p, cache3, cb) {
        if (ok) {
          return origRealpath(p, cache3, cb);
        }
        if (typeof cache3 === "function") {
          cb = cache3;
          cache3 = null;
        }
        origRealpath(p, cache3, function(er, result) {
          if (newError(er)) {
            old.realpath(p, cache3, cb);
          } else {
            cb(er, result);
          }
        });
      }
      function realpathSync2(p, cache3) {
        if (ok) {
          return origRealpathSync(p, cache3);
        }
        try {
          return origRealpathSync(p, cache3);
        } catch (er) {
          if (newError(er)) {
            return old.realpathSync(p, cache3);
          } else {
            throw er;
          }
        }
      }
      function monkeypatch() {
        fs4.realpath = realpath2;
        fs4.realpathSync = realpathSync2;
      }
      function unmonkeypatch() {
        fs4.realpath = origRealpath;
        fs4.realpathSync = origRealpathSync;
      }
    }
  });

  // ../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js
  var require_concat_map = __commonJS({
    "../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js"(exports, module) {
      module.exports = function(xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          if (isArray(x))
            res.push.apply(res, x);
          else
            res.push(x);
        }
        return res;
      };
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
    }
  });

  // ../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js
  var require_brace_expansion2 = __commonJS({
    "../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js"(exports, module) {
      var concatMap = require_concat_map();
      var balanced = require_balanced_match();
      module.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand2(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand2(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m || /\$$/.test(m.pre))
          return [str];
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              var post = m.post.length ? expand2(m.post, false) : [""];
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var pre = m.pre;
        var post = m.post.length ? expand2(m.post, false) : [""];
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad3 = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad3) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = concatMap(n, function(el) {
            return expand2(el, false);
          });
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
        return expansions;
      }
    }
  });

  // ../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js
  var require_minimatch = __commonJS({
    "../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js"(exports, module) {
      module.exports = minimatch2;
      minimatch2.Minimatch = Minimatch2;
      var path5 = function() {
        try {
          return __require2("path");
        } catch (e) {
        }
      }() || {
        sep: "/"
      };
      minimatch2.sep = path5.sep;
      var GLOBSTAR2 = minimatch2.GLOBSTAR = Minimatch2.GLOBSTAR = {};
      var expand2 = require_brace_expansion2();
      var plTypes = {
        "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
        "?": { open: "(?:", close: ")?" },
        "+": { open: "(?:", close: ")+" },
        "*": { open: "(?:", close: ")*" },
        "@": { open: "(?:", close: ")" }
      };
      var qmark3 = "[^/]";
      var star3 = qmark3 + "*?";
      var twoStarDot2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      var twoStarNoDot2 = "(?:(?!(?:\\/|^)\\.).)*?";
      var reSpecials2 = charSet("().*{}+?[]^$\\!");
      function charSet(s) {
        return s.split("").reduce(function(set2, c) {
          set2[c] = true;
          return set2;
        }, {});
      }
      var slashSplit = /\/+/;
      minimatch2.filter = filter2;
      function filter2(pattern, options) {
        options = options || {};
        return function(p, i, list) {
          return minimatch2(p, pattern, options);
        };
      }
      function ext2(a, b) {
        b = b || {};
        var t = {};
        Object.keys(a).forEach(function(k) {
          t[k] = a[k];
        });
        Object.keys(b).forEach(function(k) {
          t[k] = b[k];
        });
        return t;
      }
      minimatch2.defaults = function(def) {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return minimatch2;
        }
        var orig = minimatch2;
        var m = function minimatch3(p, pattern, options) {
          return orig(p, pattern, ext2(def, options));
        };
        m.Minimatch = function Minimatch3(pattern, options) {
          return new orig.Minimatch(pattern, ext2(def, options));
        };
        m.Minimatch.defaults = function defaults2(options) {
          return orig.defaults(ext2(def, options)).Minimatch;
        };
        m.filter = function filter3(pattern, options) {
          return orig.filter(pattern, ext2(def, options));
        };
        m.defaults = function defaults2(options) {
          return orig.defaults(ext2(def, options));
        };
        m.makeRe = function makeRe3(pattern, options) {
          return orig.makeRe(pattern, ext2(def, options));
        };
        m.braceExpand = function braceExpand3(pattern, options) {
          return orig.braceExpand(pattern, ext2(def, options));
        };
        m.match = function(list, pattern, options) {
          return orig.match(list, pattern, ext2(def, options));
        };
        return m;
      };
      Minimatch2.defaults = function(def) {
        return minimatch2.defaults(def).Minimatch;
      };
      function minimatch2(p, pattern, options) {
        assertValidPattern2(pattern);
        if (!options)
          options = {};
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        return new Minimatch2(pattern, options).match(p);
      }
      function Minimatch2(pattern, options) {
        if (!(this instanceof Minimatch2)) {
          return new Minimatch2(pattern, options);
        }
        assertValidPattern2(pattern);
        if (!options)
          options = {};
        pattern = pattern.trim();
        if (!options.allowWindowsEscape && path5.sep !== "/") {
          pattern = pattern.split(path5.sep).join("/");
        }
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      Minimatch2.prototype.debug = function() {
      };
      Minimatch2.prototype.make = make;
      function make() {
        var pattern = this.pattern;
        var options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        var set2 = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = function debug2() {
            console.error.apply(console, arguments);
          };
        this.debug(this.pattern, set2);
        set2 = this.globParts = set2.map(function(s) {
          return s.split(slashSplit);
        });
        this.debug(this.pattern, set2);
        set2 = set2.map(function(s, si, set3) {
          return s.map(this.parse, this);
        }, this);
        this.debug(this.pattern, set2);
        set2 = set2.filter(function(s) {
          return s.indexOf(false) === -1;
        });
        this.debug(this.pattern, set2);
        this.set = set2;
      }
      Minimatch2.prototype.parseNegate = parseNegate;
      function parseNegate() {
        var pattern = this.pattern;
        var negate = false;
        var options = this.options;
        var negateOffset = 0;
        if (options.nonegate)
          return;
        for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      minimatch2.braceExpand = function(pattern, options) {
        return braceExpand2(pattern, options);
      };
      Minimatch2.prototype.braceExpand = braceExpand2;
      function braceExpand2(pattern, options) {
        if (!options) {
          if (this instanceof Minimatch2) {
            options = this.options;
          } else {
            options = {};
          }
        }
        pattern = typeof pattern === "undefined" ? this.pattern : pattern;
        assertValidPattern2(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          return [pattern];
        }
        return expand2(pattern);
      }
      var MAX_PATTERN_LENGTH2 = 1024 * 64;
      var assertValidPattern2 = function(pattern) {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }
        if (pattern.length > MAX_PATTERN_LENGTH2) {
          throw new TypeError("pattern is too long");
        }
      };
      Minimatch2.prototype.parse = parse3;
      var SUBPARSE = {};
      function parse3(pattern, isSub) {
        assertValidPattern2(pattern);
        var options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR2;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        var re = "";
        var hasMagic2 = !!options.nocase;
        var escaping = false;
        var patternListStack = [];
        var negativeLists = [];
        var stateChar;
        var inClass = false;
        var reClassStart = -1;
        var classStart = -1;
        var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        var self2 = this;
        function clearStateChar() {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star3;
                hasMagic2 = true;
                break;
              case "?":
                re += qmark3;
                hasMagic2 = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            self2.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        }
        for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping && reSpecials2[c]) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              self2.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic2 = true;
              var pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic2 = hasMagic2 || sp[1];
                inClass = false;
                continue;
              }
              hasMagic2 = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (escaping) {
                escaping = false;
              } else if (reSpecials2[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic2 = hasMagic2 || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          var tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          var t = pl.type === "*" ? star3 : pl.type === "?" ? qmark3 : "\\" + pl.type;
          hasMagic2 = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        var addPatternStart2 = false;
        switch (re.charAt(0)) {
          case "[":
          case ".":
          case "(":
            addPatternStart2 = true;
        }
        for (var n = negativeLists.length - 1; n > -1; n--) {
          var nl = negativeLists[n];
          var nlBefore = re.slice(0, nl.reStart);
          var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
          var nlAfter = re.slice(nl.reEnd);
          nlLast += nlAfter;
          var openParensBefore = nlBefore.split("(").length - 1;
          var cleanAfter = nlAfter;
          for (i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          var dollar = "";
          if (nlAfter === "" && isSub !== SUBPARSE) {
            dollar = "$";
          }
          var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
          re = newRe;
        }
        if (re !== "" && hasMagic2) {
          re = "(?=.)" + re;
        }
        if (addPatternStart2) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic2];
        }
        if (!hasMagic2) {
          return globUnescape(pattern);
        }
        var flags = options.nocase ? "i" : "";
        try {
          var regExp = new RegExp("^" + re + "$", flags);
        } catch (er) {
          return new RegExp("$.");
        }
        regExp._glob = pattern;
        regExp._src = re;
        return regExp;
      }
      minimatch2.makeRe = function(pattern, options) {
        return new Minimatch2(pattern, options || {}).makeRe();
      };
      Minimatch2.prototype.makeRe = makeRe2;
      function makeRe2() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        var set2 = this.set;
        if (!set2.length) {
          this.regexp = false;
          return this.regexp;
        }
        var options = this.options;
        var twoStar = options.noglobstar ? star3 : options.dot ? twoStarDot2 : twoStarNoDot2;
        var flags = options.nocase ? "i" : "";
        var re = set2.map(function(pattern) {
          return pattern.map(function(p) {
            return p === GLOBSTAR2 ? twoStar : typeof p === "string" ? regExpEscape3(p) : p._src;
          }).join("\\/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      minimatch2.match = function(list, pattern, options) {
        options = options || {};
        var mm = new Minimatch2(pattern, options);
        list = list.filter(function(f2) {
          return mm.match(f2);
        });
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      Minimatch2.prototype.match = function match3(f2, partial) {
        if (typeof partial === "undefined")
          partial = this.partial;
        this.debug("match", f2, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f2 === "";
        if (f2 === "/" && partial)
          return true;
        var options = this.options;
        if (path5.sep !== "/") {
          f2 = f2.split(path5.sep).join("/");
        }
        f2 = f2.split(slashSplit);
        this.debug(this.pattern, "split", f2);
        var set2 = this.set;
        this.debug(this.pattern, "set", set2);
        var filename;
        var i;
        for (i = f2.length - 1; i >= 0; i--) {
          filename = f2[i];
          if (filename)
            break;
        }
        for (i = 0; i < set2.length; i++) {
          var pattern = set2[i];
          var file = f2;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          var hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      };
      Minimatch2.prototype.matchOne = function(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f2 = file[fi];
          this.debug(pattern, p, f2);
          if (p === false)
            return false;
          if (p === GLOBSTAR2) {
            this.debug("GLOBSTAR", [pattern, p, f2]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f2 === p;
            this.debug("string match", p, f2, hit);
          } else {
            hit = f2.match(p);
            this.debug("pattern match", p, f2, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      };
      function globUnescape(s) {
        return s.replace(/\\(.)/g, "$1");
      }
      function regExpEscape3(s) {
        return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
    }
  });

  // ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
  var require_inherits = __commonJS({
    "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports, module) {
      try {
        util = __require2("util");
        if (typeof util.inherits !== "function")
          throw "";
        module.exports = util.inherits;
      } catch (e) {
        module.exports = require_inherits_browser();
      }
      var util;
    }
  });

  // ../../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js
  var require_path_is_absolute = __commonJS({
    "../../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js"(exports, module) {
      "use strict";
      function posix2(path5) {
        return path5.charAt(0) === "/";
      }
      function win322(path5) {
        var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
        var result = splitDeviceRe.exec(path5);
        var device = result[1] || "";
        var isUnc = Boolean(device && device.charAt(1) !== ":");
        return Boolean(result[2] || isUnc);
      }
      module.exports = process.platform === "win32" ? win322 : posix2;
      module.exports.posix = posix2;
      module.exports.win32 = win322;
    }
  });

  // ../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/common.js
  var require_common = __commonJS({
    "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/common.js"(exports) {
      exports.setopts = setopts;
      exports.ownProp = ownProp;
      exports.makeAbs = makeAbs;
      exports.finish = finish;
      exports.mark = mark;
      exports.isIgnored = isIgnored;
      exports.childrenIgnored = childrenIgnored;
      function ownProp(obj, field) {
        return Object.prototype.hasOwnProperty.call(obj, field);
      }
      var fs4 = __require2("fs");
      var path5 = __require2("path");
      var minimatch2 = require_minimatch();
      var isAbsolute = require_path_is_absolute();
      var Minimatch2 = minimatch2.Minimatch;
      function alphasort(a, b) {
        return a.localeCompare(b, "en");
      }
      function setupIgnores(self2, options) {
        self2.ignore = options.ignore || [];
        if (!Array.isArray(self2.ignore))
          self2.ignore = [self2.ignore];
        if (self2.ignore.length) {
          self2.ignore = self2.ignore.map(ignoreMap);
        }
      }
      function ignoreMap(pattern) {
        var gmatcher = null;
        if (pattern.slice(-3) === "/**") {
          var gpattern = pattern.replace(/(\/\*\*)+$/, "");
          gmatcher = new Minimatch2(gpattern, { dot: true });
        }
        return {
          matcher: new Minimatch2(pattern, { dot: true }),
          gmatcher
        };
      }
      function setopts(self2, pattern, options) {
        if (!options)
          options = {};
        if (options.matchBase && -1 === pattern.indexOf("/")) {
          if (options.noglobstar) {
            throw new Error("base matching requires globstar");
          }
          pattern = "**/" + pattern;
        }
        self2.silent = !!options.silent;
        self2.pattern = pattern;
        self2.strict = options.strict !== false;
        self2.realpath = !!options.realpath;
        self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
        self2.follow = !!options.follow;
        self2.dot = !!options.dot;
        self2.mark = !!options.mark;
        self2.nodir = !!options.nodir;
        if (self2.nodir)
          self2.mark = true;
        self2.sync = !!options.sync;
        self2.nounique = !!options.nounique;
        self2.nonull = !!options.nonull;
        self2.nosort = !!options.nosort;
        self2.nocase = !!options.nocase;
        self2.stat = !!options.stat;
        self2.noprocess = !!options.noprocess;
        self2.absolute = !!options.absolute;
        self2.fs = options.fs || fs4;
        self2.maxLength = options.maxLength || Infinity;
        self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
        self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
        self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
        setupIgnores(self2, options);
        self2.changedCwd = false;
        var cwd = process.cwd();
        if (!ownProp(options, "cwd"))
          self2.cwd = cwd;
        else {
          self2.cwd = path5.resolve(options.cwd);
          self2.changedCwd = self2.cwd !== cwd;
        }
        self2.root = options.root || path5.resolve(self2.cwd, "/");
        self2.root = path5.resolve(self2.root);
        if (process.platform === "win32")
          self2.root = self2.root.replace(/\\/g, "/");
        self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
        if (process.platform === "win32")
          self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
        self2.nomount = !!options.nomount;
        options.nonegate = true;
        options.nocomment = true;
        options.allowWindowsEscape = false;
        self2.minimatch = new Minimatch2(pattern, options);
        self2.options = self2.minimatch.options;
      }
      function finish(self2) {
        var nou = self2.nounique;
        var all = nou ? [] : /* @__PURE__ */ Object.create(null);
        for (var i = 0, l = self2.matches.length; i < l; i++) {
          var matches = self2.matches[i];
          if (!matches || Object.keys(matches).length === 0) {
            if (self2.nonull) {
              var literal = self2.minimatch.globSet[i];
              if (nou)
                all.push(literal);
              else
                all[literal] = true;
            }
          } else {
            var m = Object.keys(matches);
            if (nou)
              all.push.apply(all, m);
            else
              m.forEach(function(m2) {
                all[m2] = true;
              });
          }
        }
        if (!nou)
          all = Object.keys(all);
        if (!self2.nosort)
          all = all.sort(alphasort);
        if (self2.mark) {
          for (var i = 0; i < all.length; i++) {
            all[i] = self2._mark(all[i]);
          }
          if (self2.nodir) {
            all = all.filter(function(e) {
              var notDir = !/\/$/.test(e);
              var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
              if (notDir && c)
                notDir = c !== "DIR" && !Array.isArray(c);
              return notDir;
            });
          }
        }
        if (self2.ignore.length)
          all = all.filter(function(m2) {
            return !isIgnored(self2, m2);
          });
        self2.found = all;
      }
      function mark(self2, p) {
        var abs = makeAbs(self2, p);
        var c = self2.cache[abs];
        var m = p;
        if (c) {
          var isDir = c === "DIR" || Array.isArray(c);
          var slash = p.slice(-1) === "/";
          if (isDir && !slash)
            m += "/";
          else if (!isDir && slash)
            m = m.slice(0, -1);
          if (m !== p) {
            var mabs = makeAbs(self2, m);
            self2.statCache[mabs] = self2.statCache[abs];
            self2.cache[mabs] = self2.cache[abs];
          }
        }
        return m;
      }
      function makeAbs(self2, f2) {
        var abs = f2;
        if (f2.charAt(0) === "/") {
          abs = path5.join(self2.root, f2);
        } else if (isAbsolute(f2) || f2 === "") {
          abs = f2;
        } else if (self2.changedCwd) {
          abs = path5.resolve(self2.cwd, f2);
        } else {
          abs = path5.resolve(f2);
        }
        if (process.platform === "win32")
          abs = abs.replace(/\\/g, "/");
        return abs;
      }
      function isIgnored(self2, path6) {
        if (!self2.ignore.length)
          return false;
        return self2.ignore.some(function(item) {
          return item.matcher.match(path6) || !!(item.gmatcher && item.gmatcher.match(path6));
        });
      }
      function childrenIgnored(self2, path6) {
        if (!self2.ignore.length)
          return false;
        return self2.ignore.some(function(item) {
          return !!(item.gmatcher && item.gmatcher.match(path6));
        });
      }
    }
  });

  // ../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/sync.js
  var require_sync = __commonJS({
    "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/sync.js"(exports, module) {
      module.exports = globSync2;
      globSync2.GlobSync = GlobSync;
      var rp = require_fs();
      var minimatch2 = require_minimatch();
      var Minimatch2 = minimatch2.Minimatch;
      var Glob2 = require_glob().Glob;
      var util = __require2("util");
      var path5 = __require2("path");
      var assert5 = __require2("assert");
      var isAbsolute = require_path_is_absolute();
      var common = require_common();
      var setopts = common.setopts;
      var ownProp = common.ownProp;
      var childrenIgnored = common.childrenIgnored;
      var isIgnored = common.isIgnored;
      function globSync2(pattern, options) {
        if (typeof options === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        return new GlobSync(pattern, options).found;
      }
      function GlobSync(pattern, options) {
        if (!pattern)
          throw new Error("must provide pattern");
        if (typeof options === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        if (!(this instanceof GlobSync))
          return new GlobSync(pattern, options);
        setopts(this, pattern, options);
        if (this.noprocess)
          return this;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        for (var i = 0; i < n; i++) {
          this._process(this.minimatch.set[i], i, false);
        }
        this._finish();
      }
      GlobSync.prototype._finish = function() {
        assert5.ok(this instanceof GlobSync);
        if (this.realpath) {
          var self2 = this;
          this.matches.forEach(function(matchset, index) {
            var set2 = self2.matches[index] = /* @__PURE__ */ Object.create(null);
            for (var p in matchset) {
              try {
                p = self2._makeAbs(p);
                var real = rp.realpathSync(p, self2.realpathCache);
                set2[real] = true;
              } catch (er) {
                if (er.syscall === "stat")
                  set2[self2._makeAbs(p)] = true;
                else
                  throw er;
              }
            }
          });
        }
        common.finish(this);
      };
      GlobSync.prototype._process = function(pattern, index, inGlobStar) {
        assert5.ok(this instanceof GlobSync);
        var n = 0;
        while (typeof pattern[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern.length:
            this._processSimple(pattern.join("/"), index);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern.slice(0, n).join("/");
            break;
        }
        var remain = pattern.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
          return typeof p === "string" ? p : "[*]";
        }).join("/"))) {
          if (!prefix || !isAbsolute(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs = this._makeAbs(read);
        if (childrenIgnored(this, read))
          return;
        var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
        else
          this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
      };
      GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
        var entries = this._readdir(abs, inGlobStar);
        if (!entries)
          return;
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return;
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            if (prefix) {
              if (prefix.slice(-1) !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path5.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          var newPattern;
          if (prefix)
            newPattern = [prefix, e];
          else
            newPattern = [e];
          this._process(newPattern.concat(remain), index, inGlobStar);
        }
      };
      GlobSync.prototype._emitMatch = function(index, e) {
        if (isIgnored(this, e))
          return;
        var abs = this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute) {
          e = abs;
        }
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        if (this.stat)
          this._stat(e);
      };
      GlobSync.prototype._readdirInGlobStar = function(abs) {
        if (this.follow)
          return this._readdir(abs, false);
        var entries;
        var lstat2;
        var stat;
        try {
          lstat2 = this.fs.lstatSync(abs);
        } catch (er) {
          if (er.code === "ENOENT") {
            return null;
          }
        }
        var isSym = lstat2 && lstat2.isSymbolicLink();
        this.symlinks[abs] = isSym;
        if (!isSym && lstat2 && !lstat2.isDirectory())
          this.cache[abs] = "FILE";
        else
          entries = this._readdir(abs, false);
        return entries;
      };
      GlobSync.prototype._readdir = function(abs, inGlobStar) {
        var entries;
        if (inGlobStar && !ownProp(this.symlinks, abs))
          return this._readdirInGlobStar(abs);
        if (ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (!c || c === "FILE")
            return null;
          if (Array.isArray(c))
            return c;
        }
        try {
          return this._readdirEntries(abs, this.fs.readdirSync(abs));
        } catch (er) {
          this._readdirError(abs, er);
          return null;
        }
      };
      GlobSync.prototype._readdirEntries = function(abs, entries) {
        if (!this.mark && !this.stat) {
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (abs === "/")
              e = abs + e;
            else
              e = abs + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs] = entries;
        return entries;
      };
      GlobSync.prototype._readdirError = function(f2, er) {
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs = this._makeAbs(f2);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
              var error2 = new Error(er.code + " invalid cwd " + this.cwd);
              error2.path = this.cwd;
              error2.code = er.code;
              throw error2;
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f2)] = false;
            break;
          default:
            this.cache[this._makeAbs(f2)] = false;
            if (this.strict)
              throw er;
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
      };
      GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
        var entries = this._readdir(abs, inGlobStar);
        if (!entries)
          return;
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false);
        var len = entries.length;
        var isSym = this.symlinks[abs];
        if (isSym && inGlobStar)
          return;
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i], remainWithoutGlobStar);
          this._process(instead, index, true);
          var below = gspref.concat(entries[i], remain);
          this._process(below, index, true);
        }
      };
      GlobSync.prototype._processSimple = function(prefix, index) {
        var exists3 = this._stat(prefix);
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        if (!exists3)
          return;
        if (prefix && isAbsolute(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path5.join(this.root, prefix);
          } else {
            prefix = path5.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (process.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
      };
      GlobSync.prototype._stat = function(f2) {
        var abs = this._makeAbs(f2);
        var needDir = f2.slice(-1) === "/";
        if (f2.length > this.maxLength)
          return false;
        if (!this.stat && ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return c;
          if (needDir && c === "FILE")
            return false;
        }
        var exists3;
        var stat = this.statCache[abs];
        if (!stat) {
          var lstat2;
          try {
            lstat2 = this.fs.lstatSync(abs);
          } catch (er) {
            if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
              this.statCache[abs] = false;
              return false;
            }
          }
          if (lstat2 && lstat2.isSymbolicLink()) {
            try {
              stat = this.fs.statSync(abs);
            } catch (er) {
              stat = lstat2;
            }
          } else {
            stat = lstat2;
          }
        }
        this.statCache[abs] = stat;
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs] = this.cache[abs] || c;
        if (needDir && c === "FILE")
          return false;
        return c;
      };
      GlobSync.prototype._mark = function(p) {
        return common.mark(this, p);
      };
      GlobSync.prototype._makeAbs = function(f2) {
        return common.makeAbs(this, f2);
      };
    }
  });

  // ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
  var require_wrappy = __commonJS({
    "../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports, module) {
      module.exports = wrappy;
      function wrappy(fn, cb) {
        if (fn && cb)
          return wrappy(fn)(cb);
        if (typeof fn !== "function")
          throw new TypeError("need wrapper function");
        Object.keys(fn).forEach(function(k) {
          wrapper[k] = fn[k];
        });
        return wrapper;
        function wrapper() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          var ret4 = fn.apply(this, args);
          var cb2 = args[args.length - 1];
          if (typeof ret4 === "function" && ret4 !== cb2) {
            Object.keys(cb2).forEach(function(k) {
              ret4[k] = cb2[k];
            });
          }
          return ret4;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
  var require_once = __commonJS({
    "../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports, module) {
      var wrappy = require_wrappy();
      module.exports = wrappy(once2);
      module.exports.strict = wrappy(onceStrict);
      once2.proto = once2(function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return once2(this);
          },
          configurable: true
        });
        Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return onceStrict(this);
          },
          configurable: true
        });
      });
      function once2(fn) {
        var f2 = function() {
          if (f2.called)
            return f2.value;
          f2.called = true;
          return f2.value = fn.apply(this, arguments);
        };
        f2.called = false;
        return f2;
      }
      function onceStrict(fn) {
        var f2 = function() {
          if (f2.called)
            throw new Error(f2.onceError);
          f2.called = true;
          return f2.value = fn.apply(this, arguments);
        };
        var name = fn.name || "Function wrapped with `once`";
        f2.onceError = name + " shouldn't be called more than once";
        f2.called = false;
        return f2;
      }
    }
  });

  // ../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js
  var require_inflight = __commonJS({
    "../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js"(exports, module) {
      var wrappy = require_wrappy();
      var reqs = /* @__PURE__ */ Object.create(null);
      var once2 = require_once();
      module.exports = wrappy(inflight);
      function inflight(key, cb) {
        if (reqs[key]) {
          reqs[key].push(cb);
          return null;
        } else {
          reqs[key] = [cb];
          return makeres(key);
        }
      }
      function makeres(key) {
        return once2(function RES() {
          var cbs = reqs[key];
          var len = cbs.length;
          var args = slice(arguments);
          try {
            for (var i = 0; i < len; i++) {
              cbs[i].apply(null, args);
            }
          } finally {
            if (cbs.length > len) {
              cbs.splice(0, len);
              process.nextTick(function() {
                RES.apply(null, args);
              });
            } else {
              delete reqs[key];
            }
          }
        });
      }
      function slice(args) {
        var length = args.length;
        var array2 = [];
        for (var i = 0; i < length; i++)
          array2[i] = args[i];
        return array2;
      }
    }
  });

  // ../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js
  var require_glob = __commonJS({
    "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js"(exports, module) {
      module.exports = glob2;
      var rp = require_fs();
      var minimatch2 = require_minimatch();
      var Minimatch2 = minimatch2.Minimatch;
      var inherits = require_inherits();
      var EE2 = __require2("events").EventEmitter;
      var path5 = __require2("path");
      var assert5 = __require2("assert");
      var isAbsolute = require_path_is_absolute();
      var globSync2 = require_sync();
      var common = require_common();
      var setopts = common.setopts;
      var ownProp = common.ownProp;
      var inflight = require_inflight();
      var util = __require2("util");
      var childrenIgnored = common.childrenIgnored;
      var isIgnored = common.isIgnored;
      var once2 = require_once();
      function glob2(pattern, options, cb) {
        if (typeof options === "function")
          cb = options, options = {};
        if (!options)
          options = {};
        if (options.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return globSync2(pattern, options);
        }
        return new Glob2(pattern, options, cb);
      }
      glob2.sync = globSync2;
      var GlobSync = glob2.GlobSync = globSync2.GlobSync;
      glob2.glob = glob2;
      function extend(origin, add2) {
        if (add2 === null || typeof add2 !== "object") {
          return origin;
        }
        var keys4 = Object.keys(add2);
        var i = keys4.length;
        while (i--) {
          origin[keys4[i]] = add2[keys4[i]];
        }
        return origin;
      }
      glob2.hasMagic = function(pattern, options_) {
        var options = extend({}, options_);
        options.noprocess = true;
        var g = new Glob2(pattern, options);
        var set2 = g.minimatch.set;
        if (!pattern)
          return false;
        if (set2.length > 1)
          return true;
        for (var j = 0; j < set2[0].length; j++) {
          if (typeof set2[0][j] !== "string")
            return true;
        }
        return false;
      };
      glob2.Glob = Glob2;
      inherits(Glob2, EE2);
      function Glob2(pattern, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        if (options && options.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return new GlobSync(pattern, options);
        }
        if (!(this instanceof Glob2))
          return new Glob2(pattern, options, cb);
        setopts(this, pattern, options);
        this._didRealPath = false;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        if (typeof cb === "function") {
          cb = once2(cb);
          this.on("error", cb);
          this.on("end", function(matches) {
            cb(null, matches);
          });
        }
        var self2 = this;
        this._processing = 0;
        this._emitQueue = [];
        this._processQueue = [];
        this.paused = false;
        if (this.noprocess)
          return this;
        if (n === 0)
          return done();
        var sync2 = true;
        for (var i = 0; i < n; i++) {
          this._process(this.minimatch.set[i], i, false, done);
        }
        sync2 = false;
        function done() {
          --self2._processing;
          if (self2._processing <= 0) {
            if (sync2) {
              process.nextTick(function() {
                self2._finish();
              });
            } else {
              self2._finish();
            }
          }
        }
      }
      Glob2.prototype._finish = function() {
        assert5(this instanceof Glob2);
        if (this.aborted)
          return;
        if (this.realpath && !this._didRealpath)
          return this._realpath();
        common.finish(this);
        this.emit("end", this.found);
      };
      Glob2.prototype._realpath = function() {
        if (this._didRealpath)
          return;
        this._didRealpath = true;
        var n = this.matches.length;
        if (n === 0)
          return this._finish();
        var self2 = this;
        for (var i = 0; i < this.matches.length; i++)
          this._realpathSet(i, next);
        function next() {
          if (--n === 0)
            self2._finish();
        }
      };
      Glob2.prototype._realpathSet = function(index, cb) {
        var matchset = this.matches[index];
        if (!matchset)
          return cb();
        var found = Object.keys(matchset);
        var self2 = this;
        var n = found.length;
        if (n === 0)
          return cb();
        var set2 = this.matches[index] = /* @__PURE__ */ Object.create(null);
        found.forEach(function(p, i) {
          p = self2._makeAbs(p);
          rp.realpath(p, self2.realpathCache, function(er, real) {
            if (!er)
              set2[real] = true;
            else if (er.syscall === "stat")
              set2[p] = true;
            else
              self2.emit("error", er);
            if (--n === 0) {
              self2.matches[index] = set2;
              cb();
            }
          });
        });
      };
      Glob2.prototype._mark = function(p) {
        return common.mark(this, p);
      };
      Glob2.prototype._makeAbs = function(f2) {
        return common.makeAbs(this, f2);
      };
      Glob2.prototype.abort = function() {
        this.aborted = true;
        this.emit("abort");
      };
      Glob2.prototype.pause = function() {
        if (!this.paused) {
          this.paused = true;
          this.emit("pause");
        }
      };
      Glob2.prototype.resume = function() {
        if (this.paused) {
          this.emit("resume");
          this.paused = false;
          if (this._emitQueue.length) {
            var eq2 = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for (var i = 0; i < eq2.length; i++) {
              var e = eq2[i];
              this._emitMatch(e[0], e[1]);
            }
          }
          if (this._processQueue.length) {
            var pq = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for (var i = 0; i < pq.length; i++) {
              var p = pq[i];
              this._processing--;
              this._process(p[0], p[1], p[2], p[3]);
            }
          }
        }
      };
      Glob2.prototype._process = function(pattern, index, inGlobStar, cb) {
        assert5(this instanceof Glob2);
        assert5(typeof cb === "function");
        if (this.aborted)
          return;
        this._processing++;
        if (this.paused) {
          this._processQueue.push([pattern, index, inGlobStar, cb]);
          return;
        }
        var n = 0;
        while (typeof pattern[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern.length:
            this._processSimple(pattern.join("/"), index, cb);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern.slice(0, n).join("/");
            break;
        }
        var remain = pattern.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
          return typeof p === "string" ? p : "[*]";
        }).join("/"))) {
          if (!prefix || !isAbsolute(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs = this._makeAbs(read);
        if (childrenIgnored(this, read))
          return cb();
        var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
        else
          this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
      };
      Glob2.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs, inGlobStar, function(er, entries) {
          return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob2.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return cb();
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            if (prefix) {
              if (prefix !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path5.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return cb();
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          var newPattern;
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          this._process([e].concat(remain), index, inGlobStar, cb);
        }
        cb();
      };
      Glob2.prototype._emitMatch = function(index, e) {
        if (this.aborted)
          return;
        if (isIgnored(this, e))
          return;
        if (this.paused) {
          this._emitQueue.push([index, e]);
          return;
        }
        var abs = isAbsolute(e) ? e : this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute)
          e = abs;
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        var st = this.statCache[abs];
        if (st)
          this.emit("stat", e, st);
        this.emit("match", e);
      };
      Glob2.prototype._readdirInGlobStar = function(abs, cb) {
        if (this.aborted)
          return;
        if (this.follow)
          return this._readdir(abs, false, cb);
        var lstatkey = "lstat\0" + abs;
        var self2 = this;
        var lstatcb = inflight(lstatkey, lstatcb_);
        if (lstatcb)
          self2.fs.lstat(abs, lstatcb);
        function lstatcb_(er, lstat2) {
          if (er && er.code === "ENOENT")
            return cb();
          var isSym = lstat2 && lstat2.isSymbolicLink();
          self2.symlinks[abs] = isSym;
          if (!isSym && lstat2 && !lstat2.isDirectory()) {
            self2.cache[abs] = "FILE";
            cb();
          } else
            self2._readdir(abs, false, cb);
        }
      };
      Glob2.prototype._readdir = function(abs, inGlobStar, cb) {
        if (this.aborted)
          return;
        cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
        if (!cb)
          return;
        if (inGlobStar && !ownProp(this.symlinks, abs))
          return this._readdirInGlobStar(abs, cb);
        if (ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (!c || c === "FILE")
            return cb();
          if (Array.isArray(c))
            return cb(null, c);
        }
        var self2 = this;
        self2.fs.readdir(abs, readdirCb(this, abs, cb));
      };
      function readdirCb(self2, abs, cb) {
        return function(er, entries) {
          if (er)
            self2._readdirError(abs, er, cb);
          else
            self2._readdirEntries(abs, entries, cb);
        };
      }
      Glob2.prototype._readdirEntries = function(abs, entries, cb) {
        if (this.aborted)
          return;
        if (!this.mark && !this.stat) {
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (abs === "/")
              e = abs + e;
            else
              e = abs + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs] = entries;
        return cb(null, entries);
      };
      Glob2.prototype._readdirError = function(f2, er, cb) {
        if (this.aborted)
          return;
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs = this._makeAbs(f2);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
              var error2 = new Error(er.code + " invalid cwd " + this.cwd);
              error2.path = this.cwd;
              error2.code = er.code;
              this.emit("error", error2);
              this.abort();
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f2)] = false;
            break;
          default:
            this.cache[this._makeAbs(f2)] = false;
            if (this.strict) {
              this.emit("error", er);
              this.abort();
            }
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
        return cb();
      };
      Glob2.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs, inGlobStar, function(er, entries) {
          self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob2.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false, cb);
        var isSym = this.symlinks[abs];
        var len = entries.length;
        if (isSym && inGlobStar)
          return cb();
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i], remainWithoutGlobStar);
          this._process(instead, index, true, cb);
          var below = gspref.concat(entries[i], remain);
          this._process(below, index, true, cb);
        }
        cb();
      };
      Glob2.prototype._processSimple = function(prefix, index, cb) {
        var self2 = this;
        this._stat(prefix, function(er, exists3) {
          self2._processSimple2(prefix, index, er, exists3, cb);
        });
      };
      Glob2.prototype._processSimple2 = function(prefix, index, er, exists3, cb) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        if (!exists3)
          return cb();
        if (prefix && isAbsolute(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path5.join(this.root, prefix);
          } else {
            prefix = path5.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (process.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
        cb();
      };
      Glob2.prototype._stat = function(f2, cb) {
        var abs = this._makeAbs(f2);
        var needDir = f2.slice(-1) === "/";
        if (f2.length > this.maxLength)
          return cb();
        if (!this.stat && ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return cb(null, c);
          if (needDir && c === "FILE")
            return cb();
        }
        var exists3;
        var stat = this.statCache[abs];
        if (stat !== void 0) {
          if (stat === false)
            return cb(null, stat);
          else {
            var type3 = stat.isDirectory() ? "DIR" : "FILE";
            if (needDir && type3 === "FILE")
              return cb();
            else
              return cb(null, type3, stat);
          }
        }
        var self2 = this;
        var statcb = inflight("stat\0" + abs, lstatcb_);
        if (statcb)
          self2.fs.lstat(abs, statcb);
        function lstatcb_(er, lstat2) {
          if (lstat2 && lstat2.isSymbolicLink()) {
            return self2.fs.stat(abs, function(er2, stat2) {
              if (er2)
                self2._stat2(f2, abs, null, lstat2, cb);
              else
                self2._stat2(f2, abs, er2, stat2, cb);
            });
          } else {
            self2._stat2(f2, abs, er, lstat2, cb);
          }
        }
      };
      Glob2.prototype._stat2 = function(f2, abs, er, stat, cb) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return cb();
        }
        var needDir = f2.slice(-1) === "/";
        this.statCache[abs] = stat;
        if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
          return cb(null, false, stat);
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs] = this.cache[abs] || c;
        if (needDir && c === "FILE")
          return cb();
        return cb(null, c, stat);
      };
    }
  });

  // ../../node_modules/.pnpm/rimraf@3.0.2/node_modules/rimraf/rimraf.js
  var require_rimraf = __commonJS({
    "../../node_modules/.pnpm/rimraf@3.0.2/node_modules/rimraf/rimraf.js"(exports, module) {
      var assert5 = __require2("assert");
      var path5 = __require2("path");
      var fs4 = __require2("fs");
      var glob2 = void 0;
      try {
        glob2 = require_glob();
      } catch (_err) {
      }
      var defaultGlobOpts = {
        nosort: true,
        silent: true
      };
      var timeout = 0;
      var isWindows = process.platform === "win32";
      var defaults2 = (options) => {
        const methods = [
          "unlink",
          "chmod",
          "stat",
          "lstat",
          "rmdir",
          "readdir"
        ];
        methods.forEach((m) => {
          options[m] = options[m] || fs4[m];
          m = m + "Sync";
          options[m] = options[m] || fs4[m];
        });
        options.maxBusyTries = options.maxBusyTries || 3;
        options.emfileWait = options.emfileWait || 1e3;
        if (options.glob === false) {
          options.disableGlob = true;
        }
        if (options.disableGlob !== true && glob2 === void 0) {
          throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
        }
        options.disableGlob = options.disableGlob || false;
        options.glob = options.glob || defaultGlobOpts;
      };
      var rimraf3 = (p, options, cb) => {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        assert5(p, "rimraf: missing path");
        assert5.equal(typeof p, "string", "rimraf: path should be a string");
        assert5.equal(typeof cb, "function", "rimraf: callback function required");
        assert5(options, "rimraf: invalid options argument provided");
        assert5.equal(typeof options, "object", "rimraf: options should be object");
        defaults2(options);
        let busyTries = 0;
        let errState = null;
        let n = 0;
        const next = (er) => {
          errState = errState || er;
          if (--n === 0)
            cb(errState);
        };
        const afterGlob = (er, results) => {
          if (er)
            return cb(er);
          n = results.length;
          if (n === 0)
            return cb();
          results.forEach((p2) => {
            const CB = (er2) => {
              if (er2) {
                if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                  busyTries++;
                  return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
                }
                if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                  return setTimeout(() => rimraf_(p2, options, CB), timeout++);
                }
                if (er2.code === "ENOENT")
                  er2 = null;
              }
              timeout = 0;
              next(er2);
            };
            rimraf_(p2, options, CB);
          });
        };
        if (options.disableGlob || !glob2.hasMagic(p))
          return afterGlob(null, [p]);
        options.lstat(p, (er, stat) => {
          if (!er)
            return afterGlob(null, [p]);
          glob2(p, options.glob, afterGlob);
        });
      };
      var rimraf_ = (p, options, cb) => {
        assert5(p);
        assert5(options);
        assert5(typeof cb === "function");
        options.lstat(p, (er, st) => {
          if (er && er.code === "ENOENT")
            return cb(null);
          if (er && er.code === "EPERM" && isWindows)
            fixWinEPERM(p, options, er, cb);
          if (st && st.isDirectory())
            return rmdir(p, options, er, cb);
          options.unlink(p, (er2) => {
            if (er2) {
              if (er2.code === "ENOENT")
                return cb(null);
              if (er2.code === "EPERM")
                return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
              if (er2.code === "EISDIR")
                return rmdir(p, options, er2, cb);
            }
            return cb(er2);
          });
        });
      };
      var fixWinEPERM = (p, options, er, cb) => {
        assert5(p);
        assert5(options);
        assert5(typeof cb === "function");
        options.chmod(p, 438, (er2) => {
          if (er2)
            cb(er2.code === "ENOENT" ? null : er);
          else
            options.stat(p, (er3, stats) => {
              if (er3)
                cb(er3.code === "ENOENT" ? null : er);
              else if (stats.isDirectory())
                rmdir(p, options, er, cb);
              else
                options.unlink(p, cb);
            });
        });
      };
      var fixWinEPERMSync = (p, options, er) => {
        assert5(p);
        assert5(options);
        try {
          options.chmodSync(p, 438);
        } catch (er2) {
          if (er2.code === "ENOENT")
            return;
          else
            throw er;
        }
        let stats;
        try {
          stats = options.statSync(p);
        } catch (er3) {
          if (er3.code === "ENOENT")
            return;
          else
            throw er;
        }
        if (stats.isDirectory())
          rmdirSync(p, options, er);
        else
          options.unlinkSync(p);
      };
      var rmdir = (p, options, originalEr, cb) => {
        assert5(p);
        assert5(options);
        assert5(typeof cb === "function");
        options.rmdir(p, (er) => {
          if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
            rmkids(p, options, cb);
          else if (er && er.code === "ENOTDIR")
            cb(originalEr);
          else
            cb(er);
        });
      };
      var rmkids = (p, options, cb) => {
        assert5(p);
        assert5(options);
        assert5(typeof cb === "function");
        options.readdir(p, (er, files) => {
          if (er)
            return cb(er);
          let n = files.length;
          if (n === 0)
            return options.rmdir(p, cb);
          let errState;
          files.forEach((f2) => {
            rimraf3(path5.join(p, f2), options, (er2) => {
              if (errState)
                return;
              if (er2)
                return cb(errState = er2);
              if (--n === 0)
                options.rmdir(p, cb);
            });
          });
        });
      };
      var rimrafSync = (p, options) => {
        options = options || {};
        defaults2(options);
        assert5(p, "rimraf: missing path");
        assert5.equal(typeof p, "string", "rimraf: path should be a string");
        assert5(options, "rimraf: missing options");
        assert5.equal(typeof options, "object", "rimraf: options should be object");
        let results;
        if (options.disableGlob || !glob2.hasMagic(p)) {
          results = [p];
        } else {
          try {
            options.lstatSync(p);
            results = [p];
          } catch (er) {
            results = glob2.sync(p, options.glob);
          }
        }
        if (!results.length)
          return;
        for (let i = 0; i < results.length; i++) {
          const p2 = results[i];
          let st;
          try {
            st = options.lstatSync(p2);
          } catch (er) {
            if (er.code === "ENOENT")
              return;
            if (er.code === "EPERM" && isWindows)
              fixWinEPERMSync(p2, options, er);
          }
          try {
            if (st && st.isDirectory())
              rmdirSync(p2, options, null);
            else
              options.unlinkSync(p2);
          } catch (er) {
            if (er.code === "ENOENT")
              return;
            if (er.code === "EPERM")
              return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
            if (er.code !== "EISDIR")
              throw er;
            rmdirSync(p2, options, er);
          }
        }
      };
      var rmdirSync = (p, options, originalEr) => {
        assert5(p);
        assert5(options);
        try {
          options.rmdirSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "ENOTDIR")
            throw originalEr;
          if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
            rmkidsSync(p, options);
        }
      };
      var rmkidsSync = (p, options) => {
        assert5(p);
        assert5(options);
        options.readdirSync(p).forEach((f2) => rimrafSync(path5.join(p, f2), options));
        const retries = isWindows ? 100 : 1;
        let i = 0;
        do {
          let threw = true;
          try {
            const ret4 = options.rmdirSync(p, options);
            threw = false;
            return ret4;
          } finally {
            if (++i < retries && threw)
              continue;
          }
        } while (true);
      };
      module.exports = rimraf3;
      rimraf3.sync = rimrafSync;
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/utils.js
  var require_utils = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/utils.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.extend = extend;
      exports.indexOf = indexOf;
      exports.escapeExpression = escapeExpression;
      exports.isEmpty = isEmpty;
      exports.createFrame = createFrame;
      exports.blockParams = blockParams;
      exports.appendContextPath = appendContextPath;
      var escape2 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      var badChars = /[&<>"'`=]/g;
      var possible = /[&<>"'`=]/;
      function escapeChar(chr) {
        return escape2[chr];
      }
      function extend(obj) {
        for (var i = 1; i < arguments.length; i++) {
          for (var key in arguments[i]) {
            if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
              obj[key] = arguments[i][key];
            }
          }
        }
        return obj;
      }
      var toString3 = Object.prototype.toString;
      exports.toString = toString3;
      var isFunction = function isFunction2(value) {
        return typeof value === "function";
      };
      if (isFunction(/x/)) {
        exports.isFunction = isFunction = function(value) {
          return typeof value === "function" && toString3.call(value) === "[object Function]";
        };
      }
      exports.isFunction = isFunction;
      var isArray = Array.isArray || function(value) {
        return value && typeof value === "object" ? toString3.call(value) === "[object Array]" : false;
      };
      exports.isArray = isArray;
      function indexOf(array2, value) {
        for (var i = 0, len = array2.length; i < len; i++) {
          if (array2[i] === value) {
            return i;
          }
        }
        return -1;
      }
      function escapeExpression(string2) {
        if (typeof string2 !== "string") {
          if (string2 && string2.toHTML) {
            return string2.toHTML();
          } else if (string2 == null) {
            return "";
          } else if (!string2) {
            return string2 + "";
          }
          string2 = "" + string2;
        }
        if (!possible.test(string2)) {
          return string2;
        }
        return string2.replace(badChars, escapeChar);
      }
      function isEmpty(value) {
        if (!value && value !== 0) {
          return true;
        } else if (isArray(value) && value.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      function createFrame(object2) {
        var frame = extend({}, object2);
        frame._parent = object2;
        return frame;
      }
      function blockParams(params, ids) {
        params.path = ids;
        return params;
      }
      function appendContextPath(contextPath, id) {
        return (contextPath ? contextPath + "." : "") + id;
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/exception.js
  var require_exception = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/exception.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
      function Exception(message, node) {
        var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
        if (loc) {
          line = loc.start.line;
          endLineNumber = loc.end.line;
          column = loc.start.column;
          endColumn = loc.end.column;
          message += " - " + line + ":" + column;
        }
        var tmp = Error.prototype.constructor.call(this, message);
        for (var idx = 0; idx < errorProps.length; idx++) {
          this[errorProps[idx]] = tmp[errorProps[idx]];
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, Exception);
        }
        try {
          if (loc) {
            this.lineNumber = line;
            this.endLineNumber = endLineNumber;
            if (Object.defineProperty) {
              Object.defineProperty(this, "column", {
                value: column,
                enumerable: true
              });
              Object.defineProperty(this, "endColumn", {
                value: endColumn,
                enumerable: true
              });
            } else {
              this.column = column;
              this.endColumn = endColumn;
            }
          }
        } catch (nop) {
        }
      }
      Exception.prototype = new Error();
      exports["default"] = Exception;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
  var require_block_helper_missing = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      exports["default"] = function(instance) {
        instance.registerHelper("blockHelperMissing", function(context2, options) {
          var inverse = options.inverse, fn = options.fn;
          if (context2 === true) {
            return fn(this);
          } else if (context2 === false || context2 == null) {
            return inverse(this);
          } else if (_utils.isArray(context2)) {
            if (context2.length > 0) {
              if (options.ids) {
                options.ids = [options.name];
              }
              return instance.helpers.each(context2, options);
            } else {
              return inverse(this);
            }
          } else {
            if (options.data && options.ids) {
              var data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
              options = { data };
            }
            return fn(context2, options);
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
  var require_each = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/each.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("each", function(context2, options) {
          if (!options) {
            throw new _exception2["default"]("Must pass iterator to #each");
          }
          var fn = options.fn, inverse = options.inverse, i = 0, ret4 = "", data = void 0, contextPath = void 0;
          if (options.data && options.ids) {
            contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
          }
          if (_utils.isFunction(context2)) {
            context2 = context2.call(this);
          }
          if (options.data) {
            data = _utils.createFrame(options.data);
          }
          function execIteration(field, index, last) {
            if (data) {
              data.key = field;
              data.index = index;
              data.first = index === 0;
              data.last = !!last;
              if (contextPath) {
                data.contextPath = contextPath + field;
              }
            }
            ret4 = ret4 + fn(context2[field], {
              data,
              blockParams: _utils.blockParams([context2[field], field], [contextPath + field, null])
            });
          }
          if (context2 && typeof context2 === "object") {
            if (_utils.isArray(context2)) {
              for (var j = context2.length; i < j; i++) {
                if (i in context2) {
                  execIteration(i, i, i === context2.length - 1);
                }
              }
            } else if (global.Symbol && context2[global.Symbol.iterator]) {
              var newContext = [];
              var iterator = context2[global.Symbol.iterator]();
              for (var it = iterator.next(); !it.done; it = iterator.next()) {
                newContext.push(it.value);
              }
              context2 = newContext;
              for (var j = context2.length; i < j; i++) {
                execIteration(i, i, i === context2.length - 1);
              }
            } else {
              (function() {
                var priorKey = void 0;
                Object.keys(context2).forEach(function(key) {
                  if (priorKey !== void 0) {
                    execIteration(priorKey, i - 1);
                  }
                  priorKey = key;
                  i++;
                });
                if (priorKey !== void 0) {
                  execIteration(priorKey, i - 1, true);
                }
              })();
            }
          }
          if (i === 0) {
            ret4 = inverse(this);
          }
          return ret4;
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
  var require_helper_missing = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("helperMissing", function() {
          if (arguments.length === 1) {
            return void 0;
          } else {
            throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
  var require_if = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/if.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("if", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#if requires exactly one argument");
          }
          if (_utils.isFunction(conditional)) {
            conditional = conditional.call(this);
          }
          if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
            return options.inverse(this);
          } else {
            return options.fn(this);
          }
        });
        instance.registerHelper("unless", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#unless requires exactly one argument");
          }
          return instance.helpers["if"].call(this, conditional, {
            fn: options.inverse,
            inverse: options.fn,
            hash: options.hash
          });
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
  var require_log = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/log.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("log", function() {
          var args = [void 0], options = arguments[arguments.length - 1];
          for (var i = 0; i < arguments.length - 1; i++) {
            args.push(arguments[i]);
          }
          var level = 1;
          if (options.hash.level != null) {
            level = options.hash.level;
          } else if (options.data && options.data.level != null) {
            level = options.data.level;
          }
          args[0] = level;
          instance.log.apply(instance, args);
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
  var require_lookup = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("lookup", function(obj, field, options) {
          if (!obj) {
            return obj;
          }
          return options.lookupProperty(obj, field);
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
  var require_with = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/with.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("with", function(context2, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#with requires exactly one argument");
          }
          if (_utils.isFunction(context2)) {
            context2 = context2.call(this);
          }
          var fn = options.fn;
          if (!_utils.isEmpty(context2)) {
            var data = options.data;
            if (options.data && options.ids) {
              data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
            }
            return fn(context2, {
              data,
              blockParams: _utils.blockParams([context2], [data && data.contextPath])
            });
          } else {
            return options.inverse(this);
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers.js
  var require_helpers = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.registerDefaultHelpers = registerDefaultHelpers;
      exports.moveHelperToHooks = moveHelperToHooks;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _helpersBlockHelperMissing = require_block_helper_missing();
      var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
      var _helpersEach = require_each();
      var _helpersEach2 = _interopRequireDefault(_helpersEach);
      var _helpersHelperMissing = require_helper_missing();
      var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
      var _helpersIf = require_if();
      var _helpersIf2 = _interopRequireDefault(_helpersIf);
      var _helpersLog = require_log();
      var _helpersLog2 = _interopRequireDefault(_helpersLog);
      var _helpersLookup = require_lookup();
      var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
      var _helpersWith = require_with();
      var _helpersWith2 = _interopRequireDefault(_helpersWith);
      function registerDefaultHelpers(instance) {
        _helpersBlockHelperMissing2["default"](instance);
        _helpersEach2["default"](instance);
        _helpersHelperMissing2["default"](instance);
        _helpersIf2["default"](instance);
        _helpersLog2["default"](instance);
        _helpersLookup2["default"](instance);
        _helpersWith2["default"](instance);
      }
      function moveHelperToHooks(instance, helperName, keepHelper) {
        if (instance.helpers[helperName]) {
          instance.hooks[helperName] = instance.helpers[helperName];
          if (!keepHelper) {
            delete instance.helpers[helperName];
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
  var require_inline = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      exports["default"] = function(instance) {
        instance.registerDecorator("inline", function(fn, props, container, options) {
          var ret4 = fn;
          if (!props.partials) {
            props.partials = {};
            ret4 = function(context2, options2) {
              var original = container.partials;
              container.partials = _utils.extend({}, original, props.partials);
              var ret5 = fn(context2, options2);
              container.partials = original;
              return ret5;
            };
          }
          props.partials[options.args[0]] = options.fn;
          return ret4;
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/decorators.js
  var require_decorators = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/decorators.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.registerDefaultDecorators = registerDefaultDecorators;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _decoratorsInline = require_inline();
      var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
      function registerDefaultDecorators(instance) {
        _decoratorsInline2["default"](instance);
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/logger.js
  var require_logger = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/logger.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      var logger = {
        methodMap: ["debug", "info", "warn", "error"],
        level: "info",
        // Maps a given level value to the `methodMap` indexes above.
        lookupLevel: function lookupLevel(level) {
          if (typeof level === "string") {
            var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
            if (levelMap >= 0) {
              level = levelMap;
            } else {
              level = parseInt(level, 10);
            }
          }
          return level;
        },
        // Can be overridden in the host environment
        log: function log2(level) {
          level = logger.lookupLevel(level);
          if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
            var method = logger.methodMap[level];
            if (!console[method]) {
              method = "log";
            }
            for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              message[_key - 1] = arguments[_key];
            }
            console[method].apply(console, message);
          }
        }
      };
      exports["default"] = logger;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
  var require_create_new_lookup_object = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.createNewLookupObject = createNewLookupObject;
      var _utils = require_utils();
      function createNewLookupObject() {
        for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
  var require_proto_access = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.createProtoAccessControl = createProtoAccessControl;
      exports.resultIsAllowed = resultIsAllowed;
      exports.resetLoggedProperties = resetLoggedProperties;
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _createNewLookupObject = require_create_new_lookup_object();
      var _logger = require_logger();
      var logger = _interopRequireWildcard(_logger);
      var loggedProperties = /* @__PURE__ */ Object.create(null);
      function createProtoAccessControl(runtimeOptions) {
        var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
        defaultMethodWhiteList["constructor"] = false;
        defaultMethodWhiteList["__defineGetter__"] = false;
        defaultMethodWhiteList["__defineSetter__"] = false;
        defaultMethodWhiteList["__lookupGetter__"] = false;
        var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
        defaultPropertyWhiteList["__proto__"] = false;
        return {
          properties: {
            whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
            defaultValue: runtimeOptions.allowProtoPropertiesByDefault
          },
          methods: {
            whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
            defaultValue: runtimeOptions.allowProtoMethodsByDefault
          }
        };
      }
      function resultIsAllowed(result, protoAccessControl, propertyName) {
        if (typeof result === "function") {
          return checkWhiteList(protoAccessControl.methods, propertyName);
        } else {
          return checkWhiteList(protoAccessControl.properties, propertyName);
        }
      }
      function checkWhiteList(protoAccessControlForType, propertyName) {
        if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
          return protoAccessControlForType.whitelist[propertyName] === true;
        }
        if (protoAccessControlForType.defaultValue !== void 0) {
          return protoAccessControlForType.defaultValue;
        }
        logUnexpecedPropertyAccessOnce(propertyName);
        return false;
      }
      function logUnexpecedPropertyAccessOnce(propertyName) {
        if (loggedProperties[propertyName] !== true) {
          loggedProperties[propertyName] = true;
          logger.log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
        }
      }
      function resetLoggedProperties() {
        Object.keys(loggedProperties).forEach(function(propertyName) {
          delete loggedProperties[propertyName];
        });
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/base.js
  var require_base = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.HandlebarsEnvironment = HandlebarsEnvironment;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _helpers = require_helpers();
      var _decorators = require_decorators();
      var _logger = require_logger();
      var _logger2 = _interopRequireDefault(_logger);
      var _internalProtoAccess = require_proto_access();
      var VERSION = "4.7.7";
      exports.VERSION = VERSION;
      var COMPILER_REVISION = 8;
      exports.COMPILER_REVISION = COMPILER_REVISION;
      var LAST_COMPATIBLE_COMPILER_REVISION = 7;
      exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
      var REVISION_CHANGES = {
        1: "<= 1.0.rc.2",
        // 1.0.rc.2 is actually rev2 but doesn't report it
        2: "== 1.0.0-rc.3",
        3: "== 1.0.0-rc.4",
        4: "== 1.x.x",
        5: "== 2.0.0-alpha.x",
        6: ">= 2.0.0-beta.1",
        7: ">= 4.0.0 <4.3.0",
        8: ">= 4.3.0"
      };
      exports.REVISION_CHANGES = REVISION_CHANGES;
      var objectType = "[object Object]";
      function HandlebarsEnvironment(helpers, partials, decorators) {
        this.helpers = helpers || {};
        this.partials = partials || {};
        this.decorators = decorators || {};
        _helpers.registerDefaultHelpers(this);
        _decorators.registerDefaultDecorators(this);
      }
      HandlebarsEnvironment.prototype = {
        constructor: HandlebarsEnvironment,
        logger: _logger2["default"],
        log: _logger2["default"].log,
        registerHelper: function registerHelper(name, fn) {
          if (_utils.toString.call(name) === objectType) {
            if (fn) {
              throw new _exception2["default"]("Arg not supported with multiple helpers");
            }
            _utils.extend(this.helpers, name);
          } else {
            this.helpers[name] = fn;
          }
        },
        unregisterHelper: function unregisterHelper(name) {
          delete this.helpers[name];
        },
        registerPartial: function registerPartial(name, partial) {
          if (_utils.toString.call(name) === objectType) {
            _utils.extend(this.partials, name);
          } else {
            if (typeof partial === "undefined") {
              throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
            }
            this.partials[name] = partial;
          }
        },
        unregisterPartial: function unregisterPartial(name) {
          delete this.partials[name];
        },
        registerDecorator: function registerDecorator(name, fn) {
          if (_utils.toString.call(name) === objectType) {
            if (fn) {
              throw new _exception2["default"]("Arg not supported with multiple decorators");
            }
            _utils.extend(this.decorators, name);
          } else {
            this.decorators[name] = fn;
          }
        },
        unregisterDecorator: function unregisterDecorator(name) {
          delete this.decorators[name];
        },
        /**
         * Reset the memory of illegal property accesses that have already been logged.
         * @deprecated should only be used in handlebars test-cases
         */
        resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
          _internalProtoAccess.resetLoggedProperties();
        }
      };
      var log2 = _logger2["default"].log;
      exports.log = log2;
      exports.createFrame = _utils.createFrame;
      exports.logger = _logger2["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/safe-string.js
  var require_safe_string = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/safe-string.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function SafeString(string2) {
        this.string = string2;
      }
      SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
        return "" + this.string;
      };
      exports["default"] = SafeString;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
  var require_wrapHelper = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.wrapHelper = wrapHelper;
      function wrapHelper(helper, transformOptionsFn) {
        if (typeof helper !== "function") {
          return helper;
        }
        var wrapper = function wrapper2() {
          var options = arguments[arguments.length - 1];
          arguments[arguments.length - 1] = transformOptionsFn(options);
          return helper.apply(this, arguments);
        };
        return wrapper;
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/runtime.js
  var require_runtime = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/runtime.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.checkRevision = checkRevision;
      exports.template = template;
      exports.wrapProgram = wrapProgram;
      exports.resolvePartial = resolvePartial;
      exports.invokePartial = invokePartial;
      exports.noop = noop;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _utils = require_utils();
      var Utils = _interopRequireWildcard(_utils);
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _base = require_base();
      var _helpers = require_helpers();
      var _internalWrapHelper = require_wrapHelper();
      var _internalProtoAccess = require_proto_access();
      function checkRevision(compilerInfo) {
        var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
        if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
          return;
        }
        if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
          var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
          throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
        } else {
          throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
        }
      }
      function template(templateSpec, env) {
        if (!env) {
          throw new _exception2["default"]("No environment passed to template");
        }
        if (!templateSpec || !templateSpec.main) {
          throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
        }
        templateSpec.main.decorator = templateSpec.main_d;
        env.VM.checkRevision(templateSpec.compiler);
        var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
        function invokePartialWrapper(partial, context2, options) {
          if (options.hash) {
            context2 = Utils.extend({}, context2, options.hash);
            if (options.ids) {
              options.ids[0] = true;
            }
          }
          partial = env.VM.resolvePartial.call(this, partial, context2, options);
          var extendedOptions = Utils.extend({}, options, {
            hooks: this.hooks,
            protoAccessControl: this.protoAccessControl
          });
          var result = env.VM.invokePartial.call(this, partial, context2, extendedOptions);
          if (result == null && env.compile) {
            options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
            result = options.partials[options.name](context2, extendedOptions);
          }
          if (result != null) {
            if (options.indent) {
              var lines = result.split("\n");
              for (var i = 0, l = lines.length; i < l; i++) {
                if (!lines[i] && i + 1 === l) {
                  break;
                }
                lines[i] = options.indent + lines[i];
              }
              result = lines.join("\n");
            }
            return result;
          } else {
            throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
          }
        }
        var container = {
          strict: function strict(obj, name, loc) {
            if (!obj || !(name in obj)) {
              throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
                loc
              });
            }
            return container.lookupProperty(obj, name);
          },
          lookupProperty: function lookupProperty(parent, propertyName) {
            var result = parent[propertyName];
            if (result == null) {
              return result;
            }
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return result;
            }
            if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
              return result;
            }
            return void 0;
          },
          lookup: function lookup(depths, name) {
            var len = depths.length;
            for (var i = 0; i < len; i++) {
              var result = depths[i] && container.lookupProperty(depths[i], name);
              if (result != null) {
                return depths[i][name];
              }
            }
          },
          lambda: function lambda(current, context2) {
            return typeof current === "function" ? current.call(context2) : current;
          },
          escapeExpression: Utils.escapeExpression,
          invokePartial: invokePartialWrapper,
          fn: function fn(i) {
            var ret5 = templateSpec[i];
            ret5.decorator = templateSpec[i + "_d"];
            return ret5;
          },
          programs: [],
          program: function program2(i, data, declaredBlockParams, blockParams, depths) {
            var programWrapper = this.programs[i], fn = this.fn(i);
            if (data || depths || blockParams || declaredBlockParams) {
              programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
            } else if (!programWrapper) {
              programWrapper = this.programs[i] = wrapProgram(this, i, fn);
            }
            return programWrapper;
          },
          data: function data(value, depth) {
            while (value && depth--) {
              value = value._parent;
            }
            return value;
          },
          mergeIfNeeded: function mergeIfNeeded(param, common) {
            var obj = param || common;
            if (param && common && param !== common) {
              obj = Utils.extend({}, common, param);
            }
            return obj;
          },
          // An empty object to use as replacement for null-contexts
          nullContext: Object.seal({}),
          noop: env.VM.noop,
          compilerInfo: templateSpec.compiler
        };
        function ret4(context2) {
          var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          var data = options.data;
          ret4._setup(options);
          if (!options.partial && templateSpec.useData) {
            data = initData(context2, data);
          }
          var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
          if (templateSpec.useDepths) {
            if (options.depths) {
              depths = context2 != options.depths[0] ? [context2].concat(options.depths) : options.depths;
            } else {
              depths = [context2];
            }
          }
          function main(context3) {
            return "" + templateSpec.main(container, context3, container.helpers, container.partials, data, blockParams, depths);
          }
          main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
          return main(context2, options);
        }
        ret4.isTop = true;
        ret4._setup = function(options) {
          if (!options.partial) {
            var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
            wrapHelpersToPassLookupProperty(mergedHelpers, container);
            container.helpers = mergedHelpers;
            if (templateSpec.usePartial) {
              container.partials = container.mergeIfNeeded(options.partials, env.partials);
            }
            if (templateSpec.usePartial || templateSpec.useDecorators) {
              container.decorators = Utils.extend({}, env.decorators, options.decorators);
            }
            container.hooks = {};
            container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
            var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
            _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
            _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
          } else {
            container.protoAccessControl = options.protoAccessControl;
            container.helpers = options.helpers;
            container.partials = options.partials;
            container.decorators = options.decorators;
            container.hooks = options.hooks;
          }
        };
        ret4._child = function(i, data, blockParams, depths) {
          if (templateSpec.useBlockParams && !blockParams) {
            throw new _exception2["default"]("must pass block params");
          }
          if (templateSpec.useDepths && !depths) {
            throw new _exception2["default"]("must pass parent depths");
          }
          return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
        };
        return ret4;
      }
      function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
        function prog(context2) {
          var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          var currentDepths = depths;
          if (depths && context2 != depths[0] && !(context2 === container.nullContext && depths[0] === null)) {
            currentDepths = [context2].concat(depths);
          }
          return fn(container, context2, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
        }
        prog = executeDecorators(fn, prog, container, depths, data, blockParams);
        prog.program = i;
        prog.depth = depths ? depths.length : 0;
        prog.blockParams = declaredBlockParams || 0;
        return prog;
      }
      function resolvePartial(partial, context2, options) {
        if (!partial) {
          if (options.name === "@partial-block") {
            partial = options.data["partial-block"];
          } else {
            partial = options.partials[options.name];
          }
        } else if (!partial.call && !options.name) {
          options.name = partial;
          partial = options.partials[partial];
        }
        return partial;
      }
      function invokePartial(partial, context2, options) {
        var currentPartialBlock = options.data && options.data["partial-block"];
        options.partial = true;
        if (options.ids) {
          options.data.contextPath = options.ids[0] || options.data.contextPath;
        }
        var partialBlock = void 0;
        if (options.fn && options.fn !== noop) {
          (function() {
            options.data = _base.createFrame(options.data);
            var fn = options.fn;
            partialBlock = options.data["partial-block"] = function partialBlockWrapper(context3) {
              var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
              options2.data = _base.createFrame(options2.data);
              options2.data["partial-block"] = currentPartialBlock;
              return fn(context3, options2);
            };
            if (fn.partials) {
              options.partials = Utils.extend({}, options.partials, fn.partials);
            }
          })();
        }
        if (partial === void 0 && partialBlock) {
          partial = partialBlock;
        }
        if (partial === void 0) {
          throw new _exception2["default"]("The partial " + options.name + " could not be found");
        } else if (partial instanceof Function) {
          return partial(context2, options);
        }
      }
      function noop() {
        return "";
      }
      function initData(context2, data) {
        if (!data || !("root" in data)) {
          data = data ? _base.createFrame(data) : {};
          data.root = context2;
        }
        return data;
      }
      function executeDecorators(fn, prog, container, depths, data, blockParams) {
        if (fn.decorator) {
          var props = {};
          prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
          Utils.extend(prog, props);
        }
        return prog;
      }
      function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
        Object.keys(mergedHelpers).forEach(function(helperName) {
          var helper = mergedHelpers[helperName];
          mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
        });
      }
      function passLookupPropertyOption(helper, container) {
        var lookupProperty = container.lookupProperty;
        return _internalWrapHelper.wrapHelper(helper, function(options) {
          return Utils.extend({ lookupProperty }, options);
        });
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
  var require_no_conflict = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/no-conflict.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(Handlebars2) {
        var root = typeof global !== "undefined" ? global : window, $Handlebars = root.Handlebars;
        Handlebars2.noConflict = function() {
          if (root.Handlebars === Handlebars2) {
            root.Handlebars = $Handlebars;
          }
          return Handlebars2;
        };
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars.runtime.js
  var require_handlebars_runtime = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars.runtime.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _handlebarsBase = require_base();
      var base = _interopRequireWildcard(_handlebarsBase);
      var _handlebarsSafeString = require_safe_string();
      var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
      var _handlebarsException = require_exception();
      var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
      var _handlebarsUtils = require_utils();
      var Utils = _interopRequireWildcard(_handlebarsUtils);
      var _handlebarsRuntime = require_runtime();
      var runtime = _interopRequireWildcard(_handlebarsRuntime);
      var _handlebarsNoConflict = require_no_conflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      function create10() {
        var hb = new base.HandlebarsEnvironment();
        Utils.extend(hb, base);
        hb.SafeString = _handlebarsSafeString2["default"];
        hb.Exception = _handlebarsException2["default"];
        hb.Utils = Utils;
        hb.escapeExpression = Utils.escapeExpression;
        hb.VM = runtime;
        hb.template = function(spec) {
          return runtime.template(spec, hb);
        };
        return hb;
      }
      var inst = create10();
      inst.create = create10;
      _handlebarsNoConflict2["default"](inst);
      inst["default"] = inst;
      exports["default"] = inst;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
  var require_ast = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var AST2 = {
        // Public API used to evaluate derived attributes regarding AST nodes
        helpers: {
          // a mustache is definitely a helper if:
          // * it is an eligible helper, and
          // * it has at least one parameter or hash segment
          helperExpression: function helperExpression(node) {
            return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
          },
          scopedId: function scopedId(path5) {
            return /^\.|this\b/.test(path5.original);
          },
          // an ID is simple if it only has one part, and that part is not
          // `..` or `this`.
          simpleId: function simpleId(path5) {
            return path5.parts.length === 1 && !AST2.helpers.scopedId(path5) && !path5.depth;
          }
        }
      };
      exports["default"] = AST2;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
  var require_parser = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var handlebars = function() {
        var parser = {
          trace: function trace() {
          },
          yy: {},
          symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];
                break;
              case 2:
                this.$ = yy.prepareProgram($$[$0]);
                break;
              case 3:
                this.$ = $$[$0];
                break;
              case 4:
                this.$ = $$[$0];
                break;
              case 5:
                this.$ = $$[$0];
                break;
              case 6:
                this.$ = $$[$0];
                break;
              case 7:
                this.$ = $$[$0];
                break;
              case 8:
                this.$ = $$[$0];
                break;
              case 9:
                this.$ = {
                  type: "CommentStatement",
                  value: yy.stripComment($$[$0]),
                  strip: yy.stripFlags($$[$0], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 10:
                this.$ = {
                  type: "ContentStatement",
                  original: $$[$0],
                  value: $$[$0],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 11:
                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 12:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                break;
              case 13:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                break;
              case 14:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                break;
              case 15:
                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 16:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 17:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 18:
                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                break;
              case 19:
                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program2 = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                program2.chained = true;
                this.$ = { strip: $$[$0 - 2].strip, program: program2, chain: true };
                break;
              case 20:
                this.$ = $$[$0];
                break;
              case 21:
                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                break;
              case 22:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 23:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 24:
                this.$ = {
                  type: "PartialStatement",
                  name: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  indent: "",
                  strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 25:
                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 26:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                break;
              case 27:
                this.$ = $$[$0];
                break;
              case 28:
                this.$ = $$[$0];
                break;
              case 29:
                this.$ = {
                  type: "SubExpression",
                  path: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 30:
                this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 31:
                this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 32:
                this.$ = yy.id($$[$0 - 1]);
                break;
              case 33:
                this.$ = $$[$0];
                break;
              case 34:
                this.$ = $$[$0];
                break;
              case 35:
                this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 36:
                this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                break;
              case 37:
                this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
                break;
              case 38:
                this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
                break;
              case 39:
                this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
                break;
              case 40:
                this.$ = $$[$0];
                break;
              case 41:
                this.$ = $$[$0];
                break;
              case 42:
                this.$ = yy.preparePath(true, $$[$0], this._$);
                break;
              case 43:
                this.$ = yy.preparePath(false, $$[$0], this._$);
                break;
              case 44:
                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
                this.$ = $$[$0 - 2];
                break;
              case 45:
                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                break;
              case 46:
                this.$ = [];
                break;
              case 47:
                $$[$0 - 1].push($$[$0]);
                break;
              case 48:
                this.$ = [];
                break;
              case 49:
                $$[$0 - 1].push($$[$0]);
                break;
              case 50:
                this.$ = [];
                break;
              case 51:
                $$[$0 - 1].push($$[$0]);
                break;
              case 58:
                this.$ = [];
                break;
              case 59:
                $$[$0 - 1].push($$[$0]);
                break;
              case 64:
                this.$ = [];
                break;
              case 65:
                $$[$0 - 1].push($$[$0]);
                break;
              case 70:
                this.$ = [];
                break;
              case 71:
                $$[$0 - 1].push($$[$0]);
                break;
              case 78:
                this.$ = [];
                break;
              case 79:
                $$[$0 - 1].push($$[$0]);
                break;
              case 82:
                this.$ = [];
                break;
              case 83:
                $$[$0 - 1].push($$[$0]);
                break;
              case 86:
                this.$ = [];
                break;
              case 87:
                $$[$0 - 1].push($$[$0]);
                break;
              case 90:
                this.$ = [];
                break;
              case 91:
                $$[$0 - 1].push($$[$0]);
                break;
              case 94:
                this.$ = [];
                break;
              case 95:
                $$[$0 - 1].push($$[$0]);
                break;
              case 98:
                this.$ = [$$[$0]];
                break;
              case 99:
                $$[$0 - 1].push($$[$0]);
                break;
              case 100:
                this.$ = [$$[$0]];
                break;
              case 101:
                $$[$0 - 1].push($$[$0]);
                break;
            }
          },
          table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
          defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
          parseError: function parseError(str, hash4) {
            throw new Error(str);
          },
          parse: function parse3(input) {
            var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF2 = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined")
              this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function")
              this.parseError = this.yy.parseError;
            function popStack(n) {
              stack.length = stack.length - 2 * n;
              vstack.length = vstack.length - n;
              lstack.length = lstack.length - n;
            }
            function lex() {
              var token;
              token = self2.lexer.lex() || 1;
              if (typeof token !== "number") {
                token = self2.symbols_[token] || token;
              }
              return token;
            }
            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while (true) {
              state = stack[stack.length - 1];
              if (this.defaultActions[state]) {
                action = this.defaultActions[state];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
                }
                action = table[state] && table[state][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push("'" + this.terminals_[p] + "'");
                    }
                  if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
                }
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(this.lexer.yytext);
                  lstack.push(this.lexer.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  if (!preErrorSymbol) {
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                      recovering--;
                  } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }
                  r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                  if (typeof r !== "undefined") {
                    return r;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash4) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash4);
              } else {
                throw new Error(str);
              }
            },
            setInput: function setInput(input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
              if (this.options.ranges)
                this.yylloc.range = [0, 0];
              this.offset = 0;
              return this;
            },
            input: function input() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges)
                this.yylloc.range[1]++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function unput(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1)
                this.yylineno -= lines.length - 1;
              var r = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
              }
              return this;
            },
            more: function more() {
              this._more = true;
              return this;
            },
            less: function less(n) {
              this.unput(this.match.slice(n));
            },
            pastInput: function pastInput() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function upcomingInput() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            showPosition: function showPosition() {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function next() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match3, tempMatch, index, col, lines;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match3 || tempMatch[0].length > match3[0].length)) {
                  match3 = tempMatch;
                  index = i;
                  if (!this.options.flex)
                    break;
                }
              }
              if (match3) {
                lines = match3[0].match(/(?:\r\n?|\n).*/g);
                if (lines)
                  this.yylineno += lines.length;
                this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match3[0].length
                };
                this.yytext += match3[0];
                this.match += match3[0];
                this.matches = match3;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._input = this._input.slice(match3[0].length);
                this.matched += match3[0];
                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input)
                  this.done = false;
                if (token)
                  return token;
                else
                  return;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== "undefined") {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function topState() {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
          lexer2.options = {};
          lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            function strip(start, end) {
              return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
            }
            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
              case 0:
                if (yy_.yytext.slice(-2) === "\\\\") {
                  strip(0, 1);
                  this.begin("mu");
                } else if (yy_.yytext.slice(-1) === "\\") {
                  strip(0, 1);
                  this.begin("emu");
                } else {
                  this.begin("mu");
                }
                if (yy_.yytext)
                  return 15;
                break;
              case 1:
                return 15;
                break;
              case 2:
                this.popState();
                return 15;
                break;
              case 3:
                this.begin("raw");
                return 15;
                break;
              case 4:
                this.popState();
                if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                  return 15;
                } else {
                  strip(5, 9);
                  return "END_RAW_BLOCK";
                }
                break;
              case 5:
                return 15;
                break;
              case 6:
                this.popState();
                return 14;
                break;
              case 7:
                return 65;
                break;
              case 8:
                return 68;
                break;
              case 9:
                return 19;
                break;
              case 10:
                this.popState();
                this.begin("raw");
                return 23;
                break;
              case 11:
                return 55;
                break;
              case 12:
                return 60;
                break;
              case 13:
                return 29;
                break;
              case 14:
                return 47;
                break;
              case 15:
                this.popState();
                return 44;
                break;
              case 16:
                this.popState();
                return 44;
                break;
              case 17:
                return 34;
                break;
              case 18:
                return 39;
                break;
              case 19:
                return 51;
                break;
              case 20:
                return 48;
                break;
              case 21:
                this.unput(yy_.yytext);
                this.popState();
                this.begin("com");
                break;
              case 22:
                this.popState();
                return 14;
                break;
              case 23:
                return 48;
                break;
              case 24:
                return 73;
                break;
              case 25:
                return 72;
                break;
              case 26:
                return 72;
                break;
              case 27:
                return 87;
                break;
              case 28:
                break;
              case 29:
                this.popState();
                return 54;
                break;
              case 30:
                this.popState();
                return 33;
                break;
              case 31:
                yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                return 80;
                break;
              case 32:
                yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                return 80;
                break;
              case 33:
                return 85;
                break;
              case 34:
                return 82;
                break;
              case 35:
                return 82;
                break;
              case 36:
                return 83;
                break;
              case 37:
                return 84;
                break;
              case 38:
                return 81;
                break;
              case 39:
                return 75;
                break;
              case 40:
                return 77;
                break;
              case 41:
                return 72;
                break;
              case 42:
                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
                return 72;
                break;
              case 43:
                return "INVALID";
                break;
              case 44:
                return 5;
                break;
            }
          };
          lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
          lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
          return lexer2;
        }();
        parser.lexer = lexer;
        function Parser2() {
          this.yy = {};
        }
        Parser2.prototype = parser;
        parser.Parser = Parser2;
        return new Parser2();
      }();
      exports["default"] = handlebars;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
  var require_visitor = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      function Visitor() {
        this.parents = [];
      }
      Visitor.prototype = {
        constructor: Visitor,
        mutating: false,
        // Visits a given value. If mutating, will replace the value if necessary.
        acceptKey: function acceptKey(node, name) {
          var value = this.accept(node[name]);
          if (this.mutating) {
            if (value && !Visitor.prototype[value.type]) {
              throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
            }
            node[name] = value;
          }
        },
        // Performs an accept operation with added sanity check to ensure
        // required keys are not removed.
        acceptRequired: function acceptRequired(node, name) {
          this.acceptKey(node, name);
          if (!node[name]) {
            throw new _exception2["default"](node.type + " requires " + name);
          }
        },
        // Traverses a given array. If mutating, empty respnses will be removed
        // for child elements.
        acceptArray: function acceptArray(array2) {
          for (var i = 0, l = array2.length; i < l; i++) {
            this.acceptKey(array2, i);
            if (!array2[i]) {
              array2.splice(i, 1);
              i--;
              l--;
            }
          }
        },
        accept: function accept(object2) {
          if (!object2) {
            return;
          }
          if (!this[object2.type]) {
            throw new _exception2["default"]("Unknown type: " + object2.type, object2);
          }
          if (this.current) {
            this.parents.unshift(this.current);
          }
          this.current = object2;
          var ret4 = this[object2.type](object2);
          this.current = this.parents.shift();
          if (!this.mutating || ret4) {
            return ret4;
          } else if (ret4 !== false) {
            return object2;
          }
        },
        Program: function Program(program2) {
          this.acceptArray(program2.body);
        },
        MustacheStatement: visitSubExpression,
        Decorator: visitSubExpression,
        BlockStatement: visitBlock,
        DecoratorBlock: visitBlock,
        PartialStatement: visitPartial,
        PartialBlockStatement: function PartialBlockStatement(partial) {
          visitPartial.call(this, partial);
          this.acceptKey(partial, "program");
        },
        ContentStatement: function ContentStatement() {
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: visitSubExpression,
        PathExpression: function PathExpression() {
        },
        StringLiteral: function StringLiteral() {
        },
        NumberLiteral: function NumberLiteral() {
        },
        BooleanLiteral: function BooleanLiteral() {
        },
        UndefinedLiteral: function UndefinedLiteral() {
        },
        NullLiteral: function NullLiteral() {
        },
        Hash: function Hash3(hash4) {
          this.acceptArray(hash4.pairs);
        },
        HashPair: function HashPair(pair) {
          this.acceptRequired(pair, "value");
        }
      };
      function visitSubExpression(mustache) {
        this.acceptRequired(mustache, "path");
        this.acceptArray(mustache.params);
        this.acceptKey(mustache, "hash");
      }
      function visitBlock(block2) {
        visitSubExpression.call(this, block2);
        this.acceptKey(block2, "program");
        this.acceptKey(block2, "inverse");
      }
      function visitPartial(partial) {
        this.acceptRequired(partial, "name");
        this.acceptArray(partial.params);
        this.acceptKey(partial, "hash");
      }
      exports["default"] = Visitor;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
  var require_whitespace_control = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = require_visitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function WhitespaceControl() {
        var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
        this.options = options;
      }
      WhitespaceControl.prototype = new _visitor2["default"]();
      WhitespaceControl.prototype.Program = function(program2) {
        var doStandalone = !this.options.ignoreStandalone;
        var isRoot = !this.isRootSeen;
        this.isRootSeen = true;
        var body = program2.body;
        for (var i = 0, l = body.length; i < l; i++) {
          var current = body[i], strip = this.accept(current);
          if (!strip) {
            continue;
          }
          var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
          if (strip.close) {
            omitRight(body, i, true);
          }
          if (strip.open) {
            omitLeft(body, i, true);
          }
          if (doStandalone && inlineStandalone) {
            omitRight(body, i);
            if (omitLeft(body, i)) {
              if (current.type === "PartialStatement") {
                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
              }
            }
          }
          if (doStandalone && openStandalone) {
            omitRight((current.program || current.inverse).body);
            omitLeft(body, i);
          }
          if (doStandalone && closeStandalone) {
            omitRight(body, i);
            omitLeft((current.inverse || current.program).body);
          }
        }
        return program2;
      };
      WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block2) {
        this.accept(block2.program);
        this.accept(block2.inverse);
        var program2 = block2.program || block2.inverse, inverse = block2.program && block2.inverse, firstInverse = inverse, lastInverse = inverse;
        if (inverse && inverse.chained) {
          firstInverse = inverse.body[0].program;
          while (lastInverse.chained) {
            lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
          }
        }
        var strip = {
          open: block2.openStrip.open,
          close: block2.closeStrip.close,
          // Determine the standalone candiacy. Basically flag our content as being possibly standalone
          // so our parent can determine if we actually are standalone
          openStandalone: isNextWhitespace(program2.body),
          closeStandalone: isPrevWhitespace((firstInverse || program2).body)
        };
        if (block2.openStrip.close) {
          omitRight(program2.body, null, true);
        }
        if (inverse) {
          var inverseStrip = block2.inverseStrip;
          if (inverseStrip.open) {
            omitLeft(program2.body, null, true);
          }
          if (inverseStrip.close) {
            omitRight(firstInverse.body, null, true);
          }
          if (block2.closeStrip.open) {
            omitLeft(lastInverse.body, null, true);
          }
          if (!this.options.ignoreStandalone && isPrevWhitespace(program2.body) && isNextWhitespace(firstInverse.body)) {
            omitLeft(program2.body);
            omitRight(firstInverse.body);
          }
        } else if (block2.closeStrip.open) {
          omitLeft(program2.body, null, true);
        }
        return strip;
      };
      WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
        return mustache.strip;
      };
      WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
        var strip = node.strip || {};
        return {
          inlineStandalone: true,
          open: strip.open,
          close: strip.close
        };
      };
      function isPrevWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = body.length;
        }
        var prev = body[i - 1], sibling = body[i - 2];
        if (!prev) {
          return isRoot;
        }
        if (prev.type === "ContentStatement") {
          return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
        }
      }
      function isNextWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = -1;
        }
        var next = body[i + 1], sibling = body[i + 2];
        if (!next) {
          return isRoot;
        }
        if (next.type === "ContentStatement") {
          return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
        }
      }
      function omitRight(body, i, multiple) {
        var current = body[i == null ? 0 : i + 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
        current.rightStripped = current.value !== original;
      }
      function omitLeft(body, i, multiple) {
        var current = body[i == null ? body.length - 1 : i - 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
        current.leftStripped = current.value !== original;
        return current.leftStripped;
      }
      exports["default"] = WhitespaceControl;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
  var require_helpers2 = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.SourceLocation = SourceLocation;
      exports.id = id;
      exports.stripFlags = stripFlags;
      exports.stripComment = stripComment;
      exports.preparePath = preparePath;
      exports.prepareMustache = prepareMustache;
      exports.prepareRawBlock = prepareRawBlock;
      exports.prepareBlock = prepareBlock;
      exports.prepareProgram = prepareProgram;
      exports.preparePartialBlock = preparePartialBlock;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      function validateClose(open, close) {
        close = close.path ? close.path.original : close;
        if (open.path.original !== close) {
          var errorNode = { loc: open.path.loc };
          throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
        }
      }
      function SourceLocation(source, locInfo) {
        this.source = source;
        this.start = {
          line: locInfo.first_line,
          column: locInfo.first_column
        };
        this.end = {
          line: locInfo.last_line,
          column: locInfo.last_column
        };
      }
      function id(token) {
        if (/^\[.*\]$/.test(token)) {
          return token.substring(1, token.length - 1);
        } else {
          return token;
        }
      }
      function stripFlags(open, close) {
        return {
          open: open.charAt(2) === "~",
          close: close.charAt(close.length - 3) === "~"
        };
      }
      function stripComment(comment) {
        return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
      }
      function preparePath(data, parts, loc) {
        loc = this.locInfo(loc);
        var original = data ? "@" : "", dig = [], depth = 0;
        for (var i = 0, l = parts.length; i < l; i++) {
          var part = parts[i].part, isLiteral = parts[i].original !== part;
          original += (parts[i].separator || "") + part;
          if (!isLiteral && (part === ".." || part === "." || part === "this")) {
            if (dig.length > 0) {
              throw new _exception2["default"]("Invalid path: " + original, { loc });
            } else if (part === "..") {
              depth++;
            }
          } else {
            dig.push(part);
          }
        }
        return {
          type: "PathExpression",
          data,
          depth,
          parts: dig,
          original,
          loc
        };
      }
      function prepareMustache(path5, params, hash4, open, strip, locInfo) {
        var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
        var decorator = /\*/.test(open);
        return {
          type: decorator ? "Decorator" : "MustacheStatement",
          path: path5,
          params,
          hash: hash4,
          escaped,
          strip,
          loc: this.locInfo(locInfo)
        };
      }
      function prepareRawBlock(openRawBlock, contents, close, locInfo) {
        validateClose(openRawBlock, close);
        locInfo = this.locInfo(locInfo);
        var program2 = {
          type: "Program",
          body: contents,
          strip: {},
          loc: locInfo
        };
        return {
          type: "BlockStatement",
          path: openRawBlock.path,
          params: openRawBlock.params,
          hash: openRawBlock.hash,
          program: program2,
          openStrip: {},
          inverseStrip: {},
          closeStrip: {},
          loc: locInfo
        };
      }
      function prepareBlock(openBlock, program2, inverseAndProgram, close, inverted, locInfo) {
        if (close && close.path) {
          validateClose(openBlock, close);
        }
        var decorator = /\*/.test(openBlock.open);
        program2.blockParams = openBlock.blockParams;
        var inverse = void 0, inverseStrip = void 0;
        if (inverseAndProgram) {
          if (decorator) {
            throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
          }
          if (inverseAndProgram.chain) {
            inverseAndProgram.program.body[0].closeStrip = close.strip;
          }
          inverseStrip = inverseAndProgram.strip;
          inverse = inverseAndProgram.program;
        }
        if (inverted) {
          inverted = inverse;
          inverse = program2;
          program2 = inverted;
        }
        return {
          type: decorator ? "DecoratorBlock" : "BlockStatement",
          path: openBlock.path,
          params: openBlock.params,
          hash: openBlock.hash,
          program: program2,
          inverse,
          openStrip: openBlock.strip,
          inverseStrip,
          closeStrip: close && close.strip,
          loc: this.locInfo(locInfo)
        };
      }
      function prepareProgram(statements, loc) {
        if (!loc && statements.length) {
          var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
          if (firstLoc && lastLoc) {
            loc = {
              source: firstLoc.source,
              start: {
                line: firstLoc.start.line,
                column: firstLoc.start.column
              },
              end: {
                line: lastLoc.end.line,
                column: lastLoc.end.column
              }
            };
          }
        }
        return {
          type: "Program",
          body: statements,
          strip: {},
          loc
        };
      }
      function preparePartialBlock(open, program2, close, locInfo) {
        validateClose(open, close);
        return {
          type: "PartialBlockStatement",
          name: open.path,
          params: open.params,
          hash: open.hash,
          program: program2,
          openStrip: open.strip,
          closeStrip: close && close.strip,
          loc: this.locInfo(locInfo)
        };
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
  var require_base2 = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.parseWithoutProcessing = parseWithoutProcessing;
      exports.parse = parse3;
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _parser = require_parser();
      var _parser2 = _interopRequireDefault(_parser);
      var _whitespaceControl = require_whitespace_control();
      var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
      var _helpers = require_helpers2();
      var Helpers = _interopRequireWildcard(_helpers);
      var _utils = require_utils();
      exports.parser = _parser2["default"];
      var yy = {};
      _utils.extend(yy, Helpers);
      function parseWithoutProcessing(input, options) {
        if (input.type === "Program") {
          return input;
        }
        _parser2["default"].yy = yy;
        yy.locInfo = function(locInfo) {
          return new yy.SourceLocation(options && options.srcName, locInfo);
        };
        var ast = _parser2["default"].parse(input);
        return ast;
      }
      function parse3(input, options) {
        var ast = parseWithoutProcessing(input, options);
        var strip = new _whitespaceControl2["default"](options);
        return strip.accept(ast);
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
  var require_compiler = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Compiler = Compiler;
      exports.precompile = precompile;
      exports.compile = compile6;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = require_utils();
      var _ast = require_ast();
      var _ast2 = _interopRequireDefault(_ast);
      var slice = [].slice;
      function Compiler() {
      }
      Compiler.prototype = {
        compiler: Compiler,
        equals: function equals3(other) {
          var len = this.opcodes.length;
          if (other.opcodes.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
            if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
              return false;
            }
          }
          len = this.children.length;
          for (var i = 0; i < len; i++) {
            if (!this.children[i].equals(other.children[i])) {
              return false;
            }
          }
          return true;
        },
        guid: 0,
        compile: function compile7(program2, options) {
          this.sourceNode = [];
          this.opcodes = [];
          this.children = [];
          this.options = options;
          this.stringParams = options.stringParams;
          this.trackIds = options.trackIds;
          options.blockParams = options.blockParams || [];
          options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
            helperMissing: true,
            blockHelperMissing: true,
            each: true,
            "if": true,
            unless: true,
            "with": true,
            log: true,
            lookup: true
          }, options.knownHelpers);
          return this.accept(program2);
        },
        compileProgram: function compileProgram(program2) {
          var childCompiler = new this.compiler(), result = childCompiler.compile(program2, this.options), guid = this.guid++;
          this.usePartial = this.usePartial || result.usePartial;
          this.children[guid] = result;
          this.useDepths = this.useDepths || result.useDepths;
          return guid;
        },
        accept: function accept(node) {
          if (!this[node.type]) {
            throw new _exception2["default"]("Unknown type: " + node.type, node);
          }
          this.sourceNode.unshift(node);
          var ret4 = this[node.type](node);
          this.sourceNode.shift();
          return ret4;
        },
        Program: function Program(program2) {
          this.options.blockParams.unshift(program2.blockParams);
          var body = program2.body, bodyLength = body.length;
          for (var i = 0; i < bodyLength; i++) {
            this.accept(body[i]);
          }
          this.options.blockParams.shift();
          this.isSimple = bodyLength === 1;
          this.blockParams = program2.blockParams ? program2.blockParams.length : 0;
          return this;
        },
        BlockStatement: function BlockStatement(block2) {
          transformLiteralToPath(block2);
          var program2 = block2.program, inverse = block2.inverse;
          program2 = program2 && this.compileProgram(program2);
          inverse = inverse && this.compileProgram(inverse);
          var type3 = this.classifySexpr(block2);
          if (type3 === "helper") {
            this.helperSexpr(block2, program2, inverse);
          } else if (type3 === "simple") {
            this.simpleSexpr(block2);
            this.opcode("pushProgram", program2);
            this.opcode("pushProgram", inverse);
            this.opcode("emptyHash");
            this.opcode("blockValue", block2.path.original);
          } else {
            this.ambiguousSexpr(block2, program2, inverse);
            this.opcode("pushProgram", program2);
            this.opcode("pushProgram", inverse);
            this.opcode("emptyHash");
            this.opcode("ambiguousBlockValue");
          }
          this.opcode("append");
        },
        DecoratorBlock: function DecoratorBlock(decorator) {
          var program2 = decorator.program && this.compileProgram(decorator.program);
          var params = this.setupFullMustacheParams(decorator, program2, void 0), path5 = decorator.path;
          this.useDecorators = true;
          this.opcode("registerDecorator", params.length, path5.original);
        },
        PartialStatement: function PartialStatement(partial) {
          this.usePartial = true;
          var program2 = partial.program;
          if (program2) {
            program2 = this.compileProgram(partial.program);
          }
          var params = partial.params;
          if (params.length > 1) {
            throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
          } else if (!params.length) {
            if (this.options.explicitPartialContext) {
              this.opcode("pushLiteral", "undefined");
            } else {
              params.push({ type: "PathExpression", parts: [], depth: 0 });
            }
          }
          var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
          if (isDynamic) {
            this.accept(partial.name);
          }
          this.setupFullMustacheParams(partial, program2, void 0, true);
          var indent2 = partial.indent || "";
          if (this.options.preventIndent && indent2) {
            this.opcode("appendContent", indent2);
            indent2 = "";
          }
          this.opcode("invokePartial", isDynamic, partialName, indent2);
          this.opcode("append");
        },
        PartialBlockStatement: function PartialBlockStatement(partialBlock) {
          this.PartialStatement(partialBlock);
        },
        MustacheStatement: function MustacheStatement(mustache) {
          this.SubExpression(mustache);
          if (mustache.escaped && !this.options.noEscape) {
            this.opcode("appendEscaped");
          } else {
            this.opcode("append");
          }
        },
        Decorator: function Decorator(decorator) {
          this.DecoratorBlock(decorator);
        },
        ContentStatement: function ContentStatement(content) {
          if (content.value) {
            this.opcode("appendContent", content.value);
          }
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: function SubExpression(sexpr) {
          transformLiteralToPath(sexpr);
          var type3 = this.classifySexpr(sexpr);
          if (type3 === "simple") {
            this.simpleSexpr(sexpr);
          } else if (type3 === "helper") {
            this.helperSexpr(sexpr);
          } else {
            this.ambiguousSexpr(sexpr);
          }
        },
        ambiguousSexpr: function ambiguousSexpr(sexpr, program2, inverse) {
          var path5 = sexpr.path, name = path5.parts[0], isBlock = program2 != null || inverse != null;
          this.opcode("getContext", path5.depth);
          this.opcode("pushProgram", program2);
          this.opcode("pushProgram", inverse);
          path5.strict = true;
          this.accept(path5);
          this.opcode("invokeAmbiguous", name, isBlock);
        },
        simpleSexpr: function simpleSexpr(sexpr) {
          var path5 = sexpr.path;
          path5.strict = true;
          this.accept(path5);
          this.opcode("resolvePossibleLambda");
        },
        helperSexpr: function helperSexpr(sexpr, program2, inverse) {
          var params = this.setupFullMustacheParams(sexpr, program2, inverse), path5 = sexpr.path, name = path5.parts[0];
          if (this.options.knownHelpers[name]) {
            this.opcode("invokeKnownHelper", params.length, name);
          } else if (this.options.knownHelpersOnly) {
            throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
          } else {
            path5.strict = true;
            path5.falsy = true;
            this.accept(path5);
            this.opcode("invokeHelper", params.length, path5.original, _ast2["default"].helpers.simpleId(path5));
          }
        },
        PathExpression: function PathExpression(path5) {
          this.addDepth(path5.depth);
          this.opcode("getContext", path5.depth);
          var name = path5.parts[0], scoped = _ast2["default"].helpers.scopedId(path5), blockParamId = !path5.depth && !scoped && this.blockParamIndex(name);
          if (blockParamId) {
            this.opcode("lookupBlockParam", blockParamId, path5.parts);
          } else if (!name) {
            this.opcode("pushContext");
          } else if (path5.data) {
            this.options.data = true;
            this.opcode("lookupData", path5.depth, path5.parts, path5.strict);
          } else {
            this.opcode("lookupOnContext", path5.parts, path5.falsy, path5.strict, scoped);
          }
        },
        StringLiteral: function StringLiteral(string2) {
          this.opcode("pushString", string2.value);
        },
        NumberLiteral: function NumberLiteral(number4) {
          this.opcode("pushLiteral", number4.value);
        },
        BooleanLiteral: function BooleanLiteral(bool2) {
          this.opcode("pushLiteral", bool2.value);
        },
        UndefinedLiteral: function UndefinedLiteral() {
          this.opcode("pushLiteral", "undefined");
        },
        NullLiteral: function NullLiteral() {
          this.opcode("pushLiteral", "null");
        },
        Hash: function Hash3(hash4) {
          var pairs = hash4.pairs, i = 0, l = pairs.length;
          this.opcode("pushHash");
          for (; i < l; i++) {
            this.pushParam(pairs[i].value);
          }
          while (i--) {
            this.opcode("assignToHash", pairs[i].key);
          }
          this.opcode("popHash");
        },
        // HELPERS
        opcode: function opcode(name) {
          this.opcodes.push({
            opcode: name,
            args: slice.call(arguments, 1),
            loc: this.sourceNode[0].loc
          });
        },
        addDepth: function addDepth(depth) {
          if (!depth) {
            return;
          }
          this.useDepths = true;
        },
        classifySexpr: function classifySexpr(sexpr) {
          var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
          var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
          var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
          var isEligible = !isBlockParam && (isHelper || isSimple);
          if (isEligible && !isHelper) {
            var _name = sexpr.path.parts[0], options = this.options;
            if (options.knownHelpers[_name]) {
              isHelper = true;
            } else if (options.knownHelpersOnly) {
              isEligible = false;
            }
          }
          if (isHelper) {
            return "helper";
          } else if (isEligible) {
            return "ambiguous";
          } else {
            return "simple";
          }
        },
        pushParams: function pushParams(params) {
          for (var i = 0, l = params.length; i < l; i++) {
            this.pushParam(params[i]);
          }
        },
        pushParam: function pushParam(val) {
          var value = val.value != null ? val.value : val.original || "";
          if (this.stringParams) {
            if (value.replace) {
              value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
            }
            if (val.depth) {
              this.addDepth(val.depth);
            }
            this.opcode("getContext", val.depth || 0);
            this.opcode("pushStringParam", value, val.type);
            if (val.type === "SubExpression") {
              this.accept(val);
            }
          } else {
            if (this.trackIds) {
              var blockParamIndex = void 0;
              if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
                blockParamIndex = this.blockParamIndex(val.parts[0]);
              }
              if (blockParamIndex) {
                var blockParamChild = val.parts.slice(1).join(".");
                this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
              } else {
                value = val.original || value;
                if (value.replace) {
                  value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
                }
                this.opcode("pushId", val.type, value);
              }
            }
            this.accept(val);
          }
        },
        setupFullMustacheParams: function setupFullMustacheParams(sexpr, program2, inverse, omitEmpty) {
          var params = sexpr.params;
          this.pushParams(params);
          this.opcode("pushProgram", program2);
          this.opcode("pushProgram", inverse);
          if (sexpr.hash) {
            this.accept(sexpr.hash);
          } else {
            this.opcode("emptyHash", omitEmpty);
          }
          return params;
        },
        blockParamIndex: function blockParamIndex(name) {
          for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
            var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
            if (blockParams && param >= 0) {
              return [depth, param];
            }
          }
        }
      };
      function precompile(input, options, env) {
        if (input == null || typeof input !== "string" && input.type !== "Program") {
          throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
        }
        options = options || {};
        if (!("data" in options)) {
          options.data = true;
        }
        if (options.compat) {
          options.useDepths = true;
        }
        var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
        return new env.JavaScriptCompiler().compile(environment, options);
      }
      function compile6(input, options, env) {
        if (options === void 0)
          options = {};
        if (input == null || typeof input !== "string" && input.type !== "Program") {
          throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
        }
        options = _utils.extend({}, options);
        if (!("data" in options)) {
          options.data = true;
        }
        if (options.compat) {
          options.useDepths = true;
        }
        var compiled = void 0;
        function compileInput() {
          var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
          return env.template(templateSpec);
        }
        function ret4(context2, execOptions) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled.call(this, context2, execOptions);
        }
        ret4._setup = function(setupOptions) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled._setup(setupOptions);
        };
        ret4._child = function(i, data, blockParams, depths) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled._child(i, data, blockParams, depths);
        };
        return ret4;
      }
      function argEquals(a, b) {
        if (a === b) {
          return true;
        }
        if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
          for (var i = 0; i < a.length; i++) {
            if (!argEquals(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
      }
      function transformLiteralToPath(sexpr) {
        if (!sexpr.path.parts) {
          var literal = sexpr.path;
          sexpr.path = {
            type: "PathExpression",
            data: false,
            depth: 0,
            parts: [literal.original + ""],
            original: literal.original + "",
            loc: literal.loc
          };
        }
      }
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
  var require_base64 = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number4) {
        if (0 <= number4 && number4 < intToCharMap.length) {
          return intToCharMap[number4];
        }
        throw new TypeError("Must be between 0 and 63: " + number4);
      };
      exports.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
  var require_util2 = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match3 = aUrl.match(urlRegexp);
        if (!match3) {
          return null;
        }
        return {
          scheme: match3[1],
          auth: match3[2],
          host: match3[3],
          port: match3[4],
          path: match3[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize5(aPath) {
        var path5 = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path5 = url.path;
        }
        var isAbsolute = exports.isAbsolute(path5);
        var parts = path5.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path5 = parts.join("/");
        if (path5 === "") {
          path5 = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path5;
          return urlGenerate(url);
        }
        return path5;
      }
      exports.normalize = normalize5;
      function join10(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize5(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join10;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative2(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative2;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity2(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity2 : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity2 : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join10(urlGenerate(parsed), sourceURL);
        }
        return normalize5(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
  var require_array_set = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js"(exports) {
      var util = require_util2();
      var has4 = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set2 = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set2.add(aArray[i], aAllowDuplicates);
        }
        return set2;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has4.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has4.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has4.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js"(exports) {
      var util = require_util2();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util = require_util2();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, "generated");
        var original = util.getArg(aArgs, "original", null);
        var source = util.getArg(aArgs, "source", null);
        var name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ",";
            }
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map2 = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map2.file = this._file;
        }
        if (this._sourceRoot != null) {
          map2.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
        }
        return map2;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js
  var require_binary_search = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js"(exports) {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports.GREATEST_LOWER_BOUND
        );
        if (index < 0) {
          return -1;
        }
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
        return index;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js
  var require_quick_sort = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js"(exports) {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1;
          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }
      exports.quickSort = function(ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js
  var require_source_map_consumer = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js"(exports) {
      var util = require_util2();
      var binarySearch = require_binary_search();
      var ArraySet = require_array_set().ArraySet;
      var base64VLQ = require_base64_vlq();
      var quickSort = require_quick_sort().quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };
      SourceMapConsumer.prototype._version = 3;
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context2 = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function(mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context2);
      };
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, "line");
        var needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (aArgs.column === void 0) {
            var originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      };
      exports.SourceMapConsumer = SourceMapConsumer;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version2 = util.getArg(sourceMap, "version");
        var sources = util.getArg(sourceMap, "sources");
        var names = util.getArg(sourceMap, "names", []);
        var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        var mappings = util.getArg(sourceMap, "mappings");
        var file = util.getArg(sourceMap, "file", null);
        if (version2 != this._version) {
          throw new Error("Unsupported version: " + version2);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util.normalize).map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function(s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
      BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        var i;
        for (i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      };
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(
          smc._sources.toArray(),
          smc.sourceRoot
        );
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function(s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
        return smc;
      };
      BasicSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function() {
          return this._absoluteSources.slice();
        }
      });
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        while (index < length) {
          if (aStr.charAt(index) === ";") {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
          } else if (aStr.charAt(index) === ",") {
            index++;
          } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index, end);
            segment = cachedSegments[str];
            if (segment) {
              index += str.length;
            } else {
              segment = [];
              while (index < end) {
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
              }
              if (segment.length === 2) {
                throw new Error("Found a source, but no line and column");
              }
              if (segment.length === 3) {
                throw new Error("Found a source and line, but no column");
              }
              cachedSegments[str] = segment;
            }
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
              if (segment.length > 4) {
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === "number") {
              originalMappings.push(mapping);
            }
          }
        }
        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
        quickSort(originalMappings, util.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = Infinity;
        }
      };
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util.compareByGeneratedPositionsDeflated,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      };
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version2 = util.getArg(sourceMap, "version");
        var sections = util.getArg(sourceMap, "sections");
        if (version2 != this._version) {
          throw new Error("Unsupported version: " + version2);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function(s) {
          if (s.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          var offset = util.getArg(s, "offset");
          var offsetLine = util.getArg(offset, "line");
          var offsetColumn = util.getArg(offset, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
      IndexedSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function() {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }
      });
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret4 = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret4;
          }
        }
        return {
          line: null,
          column: null
        };
      };
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }
            var adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js
  var require_source_node = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js"(exports) {
      var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      var util = require_util2();
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node = new SourceNode();
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map2 = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map2.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map2.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map2.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map2.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map: map2 };
      };
      exports.SourceNode = SourceNode;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js
  var require_source_map = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js"(exports) {
      exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
      exports.SourceNode = require_source_node().SourceNode;
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
  var require_code_gen = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      var SourceNode = void 0;
      try {
        if (typeof define !== "function" || !define.amd) {
          SourceMap = require_source_map();
          SourceNode = SourceMap.SourceNode;
        }
      } catch (err) {
      }
      var SourceMap;
      if (!SourceNode) {
        SourceNode = function(line, column, srcFile, chunks) {
          this.src = "";
          if (chunks) {
            this.add(chunks);
          }
        };
        SourceNode.prototype = {
          add: function add2(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src += chunks;
          },
          prepend: function prepend(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src = chunks + this.src;
          },
          toStringWithSourceMap: function toStringWithSourceMap() {
            return { code: this.toString() };
          },
          toString: function toString3() {
            return this.src;
          }
        };
      }
      function castChunk(chunk, codeGen, loc) {
        if (_utils.isArray(chunk)) {
          var ret4 = [];
          for (var i = 0, len = chunk.length; i < len; i++) {
            ret4.push(codeGen.wrap(chunk[i], loc));
          }
          return ret4;
        } else if (typeof chunk === "boolean" || typeof chunk === "number") {
          return chunk + "";
        }
        return chunk;
      }
      function CodeGen(srcFile) {
        this.srcFile = srcFile;
        this.source = [];
      }
      CodeGen.prototype = {
        isEmpty: function isEmpty() {
          return !this.source.length;
        },
        prepend: function prepend(source, loc) {
          this.source.unshift(this.wrap(source, loc));
        },
        push: function push(source, loc) {
          this.source.push(this.wrap(source, loc));
        },
        merge: function merge() {
          var source = this.empty();
          this.each(function(line) {
            source.add(["  ", line, "\n"]);
          });
          return source;
        },
        each: function each(iter) {
          for (var i = 0, len = this.source.length; i < len; i++) {
            iter(this.source[i]);
          }
        },
        empty: function empty() {
          var loc = this.currentLocation || { start: {} };
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
        },
        wrap: function wrap2(chunk) {
          var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
          if (chunk instanceof SourceNode) {
            return chunk;
          }
          chunk = castChunk(chunk, this, loc);
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
        },
        functionCall: function functionCall(fn, type3, params) {
          params = this.generateList(params);
          return this.wrap([fn, type3 ? "." + type3 + "(" : "(", params, ")"]);
        },
        quotedString: function quotedString(str) {
          return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
        },
        objectLiteral: function objectLiteral(obj) {
          var _this = this;
          var pairs = [];
          Object.keys(obj).forEach(function(key) {
            var value = castChunk(obj[key], _this);
            if (value !== "undefined") {
              pairs.push([_this.quotedString(key), ":", value]);
            }
          });
          var ret4 = this.generateList(pairs);
          ret4.prepend("{");
          ret4.add("}");
          return ret4;
        },
        generateList: function generateList(entries) {
          var ret4 = this.empty();
          for (var i = 0, len = entries.length; i < len; i++) {
            if (i) {
              ret4.add(",");
            }
            ret4.add(castChunk(entries[i], this));
          }
          return ret4;
        },
        generateArray: function generateArray(entries) {
          var ret4 = this.generateList(entries);
          ret4.prepend("[");
          ret4.add("]");
          return ret4;
        }
      };
      exports["default"] = CodeGen;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
  var require_javascript_compiler = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _base = require_base();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = require_utils();
      var _codeGen = require_code_gen();
      var _codeGen2 = _interopRequireDefault(_codeGen);
      function Literal(value) {
        this.value = value;
      }
      function JavaScriptCompiler() {
      }
      JavaScriptCompiler.prototype = {
        // PUBLIC API: You can override these methods in a subclass to provide
        // alternative compiled forms for name lookup and buffering semantics
        nameLookup: function nameLookup(parent, name) {
          return this.internalNameLookup(parent, name);
        },
        depthedLookup: function depthedLookup(name) {
          return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
        },
        compilerInfo: function compilerInfo() {
          var revision = _base.COMPILER_REVISION, versions2 = _base.REVISION_CHANGES[revision];
          return [revision, versions2];
        },
        appendToBuffer: function appendToBuffer(source, location, explicit) {
          if (!_utils.isArray(source)) {
            source = [source];
          }
          source = this.source.wrap(source, location);
          if (this.environment.isSimple) {
            return ["return ", source, ";"];
          } else if (explicit) {
            return ["buffer += ", source, ";"];
          } else {
            source.appendToBuffer = true;
            return source;
          }
        },
        initializeBuffer: function initializeBuffer() {
          return this.quotedString("");
        },
        // END PUBLIC API
        internalNameLookup: function internalNameLookup(parent, name) {
          this.lookupPropertyFunctionIsUsed = true;
          return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
        },
        lookupPropertyFunctionIsUsed: false,
        compile: function compile6(environment, options, context2, asObject) {
          this.environment = environment;
          this.options = options;
          this.stringParams = this.options.stringParams;
          this.trackIds = this.options.trackIds;
          this.precompile = !asObject;
          this.name = this.environment.name;
          this.isChild = !!context2;
          this.context = context2 || {
            decorators: [],
            programs: [],
            environments: []
          };
          this.preamble();
          this.stackSlot = 0;
          this.stackVars = [];
          this.aliases = {};
          this.registers = { list: [] };
          this.hashes = [];
          this.compileStack = [];
          this.inlineStack = [];
          this.blockParams = [];
          this.compileChildren(environment, options);
          this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
          this.useBlockParams = this.useBlockParams || environment.useBlockParams;
          var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
          for (i = 0, l = opcodes.length; i < l; i++) {
            opcode = opcodes[i];
            this.source.currentLocation = opcode.loc;
            firstLoc = firstLoc || opcode.loc;
            this[opcode.opcode].apply(this, opcode.args);
          }
          this.source.currentLocation = firstLoc;
          this.pushSource("");
          if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
            throw new _exception2["default"]("Compile completed with content left on stack");
          }
          if (!this.decorators.isEmpty()) {
            this.useDecorators = true;
            this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
            this.decorators.push("return fn;");
            if (asObject) {
              this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
            } else {
              this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
              this.decorators.push("}\n");
              this.decorators = this.decorators.merge();
            }
          } else {
            this.decorators = void 0;
          }
          var fn = this.createFunctionContext(asObject);
          if (!this.isChild) {
            var ret4 = {
              compiler: this.compilerInfo(),
              main: fn
            };
            if (this.decorators) {
              ret4.main_d = this.decorators;
              ret4.useDecorators = true;
            }
            var _context = this.context;
            var programs = _context.programs;
            var decorators = _context.decorators;
            for (i = 0, l = programs.length; i < l; i++) {
              if (programs[i]) {
                ret4[i] = programs[i];
                if (decorators[i]) {
                  ret4[i + "_d"] = decorators[i];
                  ret4.useDecorators = true;
                }
              }
            }
            if (this.environment.usePartial) {
              ret4.usePartial = true;
            }
            if (this.options.data) {
              ret4.useData = true;
            }
            if (this.useDepths) {
              ret4.useDepths = true;
            }
            if (this.useBlockParams) {
              ret4.useBlockParams = true;
            }
            if (this.options.compat) {
              ret4.compat = true;
            }
            if (!asObject) {
              ret4.compiler = JSON.stringify(ret4.compiler);
              this.source.currentLocation = { start: { line: 1, column: 0 } };
              ret4 = this.objectLiteral(ret4);
              if (options.srcName) {
                ret4 = ret4.toStringWithSourceMap({ file: options.destName });
                ret4.map = ret4.map && ret4.map.toString();
              } else {
                ret4 = ret4.toString();
              }
            } else {
              ret4.compilerOptions = this.options;
            }
            return ret4;
          } else {
            return fn;
          }
        },
        preamble: function preamble() {
          this.lastContext = 0;
          this.source = new _codeGen2["default"](this.options.srcName);
          this.decorators = new _codeGen2["default"](this.options.srcName);
        },
        createFunctionContext: function createFunctionContext(asObject) {
          var _this = this;
          var varDeclarations = "";
          var locals = this.stackVars.concat(this.registers.list);
          if (locals.length > 0) {
            varDeclarations += ", " + locals.join(", ");
          }
          var aliasCount = 0;
          Object.keys(this.aliases).forEach(function(alias) {
            var node = _this.aliases[alias];
            if (node.children && node.referenceCount > 1) {
              varDeclarations += ", alias" + ++aliasCount + "=" + alias;
              node.children[0] = "alias" + aliasCount;
            }
          });
          if (this.lookupPropertyFunctionIsUsed) {
            varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
          }
          var params = ["container", "depth0", "helpers", "partials", "data"];
          if (this.useBlockParams || this.useDepths) {
            params.push("blockParams");
          }
          if (this.useDepths) {
            params.push("depths");
          }
          var source = this.mergeSource(varDeclarations);
          if (asObject) {
            params.push(source);
            return Function.apply(this, params);
          } else {
            return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
          }
        },
        mergeSource: function mergeSource(varDeclarations) {
          var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
          this.source.each(function(line) {
            if (line.appendToBuffer) {
              if (bufferStart) {
                line.prepend("  + ");
              } else {
                bufferStart = line;
              }
              bufferEnd = line;
            } else {
              if (bufferStart) {
                if (!sourceSeen) {
                  appendFirst = true;
                } else {
                  bufferStart.prepend("buffer += ");
                }
                bufferEnd.add(";");
                bufferStart = bufferEnd = void 0;
              }
              sourceSeen = true;
              if (!isSimple) {
                appendOnly = false;
              }
            }
          });
          if (appendOnly) {
            if (bufferStart) {
              bufferStart.prepend("return ");
              bufferEnd.add(";");
            } else if (!sourceSeen) {
              this.source.push('return "";');
            }
          } else {
            varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
            if (bufferStart) {
              bufferStart.prepend("return buffer + ");
              bufferEnd.add(";");
            } else {
              this.source.push("return buffer;");
            }
          }
          if (varDeclarations) {
            this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
          }
          return this.source.merge();
        },
        lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
          return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
        },
        // [blockValue]
        //
        // On stack, before: hash, inverse, program, value
        // On stack, after: return value of blockHelperMissing
        //
        // The purpose of this opcode is to take a block of the form
        // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
        // replace it on the stack with the result of properly
        // invoking blockHelperMissing.
        blockValue: function blockValue(name) {
          var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs(name, 0, params);
          var blockName = this.popStack();
          params.splice(1, 0, blockName);
          this.push(this.source.functionCall(blockHelperMissing, "call", params));
        },
        // [ambiguousBlockValue]
        //
        // On stack, before: hash, inverse, program, value
        // Compiler value, before: lastHelper=value of last found helper, if any
        // On stack, after, if no lastHelper: same as [blockValue]
        // On stack, after, if lastHelper: value
        ambiguousBlockValue: function ambiguousBlockValue() {
          var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs("", 0, params, true);
          this.flushInline();
          var current = this.topStack();
          params.splice(1, 0, current);
          this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
        },
        // [appendContent]
        //
        // On stack, before: ...
        // On stack, after: ...
        //
        // Appends the string value of `content` to the current buffer
        appendContent: function appendContent(content) {
          if (this.pendingContent) {
            content = this.pendingContent + content;
          } else {
            this.pendingLocation = this.source.currentLocation;
          }
          this.pendingContent = content;
        },
        // [append]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Coerces `value` to a String and appends it to the current buffer.
        //
        // If `value` is truthy, or 0, it is coerced into a string and appended
        // Otherwise, the empty string is appended
        append: function append() {
          if (this.isInline()) {
            this.replaceStack(function(current) {
              return [" != null ? ", current, ' : ""'];
            });
            this.pushSource(this.appendToBuffer(this.popStack()));
          } else {
            var local = this.popStack();
            this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
            if (this.environment.isSimple) {
              this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
            }
          }
        },
        // [appendEscaped]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Escape `value` and append it to the buffer
        appendEscaped: function appendEscaped() {
          this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
        },
        // [getContext]
        //
        // On stack, before: ...
        // On stack, after: ...
        // Compiler value, after: lastContext=depth
        //
        // Set the value of the `lastContext` compiler value to the depth
        getContext: function getContext(depth) {
          this.lastContext = depth;
        },
        // [pushContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext, ...
        //
        // Pushes the value of the current context onto the stack.
        pushContext: function pushContext() {
          this.pushStackLiteral(this.contextName(this.lastContext));
        },
        // [lookupOnContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext[name], ...
        //
        // Looks up the value of `name` on the current context and pushes
        // it onto the stack.
        lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
          var i = 0;
          if (!scoped && this.options.compat && !this.lastContext) {
            this.push(this.depthedLookup(parts[i++]));
          } else {
            this.pushContext();
          }
          this.resolvePath("context", parts, i, falsy, strict);
        },
        // [lookupBlockParam]
        //
        // On stack, before: ...
        // On stack, after: blockParam[name], ...
        //
        // Looks up the value of `parts` on the given block param and pushes
        // it onto the stack.
        lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
          this.useBlockParams = true;
          this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
          this.resolvePath("context", parts, 1);
        },
        // [lookupData]
        //
        // On stack, before: ...
        // On stack, after: data, ...
        //
        // Push the data lookup operator
        lookupData: function lookupData(depth, parts, strict) {
          if (!depth) {
            this.pushStackLiteral("data");
          } else {
            this.pushStackLiteral("container.data(data, " + depth + ")");
          }
          this.resolvePath("data", parts, 0, true, strict);
        },
        resolvePath: function resolvePath(type3, parts, i, falsy, strict) {
          var _this2 = this;
          if (this.options.strict || this.options.assumeObjects) {
            this.push(strictLookup(this.options.strict && strict, this, parts, type3));
            return;
          }
          var len = parts.length;
          for (; i < len; i++) {
            this.replaceStack(function(current) {
              var lookup = _this2.nameLookup(current, parts[i], type3);
              if (!falsy) {
                return [" != null ? ", lookup, " : ", current];
              } else {
                return [" && ", lookup];
              }
            });
          }
        },
        // [resolvePossibleLambda]
        //
        // On stack, before: value, ...
        // On stack, after: resolved value, ...
        //
        // If the `value` is a lambda, replace it on the stack by
        // the return value of the lambda
        resolvePossibleLambda: function resolvePossibleLambda() {
          this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
        },
        // [pushStringParam]
        //
        // On stack, before: ...
        // On stack, after: string, currentContext, ...
        //
        // This opcode is designed for use in string mode, which
        // provides the string value of a parameter along with its
        // depth rather than resolving it immediately.
        pushStringParam: function pushStringParam(string2, type3) {
          this.pushContext();
          this.pushString(type3);
          if (type3 !== "SubExpression") {
            if (typeof string2 === "string") {
              this.pushString(string2);
            } else {
              this.pushStackLiteral(string2);
            }
          }
        },
        emptyHash: function emptyHash(omitEmpty) {
          if (this.trackIds) {
            this.push("{}");
          }
          if (this.stringParams) {
            this.push("{}");
            this.push("{}");
          }
          this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
        },
        pushHash: function pushHash() {
          if (this.hash) {
            this.hashes.push(this.hash);
          }
          this.hash = { values: {}, types: [], contexts: [], ids: [] };
        },
        popHash: function popHash() {
          var hash4 = this.hash;
          this.hash = this.hashes.pop();
          if (this.trackIds) {
            this.push(this.objectLiteral(hash4.ids));
          }
          if (this.stringParams) {
            this.push(this.objectLiteral(hash4.contexts));
            this.push(this.objectLiteral(hash4.types));
          }
          this.push(this.objectLiteral(hash4.values));
        },
        // [pushString]
        //
        // On stack, before: ...
        // On stack, after: quotedString(string), ...
        //
        // Push a quoted version of `string` onto the stack
        pushString: function pushString(string2) {
          this.pushStackLiteral(this.quotedString(string2));
        },
        // [pushLiteral]
        //
        // On stack, before: ...
        // On stack, after: value, ...
        //
        // Pushes a value onto the stack. This operation prevents
        // the compiler from creating a temporary variable to hold
        // it.
        pushLiteral: function pushLiteral(value) {
          this.pushStackLiteral(value);
        },
        // [pushProgram]
        //
        // On stack, before: ...
        // On stack, after: program(guid), ...
        //
        // Push a program expression onto the stack. This takes
        // a compile-time guid and converts it into a runtime-accessible
        // expression.
        pushProgram: function pushProgram(guid) {
          if (guid != null) {
            this.pushStackLiteral(this.programExpression(guid));
          } else {
            this.pushStackLiteral(null);
          }
        },
        // [registerDecorator]
        //
        // On stack, before: hash, program, params..., ...
        // On stack, after: ...
        //
        // Pops off the decorator's parameters, invokes the decorator,
        // and inserts the decorator into the decorators list.
        registerDecorator: function registerDecorator(paramSize, name) {
          var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
          this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
        },
        // [invokeHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // Pops off the helper's parameters, invokes the helper,
        // and pushes the helper's return value onto the stack.
        //
        // If the helper is not found, `helperMissing` is called.
        invokeHelper: function invokeHelper(paramSize, name, isSimple) {
          var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
          var possibleFunctionCalls = [];
          if (isSimple) {
            possibleFunctionCalls.push(helper.name);
          }
          possibleFunctionCalls.push(nonHelper);
          if (!this.options.strict) {
            possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
          }
          var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
          var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
          this.push(functionCall);
        },
        itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
          var result = [];
          result.push(items[0]);
          for (var i = 1; i < items.length; i++) {
            result.push(separator, items[i]);
          }
          return result;
        },
        // [invokeKnownHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // This operation is used when the helper is known to exist,
        // so a `helperMissing` fallback is not required.
        invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
          var helper = this.setupHelper(paramSize, name);
          this.push(this.source.functionCall(helper.name, "call", helper.callParams));
        },
        // [invokeAmbiguous]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of disambiguation
        //
        // This operation is used when an expression like `{{foo}}`
        // is provided, but we don't know at compile-time whether it
        // is a helper or a path.
        //
        // This operation emits more code than the other options,
        // and can be avoided by passing the `knownHelpers` and
        // `knownHelpersOnly` flags at compile-time.
        invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
          this.useRegister("helper");
          var nonHelper = this.popStack();
          this.emptyHash();
          var helper = this.setupHelper(0, name, helperCall);
          var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
          var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
          if (!this.options.strict) {
            lookup[0] = "(helper = ";
            lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
          }
          this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
        },
        // [invokePartial]
        //
        // On stack, before: context, ...
        // On stack after: result of partial invocation
        //
        // This operation pops off a context, invokes a partial with that context,
        // and pushes the result of the invocation back.
        invokePartial: function invokePartial(isDynamic, name, indent2) {
          var params = [], options = this.setupParams(name, 1, params);
          if (isDynamic) {
            name = this.popStack();
            delete options.name;
          }
          if (indent2) {
            options.indent = JSON.stringify(indent2);
          }
          options.helpers = "helpers";
          options.partials = "partials";
          options.decorators = "container.decorators";
          if (!isDynamic) {
            params.unshift(this.nameLookup("partials", name, "partial"));
          } else {
            params.unshift(name);
          }
          if (this.options.compat) {
            options.depths = "depths";
          }
          options = this.objectLiteral(options);
          params.push(options);
          this.push(this.source.functionCall("container.invokePartial", "", params));
        },
        // [assignToHash]
        //
        // On stack, before: value, ..., hash, ...
        // On stack, after: ..., hash, ...
        //
        // Pops a value off the stack and assigns it to the current hash
        assignToHash: function assignToHash(key) {
          var value = this.popStack(), context2 = void 0, type3 = void 0, id = void 0;
          if (this.trackIds) {
            id = this.popStack();
          }
          if (this.stringParams) {
            type3 = this.popStack();
            context2 = this.popStack();
          }
          var hash4 = this.hash;
          if (context2) {
            hash4.contexts[key] = context2;
          }
          if (type3) {
            hash4.types[key] = type3;
          }
          if (id) {
            hash4.ids[key] = id;
          }
          hash4.values[key] = value;
        },
        pushId: function pushId(type3, name, child) {
          if (type3 === "BlockParam") {
            this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
          } else if (type3 === "PathExpression") {
            this.pushString(name);
          } else if (type3 === "SubExpression") {
            this.pushStackLiteral("true");
          } else {
            this.pushStackLiteral("null");
          }
        },
        // HELPERS
        compiler: JavaScriptCompiler,
        compileChildren: function compileChildren(environment, options) {
          var children = environment.children, child = void 0, compiler = void 0;
          for (var i = 0, l = children.length; i < l; i++) {
            child = children[i];
            compiler = new this.compiler();
            var existing = this.matchExistingProgram(child);
            if (existing == null) {
              this.context.programs.push("");
              var index = this.context.programs.length;
              child.index = index;
              child.name = "program" + index;
              this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
              this.context.decorators[index] = compiler.decorators;
              this.context.environments[index] = child;
              this.useDepths = this.useDepths || compiler.useDepths;
              this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
              child.useDepths = this.useDepths;
              child.useBlockParams = this.useBlockParams;
            } else {
              child.index = existing.index;
              child.name = "program" + existing.index;
              this.useDepths = this.useDepths || existing.useDepths;
              this.useBlockParams = this.useBlockParams || existing.useBlockParams;
            }
          }
        },
        matchExistingProgram: function matchExistingProgram(child) {
          for (var i = 0, len = this.context.environments.length; i < len; i++) {
            var environment = this.context.environments[i];
            if (environment && environment.equals(child)) {
              return environment;
            }
          }
        },
        programExpression: function programExpression(guid) {
          var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
          if (this.useBlockParams || this.useDepths) {
            programParams.push("blockParams");
          }
          if (this.useDepths) {
            programParams.push("depths");
          }
          return "container.program(" + programParams.join(", ") + ")";
        },
        useRegister: function useRegister(name) {
          if (!this.registers[name]) {
            this.registers[name] = true;
            this.registers.list.push(name);
          }
        },
        push: function push(expr) {
          if (!(expr instanceof Literal)) {
            expr = this.source.wrap(expr);
          }
          this.inlineStack.push(expr);
          return expr;
        },
        pushStackLiteral: function pushStackLiteral(item) {
          this.push(new Literal(item));
        },
        pushSource: function pushSource(source) {
          if (this.pendingContent) {
            this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
            this.pendingContent = void 0;
          }
          if (source) {
            this.source.push(source);
          }
        },
        replaceStack: function replaceStack(callback) {
          var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
          if (!this.isInline()) {
            throw new _exception2["default"]("replaceStack on non-inline");
          }
          var top = this.popStack(true);
          if (top instanceof Literal) {
            stack = [top.value];
            prefix = ["(", stack];
            usedLiteral = true;
          } else {
            createdStack = true;
            var _name = this.incrStack();
            prefix = ["((", this.push(_name), " = ", top, ")"];
            stack = this.topStack();
          }
          var item = callback.call(this, stack);
          if (!usedLiteral) {
            this.popStack();
          }
          if (createdStack) {
            this.stackSlot--;
          }
          this.push(prefix.concat(item, ")"));
        },
        incrStack: function incrStack() {
          this.stackSlot++;
          if (this.stackSlot > this.stackVars.length) {
            this.stackVars.push("stack" + this.stackSlot);
          }
          return this.topStackName();
        },
        topStackName: function topStackName() {
          return "stack" + this.stackSlot;
        },
        flushInline: function flushInline() {
          var inlineStack = this.inlineStack;
          this.inlineStack = [];
          for (var i = 0, len = inlineStack.length; i < len; i++) {
            var entry = inlineStack[i];
            if (entry instanceof Literal) {
              this.compileStack.push(entry);
            } else {
              var stack = this.incrStack();
              this.pushSource([stack, " = ", entry, ";"]);
              this.compileStack.push(stack);
            }
          }
        },
        isInline: function isInline() {
          return this.inlineStack.length;
        },
        popStack: function popStack(wrapped) {
          var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
          if (!wrapped && item instanceof Literal) {
            return item.value;
          } else {
            if (!inline) {
              if (!this.stackSlot) {
                throw new _exception2["default"]("Invalid stack pop");
              }
              this.stackSlot--;
            }
            return item;
          }
        },
        topStack: function topStack() {
          var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
          if (item instanceof Literal) {
            return item.value;
          } else {
            return item;
          }
        },
        contextName: function contextName(context2) {
          if (this.useDepths && context2) {
            return "depths[" + context2 + "]";
          } else {
            return "depth" + context2;
          }
        },
        quotedString: function quotedString(str) {
          return this.source.quotedString(str);
        },
        objectLiteral: function objectLiteral(obj) {
          return this.source.objectLiteral(obj);
        },
        aliasable: function aliasable(name) {
          var ret4 = this.aliases[name];
          if (ret4) {
            ret4.referenceCount++;
            return ret4;
          }
          ret4 = this.aliases[name] = this.source.wrap(name);
          ret4.aliasable = true;
          ret4.referenceCount = 1;
          return ret4;
        },
        setupHelper: function setupHelper(paramSize, name, blockHelper) {
          var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
          var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
          return {
            params,
            paramsInit,
            name: foundHelper,
            callParams: [callContext].concat(params)
          };
        },
        setupParams: function setupParams(helper, paramSize, params) {
          var options = {}, contexts = [], types2 = [], ids = [], objectArgs = !params, param = void 0;
          if (objectArgs) {
            params = [];
          }
          options.name = this.quotedString(helper);
          options.hash = this.popStack();
          if (this.trackIds) {
            options.hashIds = this.popStack();
          }
          if (this.stringParams) {
            options.hashTypes = this.popStack();
            options.hashContexts = this.popStack();
          }
          var inverse = this.popStack(), program2 = this.popStack();
          if (program2 || inverse) {
            options.fn = program2 || "container.noop";
            options.inverse = inverse || "container.noop";
          }
          var i = paramSize;
          while (i--) {
            param = this.popStack();
            params[i] = param;
            if (this.trackIds) {
              ids[i] = this.popStack();
            }
            if (this.stringParams) {
              types2[i] = this.popStack();
              contexts[i] = this.popStack();
            }
          }
          if (objectArgs) {
            options.args = this.source.generateArray(params);
          }
          if (this.trackIds) {
            options.ids = this.source.generateArray(ids);
          }
          if (this.stringParams) {
            options.types = this.source.generateArray(types2);
            options.contexts = this.source.generateArray(contexts);
          }
          if (this.options.data) {
            options.data = "data";
          }
          if (this.useBlockParams) {
            options.blockParams = "blockParams";
          }
          return options;
        },
        setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
          var options = this.setupParams(helper, paramSize, params);
          options.loc = JSON.stringify(this.source.currentLocation);
          options = this.objectLiteral(options);
          if (useRegister) {
            this.useRegister("options");
            params.push("options");
            return ["options=", options];
          } else if (params) {
            params.push(options);
            return "";
          } else {
            return options;
          }
        }
      };
      (function() {
        var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
        for (var i = 0, l = reservedWords.length; i < l; i++) {
          compilerWords[reservedWords[i]] = true;
        }
      })();
      JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
      };
      function strictLookup(requireTerminal, compiler, parts, type3) {
        var stack = compiler.popStack(), i = 0, len = parts.length;
        if (requireTerminal) {
          len--;
        }
        for (; i < len; i++) {
          stack = compiler.nameLookup(stack, parts[i], type3);
        }
        if (requireTerminal) {
          return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
        } else {
          return stack;
        }
      }
      exports["default"] = JavaScriptCompiler;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars.js
  var require_handlebars = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _handlebarsRuntime = require_handlebars_runtime();
      var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
      var _handlebarsCompilerAst = require_ast();
      var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
      var _handlebarsCompilerBase = require_base2();
      var _handlebarsCompilerCompiler = require_compiler();
      var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
      var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
      var _handlebarsCompilerVisitor = require_visitor();
      var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
      var _handlebarsNoConflict = require_no_conflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      var _create = _handlebarsRuntime2["default"].create;
      function create10() {
        var hb = _create();
        hb.compile = function(input, options) {
          return _handlebarsCompilerCompiler.compile(input, options, hb);
        };
        hb.precompile = function(input, options) {
          return _handlebarsCompilerCompiler.precompile(input, options, hb);
        };
        hb.AST = _handlebarsCompilerAst2["default"];
        hb.Compiler = _handlebarsCompilerCompiler.Compiler;
        hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
        hb.Parser = _handlebarsCompilerBase.parser;
        hb.parse = _handlebarsCompilerBase.parse;
        hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
        return hb;
      }
      var inst = create10();
      inst.create = create10;
      _handlebarsNoConflict2["default"](inst);
      inst.Visitor = _handlebarsCompilerVisitor2["default"];
      inst["default"] = inst;
      exports["default"] = inst;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js
  var require_printer = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.print = print2;
      exports.PrintVisitor = PrintVisitor;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = require_visitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function print2(ast) {
        return new PrintVisitor().accept(ast);
      }
      function PrintVisitor() {
        this.padding = 0;
      }
      PrintVisitor.prototype = new _visitor2["default"]();
      PrintVisitor.prototype.pad = function(string2) {
        var out = "";
        for (var i = 0, l = this.padding; i < l; i++) {
          out += "  ";
        }
        out += string2 + "\n";
        return out;
      };
      PrintVisitor.prototype.Program = function(program2) {
        var out = "", body = program2.body, i = void 0, l = void 0;
        if (program2.blockParams) {
          var blockParams = "BLOCK PARAMS: [";
          for (i = 0, l = program2.blockParams.length; i < l; i++) {
            blockParams += " " + program2.blockParams[i];
          }
          blockParams += " ]";
          out += this.pad(blockParams);
        }
        for (i = 0, l = body.length; i < l; i++) {
          out += this.accept(body[i]);
        }
        this.padding--;
        return out;
      };
      PrintVisitor.prototype.MustacheStatement = function(mustache) {
        return this.pad("{{ " + this.SubExpression(mustache) + " }}");
      };
      PrintVisitor.prototype.Decorator = function(mustache) {
        return this.pad("{{ DIRECTIVE " + this.SubExpression(mustache) + " }}");
      };
      PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function(block2) {
        var out = "";
        out += this.pad((block2.type === "DecoratorBlock" ? "DIRECTIVE " : "") + "BLOCK:");
        this.padding++;
        out += this.pad(this.SubExpression(block2));
        if (block2.program) {
          out += this.pad("PROGRAM:");
          this.padding++;
          out += this.accept(block2.program);
          this.padding--;
        }
        if (block2.inverse) {
          if (block2.program) {
            this.padding++;
          }
          out += this.pad("{{^}}");
          this.padding++;
          out += this.accept(block2.inverse);
          this.padding--;
          if (block2.program) {
            this.padding--;
          }
        }
        this.padding--;
        return out;
      };
      PrintVisitor.prototype.PartialStatement = function(partial) {
        var content = "PARTIAL:" + partial.name.original;
        if (partial.params[0]) {
          content += " " + this.accept(partial.params[0]);
        }
        if (partial.hash) {
          content += " " + this.accept(partial.hash);
        }
        return this.pad("{{> " + content + " }}");
      };
      PrintVisitor.prototype.PartialBlockStatement = function(partial) {
        var content = "PARTIAL BLOCK:" + partial.name.original;
        if (partial.params[0]) {
          content += " " + this.accept(partial.params[0]);
        }
        if (partial.hash) {
          content += " " + this.accept(partial.hash);
        }
        content += " " + this.pad("PROGRAM:");
        this.padding++;
        content += this.accept(partial.program);
        this.padding--;
        return this.pad("{{> " + content + " }}");
      };
      PrintVisitor.prototype.ContentStatement = function(content) {
        return this.pad("CONTENT[ '" + content.value + "' ]");
      };
      PrintVisitor.prototype.CommentStatement = function(comment) {
        return this.pad("{{! '" + comment.value + "' }}");
      };
      PrintVisitor.prototype.SubExpression = function(sexpr) {
        var params = sexpr.params, paramStrings = [], hash4 = void 0;
        for (var i = 0, l = params.length; i < l; i++) {
          paramStrings.push(this.accept(params[i]));
        }
        params = "[" + paramStrings.join(", ") + "]";
        hash4 = sexpr.hash ? " " + this.accept(sexpr.hash) : "";
        return this.accept(sexpr.path) + " " + params + hash4;
      };
      PrintVisitor.prototype.PathExpression = function(id) {
        var path5 = id.parts.join("/");
        return (id.data ? "@" : "") + "PATH:" + path5;
      };
      PrintVisitor.prototype.StringLiteral = function(string2) {
        return '"' + string2.value + '"';
      };
      PrintVisitor.prototype.NumberLiteral = function(number4) {
        return "NUMBER{" + number4.value + "}";
      };
      PrintVisitor.prototype.BooleanLiteral = function(bool2) {
        return "BOOLEAN{" + bool2.value + "}";
      };
      PrintVisitor.prototype.UndefinedLiteral = function() {
        return "UNDEFINED";
      };
      PrintVisitor.prototype.NullLiteral = function() {
        return "NULL";
      };
      PrintVisitor.prototype.Hash = function(hash4) {
        var pairs = hash4.pairs, joinedPairs = [];
        for (var i = 0, l = pairs.length; i < l; i++) {
          joinedPairs.push(this.accept(pairs[i]));
        }
        return "HASH{" + joinedPairs.join(", ") + "}";
      };
      PrintVisitor.prototype.HashPair = function(pair) {
        return pair.key + "=" + this.accept(pair.value);
      };
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/lib/index.js"(exports, module) {
      var handlebars = require_handlebars()["default"];
      var printer = require_printer();
      handlebars.PrintVisitor = printer.PrintVisitor;
      handlebars.print = printer.print;
      module.exports = handlebars;
      function extension(module2, filename) {
        var fs4 = __require2("fs");
        var templateString = fs4.readFileSync(filename, "utf8");
        module2.exports = handlebars.compile(templateString);
      }
      if (typeof __require2 !== "undefined" && __require2.extensions) {
        __require2.extensions[".handlebars"] = extension;
        __require2.extensions[".hbs"] = extension;
      }
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/styles.js
  var require_styles = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/styles.js"(exports, module) {
      var styles = {};
      module["exports"] = styles;
      var codes = {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29],
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        grey: [90, 39],
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // legacy styles for colors pre v1.0.0
        blackBG: [40, 49],
        redBG: [41, 49],
        greenBG: [42, 49],
        yellowBG: [43, 49],
        blueBG: [44, 49],
        magentaBG: [45, 49],
        cyanBG: [46, 49],
        whiteBG: [47, 49]
      };
      Object.keys(codes).forEach(function(key) {
        var val = codes[key];
        var style = styles[key] = [];
        style.open = "\x1B[" + val[0] + "m";
        style.close = "\x1B[" + val[1] + "m";
      });
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/system/supports-colors.js
  var require_supports_colors = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/system/supports-colors.js"(exports, module) {
      var argv = process.argv;
      module.exports = function() {
        if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
          return false;
        }
        if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
          return true;
        }
        if (process.stdout && !process.stdout.isTTY) {
          return false;
        }
        if (process.platform === "win32") {
          return true;
        }
        if ("COLORTERM" in process.env) {
          return true;
        }
        if (process.env.TERM === "dumb") {
          return false;
        }
        if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
          return true;
        }
        return false;
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/trap.js
  var require_trap = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/trap.js"(exports, module) {
      module["exports"] = function runTheTrap(text, options) {
        var result = "";
        text = text || "Run the trap, drop the bass";
        text = text.split("");
        var trap = {
          a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
          b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
          c: ["\xA9", "\u023B", "\u03FE"],
          d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
          e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
          f: ["\u04FA"],
          g: ["\u0262"],
          h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
          i: ["\u0F0F"],
          j: ["\u0134"],
          k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
          l: ["\u0139"],
          m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
          n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
          o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
          p: ["\u01F7", "\u048E"],
          q: ["\u09CD"],
          r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
          s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
          t: ["\u0141", "\u0166", "\u0373"],
          u: ["\u01B1", "\u054D"],
          v: ["\u05D8"],
          w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
          x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
          y: ["\xA5", "\u04B0", "\u04CB"],
          z: ["\u01B5", "\u0240"]
        };
        text.forEach(function(c) {
          c = c.toLowerCase();
          var chars = trap[c] || [" "];
          var rand = Math.floor(Math.random() * chars.length);
          if (typeof trap[c] !== "undefined") {
            result += trap[c][rand];
          } else {
            result += c;
          }
        });
        return result;
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/zalgo.js
  var require_zalgo = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/zalgo.js"(exports, module) {
      module["exports"] = function zalgo(text, options) {
        text = text || "   he is here   ";
        var soul = {
          "up": [
            "\u030D",
            "\u030E",
            "\u0304",
            "\u0305",
            "\u033F",
            "\u0311",
            "\u0306",
            "\u0310",
            "\u0352",
            "\u0357",
            "\u0351",
            "\u0307",
            "\u0308",
            "\u030A",
            "\u0342",
            "\u0313",
            "\u0308",
            "\u034A",
            "\u034B",
            "\u034C",
            "\u0303",
            "\u0302",
            "\u030C",
            "\u0350",
            "\u0300",
            "\u0301",
            "\u030B",
            "\u030F",
            "\u0312",
            "\u0313",
            "\u0314",
            "\u033D",
            "\u0309",
            "\u0363",
            "\u0364",
            "\u0365",
            "\u0366",
            "\u0367",
            "\u0368",
            "\u0369",
            "\u036A",
            "\u036B",
            "\u036C",
            "\u036D",
            "\u036E",
            "\u036F",
            "\u033E",
            "\u035B",
            "\u0346",
            "\u031A"
          ],
          "down": [
            "\u0316",
            "\u0317",
            "\u0318",
            "\u0319",
            "\u031C",
            "\u031D",
            "\u031E",
            "\u031F",
            "\u0320",
            "\u0324",
            "\u0325",
            "\u0326",
            "\u0329",
            "\u032A",
            "\u032B",
            "\u032C",
            "\u032D",
            "\u032E",
            "\u032F",
            "\u0330",
            "\u0331",
            "\u0332",
            "\u0333",
            "\u0339",
            "\u033A",
            "\u033B",
            "\u033C",
            "\u0345",
            "\u0347",
            "\u0348",
            "\u0349",
            "\u034D",
            "\u034E",
            "\u0353",
            "\u0354",
            "\u0355",
            "\u0356",
            "\u0359",
            "\u035A",
            "\u0323"
          ],
          "mid": [
            "\u0315",
            "\u031B",
            "\u0300",
            "\u0301",
            "\u0358",
            "\u0321",
            "\u0322",
            "\u0327",
            "\u0328",
            "\u0334",
            "\u0335",
            "\u0336",
            "\u035C",
            "\u035D",
            "\u035E",
            "\u035F",
            "\u0360",
            "\u0362",
            "\u0338",
            "\u0337",
            "\u0361",
            " \u0489"
          ]
        }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
        function randomNumber(range) {
          var r = Math.floor(Math.random() * range);
          return r;
        }
        function is_char(character) {
          var bool2 = false;
          all.filter(function(i) {
            bool2 = i === character;
          });
          return bool2;
        }
        function heComes(text2, options2) {
          var result = "", counts, l;
          options2 = options2 || {};
          options2["up"] = options2["up"] || true;
          options2["mid"] = options2["mid"] || true;
          options2["down"] = options2["down"] || true;
          options2["size"] = options2["size"] || "maxi";
          text2 = text2.split("");
          for (l in text2) {
            if (is_char(l)) {
              continue;
            }
            result = result + text2[l];
            counts = { "up": 0, "down": 0, "mid": 0 };
            switch (options2.size) {
              case "mini":
                counts.up = randomNumber(8);
                counts.min = randomNumber(2);
                counts.down = randomNumber(8);
                break;
              case "maxi":
                counts.up = randomNumber(16) + 3;
                counts.min = randomNumber(4) + 1;
                counts.down = randomNumber(64) + 3;
                break;
              default:
                counts.up = randomNumber(8) + 1;
                counts.mid = randomNumber(6) / 2;
                counts.down = randomNumber(8) + 1;
                break;
            }
            var arr = ["up", "mid", "down"];
            for (var d in arr) {
              var index = arr[d];
              for (var i = 0; i <= counts[index]; i++) {
                if (options2[index]) {
                  result = result + soul[index][randomNumber(soul[index].length)];
                }
              }
            }
          }
          return result;
        }
        return heComes(text);
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/america.js
  var require_america = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/america.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = function() {
        return function(letter, i, exploded) {
          if (letter === " ")
            return letter;
          switch (i % 3) {
            case 0:
              return colors.red(letter);
            case 1:
              return colors.white(letter);
            case 2:
              return colors.blue(letter);
          }
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/zebra.js
  var require_zebra = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/zebra.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/rainbow.js
  var require_rainbow = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/rainbow.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = function() {
        var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
        return function(letter, i, exploded) {
          if (letter === " ") {
            return letter;
          } else {
            return colors[rainbowColors[i++ % rainbowColors.length]](letter);
          }
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/random.js
  var require_random = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/random.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = function() {
        var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
        return function(letter, i, exploded) {
          return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/colors.js
  var require_colors = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/colors.js"(exports, module) {
      var colors = {};
      module["exports"] = colors;
      colors.themes = {};
      var ansiStyles = colors.styles = require_styles();
      var defineProps = Object.defineProperties;
      colors.supportsColor = require_supports_colors();
      if (typeof colors.enabled === "undefined") {
        colors.enabled = colors.supportsColor;
      }
      colors.stripColors = colors.strip = function(str) {
        return ("" + str).replace(/\x1B\[\d+m/g, "");
      };
      var stylize = colors.stylize = function stylize2(str, style) {
        return ansiStyles[style].open + str + ansiStyles[style].close;
      };
      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
      var escapeStringRegexp = function(str) {
        if (typeof str !== "string") {
          throw new TypeError("Expected a string");
        }
        return str.replace(matchOperatorsRe, "\\$&");
      };
      function build3(_styles) {
        var builder = function builder2() {
          return applyStyle.apply(builder2, arguments);
        };
        builder._styles = _styles;
        builder.__proto__ = proto;
        return builder;
      }
      var styles = function() {
        var ret4 = {};
        ansiStyles.grey = ansiStyles.gray;
        Object.keys(ansiStyles).forEach(function(key) {
          ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
          ret4[key] = {
            get: function() {
              return build3(this._styles.concat(key));
            }
          };
        });
        return ret4;
      }();
      var proto = defineProps(function colors2() {
      }, styles);
      function applyStyle() {
        var args = arguments;
        var argsLen = args.length;
        var str = argsLen !== 0 && String(arguments[0]);
        if (argsLen > 1) {
          for (var a = 1; a < argsLen; a++) {
            str += " " + args[a];
          }
        }
        if (!colors.enabled || !str) {
          return str;
        }
        var nestedStyles = this._styles;
        var i = nestedStyles.length;
        while (i--) {
          var code = ansiStyles[nestedStyles[i]];
          str = code.open + str.replace(code.closeRe, code.open) + code.close;
        }
        return str;
      }
      function applyTheme(theme) {
        for (var style in theme) {
          (function(style2) {
            colors[style2] = function(str) {
              return colors[theme[style2]](str);
            };
          })(style);
        }
      }
      colors.setTheme = function(theme) {
        if (typeof theme === "string") {
          try {
            colors.themes[theme] = __require2(theme);
            applyTheme(colors.themes[theme]);
            return colors.themes[theme];
          } catch (err) {
            console.log(err);
            return err;
          }
        } else {
          applyTheme(theme);
        }
      };
      function init2() {
        var ret4 = {};
        Object.keys(styles).forEach(function(name) {
          ret4[name] = {
            get: function() {
              return build3([name]);
            }
          };
        });
        return ret4;
      }
      var sequencer = function sequencer2(map3, str) {
        var exploded = str.split(""), i = 0;
        exploded = exploded.map(map3);
        return exploded.join("");
      };
      colors.trap = require_trap();
      colors.zalgo = require_zalgo();
      colors.maps = {};
      colors.maps.america = require_america();
      colors.maps.zebra = require_zebra();
      colors.maps.rainbow = require_rainbow();
      colors.maps.random = require_random();
      for (map2 in colors.maps) {
        (function(map3) {
          colors[map3] = function(str) {
            return sequencer(colors.maps[map3], str);
          };
        })(map2);
      }
      var map2;
      defineProps(colors, init2());
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/safe.js
  var require_safe = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/safe.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = colors;
    }
  });

  // ../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/utils.js"(exports) {
      exports.repeat = function(str, times) {
        return Array(times + 1).join(str);
      };
      exports.pad = function(str, len, pad3, dir) {
        if (len + 1 >= str.length)
          switch (dir) {
            case "left":
              str = Array(len + 1 - str.length).join(pad3) + str;
              break;
            case "both":
              var right = Math.ceil((padlen = len - str.length) / 2);
              var left = padlen - right;
              str = Array(left + 1).join(pad3) + str + Array(right + 1).join(pad3);
              break;
            default:
              str = str + Array(len + 1 - str.length).join(pad3);
          }
        ;
        return str;
      };
      exports.truncate = function(str, length, chr) {
        chr = chr || "\u2026";
        return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
      };
      function options(defaults2, opts) {
        for (var p in opts) {
          if (p === "__proto__" || p === "constructor" || p === "prototype") {
            continue;
          }
          if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
            defaults2[p] = defaults2[p] || {};
            options(defaults2[p], opts[p]);
          } else {
            defaults2[p] = opts[p];
          }
        }
        return defaults2;
      }
      exports.options = options;
      exports.strlen = function(str) {
        var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
        var stripped = ("" + str).replace(code, "");
        var split4 = stripped.split("\n");
        return split4.reduce(function(memo, s) {
          return s.length > memo ? s.length : memo;
        }, 0);
      };
    }
  });

  // ../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/index.js
  var require_lib2 = __commonJS({
    "../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/index.js"(exports, module) {
      var colors = require_safe();
      var utils = require_utils2();
      var repeat = utils.repeat;
      var truncate = utils.truncate;
      var pad3 = utils.pad;
      function Table(options) {
        this.options = utils.options({
          chars: {
            "top": "\u2500",
            "top-mid": "\u252C",
            "top-left": "\u250C",
            "top-right": "\u2510",
            "bottom": "\u2500",
            "bottom-mid": "\u2534",
            "bottom-left": "\u2514",
            "bottom-right": "\u2518",
            "left": "\u2502",
            "left-mid": "\u251C",
            "mid": "\u2500",
            "mid-mid": "\u253C",
            "right": "\u2502",
            "right-mid": "\u2524",
            "middle": "\u2502"
          },
          truncate: "\u2026",
          colWidths: [],
          colAligns: [],
          style: {
            "padding-left": 1,
            "padding-right": 1,
            head: ["red"],
            border: ["grey"],
            compact: false
          },
          head: []
        }, options);
        if (options && options.rows) {
          for (var i = 0; i < options.rows.length; i++) {
            this.push(options.rows[i]);
          }
        }
      }
      Table.prototype.__proto__ = Array.prototype;
      Table.prototype.__defineGetter__("width", function() {
        var str = this.toString().split("\n");
        if (str.length)
          return str[0].length;
        return 0;
      });
      Table.prototype.render;
      Table.prototype.toString = function() {
        var ret4 = "", options = this.options, style = options.style, head = options.head, chars = options.chars, truncater = options.truncate, colWidths = options.colWidths || new Array(this.head.length), totalWidth = 0;
        if (!head.length && !this.length)
          return "";
        if (!colWidths.length) {
          var all_rows = this.slice(0);
          if (head.length) {
            all_rows = all_rows.concat([head]);
          }
          ;
          all_rows.forEach(function(cells) {
            if (typeof cells === "object" && cells.length) {
              extractColumnWidths(cells);
            } else {
              var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
              colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
              if (typeof value_cell === "object" && value_cell.length) {
                extractColumnWidths(value_cell, 1);
              } else {
                colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
              }
            }
          });
        }
        ;
        totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(
          function(a, b) {
            return a + b;
          }
        )) + colWidths.length + 1;
        function extractColumnWidths(arr, offset) {
          var offset = offset || 0;
          arr.forEach(function(cell, i) {
            colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
          });
        }
        ;
        function get_width(obj) {
          return typeof obj == "object" && obj.width != void 0 ? obj.width : (typeof obj == "object" ? utils.strlen(obj.text) : utils.strlen(obj)) + (style["padding-left"] || 0) + (style["padding-right"] || 0);
        }
        function line(line2, left, right, intersection) {
          var width = 0, line2 = left + repeat(line2, totalWidth - 2) + right;
          colWidths.forEach(function(w, i) {
            if (i == colWidths.length - 1)
              return;
            width += w + 1;
            line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
          });
          return applyStyles(options.style.border, line2);
        }
        ;
        function lineTop() {
          var l2 = line(
            chars.top,
            chars["top-left"] || chars.top,
            chars["top-right"] || chars.top,
            chars["top-mid"]
          );
          if (l2)
            ret4 += l2 + "\n";
        }
        ;
        function generateRow(items, style2) {
          var cells = [], max_height = 0;
          if (!Array.isArray(items) && typeof items === "object") {
            var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
            if (Array.isArray(value)) {
              items = value;
              items.unshift(key);
            } else {
              items = [key, value];
            }
          }
          items.forEach(function(item, i) {
            var contents = item.toString().split("\n").reduce(function(memo, l2) {
              memo.push(string2(l2, i));
              return memo;
            }, []);
            var height = contents.length;
            if (height > max_height) {
              max_height = height;
            }
            ;
            cells.push({ contents, height });
          });
          var lines = new Array(max_height);
          cells.forEach(function(cell, i) {
            cell.contents.forEach(function(line2, j2) {
              if (!lines[j2]) {
                lines[j2] = [];
              }
              ;
              if (style2 || first_cell_head && i === 0 && options.style.head) {
                line2 = applyStyles(options.style.head, line2);
              }
              lines[j2].push(line2);
            });
            for (var j = cell.height, l2 = max_height; j < l2; j++) {
              if (!lines[j]) {
                lines[j] = [];
              }
              ;
              lines[j].push(string2("", i));
            }
          });
          var ret5 = "";
          lines.forEach(function(line2, index) {
            if (ret5.length > 0) {
              ret5 += "\n" + applyStyles(options.style.border, chars.left);
            }
            ret5 += line2.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
          });
          return applyStyles(options.style.border, chars.left) + ret5;
        }
        ;
        function applyStyles(styles, subject) {
          if (!subject)
            return "";
          styles.forEach(function(style2) {
            subject = colors[style2](subject);
          });
          return subject;
        }
        ;
        function string2(str, index) {
          var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style["padding-left"] || 0) - (style["padding-right"] || 0), align = options.colAligns[index] || "left";
          return repeat(" ", style["padding-left"] || 0) + (length == width ? str : length < width ? pad3(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat(" ", style["padding-right"] || 0);
        }
        ;
        if (head.length) {
          lineTop();
          ret4 += generateRow(head, style.head) + "\n";
        }
        if (this.length)
          this.forEach(function(cells, i) {
            if (!head.length && i == 0)
              lineTop();
            else {
              if (!style.compact || i < !!head.length ? 1 : cells.length == 0) {
                var l2 = line(
                  chars.mid,
                  chars["left-mid"],
                  chars["right-mid"],
                  chars["mid-mid"]
                );
                if (l2)
                  ret4 += l2 + "\n";
              }
            }
            if (cells.hasOwnProperty("length") && !cells.length) {
              return;
            } else {
              ret4 += generateRow(cells) + "\n";
            }
            ;
          });
        var l = line(
          chars.bottom,
          chars["bottom-left"] || chars.bottom,
          chars["bottom-right"] || chars.bottom,
          chars["bottom-mid"]
        );
        if (l)
          ret4 += l;
        else
          ret4 = ret4.slice(0, -1);
        return ret4;
      };
      module.exports = Table;
      module.exports.version = "0.0.1";
    }
  });

  // ../../node_modules/.pnpm/lodash.camelcase@4.3.0/node_modules/lodash.camelcase/index.js
  var require_lodash = __commonJS({
    "../../node_modules/.pnpm/lodash.camelcase@4.3.0/node_modules/lodash.camelcase/index.js"(exports, module) {
      var INFINITY = 1 / 0;
      var symbolTag = "[object Symbol]";
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
      var rsComboSymbolsRange = "\\u20d0-\\u20f0";
      var rsDingbatRange = "\\u2700-\\u27bf";
      var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
      var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
      var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
      var rsPunctuationRange = "\\u2000-\\u206f";
      var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
      var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsBreak = "[" + rsBreakRange + "]";
      var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
      var rsDigits = "\\d+";
      var rsDingbat = "[" + rsDingbatRange + "]";
      var rsLower = "[" + rsLowerRange + "]";
      var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsUpper = "[" + rsUpperRange + "]";
      var rsZWJ = "\\u200d";
      var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
      var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
      var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
      var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
        rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
        rsUpper + "+" + rsOptUpperContr,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "ss"
      };
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 ? array2.length : 0;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var Symbol2 = root.Symbol;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
      function baseSlice(array2, start, end) {
        var index = -1, length = array2.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array2[index + start];
        }
        return result;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castSlice(array2, start, end) {
        var length = array2.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array2 : baseSlice(array2, start, end);
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString3(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function isObjectLike2(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
      }
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      var camelCase3 = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      function capitalize(string2) {
        return upperFirst3(toString3(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString3(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      var upperFirst3 = createCaseFirst("toUpperCase");
      function words(string2, pattern, guard) {
        string2 = toString3(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      module.exports = camelCase3;
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/parser.js
  var require_parser2 = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/parser.js"(exports, module) {
      module.exports = function() {
        function peg$subclass(child, parent) {
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
        }
        function SyntaxError2(message, expected, found, offset, line, column) {
          this.message = message;
          this.expected = expected;
          this.found = found;
          this.offset = offset;
          this.line = line;
          this.column = column;
          this.name = "SyntaxError";
        }
        peg$subclass(SyntaxError2, Error);
        function parse3(input) {
          var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
            return nodes;
          }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
            addNode(node("ObjectPath", name, line, column));
          }, peg$c12 = function(name) {
            addNode(node("ArrayPath", name, line, column));
          }, peg$c13 = function(parts, name) {
            return parts.concat(name);
          }, peg$c14 = function(name) {
            return [name];
          }, peg$c15 = function(name) {
            return name;
          }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
            addNode(node("Assign", value, line, column, key));
          }, peg$c21 = function(chars) {
            return chars.join("");
          }, peg$c22 = function(node2) {
            return node2.value;
          }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
            return node("String", chars.join(""), line, column);
          }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
            return char;
          }, peg$c34 = function(char) {
            return char;
          }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
            return "";
          }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left, right) {
            return node("Float", parseFloat(left + "e" + right), line, column);
          }, peg$c43 = function(text2) {
            return node("Float", parseFloat(text2), line, column);
          }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
            return digits.join("");
          }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
            return "-" + digits.join("");
          }, peg$c50 = function(text2) {
            return node("Integer", parseInt(text2, 10), line, column);
          }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
            return node("Boolean", true, line, column);
          }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
            return node("Boolean", false, line, column);
          }, peg$c57 = function() {
            return node("Array", [], line, column);
          }, peg$c58 = function(value) {
            return node("Array", value ? [value] : [], line, column);
          }, peg$c59 = function(values) {
            return node("Array", values, line, column);
          }, peg$c60 = function(values, value) {
            return node("Array", values.concat(value), line, column);
          }, peg$c61 = function(value) {
            return value;
          }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values) {
            return node("InlineTable", values, line, column);
          }, peg$c69 = function(key, value) {
            return node("InlineTableValue", value, line, column, key);
          }, peg$c70 = function(digits) {
            return "." + digits;
          }, peg$c71 = function(date2) {
            return date2.join("");
          }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time) {
            return time.join("");
          }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date2, time) {
            return node("Date", /* @__PURE__ */ new Date(date2 + "T" + time + "Z"), line, column);
          }, peg$c80 = function(date2, time) {
            return node("Date", /* @__PURE__ */ new Date(date2 + "T" + time), line, column);
          }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
            return "";
          }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
            return d.join("");
          }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
            return '"';
          }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
            return "\\";
          }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
            return "\b";
          }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
            return "	";
          }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
            return "\n";
          }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
            return "\f";
          }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
            return "\r";
          }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
            return convertCodePoint(digits.join(""));
          }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function text() {
            return input.substring(peg$reportedPos, peg$currPos);
          }
          function offset() {
            return peg$reportedPos;
          }
          function line() {
            return peg$computePosDetails(peg$reportedPos).line;
          }
          function column() {
            return peg$computePosDetails(peg$reportedPos).column;
          }
          function expected(description) {
            throw peg$buildException(
              null,
              [{ type: "other", description }],
              peg$reportedPos
            );
          }
          function error2(message) {
            throw peg$buildException(message, null, peg$reportedPos);
          }
          function peg$computePosDetails(pos) {
            function advance(details, startPos, endPos) {
              var p, ch;
              for (p = startPos; p < endPos; p++) {
                ch = input.charAt(p);
                if (ch === "\n") {
                  if (!details.seenCR) {
                    details.line++;
                  }
                  details.column = 1;
                  details.seenCR = false;
                } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                  details.line++;
                  details.column = 1;
                  details.seenCR = true;
                } else {
                  details.column++;
                  details.seenCR = false;
                }
              }
            }
            if (peg$cachedPos !== pos) {
              if (peg$cachedPos > pos) {
                peg$cachedPos = 0;
                peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
              }
              advance(peg$cachedPosDetails, peg$cachedPos, pos);
              peg$cachedPos = pos;
            }
            return peg$cachedPosDetails;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildException(message, expected2, pos) {
            function cleanupExpected(expected3) {
              var i = 1;
              expected3.sort(function(a, b) {
                if (a.description < b.description) {
                  return -1;
                } else if (a.description > b.description) {
                  return 1;
                } else {
                  return 0;
                }
              });
              while (i < expected3.length) {
                if (expected3[i - 1] === expected3[i]) {
                  expected3.splice(i, 1);
                } else {
                  i++;
                }
              }
            }
            function buildMessage(expected3, found2) {
              function stringEscape(s) {
                function hex(ch) {
                  return ch.charCodeAt(0).toString(16).toUpperCase();
                }
                return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                  return "\\x0" + hex(ch);
                }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                  return "\\x" + hex(ch);
                }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                  return "\\u0" + hex(ch);
                }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                  return "\\u" + hex(ch);
                });
              }
              var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
              for (i = 0; i < expected3.length; i++) {
                expectedDescs[i] = expected3[i].description;
              }
              expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
              foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
              return "Expected " + expectedDesc + " but " + foundDesc + " found.";
            }
            var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
            if (expected2 !== null) {
              cleanupExpected(expected2);
            }
            return new SyntaxError2(
              message !== null ? message : buildMessage(expected2, found),
              expected2,
              found,
              pos,
              posDetails.line,
              posDetails.column
            );
          }
          function peg$parsestart() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 0, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseline();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseline();
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c1();
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseline() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 1, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseexpression();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parsecomment();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parsecomment();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseNL();
                    if (s6 !== peg$FAILED) {
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseNL();
                      }
                    } else {
                      s5 = peg$c2;
                    }
                    if (s5 === peg$FAILED) {
                      s5 = peg$parseEOF();
                    }
                    if (s5 !== peg$FAILED) {
                      s1 = [s1, s2, s3, s4, s5];
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parseS();
                }
              } else {
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseNL();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parseNL();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 === peg$FAILED) {
                  s2 = peg$parseEOF();
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseNL();
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseexpression() {
            var s0;
            var key = peg$currPos * 49 + 2, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsecomment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsepath();
              if (s0 === peg$FAILED) {
                s0 = peg$parsetablearray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseassignment();
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsecomment() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 3, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s1 = peg$c3;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseNL();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = peg$c5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseNL();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseEOF();
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = peg$c5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c2;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c6);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c2;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsepath() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 4, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetable_key();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s5 = peg$c9;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c11(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetablearray() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            var key = peg$currPos * 49 + 5, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s2 = peg$c7;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsetable_key();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s6 = peg$c9;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s7 = peg$c9;
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                          }
                        }
                        if (s7 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c12(s4);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetable_key() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 6, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsedot_ended_table_key_part();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsedot_ended_table_key_part();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsetable_key_part();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c13(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsetable_key_part();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c14(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetable_key_part() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 7, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsequoted_key();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedot_ended_table_key_part() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 8, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsequoted_key();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s4 = peg$c16;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c17);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseS();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseS();
                      }
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c15(s2);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseassignment() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 9, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsekey();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c18;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsevalue();
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c20(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsequoted_key();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseS();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseS();
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s3 = peg$c18;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parseS();
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parseS();
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsevalue();
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c20(s1, s5);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsekey() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 10, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseASCII_BASIC();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseASCII_BASIC();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c21(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsequoted_key() {
            var s0, s1;
            var key = peg$currPos * 49 + 11, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsedouble_quoted_single_line_string();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c22(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsesingle_quoted_single_line_string();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c22(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsevalue() {
            var s0;
            var key = peg$currPos * 49 + 12, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsestring();
            if (s0 === peg$FAILED) {
              s0 = peg$parsedatetime();
              if (s0 === peg$FAILED) {
                s0 = peg$parsefloat();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseinteger();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseboolean();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsearray();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseinline_table();
                      }
                    }
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsestring() {
            var s0;
            var key = peg$currPos * 49 + 13, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsedouble_quoted_multiline_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsedouble_quoted_single_line_string();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesingle_quoted_multiline_string();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsesingle_quoted_single_line_string();
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedouble_quoted_multiline_string() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 14, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c23) {
              s1 = peg$c23;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsemultiline_string_char();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsemultiline_string_char();
                }
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c23) {
                    s4 = peg$c23;
                    peg$currPos += 3;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c24);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c26(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedouble_quoted_single_line_string() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 15, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
              s1 = peg$c27;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsestring_char();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsestring_char();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s3 = peg$c27;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c28);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesingle_quoted_multiline_string() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 16, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c29) {
              s1 = peg$c29;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsemultiline_literal_char();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsemultiline_literal_char();
                }
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c29) {
                    s4 = peg$c29;
                    peg$currPos += 3;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c30);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c26(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesingle_quoted_single_line_string() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 17, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c31;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseliteral_char();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseliteral_char();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c31;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c32);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsestring_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 18, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseESCAPED();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 34) {
                s2 = peg$c27;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = peg$c5;
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c33(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseliteral_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 19, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c31;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_string_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 20, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseESCAPED();
            if (s0 === peg$FAILED) {
              s0 = peg$parsemultiline_string_delim();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 3) === peg$c23) {
                  s2 = peg$c23;
                  peg$currPos += 3;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                peg$silentFails--;
                if (s2 === peg$FAILED) {
                  s1 = peg$c5;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
                if (s1 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c6);
                    }
                  }
                  if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c34(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_string_delim() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 21, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s1 = peg$c35;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c36);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseNLS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseNLS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c37();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_literal_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 22, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 3) === peg$c29) {
              s2 = peg$c29;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsefloat() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 23, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsefloat_text();
            if (s1 === peg$FAILED) {
              s1 = peg$parseinteger_text();
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 101) {
                s2 = peg$c38;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c39);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 69) {
                  s2 = peg$c40;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c41);
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseinteger_text();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c42(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsefloat_text();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c43(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsefloat_text() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 24, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c44;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s1 === peg$FAILED) {
              s1 = peg$c25;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseDIGITS();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGITS();
                  if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c47;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseDIGITS();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseDIGITS();
                    if (s5 !== peg$FAILED) {
                      s3 = [s3, s4, s5];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c49(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinteger() {
            var s0, s1;
            var key = peg$currPos * 49 + 25, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parseinteger_text();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c50(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinteger_text() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 26, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c44;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s1 === peg$FAILED) {
              s1 = peg$c25;
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseDIGIT_OR_UNDER();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                  s3 = peg$c5;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c46(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c47;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseDIGIT_OR_UNDER();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parseDIGIT_OR_UNDER();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$currPos;
                  peg$silentFails++;
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  peg$silentFails--;
                  if (s4 === peg$FAILED) {
                    s3 = peg$c5;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c2;
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c49(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseboolean() {
            var s0, s1;
            var key = peg$currPos * 49 + 27, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c53();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 5) === peg$c54) {
                s1 = peg$c54;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c55);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c56();
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 28, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearray_sep();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsearray_sep();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c57();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsearray_value();
                if (s2 === peg$FAILED) {
                  s2 = peg$c25;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c9;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c58(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                  s1 = peg$c7;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c8);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parsearray_value_list();
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$parsearray_value_list();
                    }
                  } else {
                    s2 = peg$c2;
                  }
                  if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s3 = peg$c9;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c59(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 91) {
                    s1 = peg$c7;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c8);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parsearray_value_list();
                    if (s3 !== peg$FAILED) {
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$parsearray_value_list();
                      }
                    } else {
                      s2 = peg$c2;
                    }
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parsearray_value();
                      if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s4 = peg$c9;
                          peg$currPos++;
                        } else {
                          s4 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                          }
                        }
                        if (s4 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c60(s2, s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_value() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 29, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsearray_sep();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsearray_sep();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsevalue();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsearray_sep();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsearray_sep();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_value_list() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 30, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsearray_sep();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsearray_sep();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsevalue();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsearray_sep();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsearray_sep();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s4 = peg$c62;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c63);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parsearray_sep();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parsearray_sep();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c61(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_sep() {
            var s0;
            var key = peg$currPos * 49 + 31, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseS();
            if (s0 === peg$FAILED) {
              s0 = peg$parseNL();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecomment();
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinline_table() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 32, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 123) {
              s1 = peg$c64;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c65);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseinline_table_assignment();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseinline_table_assignment();
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s5 = peg$c66;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c67);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c68(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinline_table_assignment() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 33, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s4 = peg$c18;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsevalue();
                      if (s6 !== peg$FAILED) {
                        s7 = [];
                        s8 = peg$parseS();
                        while (s8 !== peg$FAILED) {
                          s7.push(s8);
                          s8 = peg$parseS();
                        }
                        if (s7 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s8 = peg$c62;
                            peg$currPos++;
                          } else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c63);
                            }
                          }
                          if (s8 !== peg$FAILED) {
                            s9 = [];
                            s10 = peg$parseS();
                            while (s10 !== peg$FAILED) {
                              s9.push(s10);
                              s10 = peg$parseS();
                            }
                            if (s9 !== peg$FAILED) {
                              peg$reportedPos = s0;
                              s1 = peg$c69(s2, s6);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c2;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsekey();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 61) {
                      s4 = peg$c18;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c19);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseS();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseS();
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsevalue();
                        if (s6 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c69(s2, s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesecfragment() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 34, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s1 = peg$c16;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseDIGITS();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c70(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedate() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
            var key = peg$currPos * 49 + 35, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseDIGIT_OR_UNDER();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 45) {
                      s6 = peg$c47;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c48);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseDIGIT_OR_UNDER();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 45) {
                            s9 = peg$c47;
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c48);
                            }
                          }
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseDIGIT_OR_UNDER();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parseDIGIT_OR_UNDER();
                              if (s11 !== peg$FAILED) {
                                s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                                s1 = s2;
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c71(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetime() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 36, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c72;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c73);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseDIGIT_OR_UNDER();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s7 = peg$c72;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c73);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseDIGIT_OR_UNDER();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parsesecfragment();
                            if (s10 === peg$FAILED) {
                              s10 = peg$c25;
                            }
                            if (s10 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c74(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetime_with_offset() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
            var key = peg$currPos * 49 + 37, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c72;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c73);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseDIGIT_OR_UNDER();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s7 = peg$c72;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c73);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseDIGIT_OR_UNDER();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parsesecfragment();
                            if (s10 === peg$FAILED) {
                              s10 = peg$c25;
                            }
                            if (s10 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 45) {
                                s11 = peg$c47;
                                peg$currPos++;
                              } else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c48);
                                }
                              }
                              if (s11 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 43) {
                                  s11 = peg$c44;
                                  peg$currPos++;
                                } else {
                                  s11 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c45);
                                  }
                                }
                              }
                              if (s11 !== peg$FAILED) {
                                s12 = peg$parseDIGIT_OR_UNDER();
                                if (s12 !== peg$FAILED) {
                                  s13 = peg$parseDIGIT_OR_UNDER();
                                  if (s13 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 58) {
                                      s14 = peg$c72;
                                      peg$currPos++;
                                    } else {
                                      s14 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c73);
                                      }
                                    }
                                    if (s14 !== peg$FAILED) {
                                      s15 = peg$parseDIGIT_OR_UNDER();
                                      if (s15 !== peg$FAILED) {
                                        s16 = peg$parseDIGIT_OR_UNDER();
                                        if (s16 !== peg$FAILED) {
                                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                          s1 = s2;
                                        } else {
                                          peg$currPos = s1;
                                          s1 = peg$c2;
                                        }
                                      } else {
                                        peg$currPos = s1;
                                        s1 = peg$c2;
                                      }
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c74(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedatetime() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 38, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsedate();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 84) {
                s2 = peg$c75;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c76);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetime();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 90) {
                    s4 = peg$c77;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c78);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c79(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsedate();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 84) {
                  s2 = peg$c75;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c76);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsetime_with_offset();
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c80(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseS() {
            var s0;
            var key = peg$currPos * 49 + 39, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c81.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c82);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseNL() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 40, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (input.charCodeAt(peg$currPos) === 10) {
              s0 = peg$c83;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 13) {
                s1 = peg$c85;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c86);
                }
              }
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 10) {
                  s2 = peg$c83;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c84);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseNLS() {
            var s0;
            var key = peg$currPos * 49 + 41, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseNL();
            if (s0 === peg$FAILED) {
              s0 = peg$parseS();
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseEOF() {
            var s0, s1;
            var key = peg$currPos * 49 + 42, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = peg$c5;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseHEX() {
            var s0;
            var key = peg$currPos * 49 + 43, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c87.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c88);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseDIGIT_OR_UNDER() {
            var s0, s1;
            var key = peg$currPos * 49 + 44, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c89.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 95) {
                s1 = peg$c91;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c92);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c93();
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseASCII_BASIC() {
            var s0;
            var key = peg$currPos * 49 + 45, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c94.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c95);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseDIGITS() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 46, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c96(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseESCAPED() {
            var s0, s1;
            var key = peg$currPos * 49 + 47, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c97) {
              s1 = peg$c97;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c98);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c99();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c100) {
                s1 = peg$c100;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c101);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c102();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c103) {
                  s1 = peg$c103;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c104);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c105();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c106) {
                    s1 = peg$c106;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c107);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c108();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c109) {
                      s1 = peg$c109;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c110);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c111();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c112) {
                        s1 = peg$c112;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c113);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c114();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c115) {
                          s1 = peg$c115;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c116);
                          }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c117();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseESCAPED_UNICODE();
                        }
                      }
                    }
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseESCAPED_UNICODE() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 48, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c118) {
              s1 = peg$c118;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c119);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseHEX();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHEX();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseHEX();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseHEX();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseHEX();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseHEX();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseHEX();
                            if (s10 !== peg$FAILED) {
                              s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                              s2 = s3;
                            } else {
                              peg$currPos = s2;
                              s2 = peg$c2;
                            }
                          } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c120(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c121) {
                s1 = peg$c121;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c122);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseHEX();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseHEX();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseHEX();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseHEX();
                      if (s6 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c120(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          var nodes = [];
          function genError(err, line2, col) {
            var ex = new Error(err);
            ex.line = line2;
            ex.column = col;
            throw ex;
          }
          function addNode(node2) {
            nodes.push(node2);
          }
          function node(type3, value, line2, column2, key) {
            var obj = { type: type3, value, line: line2(), column: column2() };
            if (key)
              obj.key = key;
            return obj;
          }
          function convertCodePoint(str, line2, col) {
            var num = parseInt("0x" + str);
            if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
              genError("Invalid Unicode escape code: " + str, line2, col);
            } else {
              return fromCodePoint(num);
            }
          }
          function fromCodePoint() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                result += String.fromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail({ type: "end", description: "end of input" });
            }
            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
          }
        }
        return {
          SyntaxError: SyntaxError2,
          parse: parse3
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js
  var require_compiler2 = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js"(exports, module) {
      "use strict";
      function compile6(nodes) {
        var assignedPaths = [];
        var valueAssignments = [];
        var currentPath = "";
        var data = /* @__PURE__ */ Object.create(null);
        var context2 = data;
        var arrayMode = false;
        return reduce(nodes);
        function reduce(nodes2) {
          var node;
          for (var i = 0; i < nodes2.length; i++) {
            node = nodes2[i];
            switch (node.type) {
              case "Assign":
                assign(node);
                break;
              case "ObjectPath":
                setPath(node);
                break;
              case "ArrayPath":
                addTableArray(node);
                break;
            }
          }
          return data;
        }
        function genError(err, line, col) {
          var ex = new Error(err);
          ex.line = line;
          ex.column = col;
          throw ex;
        }
        function assign(node) {
          var key = node.key;
          var value = node.value;
          var line = node.line;
          var column = node.column;
          var fullPath;
          if (currentPath) {
            fullPath = currentPath + "." + key;
          } else {
            fullPath = key;
          }
          if (typeof context2[key] !== "undefined") {
            genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
          }
          context2[key] = reduceValueNode(value);
          if (!pathAssigned(fullPath)) {
            assignedPaths.push(fullPath);
            valueAssignments.push(fullPath);
          }
        }
        function pathAssigned(path5) {
          return assignedPaths.indexOf(path5) !== -1;
        }
        function reduceValueNode(node) {
          if (node.type === "Array") {
            return reduceArrayWithTypeChecking(node.value);
          } else if (node.type === "InlineTable") {
            return reduceInlineTableNode(node.value);
          } else {
            return node.value;
          }
        }
        function reduceInlineTableNode(values) {
          var obj = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < values.length; i++) {
            var val = values[i];
            if (val.value.type === "InlineTable") {
              obj[val.key] = reduceInlineTableNode(val.value.value);
            } else if (val.type === "InlineTableValue") {
              obj[val.key] = reduceValueNode(val.value);
            }
          }
          return obj;
        }
        function setPath(node) {
          var path5 = node.value;
          var quotedPath = path5.map(quoteDottedString).join(".");
          var line = node.line;
          var column = node.column;
          if (pathAssigned(quotedPath)) {
            genError("Cannot redefine existing key '" + path5 + "'.", line, column);
          }
          assignedPaths.push(quotedPath);
          context2 = deepRef(data, path5, /* @__PURE__ */ Object.create(null), line, column);
          currentPath = path5;
        }
        function addTableArray(node) {
          var path5 = node.value;
          var quotedPath = path5.map(quoteDottedString).join(".");
          var line = node.line;
          var column = node.column;
          if (!pathAssigned(quotedPath)) {
            assignedPaths.push(quotedPath);
          }
          assignedPaths = assignedPaths.filter(function(p) {
            return p.indexOf(quotedPath) !== 0;
          });
          assignedPaths.push(quotedPath);
          context2 = deepRef(data, path5, [], line, column);
          currentPath = quotedPath;
          if (context2 instanceof Array) {
            var newObj = /* @__PURE__ */ Object.create(null);
            context2.push(newObj);
            context2 = newObj;
          } else {
            genError("Cannot redefine existing key '" + path5 + "'.", line, column);
          }
        }
        function deepRef(start, keys4, value, line, column) {
          var traversed = [];
          var traversedPath = "";
          var path5 = keys4.join(".");
          var ctx = start;
          for (var i = 0; i < keys4.length; i++) {
            var key = keys4[i];
            traversed.push(key);
            traversedPath = traversed.join(".");
            if (typeof ctx[key] === "undefined") {
              if (i === keys4.length - 1) {
                ctx[key] = value;
              } else {
                ctx[key] = /* @__PURE__ */ Object.create(null);
              }
            } else if (i !== keys4.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
              genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
            }
            ctx = ctx[key];
            if (ctx instanceof Array && ctx.length && i < keys4.length - 1) {
              ctx = ctx[ctx.length - 1];
            }
          }
          return ctx;
        }
        function reduceArrayWithTypeChecking(array2) {
          var firstType = null;
          for (var i = 0; i < array2.length; i++) {
            var node = array2[i];
            if (firstType === null) {
              firstType = node.type;
            } else {
              if (node.type !== firstType) {
                genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
              }
            }
          }
          return array2.map(reduceValueNode);
        }
        function quoteDottedString(str) {
          if (str.indexOf(".") > -1) {
            return '"' + str + '"';
          } else {
            return str;
          }
        }
      }
      module.exports = {
        compile: compile6
      };
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/index.js
  var require_toml = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/index.js"(exports, module) {
      var parser = require_parser2();
      var compiler = require_compiler2();
      module.exports = {
        parse: function(input) {
          var nodes = parser.parse(input.toString());
          return compiler.compile(nodes);
        }
      };
    }
  });

  // ../../node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js
  var require_dist = __commonJS({
    "../../node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bech32m = exports.bech32 = void 0;
      var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      var ALPHABET_MAP = {};
      for (let z = 0; z < ALPHABET.length; z++) {
        const x = ALPHABET.charAt(z);
        ALPHABET_MAP[x] = z;
      }
      function polymodStep(pre) {
        const b = pre >> 25;
        return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
      }
      function prefixChk(prefix) {
        let chk = 1;
        for (let i = 0; i < prefix.length; ++i) {
          const c = prefix.charCodeAt(i);
          if (c < 33 || c > 126)
            return "Invalid prefix (" + prefix + ")";
          chk = polymodStep(chk) ^ c >> 5;
        }
        chk = polymodStep(chk);
        for (let i = 0; i < prefix.length; ++i) {
          const v = prefix.charCodeAt(i);
          chk = polymodStep(chk) ^ v & 31;
        }
        return chk;
      }
      function convert2(data, inBits, outBits, pad3) {
        let value = 0;
        let bits = 0;
        const maxV = (1 << outBits) - 1;
        const result = [];
        for (let i = 0; i < data.length; ++i) {
          value = value << inBits | data[i];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push(value >> bits & maxV);
          }
        }
        if (pad3) {
          if (bits > 0) {
            result.push(value << outBits - bits & maxV);
          }
        } else {
          if (bits >= inBits)
            return "Excess padding";
          if (value << outBits - bits & maxV)
            return "Non-zero padding";
        }
        return result;
      }
      function toWords(bytes3) {
        return convert2(bytes3, 8, 5, true);
      }
      function fromWordsUnsafe(words) {
        const res = convert2(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
      }
      function fromWords(words) {
        const res = convert2(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      function getLibraryFromEncoding(encoding) {
        let ENCODING_CONST;
        if (encoding === "bech32") {
          ENCODING_CONST = 1;
        } else {
          ENCODING_CONST = 734539939;
        }
        function encode(prefix, words, LIMIT) {
          LIMIT = LIMIT || 90;
          if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError("Exceeds length limit");
          prefix = prefix.toLowerCase();
          let chk = prefixChk(prefix);
          if (typeof chk === "string")
            throw new Error(chk);
          let result = prefix + "1";
          for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
              throw new Error("Non 5-bit word");
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
          }
          for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
          }
          chk ^= ENCODING_CONST;
          for (let i = 0; i < 6; ++i) {
            const v = chk >> (5 - i) * 5 & 31;
            result += ALPHABET.charAt(v);
          }
          return result;
        }
        function __decode(str, LIMIT) {
          LIMIT = LIMIT || 90;
          if (str.length < 8)
            return str + " too short";
          if (str.length > LIMIT)
            return "Exceeds length limit";
          const lowered = str.toLowerCase();
          const uppered = str.toUpperCase();
          if (str !== lowered && str !== uppered)
            return "Mixed-case string " + str;
          str = lowered;
          const split4 = str.lastIndexOf("1");
          if (split4 === -1)
            return "No separator character for " + str;
          if (split4 === 0)
            return "Missing prefix for " + str;
          const prefix = str.slice(0, split4);
          const wordChars = str.slice(split4 + 1);
          if (wordChars.length < 6)
            return "Data too short";
          let chk = prefixChk(prefix);
          if (typeof chk === "string")
            return chk;
          const words = [];
          for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === void 0)
              return "Unknown character " + c;
            chk = polymodStep(chk) ^ v;
            if (i + 6 >= wordChars.length)
              continue;
            words.push(v);
          }
          if (chk !== ENCODING_CONST)
            return "Invalid checksum for " + str;
          return { prefix, words };
        }
        function decodeUnsafe(str, LIMIT) {
          const res = __decode(str, LIMIT);
          if (typeof res === "object")
            return res;
        }
        function decode(str, LIMIT) {
          const res = __decode(str, LIMIT);
          if (typeof res === "object")
            return res;
          throw new Error(res);
        }
        return {
          decodeUnsafe,
          decode,
          encode,
          toWords,
          fromWordsUnsafe,
          fromWords
        };
      }
      exports.bech32 = getLibraryFromEncoding("bech32");
      exports.bech32m = getLibraryFromEncoding("bech32m");
    }
  });

  // ../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert5(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number4, base, endian) {
          if (BN2.isBN(number4)) {
            return number4;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number4 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number4 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = __require2("buffer").Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max2(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init2(number4, base, endian) {
          if (typeof number4 === "number") {
            return this._initNumber(number4, base, endian);
          }
          if (typeof number4 === "object") {
            return this._initArray(number4, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert5(base === (base | 0) && base >= 2 && base <= 36);
          number4 = number4.toString().replace(/\s+/g, "");
          var start = 0;
          if (number4[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number4.length) {
            if (base === 16) {
              this._parseHex(number4, start, endian);
            } else {
              this._parseBase(number4, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number4, base, endian) {
          if (number4 < 0) {
            this.negative = 1;
            number4 = -number4;
          }
          if (number4 < 67108864) {
            this.words = [number4 & 67108863];
            this.length = 1;
          } else if (number4 < 4503599627370496) {
            this.words = [
              number4 & 67108863,
              number4 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert5(number4 < 9007199254740992);
            this.words = [
              number4 & 67108863,
              number4 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number4, base, endian) {
          assert5(typeof number4.length === "number");
          if (number4.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number4.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number4.length - 1, j = 0; i >= 0; i -= 3) {
              w = number4[i] | number4[i - 1] << 8 | number4[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number4.length; i += 3) {
              w = number4[i] | number4[i + 1] << 8 | number4[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string2, index) {
          var c = string2.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert5(false, "Invalid character in " + string2);
          }
        }
        function parseHexByte(string2, lowerBound, index) {
          var r = parseHex4Bits(string2, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string2, index - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number4, start, endian) {
          this.length = Math.ceil((number4.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number4.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number4, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number4.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number4.length; i += 2) {
              w = parseHexByte(number4, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert5(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number4, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number4.length - start;
          var mod2 = total % limbLen;
          var end = Math.min(total, total - mod2) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number4, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod2 !== 0) {
            var pow3 = 1;
            word = parseBase(number4, i, number4.length, base);
            for (i = 0; i < mod2; i++) {
              pow3 *= base;
            }
            this.imuln(pow3);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone5() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
          } catch (e) {
            BN2.prototype.inspect = inspect2;
          }
        } else {
          BN2.prototype.inspect = inspect2;
        }
        function inspect2() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString3(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert5(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber3() {
          var ret4 = this.words[0];
          if (this.length === 2) {
            ret4 += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret4 += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert5(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret4 : ret4;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN2.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray2(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType4, size) {
          if (ArrayType4.allocUnsafe) {
            return ArrayType4.allocUnsafe(size);
          }
          return new ArrayType4(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType4, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert5(byteLength <= reqLength, "byte array longer than desired length");
          assert5(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType4, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos2(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos2(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert5(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert5(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add2(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert5(carry === 0);
          assert5((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert5(typeof num === "number");
          assert5(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow3(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert5(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert5(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert5(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert5(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert5(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert5(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert5(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask2;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert5(typeof num === "number");
          assert5(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert5(typeof num === "number");
          assert5(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert5(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert5(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod2, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod2 = res.mod.neg();
              if (positive && mod2.negative !== 0) {
                mod2.iadd(num);
              }
            }
            return {
              div,
              mod: mod2
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod2 = res.mod.neg();
              if (positive && mod2.negative !== 0) {
                mod2.isub(num);
              }
            }
            return {
              div: res.div,
              mod: mod2
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod2(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod2.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert5(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert5(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert5(p.negative === 0);
          assert5(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert5(p.negative === 0);
          assert5(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert5(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert5(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt2(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red2(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert5(!this.red, "Already a number in reduction context");
          assert5(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert5(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert5(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert5(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert5(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert5(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert5(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert5(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert5(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert5(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert5(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert5(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert5(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert5(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert5(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert5(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split4(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split4(input, output3) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output3.words[i] = input.words[i];
          }
          output3.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output3.words[output3.length++] = prev & mask2;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert5(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert5(a.negative === 0, "red works only with positives");
          assert5(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert5((a.negative | b.negative) === 0, "red works only with positives");
          assert5(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add2(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert5(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow3 = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow3);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert5(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert5(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow3(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // ../../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js
  var require_lib3 = __commonJS({
    "../../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js"(exports, module) {
      "use strict";
      var conversions = {};
      module.exports = conversions;
      function sign(x) {
        return x < 0 ? -1 : 1;
      }
      function evenRound(x) {
        if (x % 1 === 0.5 && (x & 1) === 0) {
          return Math.floor(x);
        } else {
          return Math.round(x);
        }
      }
      function createNumberConversion(bitLength, typeOpts) {
        if (!typeOpts.unsigned) {
          --bitLength;
        }
        const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
        const upperBound = Math.pow(2, bitLength) - 1;
        const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
        const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
        return function(V, opts) {
          if (!opts)
            opts = {};
          let x = +V;
          if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
              throw new TypeError("Argument is not a finite number");
            }
            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
              throw new TypeError("Argument is not in byte range");
            }
            return x;
          }
          if (!isNaN(x) && opts.clamp) {
            x = evenRound(x);
            if (x < lowerBound)
              x = lowerBound;
            if (x > upperBound)
              x = upperBound;
            return x;
          }
          if (!Number.isFinite(x) || x === 0) {
            return 0;
          }
          x = sign(x) * Math.floor(Math.abs(x));
          x = x % moduloVal;
          if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
          } else if (typeOpts.unsigned) {
            if (x < 0) {
              x += moduloVal;
            } else if (x === -0) {
              return 0;
            }
          }
          return x;
        };
      }
      conversions["void"] = function() {
        return void 0;
      };
      conversions["boolean"] = function(val) {
        return !!val;
      };
      conversions["byte"] = createNumberConversion(8, { unsigned: false });
      conversions["octet"] = createNumberConversion(8, { unsigned: true });
      conversions["short"] = createNumberConversion(16, { unsigned: false });
      conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
      conversions["long"] = createNumberConversion(32, { unsigned: false });
      conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
      conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
      conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
      conversions["double"] = function(V) {
        const x = +V;
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite floating-point value");
        }
        return x;
      };
      conversions["unrestricted double"] = function(V) {
        const x = +V;
        if (isNaN(x)) {
          throw new TypeError("Argument is NaN");
        }
        return x;
      };
      conversions["float"] = conversions["double"];
      conversions["unrestricted float"] = conversions["unrestricted double"];
      conversions["DOMString"] = function(V, opts) {
        if (!opts)
          opts = {};
        if (opts.treatNullAsEmptyString && V === null) {
          return "";
        }
        return String(V);
      };
      conversions["ByteString"] = function(V, opts) {
        const x = String(V);
        let c = void 0;
        for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
          if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
          }
        }
        return x;
      };
      conversions["USVString"] = function(V) {
        const S = String(V);
        const n = S.length;
        const U = [];
        for (let i = 0; i < n; ++i) {
          const c = S.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            U.push(String.fromCodePoint(c));
          } else if (56320 <= c && c <= 57343) {
            U.push(String.fromCodePoint(65533));
          } else {
            if (i === n - 1) {
              U.push(String.fromCodePoint(65533));
            } else {
              const d = S.charCodeAt(i + 1);
              if (56320 <= d && d <= 57343) {
                const a = c & 1023;
                const b = d & 1023;
                U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                ++i;
              } else {
                U.push(String.fromCodePoint(65533));
              }
            }
          }
        }
        return U.join("");
      };
      conversions["Date"] = function(V, opts) {
        if (!(V instanceof Date)) {
          throw new TypeError("Argument is not a Date object");
        }
        if (isNaN(V)) {
          return void 0;
        }
        return V;
      };
      conversions["RegExp"] = function(V, opts) {
        if (!(V instanceof RegExp)) {
          V = new RegExp(V);
        }
        return V;
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js
  var require_utils3 = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js"(exports, module) {
      "use strict";
      module.exports.mixin = function mixin(target, source) {
        const keys4 = Object.getOwnPropertyNames(source);
        for (let i = 0; i < keys4.length; ++i) {
          Object.defineProperty(target, keys4[i], Object.getOwnPropertyDescriptor(source, keys4[i]));
        }
      };
      module.exports.wrapperSymbol = Symbol("wrapper");
      module.exports.implSymbol = Symbol("impl");
      module.exports.wrapperForImpl = function(impl) {
        return impl[module.exports.wrapperSymbol];
      };
      module.exports.implForWrapper = function(wrapper) {
        return wrapper[module.exports.implSymbol];
      };
    }
  });

  // ../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json
  var require_mappingTable = __commonJS({
    "../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json"(exports, module) {
      module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
    }
  });

  // ../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js
  var require_tr46 = __commonJS({
    "../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js"(exports, module) {
      "use strict";
      var punycode = __require2("punycode");
      var mappingTable = require_mappingTable();
      var PROCESSING_OPTIONS = {
        TRANSITIONAL: 0,
        NONTRANSITIONAL: 1
      };
      function normalize5(str) {
        return str.split("\0").map(function(s) {
          return s.normalize("NFC");
        }).join("\0");
      }
      function findStatus(val) {
        var start = 0;
        var end = mappingTable.length - 1;
        while (start <= end) {
          var mid = Math.floor((start + end) / 2);
          var target = mappingTable[mid];
          if (target[0][0] <= val && target[0][1] >= val) {
            return target;
          } else if (target[0][0] > val) {
            end = mid - 1;
          } else {
            start = mid + 1;
          }
        }
        return null;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      function countSymbols(string2) {
        return string2.replace(regexAstralSymbols, "_").length;
      }
      function mapChars(domain_name, useSTD3, processing_option) {
        var hasError = false;
        var processed = "";
        var len = countSymbols(domain_name);
        for (var i = 0; i < len; ++i) {
          var codePoint = domain_name.codePointAt(i);
          var status = findStatus(codePoint);
          switch (status[1]) {
            case "disallowed":
              hasError = true;
              processed += String.fromCodePoint(codePoint);
              break;
            case "ignored":
              break;
            case "mapped":
              processed += String.fromCodePoint.apply(String, status[2]);
              break;
            case "deviation":
              if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
                processed += String.fromCodePoint.apply(String, status[2]);
              } else {
                processed += String.fromCodePoint(codePoint);
              }
              break;
            case "valid":
              processed += String.fromCodePoint(codePoint);
              break;
            case "disallowed_STD3_mapped":
              if (useSTD3) {
                hasError = true;
                processed += String.fromCodePoint(codePoint);
              } else {
                processed += String.fromCodePoint.apply(String, status[2]);
              }
              break;
            case "disallowed_STD3_valid":
              if (useSTD3) {
                hasError = true;
              }
              processed += String.fromCodePoint(codePoint);
              break;
          }
        }
        return {
          string: processed,
          error: hasError
        };
      }
      var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
      function validateLabel(label, processing_option) {
        if (label.substr(0, 4) === "xn--") {
          label = punycode.toUnicode(label);
          processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
        }
        var error2 = false;
        if (normalize5(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
          error2 = true;
        }
        var len = countSymbols(label);
        for (var i = 0; i < len; ++i) {
          var status = findStatus(label.codePointAt(i));
          if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
            error2 = true;
            break;
          }
        }
        return {
          label,
          error: error2
        };
      }
      function processing(domain_name, useSTD3, processing_option) {
        var result = mapChars(domain_name, useSTD3, processing_option);
        result.string = normalize5(result.string);
        var labels = result.string.split(".");
        for (var i = 0; i < labels.length; ++i) {
          try {
            var validation = validateLabel(labels[i]);
            labels[i] = validation.label;
            result.error = result.error || validation.error;
          } catch (e) {
            result.error = true;
          }
        }
        return {
          string: labels.join("."),
          error: result.error
        };
      }
      module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
        var result = processing(domain_name, useSTD3, processing_option);
        var labels = result.string.split(".");
        labels = labels.map(function(l) {
          try {
            return punycode.toASCII(l);
          } catch (e) {
            result.error = true;
            return l;
          }
        });
        if (verifyDnsLength) {
          var total = labels.slice(0, labels.length - 1).join(".").length;
          if (total.length > 253 || total.length === 0) {
            result.error = true;
          }
          for (var i = 0; i < labels.length; ++i) {
            if (labels.length > 63 || labels.length === 0) {
              result.error = true;
              break;
            }
          }
        }
        if (result.error)
          return null;
        return labels.join(".");
      };
      module.exports.toUnicode = function(domain_name, useSTD3) {
        var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
        return {
          domain: result.string,
          error: result.error
        };
      };
      module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js
  var require_url_state_machine = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
      "use strict";
      var punycode = __require2("punycode");
      var tr46 = require_tr46();
      var specialSchemes = {
        ftp: 21,
        file: null,
        gopher: 70,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var failure = Symbol("failure");
      function countSymbols(str) {
        return punycode.ucs2.decode(str).length;
      }
      function at(input, idx) {
        const c = input[idx];
        return isNaN(c) ? void 0 : String.fromCodePoint(c);
      }
      function isASCIIDigit(c) {
        return c >= 48 && c <= 57;
      }
      function isASCIIAlpha(c) {
        return c >= 65 && c <= 90 || c >= 97 && c <= 122;
      }
      function isASCIIAlphanumeric(c) {
        return isASCIIAlpha(c) || isASCIIDigit(c);
      }
      function isASCIIHex(c) {
        return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
      }
      function isSingleDot(buffer) {
        return buffer === "." || buffer.toLowerCase() === "%2e";
      }
      function isDoubleDot(buffer) {
        buffer = buffer.toLowerCase();
        return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
      }
      function isWindowsDriveLetterCodePoints(cp1, cp2) {
        return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
      }
      function isWindowsDriveLetterString(string2) {
        return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && (string2[1] === ":" || string2[1] === "|");
      }
      function isNormalizedWindowsDriveLetterString(string2) {
        return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && string2[1] === ":";
      }
      function containsForbiddenHostCodePoint(string2) {
        return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
      }
      function containsForbiddenHostCodePointExcludingPercent(string2) {
        return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
      }
      function isSpecialScheme(scheme) {
        return specialSchemes[scheme] !== void 0;
      }
      function isSpecial(url) {
        return isSpecialScheme(url.scheme);
      }
      function defaultPort(scheme) {
        return specialSchemes[scheme];
      }
      function percentEncode(c) {
        let hex = c.toString(16).toUpperCase();
        if (hex.length === 1) {
          hex = "0" + hex;
        }
        return "%" + hex;
      }
      function utf8PercentEncode(c) {
        const buf = new Buffer(c);
        let str = "";
        for (let i = 0; i < buf.length; ++i) {
          str += percentEncode(buf[i]);
        }
        return str;
      }
      function utf8PercentDecode(str) {
        const input = new Buffer(str);
        const output3 = [];
        for (let i = 0; i < input.length; ++i) {
          if (input[i] !== 37) {
            output3.push(input[i]);
          } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
            output3.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
            i += 2;
          } else {
            output3.push(input[i]);
          }
        }
        return new Buffer(output3).toString();
      }
      function isC0ControlPercentEncode(c) {
        return c <= 31 || c > 126;
      }
      var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
      function isPathPercentEncode(c) {
        return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
      }
      var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
      function isUserinfoPercentEncode(c) {
        return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
      }
      function percentEncodeChar(c, encodeSetPredicate) {
        const cStr = String.fromCodePoint(c);
        if (encodeSetPredicate(c)) {
          return utf8PercentEncode(cStr);
        }
        return cStr;
      }
      function parseIPv4Number(input) {
        let R = 10;
        if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
          input = input.substring(2);
          R = 16;
        } else if (input.length >= 2 && input.charAt(0) === "0") {
          input = input.substring(1);
          R = 8;
        }
        if (input === "") {
          return 0;
        }
        const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
        if (regex.test(input)) {
          return failure;
        }
        return parseInt(input, R);
      }
      function parseIPv4(input) {
        const parts = input.split(".");
        if (parts[parts.length - 1] === "") {
          if (parts.length > 1) {
            parts.pop();
          }
        }
        if (parts.length > 4) {
          return input;
        }
        const numbers = [];
        for (const part of parts) {
          if (part === "") {
            return input;
          }
          const n = parseIPv4Number(part);
          if (n === failure) {
            return input;
          }
          numbers.push(n);
        }
        for (let i = 0; i < numbers.length - 1; ++i) {
          if (numbers[i] > 255) {
            return failure;
          }
        }
        if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
          return failure;
        }
        let ipv4 = numbers.pop();
        let counter = 0;
        for (const n of numbers) {
          ipv4 += n * Math.pow(256, 3 - counter);
          ++counter;
        }
        return ipv4;
      }
      function serializeIPv4(address) {
        let output3 = "";
        let n = address;
        for (let i = 1; i <= 4; ++i) {
          output3 = String(n % 256) + output3;
          if (i !== 4) {
            output3 = "." + output3;
          }
          n = Math.floor(n / 256);
        }
        return output3;
      }
      function parseIPv6(input) {
        const address = [0, 0, 0, 0, 0, 0, 0, 0];
        let pieceIndex = 0;
        let compress = null;
        let pointer = 0;
        input = punycode.ucs2.decode(input);
        if (input[pointer] === 58) {
          if (input[pointer + 1] !== 58) {
            return failure;
          }
          pointer += 2;
          ++pieceIndex;
          compress = pieceIndex;
        }
        while (pointer < input.length) {
          if (pieceIndex === 8) {
            return failure;
          }
          if (input[pointer] === 58) {
            if (compress !== null) {
              return failure;
            }
            ++pointer;
            ++pieceIndex;
            compress = pieceIndex;
            continue;
          }
          let value = 0;
          let length = 0;
          while (length < 4 && isASCIIHex(input[pointer])) {
            value = value * 16 + parseInt(at(input, pointer), 16);
            ++pointer;
            ++length;
          }
          if (input[pointer] === 46) {
            if (length === 0) {
              return failure;
            }
            pointer -= length;
            if (pieceIndex > 6) {
              return failure;
            }
            let numbersSeen = 0;
            while (input[pointer] !== void 0) {
              let ipv4Piece = null;
              if (numbersSeen > 0) {
                if (input[pointer] === 46 && numbersSeen < 4) {
                  ++pointer;
                } else {
                  return failure;
                }
              }
              if (!isASCIIDigit(input[pointer])) {
                return failure;
              }
              while (isASCIIDigit(input[pointer])) {
                const number4 = parseInt(at(input, pointer));
                if (ipv4Piece === null) {
                  ipv4Piece = number4;
                } else if (ipv4Piece === 0) {
                  return failure;
                } else {
                  ipv4Piece = ipv4Piece * 10 + number4;
                }
                if (ipv4Piece > 255) {
                  return failure;
                }
                ++pointer;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              ++numbersSeen;
              if (numbersSeen === 2 || numbersSeen === 4) {
                ++pieceIndex;
              }
            }
            if (numbersSeen !== 4) {
              return failure;
            }
            break;
          } else if (input[pointer] === 58) {
            ++pointer;
            if (input[pointer] === void 0) {
              return failure;
            }
          } else if (input[pointer] !== void 0) {
            return failure;
          }
          address[pieceIndex] = value;
          ++pieceIndex;
        }
        if (compress !== null) {
          let swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex !== 0 && swaps > 0) {
            const temp = address[compress + swaps - 1];
            address[compress + swaps - 1] = address[pieceIndex];
            address[pieceIndex] = temp;
            --pieceIndex;
            --swaps;
          }
        } else if (compress === null && pieceIndex !== 8) {
          return failure;
        }
        return address;
      }
      function serializeIPv6(address) {
        let output3 = "";
        const seqResult = findLongestZeroSequence(address);
        const compress = seqResult.idx;
        let ignore0 = false;
        for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
          if (ignore0 && address[pieceIndex] === 0) {
            continue;
          } else if (ignore0) {
            ignore0 = false;
          }
          if (compress === pieceIndex) {
            const separator = pieceIndex === 0 ? "::" : ":";
            output3 += separator;
            ignore0 = true;
            continue;
          }
          output3 += address[pieceIndex].toString(16);
          if (pieceIndex !== 7) {
            output3 += ":";
          }
        }
        return output3;
      }
      function parseHost(input, isSpecialArg) {
        if (input[0] === "[") {
          if (input[input.length - 1] !== "]") {
            return failure;
          }
          return parseIPv6(input.substring(1, input.length - 1));
        }
        if (!isSpecialArg) {
          return parseOpaqueHost(input);
        }
        const domain = utf8PercentDecode(input);
        const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
        if (asciiDomain === null) {
          return failure;
        }
        if (containsForbiddenHostCodePoint(asciiDomain)) {
          return failure;
        }
        const ipv4Host = parseIPv4(asciiDomain);
        if (typeof ipv4Host === "number" || ipv4Host === failure) {
          return ipv4Host;
        }
        return asciiDomain;
      }
      function parseOpaqueHost(input) {
        if (containsForbiddenHostCodePointExcludingPercent(input)) {
          return failure;
        }
        let output3 = "";
        const decoded = punycode.ucs2.decode(input);
        for (let i = 0; i < decoded.length; ++i) {
          output3 += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
        }
        return output3;
      }
      function findLongestZeroSequence(arr) {
        let maxIdx = null;
        let maxLen = 1;
        let currStart = null;
        let currLen = 0;
        for (let i = 0; i < arr.length; ++i) {
          if (arr[i] !== 0) {
            if (currLen > maxLen) {
              maxIdx = currStart;
              maxLen = currLen;
            }
            currStart = null;
            currLen = 0;
          } else {
            if (currStart === null) {
              currStart = i;
            }
            ++currLen;
          }
        }
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        return {
          idx: maxIdx,
          len: maxLen
        };
      }
      function serializeHost(host) {
        if (typeof host === "number") {
          return serializeIPv4(host);
        }
        if (host instanceof Array) {
          return "[" + serializeIPv6(host) + "]";
        }
        return host;
      }
      function trimControlChars(url) {
        return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
      }
      function trimTabAndNewline(url) {
        return url.replace(/\u0009|\u000A|\u000D/g, "");
      }
      function shortenPath(url) {
        const path5 = url.path;
        if (path5.length === 0) {
          return;
        }
        if (url.scheme === "file" && path5.length === 1 && isNormalizedWindowsDriveLetter(path5[0])) {
          return;
        }
        path5.pop();
      }
      function includesCredentials(url) {
        return url.username !== "" || url.password !== "";
      }
      function cannotHaveAUsernamePasswordPort(url) {
        return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
      }
      function isNormalizedWindowsDriveLetter(string2) {
        return /^[A-Za-z]:$/.test(string2);
      }
      function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
        this.pointer = 0;
        this.input = input;
        this.base = base || null;
        this.encodingOverride = encodingOverride || "utf-8";
        this.stateOverride = stateOverride;
        this.url = url;
        this.failure = false;
        this.parseError = false;
        if (!this.url) {
          this.url = {
            scheme: "",
            username: "",
            password: "",
            host: null,
            port: null,
            path: [],
            query: null,
            fragment: null,
            cannotBeABaseURL: false
          };
          const res2 = trimControlChars(this.input);
          if (res2 !== this.input) {
            this.parseError = true;
          }
          this.input = res2;
        }
        const res = trimTabAndNewline(this.input);
        if (res !== this.input) {
          this.parseError = true;
        }
        this.input = res;
        this.state = stateOverride || "scheme start";
        this.buffer = "";
        this.atFlag = false;
        this.arrFlag = false;
        this.passwordTokenSeenFlag = false;
        this.input = punycode.ucs2.decode(this.input);
        for (; this.pointer <= this.input.length; ++this.pointer) {
          const c = this.input[this.pointer];
          const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
          const ret4 = this["parse " + this.state](c, cStr);
          if (!ret4) {
            break;
          } else if (ret4 === failure) {
            this.failure = true;
            break;
          }
        }
      }
      URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
        if (isASCIIAlpha(c)) {
          this.buffer += cStr.toLowerCase();
          this.state = "scheme";
        } else if (!this.stateOverride) {
          this.state = "no scheme";
          --this.pointer;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
        if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
          this.buffer += cStr.toLowerCase();
        } else if (c === 58) {
          if (this.stateOverride) {
            if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
              return false;
            }
            if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
              return false;
            }
            if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
              return false;
            }
            if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
              return false;
            }
          }
          this.url.scheme = this.buffer;
          this.buffer = "";
          if (this.stateOverride) {
            return false;
          }
          if (this.url.scheme === "file") {
            if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
              this.parseError = true;
            }
            this.state = "file";
          } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
            this.state = "special relative or authority";
          } else if (isSpecial(this.url)) {
            this.state = "special authority slashes";
          } else if (this.input[this.pointer + 1] === 47) {
            this.state = "path or authority";
            ++this.pointer;
          } else {
            this.url.cannotBeABaseURL = true;
            this.url.path.push("");
            this.state = "cannot-be-a-base-URL path";
          }
        } else if (!this.stateOverride) {
          this.buffer = "";
          this.state = "no scheme";
          this.pointer = -1;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
        if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
          return failure;
        } else if (this.base.cannotBeABaseURL && c === 35) {
          this.url.scheme = this.base.scheme;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.url.cannotBeABaseURL = true;
          this.state = "fragment";
        } else if (this.base.scheme === "file") {
          this.state = "file";
          --this.pointer;
        } else {
          this.state = "relative";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
        if (c === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "relative";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
        if (c === 47) {
          this.state = "authority";
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
        this.url.scheme = this.base.scheme;
        if (isNaN(c)) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 47) {
          this.state = "relative slash";
        } else if (c === 63) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
          this.state = "relative slash";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice(0, this.base.path.length - 1);
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
        if (isSpecial(this.url) && (c === 47 || c === 92)) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "special authority ignore slashes";
        } else if (c === 47) {
          this.state = "authority";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
        if (c === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "special authority ignore slashes";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
        if (c !== 47 && c !== 92) {
          this.state = "authority";
          --this.pointer;
        } else {
          this.parseError = true;
        }
        return true;
      };
      URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
        if (c === 64) {
          this.parseError = true;
          if (this.atFlag) {
            this.buffer = "%40" + this.buffer;
          }
          this.atFlag = true;
          const len = countSymbols(this.buffer);
          for (let pointer = 0; pointer < len; ++pointer) {
            const codePoint = this.buffer.codePointAt(pointer);
            if (codePoint === 58 && !this.passwordTokenSeenFlag) {
              this.passwordTokenSeenFlag = true;
              continue;
            }
            const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
            if (this.passwordTokenSeenFlag) {
              this.url.password += encodedCodePoints;
            } else {
              this.url.username += encodedCodePoints;
            }
          }
          this.buffer = "";
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
          if (this.atFlag && this.buffer === "") {
            this.parseError = true;
            return failure;
          }
          this.pointer -= countSymbols(this.buffer) + 1;
          this.buffer = "";
          this.state = "host";
        } else {
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
        if (this.stateOverride && this.url.scheme === "file") {
          --this.pointer;
          this.state = "file host";
        } else if (c === 58 && !this.arrFlag) {
          if (this.buffer === "") {
            this.parseError = true;
            return failure;
          }
          const host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          this.url.host = host;
          this.buffer = "";
          this.state = "port";
          if (this.stateOverride === "hostname") {
            return false;
          }
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
          --this.pointer;
          if (isSpecial(this.url) && this.buffer === "") {
            this.parseError = true;
            return failure;
          } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
            this.parseError = true;
            return false;
          }
          const host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          this.url.host = host;
          this.buffer = "";
          this.state = "path start";
          if (this.stateOverride) {
            return false;
          }
        } else {
          if (c === 91) {
            this.arrFlag = true;
          } else if (c === 93) {
            this.arrFlag = false;
          }
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
        if (isASCIIDigit(c)) {
          this.buffer += cStr;
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
          if (this.buffer !== "") {
            const port = parseInt(this.buffer);
            if (port > Math.pow(2, 16) - 1) {
              this.parseError = true;
              return failure;
            }
            this.url.port = port === defaultPort(this.url.scheme) ? null : port;
            this.buffer = "";
          }
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
          --this.pointer;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
      URLStateMachine.prototype["parse file"] = function parseFile(c) {
        this.url.scheme = "file";
        if (c === 47 || c === 92) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "file slash";
        } else if (this.base !== null && this.base.scheme === "file") {
          if (isNaN(c)) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
          } else if (c === 63) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = "";
            this.state = "query";
          } else if (c === 35) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
            this.url.fragment = "";
            this.state = "fragment";
          } else {
            if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
            !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
              this.url.host = this.base.host;
              this.url.path = this.base.path.slice();
              shortenPath(this.url);
            } else {
              this.parseError = true;
            }
            this.state = "path";
            --this.pointer;
          }
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
        if (c === 47 || c === 92) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "file host";
        } else {
          if (this.base !== null && this.base.scheme === "file") {
            if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
              this.url.path.push(this.base.path[0]);
            } else {
              this.url.host = this.base.host;
            }
          }
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
        if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
          --this.pointer;
          if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
            this.parseError = true;
            this.state = "path";
          } else if (this.buffer === "") {
            this.url.host = "";
            if (this.stateOverride) {
              return false;
            }
            this.state = "path start";
          } else {
            let host = parseHost(this.buffer, isSpecial(this.url));
            if (host === failure) {
              return failure;
            }
            if (host === "localhost") {
              host = "";
            }
            this.url.host = host;
            if (this.stateOverride) {
              return false;
            }
            this.buffer = "";
            this.state = "path start";
          }
        } else {
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
        if (isSpecial(this.url)) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "path";
          if (c !== 47 && c !== 92) {
            --this.pointer;
          }
        } else if (!this.stateOverride && c === 63) {
          this.url.query = "";
          this.state = "query";
        } else if (!this.stateOverride && c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (c !== void 0) {
          this.state = "path";
          if (c !== 47) {
            --this.pointer;
          }
        }
        return true;
      };
      URLStateMachine.prototype["parse path"] = function parsePath3(c) {
        if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
          if (isSpecial(this.url) && c === 92) {
            this.parseError = true;
          }
          if (isDoubleDot(this.buffer)) {
            shortenPath(this.url);
            if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
              this.url.path.push("");
            }
          } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          } else if (!isSingleDot(this.buffer)) {
            if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
              if (this.url.host !== "" && this.url.host !== null) {
                this.parseError = true;
                this.url.host = "";
              }
              this.buffer = this.buffer[0] + ":";
            }
            this.url.path.push(this.buffer);
          }
          this.buffer = "";
          if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
            while (this.url.path.length > 1 && this.url.path[0] === "") {
              this.parseError = true;
              this.url.path.shift();
            }
          }
          if (c === 63) {
            this.url.query = "";
            this.state = "query";
          }
          if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
          }
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.buffer += percentEncodeChar(c, isPathPercentEncode);
        }
        return true;
      };
      URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (!isNaN(c) && c !== 37) {
            this.parseError = true;
          }
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          if (!isNaN(c)) {
            this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
          }
        }
        return true;
      };
      URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
        if (isNaN(c) || !this.stateOverride && c === 35) {
          if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
            this.encodingOverride = "utf-8";
          }
          const buffer = new Buffer(this.buffer);
          for (let i = 0; i < buffer.length; ++i) {
            if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
              this.url.query += percentEncode(buffer[i]);
            } else {
              this.url.query += String.fromCodePoint(buffer[i]);
            }
          }
          this.buffer = "";
          if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
          }
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
        if (isNaN(c)) {
        } else if (c === 0) {
          this.parseError = true;
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
        }
        return true;
      };
      function serializeURL(url, excludeFragment) {
        let output3 = url.scheme + ":";
        if (url.host !== null) {
          output3 += "//";
          if (url.username !== "" || url.password !== "") {
            output3 += url.username;
            if (url.password !== "") {
              output3 += ":" + url.password;
            }
            output3 += "@";
          }
          output3 += serializeHost(url.host);
          if (url.port !== null) {
            output3 += ":" + url.port;
          }
        } else if (url.host === null && url.scheme === "file") {
          output3 += "//";
        }
        if (url.cannotBeABaseURL) {
          output3 += url.path[0];
        } else {
          for (const string2 of url.path) {
            output3 += "/" + string2;
          }
        }
        if (url.query !== null) {
          output3 += "?" + url.query;
        }
        if (!excludeFragment && url.fragment !== null) {
          output3 += "#" + url.fragment;
        }
        return output3;
      }
      function serializeOrigin(tuple) {
        let result = tuple.scheme + "://";
        result += serializeHost(tuple.host);
        if (tuple.port !== null) {
          result += ":" + tuple.port;
        }
        return result;
      }
      module.exports.serializeURL = serializeURL;
      module.exports.serializeURLOrigin = function(url) {
        switch (url.scheme) {
          case "blob":
            try {
              return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
            } catch (e) {
              return "null";
            }
          case "ftp":
          case "gopher":
          case "http":
          case "https":
          case "ws":
          case "wss":
            return serializeOrigin({
              scheme: url.scheme,
              host: url.host,
              port: url.port
            });
          case "file":
            return "file://";
          default:
            return "null";
        }
      };
      module.exports.basicURLParse = function(input, options) {
        if (options === void 0) {
          options = {};
        }
        const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
        if (usm.failure) {
          return "failure";
        }
        return usm.url;
      };
      module.exports.setTheUsername = function(url, username) {
        url.username = "";
        const decoded = punycode.ucs2.decode(username);
        for (let i = 0; i < decoded.length; ++i) {
          url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        }
      };
      module.exports.setThePassword = function(url, password) {
        url.password = "";
        const decoded = punycode.ucs2.decode(password);
        for (let i = 0; i < decoded.length; ++i) {
          url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        }
      };
      module.exports.serializeHost = serializeHost;
      module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
      module.exports.serializeInteger = function(integer) {
        return String(integer);
      };
      module.exports.parseURL = function(input, options) {
        if (options === void 0) {
          options = {};
        }
        return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js
  var require_URL_impl = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
      "use strict";
      var usm = require_url_state_machine();
      exports.implementation = class URLImpl {
        constructor(constructorArgs) {
          const url = constructorArgs[0];
          const base = constructorArgs[1];
          let parsedBase = null;
          if (base !== void 0) {
            parsedBase = usm.basicURLParse(base);
            if (parsedBase === "failure") {
              throw new TypeError("Invalid base URL");
            }
          }
          const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
          if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
          }
          this._url = parsedURL;
        }
        get href() {
          return usm.serializeURL(this._url);
        }
        set href(v) {
          const parsedURL = usm.basicURLParse(v);
          if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
          }
          this._url = parsedURL;
        }
        get origin() {
          return usm.serializeURLOrigin(this._url);
        }
        get protocol() {
          return this._url.scheme + ":";
        }
        set protocol(v) {
          usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
        }
        get username() {
          return this._url.username;
        }
        set username(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          usm.setTheUsername(this._url, v);
        }
        get password() {
          return this._url.password;
        }
        set password(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          usm.setThePassword(this._url, v);
        }
        get host() {
          const url = this._url;
          if (url.host === null) {
            return "";
          }
          if (url.port === null) {
            return usm.serializeHost(url.host);
          }
          return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
        }
        set host(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
        }
        get hostname() {
          if (this._url.host === null) {
            return "";
          }
          return usm.serializeHost(this._url.host);
        }
        set hostname(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
        }
        get port() {
          if (this._url.port === null) {
            return "";
          }
          return usm.serializeInteger(this._url.port);
        }
        set port(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          if (v === "") {
            this._url.port = null;
          } else {
            usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
          }
        }
        get pathname() {
          if (this._url.cannotBeABaseURL) {
            return this._url.path[0];
          }
          if (this._url.path.length === 0) {
            return "";
          }
          return "/" + this._url.path.join("/");
        }
        set pathname(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          this._url.path = [];
          usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
        }
        get search() {
          if (this._url.query === null || this._url.query === "") {
            return "";
          }
          return "?" + this._url.query;
        }
        set search(v) {
          const url = this._url;
          if (v === "") {
            url.query = null;
            return;
          }
          const input = v[0] === "?" ? v.substring(1) : v;
          url.query = "";
          usm.basicURLParse(input, { url, stateOverride: "query" });
        }
        get hash() {
          if (this._url.fragment === null || this._url.fragment === "") {
            return "";
          }
          return "#" + this._url.fragment;
        }
        set hash(v) {
          if (v === "") {
            this._url.fragment = null;
            return;
          }
          const input = v[0] === "#" ? v.substring(1) : v;
          this._url.fragment = "";
          usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
        }
        toJSON() {
          return this.href;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js
  var require_URL = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js"(exports, module) {
      "use strict";
      var conversions = require_lib3();
      var utils = require_utils3();
      var Impl = require_URL_impl();
      var impl = utils.implSymbol;
      function URL3(url) {
        if (!this || this[impl] || !(this instanceof URL3)) {
          throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
        }
        if (arguments.length < 1) {
          throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
        }
        const args = [];
        for (let i = 0; i < arguments.length && i < 2; ++i) {
          args[i] = arguments[i];
        }
        args[0] = conversions["USVString"](args[0]);
        if (args[1] !== void 0) {
          args[1] = conversions["USVString"](args[1]);
        }
        module.exports.setup(this, args);
      }
      URL3.prototype.toJSON = function toJSON() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        const args = [];
        for (let i = 0; i < arguments.length && i < 0; ++i) {
          args[i] = arguments[i];
        }
        return this[impl].toJSON.apply(this[impl], args);
      };
      Object.defineProperty(URL3.prototype, "href", {
        get() {
          return this[impl].href;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].href = V;
        },
        enumerable: true,
        configurable: true
      });
      URL3.prototype.toString = function() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this.href;
      };
      Object.defineProperty(URL3.prototype, "origin", {
        get() {
          return this[impl].origin;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "protocol", {
        get() {
          return this[impl].protocol;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].protocol = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "username", {
        get() {
          return this[impl].username;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].username = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "password", {
        get() {
          return this[impl].password;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].password = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "host", {
        get() {
          return this[impl].host;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].host = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "hostname", {
        get() {
          return this[impl].hostname;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].hostname = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "port", {
        get() {
          return this[impl].port;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].port = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "pathname", {
        get() {
          return this[impl].pathname;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].pathname = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "search", {
        get() {
          return this[impl].search;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].search = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "hash", {
        get() {
          return this[impl].hash;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].hash = V;
        },
        enumerable: true,
        configurable: true
      });
      module.exports = {
        is(obj) {
          return !!obj && obj[impl] instanceof Impl.implementation;
        },
        create(constructorArgs, privateData) {
          let obj = Object.create(URL3.prototype);
          this.setup(obj, constructorArgs, privateData);
          return obj;
        },
        setup(obj, constructorArgs, privateData) {
          if (!privateData)
            privateData = {};
          privateData.wrapper = obj;
          obj[impl] = new Impl.implementation(constructorArgs, privateData);
          obj[impl][utils.wrapperSymbol] = obj;
        },
        interface: URL3,
        expose: {
          Window: { URL: URL3 },
          Worker: { URL: URL3 }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js
  var require_public_api = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js"(exports) {
      "use strict";
      exports.URL = require_URL().interface;
      exports.serializeURL = require_url_state_machine().serializeURL;
      exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
      exports.basicURLParse = require_url_state_machine().basicURLParse;
      exports.setTheUsername = require_url_state_machine().setTheUsername;
      exports.setThePassword = require_url_state_machine().setThePassword;
      exports.serializeHost = require_url_state_machine().serializeHost;
      exports.serializeInteger = require_url_state_machine().serializeInteger;
      exports.parseURL = require_url_state_machine().parseURL;
    }
  });

  // ../../node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs
  var lib_exports = {};
  __export(lib_exports, {
    AbortError: () => AbortError,
    FetchError: () => FetchError,
    Headers: () => Headers2,
    Request: () => Request,
    Response: () => Response2,
    default: () => lib_default
  });
  function FetchError(message, type3, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type3;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream2.default)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof import_stream2.default) {
      body.on("error", function(err) {
        const error2 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error2;
      });
    }
  }
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof import_stream2.default)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve4, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve4(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone3(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof import_stream2.default && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof import_stream2.default) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
      body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map2, name) {
    name = name.toLowerCase();
    for (const key in map2) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys4 = Object.keys(headers[MAP]).sort();
    return keys4.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers2();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  function parseURL(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  }
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers2(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof import_stream2.default.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  function fetch2(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve4, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort2() {
        let error2 = new AbortError("The user aborted a request.");
        reject(error2);
        if (request.body && request.body instanceof import_stream2.default.Readable) {
          destroyStream(request.body, error2);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error2);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize2() {
        abort();
        finalize();
      };
      const req2 = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req2.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req2.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req2.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        if (response && response.body) {
          destroyStream(response.body, err);
        }
        finalize();
      });
      fixResponseChunkedTransferBadEnding(req2, function(err) {
        if (signal && signal.aborted) {
          return;
        }
        if (response && response.body) {
          destroyStream(response.body, err);
        }
      });
      if (parseInt(process.version.substring(1)) < 14) {
        req2.on("socket", function(s) {
          s.addListener("close", function(hadError) {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", err);
            }
          });
        });
      }
      req2.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers2(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve4(fetch2(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response2(body, response_options);
          resolve4(response);
          return;
        }
        const zlibOptions = {
          flush: import_zlib.default.Z_SYNC_FLUSH,
          finishFlush: import_zlib.default.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
          response = new Response2(body, response_options);
          resolve4(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(import_zlib.default.createInflate());
            } else {
              body = body.pipe(import_zlib.default.createInflateRaw());
            }
            response = new Response2(body, response_options);
            resolve4(response);
          });
          raw.on("end", function() {
            if (!response) {
              response = new Response2(body, response_options);
              resolve4(response);
            }
          });
          return;
        }
        if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
          body = body.pipe(import_zlib.default.createBrotliDecompress());
          response = new Response2(body, response_options);
          resolve4(response);
          return;
        }
        response = new Response2(body, response_options);
        resolve4(response);
      });
      writeToStream(req2, request);
    });
  }
  function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on("socket", function(s) {
      socket = s;
    });
    request.on("response", function(response) {
      const headers = response.headers;
      if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
        response.once("close", function(hadError) {
          const hasDataListener = socket && socket.listenerCount("data") > 0;
          if (hasDataListener && !hadError) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(err);
          }
        });
      }
    });
  }
  function destroyStream(stream2, err) {
    if (stream2.destroy) {
      stream2.destroy(err);
    } else {
      stream2.emit("error", err);
      stream2.end();
    }
  }
  var import_stream2, import_http, import_url3, import_whatwg_url, import_https, import_zlib, Readable, BUFFER2, TYPE2, Blob2, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers2, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response2, INTERNALS$2, URL2, parse_url, format_url, streamDestructionSupported, Request, URL$1, PassThrough$1, isDomainOrSubdomain, isSameProtocol, lib_default;
  var init_lib = __esm({
    "../../node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs"() {
      import_stream2 = __toESM(__require2("stream"), 1);
      import_http = __toESM(__require2("http"), 1);
      import_url3 = __toESM(__require2("url"), 1);
      import_whatwg_url = __toESM(require_public_api(), 1);
      import_https = __toESM(__require2("https"), 1);
      import_zlib = __toESM(__require2("zlib"), 1);
      Readable = import_stream2.default.Readable;
      BUFFER2 = Symbol("buffer");
      TYPE2 = Symbol("type");
      Blob2 = class {
        constructor() {
          this[TYPE2] = "";
          const blobParts = arguments[0];
          const options = arguments[1];
          const buffers = [];
          let size = 0;
          if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for (let i = 0; i < length; i++) {
              const element = a[i];
              let buffer;
              if (element instanceof Buffer) {
                buffer = element;
              } else if (ArrayBuffer.isView(element)) {
                buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
              } else if (element instanceof ArrayBuffer) {
                buffer = Buffer.from(element);
              } else if (element instanceof Blob2) {
                buffer = element[BUFFER2];
              } else {
                buffer = Buffer.from(typeof element === "string" ? element : String(element));
              }
              size += buffer.length;
              buffers.push(buffer);
            }
          }
          this[BUFFER2] = Buffer.concat(buffers);
          let type3 = options && options.type !== void 0 && String(options.type).toLowerCase();
          if (type3 && !/[^\u0020-\u007E]/.test(type3)) {
            this[TYPE2] = type3;
          }
        }
        get size() {
          return this[BUFFER2].length;
        }
        get type() {
          return this[TYPE2];
        }
        text() {
          return Promise.resolve(this[BUFFER2].toString());
        }
        arrayBuffer() {
          const buf = this[BUFFER2];
          const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          return Promise.resolve(ab);
        }
        stream() {
          const readable = new Readable();
          readable._read = function() {
          };
          readable.push(this[BUFFER2]);
          readable.push(null);
          return readable;
        }
        toString() {
          return "[object Blob]";
        }
        slice() {
          const size = this.size;
          const start = arguments[0];
          const end = arguments[1];
          let relativeStart, relativeEnd;
          if (start === void 0) {
            relativeStart = 0;
          } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
          } else {
            relativeStart = Math.min(start, size);
          }
          if (end === void 0) {
            relativeEnd = size;
          } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
          } else {
            relativeEnd = Math.min(end, size);
          }
          const span = Math.max(relativeEnd - relativeStart, 0);
          const buffer = this[BUFFER2];
          const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
          const blob = new Blob2([], { type: arguments[2] });
          blob[BUFFER2] = slicedBuffer;
          return blob;
        }
      };
      Object.defineProperties(Blob2.prototype, {
        size: { enumerable: true },
        type: { enumerable: true },
        slice: { enumerable: true }
      });
      Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
        value: "Blob",
        writable: false,
        enumerable: false,
        configurable: true
      });
      FetchError.prototype = Object.create(Error.prototype);
      FetchError.prototype.constructor = FetchError;
      FetchError.prototype.name = "FetchError";
      try {
        convert = __require2("encoding").convert;
      } catch (e) {
      }
      INTERNALS = Symbol("Body internals");
      PassThrough = import_stream2.default.PassThrough;
      Body.prototype = {
        get body() {
          return this[INTERNALS].body;
        },
        get bodyUsed() {
          return this[INTERNALS].disturbed;
        },
        /**
         * Decode response as ArrayBuffer
         *
         * @return  Promise
         */
        arrayBuffer() {
          return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          });
        },
        /**
         * Return raw response as Blob
         *
         * @return Promise
         */
        blob() {
          let ct = this.headers && this.headers.get("content-type") || "";
          return consumeBody.call(this).then(function(buf) {
            return Object.assign(
              // Prevent copying
              new Blob2([], {
                type: ct.toLowerCase()
              }),
              {
                [BUFFER2]: buf
              }
            );
          });
        },
        /**
         * Decode response as json
         *
         * @return  Promise
         */
        json() {
          var _this2 = this;
          return consumeBody.call(this).then(function(buffer) {
            try {
              return JSON.parse(buffer.toString());
            } catch (err) {
              return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
            }
          });
        },
        /**
         * Decode response as text
         *
         * @return  Promise
         */
        text() {
          return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
          });
        },
        /**
         * Decode response as buffer (non-spec api)
         *
         * @return  Promise
         */
        buffer() {
          return consumeBody.call(this);
        },
        /**
         * Decode response as text, while automatically detecting the encoding and
         * trying to decode to UTF-8 (non-spec api)
         *
         * @return  Promise
         */
        textConverted() {
          var _this3 = this;
          return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
          });
        }
      };
      Object.defineProperties(Body.prototype, {
        body: { enumerable: true },
        bodyUsed: { enumerable: true },
        arrayBuffer: { enumerable: true },
        blob: { enumerable: true },
        json: { enumerable: true },
        text: { enumerable: true }
      });
      Body.mixIn = function(proto) {
        for (const name of Object.getOwnPropertyNames(Body.prototype)) {
          if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
          }
        }
      };
      Body.Promise = global.Promise;
      invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
      invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
      MAP = Symbol("map");
      Headers2 = class {
        /**
         * Headers class
         *
         * @param   Object  headers  Response headers
         * @return  Void
         */
        constructor() {
          let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          this[MAP] = /* @__PURE__ */ Object.create(null);
          if (init2 instanceof Headers2) {
            const rawHeaders = init2.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames) {
              for (const value of rawHeaders[headerName]) {
                this.append(headerName, value);
              }
            }
            return;
          }
          if (init2 == null)
            ;
          else if (typeof init2 === "object") {
            const method = init2[Symbol.iterator];
            if (method != null) {
              if (typeof method !== "function") {
                throw new TypeError("Header pairs must be iterable");
              }
              const pairs = [];
              for (const pair of init2) {
                if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                  throw new TypeError("Each header pair must be iterable");
                }
                pairs.push(Array.from(pair));
              }
              for (const pair of pairs) {
                if (pair.length !== 2) {
                  throw new TypeError("Each header pair must be a name/value tuple");
                }
                this.append(pair[0], pair[1]);
              }
            } else {
              for (const key of Object.keys(init2)) {
                const value = init2[key];
                this.append(key, value);
              }
            }
          } else {
            throw new TypeError("Provided initializer must be an object");
          }
        }
        /**
         * Return combined header value given name
         *
         * @param   String  name  Header name
         * @return  Mixed
         */
        get(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key === void 0) {
            return null;
          }
          return this[MAP][key].join(", ");
        }
        /**
         * Iterate over all headers
         *
         * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
         * @param   Boolean   thisArg   `this` context for callback function
         * @return  Void
         */
        forEach(callback) {
          let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
          let pairs = getHeaders(this);
          let i = 0;
          while (i < pairs.length) {
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
          }
        }
        /**
         * Overwrite header values given name
         *
         * @param   String  name   Header name
         * @param   String  value  Header value
         * @return  Void
         */
        set(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          this[MAP][key !== void 0 ? key : name] = [value];
        }
        /**
         * Append a value onto existing header
         *
         * @param   String  name   Header name
         * @param   String  value  Header value
         * @return  Void
         */
        append(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          if (key !== void 0) {
            this[MAP][key].push(value);
          } else {
            this[MAP][name] = [value];
          }
        }
        /**
         * Check for header name existence
         *
         * @param   String   name  Header name
         * @return  Boolean
         */
        has(name) {
          name = `${name}`;
          validateName(name);
          return find(this[MAP], name) !== void 0;
        }
        /**
         * Delete all header values given name
         *
         * @param   String  name  Header name
         * @return  Void
         */
        delete(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key !== void 0) {
            delete this[MAP][key];
          }
        }
        /**
         * Return raw headers (non-spec api)
         *
         * @return  Object
         */
        raw() {
          return this[MAP];
        }
        /**
         * Get an iterator on keys.
         *
         * @return  Iterator
         */
        keys() {
          return createHeadersIterator(this, "key");
        }
        /**
         * Get an iterator on values.
         *
         * @return  Iterator
         */
        values() {
          return createHeadersIterator(this, "value");
        }
        /**
         * Get an iterator on entries.
         *
         * This is the default iterator of the Headers object.
         *
         * @return  Iterator
         */
        [Symbol.iterator]() {
          return createHeadersIterator(this, "key+value");
        }
      };
      Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
      Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
        value: "Headers",
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperties(Headers2.prototype, {
        get: { enumerable: true },
        forEach: { enumerable: true },
        set: { enumerable: true },
        append: { enumerable: true },
        has: { enumerable: true },
        delete: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true }
      });
      INTERNAL = Symbol("internal");
      HeadersIteratorPrototype = Object.setPrototypeOf({
        next() {
          if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError("Value of `this` is not a HeadersIterator");
          }
          var _INTERNAL = this[INTERNAL];
          const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
          const values = getHeaders(target, kind);
          const len = values.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true
            };
          }
          this[INTERNAL].index = index + 1;
          return {
            value: values[index],
            done: false
          };
        }
      }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
      Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
        value: "HeadersIterator",
        writable: false,
        enumerable: false,
        configurable: true
      });
      INTERNALS$1 = Symbol("Response internals");
      STATUS_CODES = import_http.default.STATUS_CODES;
      Response2 = class {
        constructor() {
          let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          Body.call(this, body, opts);
          const status = opts.status || 200;
          const headers = new Headers2(opts.headers);
          if (body != null && !headers.has("Content-Type")) {
            const contentType = extractContentType(body);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          this[INTERNALS$1] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter
          };
        }
        get url() {
          return this[INTERNALS$1].url || "";
        }
        get status() {
          return this[INTERNALS$1].status;
        }
        /**
         * Convenience property representing if the request ended normally
         */
        get ok() {
          return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
        }
        get redirected() {
          return this[INTERNALS$1].counter > 0;
        }
        get statusText() {
          return this[INTERNALS$1].statusText;
        }
        get headers() {
          return this[INTERNALS$1].headers;
        }
        /**
         * Clone this response
         *
         * @return  Response
         */
        clone() {
          return new Response2(clone3(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
          });
        }
      };
      Body.mixIn(Response2.prototype);
      Object.defineProperties(Response2.prototype, {
        url: { enumerable: true },
        status: { enumerable: true },
        ok: { enumerable: true },
        redirected: { enumerable: true },
        statusText: { enumerable: true },
        headers: { enumerable: true },
        clone: { enumerable: true }
      });
      Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
        value: "Response",
        writable: false,
        enumerable: false,
        configurable: true
      });
      INTERNALS$2 = Symbol("Request internals");
      URL2 = import_url3.default.URL || import_whatwg_url.default.URL;
      parse_url = import_url3.default.parse;
      format_url = import_url3.default.format;
      streamDestructionSupported = "destroy" in import_stream2.default.Readable.prototype;
      Request = class {
        constructor(input) {
          let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          let parsedURL;
          if (!isRequest(input)) {
            if (input && input.href) {
              parsedURL = parseURL(input.href);
            } else {
              parsedURL = parseURL(`${input}`);
            }
            input = {};
          } else {
            parsedURL = parseURL(input.url);
          }
          let method = init2.method || input.method || "GET";
          method = method.toUpperCase();
          if ((init2.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
            throw new TypeError("Request with GET/HEAD method cannot have body");
          }
          let inputBody = init2.body != null ? init2.body : isRequest(input) && input.body !== null ? clone3(input) : null;
          Body.call(this, inputBody, {
            timeout: init2.timeout || input.timeout || 0,
            size: init2.size || input.size || 0
          });
          const headers = new Headers2(init2.headers || input.headers || {});
          if (inputBody != null && !headers.has("Content-Type")) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          let signal = isRequest(input) ? input.signal : null;
          if ("signal" in init2)
            signal = init2.signal;
          if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError("Expected signal to be an instanceof AbortSignal");
          }
          this[INTERNALS$2] = {
            method,
            redirect: init2.redirect || input.redirect || "follow",
            headers,
            parsedURL,
            signal
          };
          this.follow = init2.follow !== void 0 ? init2.follow : input.follow !== void 0 ? input.follow : 20;
          this.compress = init2.compress !== void 0 ? init2.compress : input.compress !== void 0 ? input.compress : true;
          this.counter = init2.counter || input.counter || 0;
          this.agent = init2.agent || input.agent;
        }
        get method() {
          return this[INTERNALS$2].method;
        }
        get url() {
          return format_url(this[INTERNALS$2].parsedURL);
        }
        get headers() {
          return this[INTERNALS$2].headers;
        }
        get redirect() {
          return this[INTERNALS$2].redirect;
        }
        get signal() {
          return this[INTERNALS$2].signal;
        }
        /**
         * Clone this request
         *
         * @return  Request
         */
        clone() {
          return new Request(this);
        }
      };
      Body.mixIn(Request.prototype);
      Object.defineProperty(Request.prototype, Symbol.toStringTag, {
        value: "Request",
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperties(Request.prototype, {
        method: { enumerable: true },
        url: { enumerable: true },
        headers: { enumerable: true },
        redirect: { enumerable: true },
        clone: { enumerable: true },
        signal: { enumerable: true }
      });
      AbortError.prototype = Object.create(Error.prototype);
      AbortError.prototype.constructor = AbortError;
      AbortError.prototype.name = "AbortError";
      URL$1 = import_url3.default.URL || import_whatwg_url.default.URL;
      PassThrough$1 = import_stream2.default.PassThrough;
      isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
        const orig = new URL$1(original).hostname;
        const dest = new URL$1(destination).hostname;
        return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
      };
      isSameProtocol = function isSameProtocol2(destination, original) {
        const orig = new URL$1(original).protocol;
        const dest = new URL$1(destination).protocol;
        return orig === dest;
      };
      fetch2.isRedirect = function(code) {
        return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
      };
      fetch2.Promise = global.Promise;
      lib_default = fetch2;
    }
  });

  // ../../node_modules/.pnpm/cross-fetch@4.0.0/node_modules/cross-fetch/dist/node-ponyfill.js
  var require_node_ponyfill = __commonJS({
    "../../node_modules/.pnpm/cross-fetch@4.0.0/node_modules/cross-fetch/dist/node-ponyfill.js"(exports, module) {
      var nodeFetch = (init_lib(), __toCommonJS(lib_exports));
      var realFetch = nodeFetch.default || nodeFetch;
      var fetch3 = function(url, options) {
        if (/^\/\//.test(url)) {
          url = "https:" + url;
        }
        return realFetch.call(this, url, options);
      };
      fetch3.ponyfill = true;
      module.exports = exports = fetch3;
      exports.fetch = fetch3;
      exports.Headers = nodeFetch.Headers;
      exports.Request = nodeFetch.Request;
      exports.Response = nodeFetch.Response;
      exports.default = fetch3;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isObjectLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isObjectLike = isObjectLike2;
      function isObjectLike2(value) {
        return typeof value == "object" && value !== null;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/invariant.js
  var require_invariant = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/invariant.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invariant = invariant2;
      function invariant2(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(
            message != null ? message : "Unexpected invariant triggered."
          );
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/location.js
  var require_location = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/location.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getLocation = getLocation2;
      var _invariant = require_invariant();
      var LineRegExp2 = /\r\n|[\n\r]/g;
      function getLocation2(source, position) {
        let lastLineStart = 0;
        let line = 1;
        for (const match3 of source.body.matchAll(LineRegExp2)) {
          typeof match3.index === "number" || (0, _invariant.invariant)(false);
          if (match3.index >= position) {
            break;
          }
          lastLineStart = match3.index + match3[0].length;
          line += 1;
        }
        return {
          line,
          column: position + 1 - lastLineStart
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printLocation.js
  var require_printLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printLocation = printLocation2;
      exports.printSourceLocation = printSourceLocation2;
      var _location = require_location();
      function printLocation2(location) {
        return printSourceLocation2(
          location.source,
          (0, _location.getLocation)(location.source, location.start)
        );
      }
      function printSourceLocation2(source, sourceLocation) {
        const firstLineColumnOffset = source.locationOffset.column - 1;
        const body = "".padStart(firstLineColumnOffset) + source.body;
        const lineIndex = sourceLocation.line - 1;
        const lineOffset = source.locationOffset.line - 1;
        const lineNum = sourceLocation.line + lineOffset;
        const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
        const columnNum = sourceLocation.column + columnOffset;
        const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
        const lines = body.split(/\r\n|[\n\r]/g);
        const locationLine = lines[lineIndex];
        if (locationLine.length > 120) {
          const subLineIndex = Math.floor(columnNum / 80);
          const subLineColumnNum = columnNum % 80;
          const subLines = [];
          for (let i = 0; i < locationLine.length; i += 80) {
            subLines.push(locationLine.slice(i, i + 80));
          }
          return locationStr + printPrefixedLines2([
            [`${lineNum} |`, subLines[0]],
            ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
            ["|", "^".padStart(subLineColumnNum)],
            ["|", subLines[subLineIndex + 1]]
          ]);
        }
        return locationStr + printPrefixedLines2([
          // Lines specified like this: ["prefix", "string"],
          [`${lineNum - 1} |`, lines[lineIndex - 1]],
          [`${lineNum} |`, locationLine],
          ["|", "^".padStart(columnNum)],
          [`${lineNum + 1} |`, lines[lineIndex + 1]]
        ]);
      }
      function printPrefixedLines2(lines) {
        const existingLines = lines.filter(([_, line]) => line !== void 0);
        const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
        return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/GraphQLError.js
  var require_GraphQLError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/GraphQLError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLError = void 0;
      exports.formatError = formatError;
      exports.printError = printError;
      var _isObjectLike = require_isObjectLike();
      var _location = require_location();
      var _printLocation = require_printLocation();
      function toNormalizedOptions2(args) {
        const firstArg = args[0];
        if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
          return {
            nodes: firstArg,
            source: args[1],
            positions: args[2],
            path: args[3],
            originalError: args[4],
            extensions: args[5]
          };
        }
        return firstArg;
      }
      var GraphQLError2 = class extends Error {
        /**
         * An array of `{ line, column }` locations within the source GraphQL document
         * which correspond to this error.
         *
         * Errors during validation often contain multiple locations, for example to
         * point out two things with the same name. Errors during execution include a
         * single location, the field which produced the error.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array describing the JSON-path into the execution response which
         * corresponds to this error. Only included for errors during execution.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array of GraphQL AST Nodes corresponding to this error.
         */
        /**
         * The source GraphQL document for the first location of this error.
         *
         * Note that if this Error represents more than one node, the source may not
         * represent nodes after the first node.
         */
        /**
         * An array of character offsets within the source GraphQL document
         * which correspond to this error.
         */
        /**
         * The original error thrown from a field resolver during execution.
         */
        /**
         * Extension fields to add to the formatted error.
         */
        /**
         * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
         */
        constructor(message, ...rawArgs) {
          var _this$nodes, _nodeLocations$, _ref;
          const { nodes, source, positions, path: path5, originalError, extensions } = toNormalizedOptions2(rawArgs);
          super(message);
          this.name = "GraphQLError";
          this.path = path5 !== null && path5 !== void 0 ? path5 : void 0;
          this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
          this.nodes = undefinedIfEmpty2(
            Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
          );
          const nodeLocations = undefinedIfEmpty2(
            (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
          );
          this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
          this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
          this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
            (loc) => (0, _location.getLocation)(loc.source, loc.start)
          );
          const originalExtensions = (0, _isObjectLike.isObjectLike)(
            originalError === null || originalError === void 0 ? void 0 : originalError.extensions
          ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
          this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
          Object.defineProperties(this, {
            message: {
              writable: true,
              enumerable: true
            },
            name: {
              enumerable: false
            },
            nodes: {
              enumerable: false
            },
            source: {
              enumerable: false
            },
            positions: {
              enumerable: false
            },
            originalError: {
              enumerable: false
            }
          });
          if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
              value: originalError.stack,
              writable: true,
              configurable: true
            });
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, GraphQLError2);
          } else {
            Object.defineProperty(this, "stack", {
              value: Error().stack,
              writable: true,
              configurable: true
            });
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLError";
        }
        toString() {
          let output3 = this.message;
          if (this.nodes) {
            for (const node of this.nodes) {
              if (node.loc) {
                output3 += "\n\n" + (0, _printLocation.printLocation)(node.loc);
              }
            }
          } else if (this.source && this.locations) {
            for (const location of this.locations) {
              output3 += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
            }
          }
          return output3;
        }
        toJSON() {
          const formattedError = {
            message: this.message
          };
          if (this.locations != null) {
            formattedError.locations = this.locations;
          }
          if (this.path != null) {
            formattedError.path = this.path;
          }
          if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
          }
          return formattedError;
        }
      };
      exports.GraphQLError = GraphQLError2;
      function undefinedIfEmpty2(array2) {
        return array2 === void 0 || array2.length === 0 ? void 0 : array2;
      }
      function printError(error2) {
        return error2.toString();
      }
      function formatError(error2) {
        return error2.toJSON();
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/syntaxError.js
  var require_syntaxError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/syntaxError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.syntaxError = syntaxError2;
      var _GraphQLError = require_GraphQLError();
      function syntaxError2(source, position, description) {
        return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
          source,
          positions: [position]
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/ast.js
  var require_ast2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/ast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = void 0;
      exports.isNode = isNode2;
      var Location2 = class {
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The Token at which this Node begins.
         */
        /**
         * The Token at which this Node ends.
         */
        /**
         * The Source document the AST represents.
         */
        constructor(startToken, endToken, source) {
          this.start = startToken.start;
          this.end = endToken.end;
          this.startToken = startToken;
          this.endToken = endToken;
          this.source = source;
        }
        get [Symbol.toStringTag]() {
          return "Location";
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end
          };
        }
      };
      exports.Location = Location2;
      var Token2 = class {
        /**
         * The kind of Token.
         */
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The 1-indexed line number on which this Token appears.
         */
        /**
         * The 1-indexed column number at which this Token begins.
         */
        /**
         * For non-punctuation tokens, represents the interpreted value of the token.
         *
         * Note: is undefined for punctuation tokens, but typed as string for
         * convenience in the parser.
         */
        /**
         * Tokens exist as nodes in a double-linked-list amongst all tokens
         * including ignored tokens. <SOF> is always the first node and <EOF>
         * the last.
         */
        constructor(kind, start, end, line, column, value) {
          this.kind = kind;
          this.start = start;
          this.end = end;
          this.line = line;
          this.column = column;
          this.value = value;
          this.prev = null;
          this.next = null;
        }
        get [Symbol.toStringTag]() {
          return "Token";
        }
        toJSON() {
          return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
          };
        }
      };
      exports.Token = Token2;
      var QueryDocumentKeys2 = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: [
          "name",
          "variableDefinitions",
          "directives",
          "selectionSet"
        ],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: [
          "name",
          // Note: fragment variable definitions are deprecated and will removed in v17.0.0
          "variableDefinitions",
          "typeCondition",
          "directives",
          "selectionSet"
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: [
          "description",
          "name",
          "type",
          "defaultValue",
          "directives"
        ],
        InterfaceTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
      };
      exports.QueryDocumentKeys = QueryDocumentKeys2;
      var kindValues2 = new Set(Object.keys(QueryDocumentKeys2));
      function isNode2(maybeNode) {
        const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
        return typeof maybeKind === "string" && kindValues2.has(maybeKind);
      }
      var OperationTypeNode2;
      exports.OperationTypeNode = OperationTypeNode2;
      (function(OperationTypeNode3) {
        OperationTypeNode3["QUERY"] = "query";
        OperationTypeNode3["MUTATION"] = "mutation";
        OperationTypeNode3["SUBSCRIPTION"] = "subscription";
      })(OperationTypeNode2 || (exports.OperationTypeNode = OperationTypeNode2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/directiveLocation.js
  var require_directiveLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/directiveLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DirectiveLocation = void 0;
      var DirectiveLocation2;
      exports.DirectiveLocation = DirectiveLocation2;
      (function(DirectiveLocation3) {
        DirectiveLocation3["QUERY"] = "QUERY";
        DirectiveLocation3["MUTATION"] = "MUTATION";
        DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation3["FIELD"] = "FIELD";
        DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation3["SCHEMA"] = "SCHEMA";
        DirectiveLocation3["SCALAR"] = "SCALAR";
        DirectiveLocation3["OBJECT"] = "OBJECT";
        DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation3["INTERFACE"] = "INTERFACE";
        DirectiveLocation3["UNION"] = "UNION";
        DirectiveLocation3["ENUM"] = "ENUM";
        DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation2 || (exports.DirectiveLocation = DirectiveLocation2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/kinds.js
  var require_kinds = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/kinds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Kind = void 0;
      var Kind2;
      exports.Kind = Kind2;
      (function(Kind3) {
        Kind3["NAME"] = "Name";
        Kind3["DOCUMENT"] = "Document";
        Kind3["OPERATION_DEFINITION"] = "OperationDefinition";
        Kind3["VARIABLE_DEFINITION"] = "VariableDefinition";
        Kind3["SELECTION_SET"] = "SelectionSet";
        Kind3["FIELD"] = "Field";
        Kind3["ARGUMENT"] = "Argument";
        Kind3["FRAGMENT_SPREAD"] = "FragmentSpread";
        Kind3["INLINE_FRAGMENT"] = "InlineFragment";
        Kind3["FRAGMENT_DEFINITION"] = "FragmentDefinition";
        Kind3["VARIABLE"] = "Variable";
        Kind3["INT"] = "IntValue";
        Kind3["FLOAT"] = "FloatValue";
        Kind3["STRING"] = "StringValue";
        Kind3["BOOLEAN"] = "BooleanValue";
        Kind3["NULL"] = "NullValue";
        Kind3["ENUM"] = "EnumValue";
        Kind3["LIST"] = "ListValue";
        Kind3["OBJECT"] = "ObjectValue";
        Kind3["OBJECT_FIELD"] = "ObjectField";
        Kind3["DIRECTIVE"] = "Directive";
        Kind3["NAMED_TYPE"] = "NamedType";
        Kind3["LIST_TYPE"] = "ListType";
        Kind3["NON_NULL_TYPE"] = "NonNullType";
        Kind3["SCHEMA_DEFINITION"] = "SchemaDefinition";
        Kind3["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
        Kind3["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
        Kind3["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
        Kind3["FIELD_DEFINITION"] = "FieldDefinition";
        Kind3["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
        Kind3["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
        Kind3["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
        Kind3["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
        Kind3["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
        Kind3["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
        Kind3["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
        Kind3["SCHEMA_EXTENSION"] = "SchemaExtension";
        Kind3["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
        Kind3["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
        Kind3["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
        Kind3["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
        Kind3["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
        Kind3["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
      })(Kind2 || (exports.Kind = Kind2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/characterClasses.js
  var require_characterClasses = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/characterClasses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isDigit = isDigit2;
      exports.isLetter = isLetter2;
      exports.isNameContinue = isNameContinue2;
      exports.isNameStart = isNameStart2;
      exports.isWhiteSpace = isWhiteSpace2;
      function isWhiteSpace2(code) {
        return code === 9 || code === 32;
      }
      function isDigit2(code) {
        return code >= 48 && code <= 57;
      }
      function isLetter2(code) {
        return code >= 97 && code <= 122 || // A-Z
        code >= 65 && code <= 90;
      }
      function isNameStart2(code) {
        return isLetter2(code) || code === 95;
      }
      function isNameContinue2(code) {
        return isLetter2(code) || isDigit2(code) || code === 95;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/blockString.js
  var require_blockString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/blockString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dedentBlockStringLines = dedentBlockStringLines2;
      exports.isPrintableAsBlockString = isPrintableAsBlockString;
      exports.printBlockString = printBlockString2;
      var _characterClasses = require_characterClasses();
      function dedentBlockStringLines2(lines) {
        var _firstNonEmptyLine2;
        let commonIndent = Number.MAX_SAFE_INTEGER;
        let firstNonEmptyLine = null;
        let lastNonEmptyLine = -1;
        for (let i = 0; i < lines.length; ++i) {
          var _firstNonEmptyLine;
          const line = lines[i];
          const indent2 = leadingWhitespace2(line);
          if (indent2 === line.length) {
            continue;
          }
          firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
          lastNonEmptyLine = i;
          if (i !== 0 && indent2 < commonIndent) {
            commonIndent = indent2;
          }
        }
        return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
          (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
          lastNonEmptyLine + 1
        );
      }
      function leadingWhitespace2(str) {
        let i = 0;
        while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
          ++i;
        }
        return i;
      }
      function isPrintableAsBlockString(value) {
        if (value === "") {
          return true;
        }
        let isEmptyLine = true;
        let hasIndent = false;
        let hasCommonIndent = true;
        let seenNonEmptyLine = false;
        for (let i = 0; i < value.length; ++i) {
          switch (value.codePointAt(i)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 11:
            case 12:
            case 14:
            case 15:
              return false;
            case 13:
              return false;
            case 10:
              if (isEmptyLine && !seenNonEmptyLine) {
                return false;
              }
              seenNonEmptyLine = true;
              isEmptyLine = true;
              hasIndent = false;
              break;
            case 9:
            case 32:
              hasIndent || (hasIndent = isEmptyLine);
              break;
            default:
              hasCommonIndent && (hasCommonIndent = hasIndent);
              isEmptyLine = false;
          }
        }
        if (isEmptyLine) {
          return false;
        }
        if (hasCommonIndent && seenNonEmptyLine) {
          return false;
        }
        return true;
      }
      function printBlockString2(value, options) {
        const escapedValue = value.replace(/"""/g, '\\"""');
        const lines = escapedValue.split(/\r\n|[\n\r]/g);
        const isSingleLine = lines.length === 1;
        const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
          (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
        );
        const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
        const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
        const hasTrailingSlash = value.endsWith("\\");
        const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
        const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
        (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
        let result = "";
        const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
        if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
          result += "\n";
        }
        result += escapedValue;
        if (printAsMultipleLines || forceTrailingNewline) {
          result += "\n";
        }
        return '"""' + result + '"""';
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/tokenKind.js
  var require_tokenKind = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/tokenKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TokenKind = void 0;
      var TokenKind2;
      exports.TokenKind = TokenKind2;
      (function(TokenKind3) {
        TokenKind3["SOF"] = "<SOF>";
        TokenKind3["EOF"] = "<EOF>";
        TokenKind3["BANG"] = "!";
        TokenKind3["DOLLAR"] = "$";
        TokenKind3["AMP"] = "&";
        TokenKind3["PAREN_L"] = "(";
        TokenKind3["PAREN_R"] = ")";
        TokenKind3["SPREAD"] = "...";
        TokenKind3["COLON"] = ":";
        TokenKind3["EQUALS"] = "=";
        TokenKind3["AT"] = "@";
        TokenKind3["BRACKET_L"] = "[";
        TokenKind3["BRACKET_R"] = "]";
        TokenKind3["BRACE_L"] = "{";
        TokenKind3["PIPE"] = "|";
        TokenKind3["BRACE_R"] = "}";
        TokenKind3["NAME"] = "Name";
        TokenKind3["INT"] = "Int";
        TokenKind3["FLOAT"] = "Float";
        TokenKind3["STRING"] = "String";
        TokenKind3["BLOCK_STRING"] = "BlockString";
        TokenKind3["COMMENT"] = "Comment";
      })(TokenKind2 || (exports.TokenKind = TokenKind2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/lexer.js
  var require_lexer = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/lexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Lexer = void 0;
      exports.isPunctuatorTokenKind = isPunctuatorTokenKind2;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast2();
      var _blockString = require_blockString();
      var _characterClasses = require_characterClasses();
      var _tokenKind = require_tokenKind();
      var Lexer2 = class {
        /**
         * The previously focused non-ignored token.
         */
        /**
         * The currently focused non-ignored token.
         */
        /**
         * The (1-indexed) line containing the current token.
         */
        /**
         * The character offset at which the current line begins.
         */
        constructor(source) {
          const startOfFileToken = new _ast.Token(
            _tokenKind.TokenKind.SOF,
            0,
            0,
            0,
            0
          );
          this.source = source;
          this.lastToken = startOfFileToken;
          this.token = startOfFileToken;
          this.line = 1;
          this.lineStart = 0;
        }
        get [Symbol.toStringTag]() {
          return "Lexer";
        }
        /**
         * Advances the token stream to the next non-ignored token.
         */
        advance() {
          this.lastToken = this.token;
          const token = this.token = this.lookahead();
          return token;
        }
        /**
         * Looks ahead and returns the next non-ignored token, but does not change
         * the state of Lexer.
         */
        lookahead() {
          let token = this.token;
          if (token.kind !== _tokenKind.TokenKind.EOF) {
            do {
              if (token.next) {
                token = token.next;
              } else {
                const nextToken = readNextToken2(this, token.end);
                token.next = nextToken;
                nextToken.prev = token;
                token = nextToken;
              }
            } while (token.kind === _tokenKind.TokenKind.COMMENT);
          }
          return token;
        }
      };
      exports.Lexer = Lexer2;
      function isPunctuatorTokenKind2(kind) {
        return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
      }
      function isUnicodeScalarValue2(code) {
        return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
      }
      function isSupplementaryCodePoint2(body, location) {
        return isLeadingSurrogate2(body.charCodeAt(location)) && isTrailingSurrogate2(body.charCodeAt(location + 1));
      }
      function isLeadingSurrogate2(code) {
        return code >= 55296 && code <= 56319;
      }
      function isTrailingSurrogate2(code) {
        return code >= 56320 && code <= 57343;
      }
      function printCodePointAt2(lexer, location) {
        const code = lexer.source.body.codePointAt(location);
        if (code === void 0) {
          return _tokenKind.TokenKind.EOF;
        } else if (code >= 32 && code <= 126) {
          const char = String.fromCodePoint(code);
          return char === '"' ? `'"'` : `"${char}"`;
        }
        return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
      }
      function createToken2(lexer, kind, start, end, value) {
        const line = lexer.line;
        const col = 1 + start - lexer.lineStart;
        return new _ast.Token(kind, start, end, line, col, value);
      }
      function readNextToken2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          switch (code) {
            case 65279:
            case 9:
            case 32:
            case 44:
              ++position;
              continue;
            case 10:
              ++position;
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 13:
              if (body.charCodeAt(position + 1) === 10) {
                position += 2;
              } else {
                ++position;
              }
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 35:
              return readComment2(lexer, position);
            case 33:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BANG,
                position,
                position + 1
              );
            case 36:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.DOLLAR,
                position,
                position + 1
              );
            case 38:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.AMP,
                position,
                position + 1
              );
            case 40:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.PAREN_L,
                position,
                position + 1
              );
            case 41:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.PAREN_R,
                position,
                position + 1
              );
            case 46:
              if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
                return createToken2(
                  lexer,
                  _tokenKind.TokenKind.SPREAD,
                  position,
                  position + 3
                );
              }
              break;
            case 58:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.COLON,
                position,
                position + 1
              );
            case 61:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.EQUALS,
                position,
                position + 1
              );
            case 64:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.AT,
                position,
                position + 1
              );
            case 91:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BRACKET_L,
                position,
                position + 1
              );
            case 93:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BRACKET_R,
                position,
                position + 1
              );
            case 123:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BRACE_L,
                position,
                position + 1
              );
            case 124:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.PIPE,
                position,
                position + 1
              );
            case 125:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BRACE_R,
                position,
                position + 1
              );
            case 34:
              if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
                return readBlockString2(lexer, position);
              }
              return readString2(lexer, position);
          }
          if ((0, _characterClasses.isDigit)(code) || code === 45) {
            return readNumber2(lexer, position, code);
          }
          if ((0, _characterClasses.isNameStart)(code)) {
            return readName2(lexer, position);
          }
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue2(code) || isSupplementaryCodePoint2(body, position) ? `Unexpected character: ${printCodePointAt2(lexer, position)}.` : `Invalid character: ${printCodePointAt2(lexer, position)}.`
          );
        }
        return createToken2(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
      }
      function readComment2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue2(code)) {
            ++position;
          } else if (isSupplementaryCodePoint2(body, position)) {
            position += 2;
          } else {
            break;
          }
        }
        return createToken2(
          lexer,
          _tokenKind.TokenKind.COMMENT,
          start,
          position,
          body.slice(start + 1, position)
        );
      }
      function readNumber2(lexer, start, firstCode) {
        const body = lexer.source.body;
        let position = start;
        let code = firstCode;
        let isFloat = false;
        if (code === 45) {
          code = body.charCodeAt(++position);
        }
        if (code === 48) {
          code = body.charCodeAt(++position);
          if ((0, _characterClasses.isDigit)(code)) {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid number, unexpected digit after 0: ${printCodePointAt2(
                lexer,
                position
              )}.`
            );
          }
        } else {
          position = readDigits2(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46) {
          isFloat = true;
          code = body.charCodeAt(++position);
          position = readDigits2(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 69 || code === 101) {
          isFloat = true;
          code = body.charCodeAt(++position);
          if (code === 43 || code === 45) {
            code = body.charCodeAt(++position);
          }
          position = readDigits2(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid number, expected digit but got: ${printCodePointAt2(
              lexer,
              position
            )}.`
          );
        }
        return createToken2(
          lexer,
          isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
          start,
          position,
          body.slice(start, position)
        );
      }
      function readDigits2(lexer, start, firstCode) {
        if (!(0, _characterClasses.isDigit)(firstCode)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            start,
            `Invalid number, expected digit but got: ${printCodePointAt2(
              lexer,
              start
            )}.`
          );
        }
        const body = lexer.source.body;
        let position = start + 1;
        while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
          ++position;
        }
        return position;
      }
      function readString2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        let chunkStart = position;
        let value = "";
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34) {
            value += body.slice(chunkStart, position);
            return createToken2(
              lexer,
              _tokenKind.TokenKind.STRING,
              start,
              position + 1,
              value
            );
          }
          if (code === 92) {
            value += body.slice(chunkStart, position);
            const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth2(lexer, position) : readEscapedUnicodeFixedWidth2(lexer, position) : readEscapedCharacter2(lexer, position);
            value += escape2.value;
            position += escape2.size;
            chunkStart = position;
            continue;
          }
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue2(code)) {
            ++position;
          } else if (isSupplementaryCodePoint2(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid character within String: ${printCodePointAt2(
                lexer,
                position
              )}.`
            );
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          "Unterminated string."
        );
      }
      function readEscapedUnicodeVariableWidth2(lexer, position) {
        const body = lexer.source.body;
        let point = 0;
        let size = 3;
        while (size < 12) {
          const code = body.charCodeAt(position + size++);
          if (code === 125) {
            if (size < 5 || !isUnicodeScalarValue2(point)) {
              break;
            }
            return {
              value: String.fromCodePoint(point),
              size
            };
          }
          point = point << 4 | readHexDigit2(code);
          if (point < 0) {
            break;
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid Unicode escape sequence: "${body.slice(
            position,
            position + size
          )}".`
        );
      }
      function readEscapedUnicodeFixedWidth2(lexer, position) {
        const body = lexer.source.body;
        const code = read16BitHexCode2(body, position + 2);
        if (isUnicodeScalarValue2(code)) {
          return {
            value: String.fromCodePoint(code),
            size: 6
          };
        }
        if (isLeadingSurrogate2(code)) {
          if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
            const trailingCode = read16BitHexCode2(body, position + 8);
            if (isTrailingSurrogate2(trailingCode)) {
              return {
                value: String.fromCodePoint(code, trailingCode),
                size: 12
              };
            }
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
        );
      }
      function read16BitHexCode2(body, position) {
        return readHexDigit2(body.charCodeAt(position)) << 12 | readHexDigit2(body.charCodeAt(position + 1)) << 8 | readHexDigit2(body.charCodeAt(position + 2)) << 4 | readHexDigit2(body.charCodeAt(position + 3));
      }
      function readHexDigit2(code) {
        return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
      }
      function readEscapedCharacter2(lexer, position) {
        const body = lexer.source.body;
        const code = body.charCodeAt(position + 1);
        switch (code) {
          case 34:
            return {
              value: '"',
              size: 2
            };
          case 92:
            return {
              value: "\\",
              size: 2
            };
          case 47:
            return {
              value: "/",
              size: 2
            };
          case 98:
            return {
              value: "\b",
              size: 2
            };
          case 102:
            return {
              value: "\f",
              size: 2
            };
          case 110:
            return {
              value: "\n",
              size: 2
            };
          case 114:
            return {
              value: "\r",
              size: 2
            };
          case 116:
            return {
              value: "	",
              size: 2
            };
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid character escape sequence: "${body.slice(
            position,
            position + 2
          )}".`
        );
      }
      function readBlockString2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let lineStart = lexer.lineStart;
        let position = start + 3;
        let chunkStart = position;
        let currentLine = "";
        const blockLines = [];
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            const token = createToken2(
              lexer,
              _tokenKind.TokenKind.BLOCK_STRING,
              start,
              position + 3,
              // Return a string of the lines joined with U+000A.
              (0, _blockString.dedentBlockStringLines)(blockLines).join("\n")
            );
            lexer.line += blockLines.length - 1;
            lexer.lineStart = lineStart;
            return token;
          }
          if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
            currentLine += body.slice(chunkStart, position);
            chunkStart = position + 1;
            position += 4;
            continue;
          }
          if (code === 10 || code === 13) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            if (code === 13 && body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            currentLine = "";
            chunkStart = position;
            lineStart = position;
            continue;
          }
          if (isUnicodeScalarValue2(code)) {
            ++position;
          } else if (isSupplementaryCodePoint2(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid character within String: ${printCodePointAt2(
                lexer,
                position
              )}.`
            );
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          "Unterminated string."
        );
      }
      function readName2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if ((0, _characterClasses.isNameContinue)(code)) {
            ++position;
          } else {
            break;
          }
        }
        return createToken2(
          lexer,
          _tokenKind.TokenKind.NAME,
          start,
          position,
          body.slice(start, position)
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/devAssert.js
  var require_devAssert = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/devAssert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.devAssert = devAssert2;
      function devAssert2(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/inspect.js
  var require_inspect = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/inspect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.inspect = inspect2;
      var MAX_ARRAY_LENGTH2 = 10;
      var MAX_RECURSIVE_DEPTH2 = 2;
      function inspect2(value) {
        return formatValue2(value, []);
      }
      function formatValue2(value, seenValues) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(value);
          case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
          case "object":
            return formatObjectValue2(value, seenValues);
          default:
            return String(value);
        }
      }
      function formatObjectValue2(value, previouslySeenValues) {
        if (value === null) {
          return "null";
        }
        if (previouslySeenValues.includes(value)) {
          return "[Circular]";
        }
        const seenValues = [...previouslySeenValues, value];
        if (isJSONable2(value)) {
          const jsonValue = value.toJSON();
          if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
          }
        } else if (Array.isArray(value)) {
          return formatArray2(value, seenValues);
        }
        return formatObject2(value, seenValues);
      }
      function isJSONable2(value) {
        return typeof value.toJSON === "function";
      }
      function formatObject2(object2, seenValues) {
        const entries = Object.entries(object2);
        if (entries.length === 0) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
          return "[" + getObjectTag2(object2) + "]";
        }
        const properties = entries.map(
          ([key, value]) => key + ": " + formatValue2(value, seenValues)
        );
        return "{ " + properties.join(", ") + " }";
      }
      function formatArray2(array2, seenValues) {
        if (array2.length === 0) {
          return "[]";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
          return "[Array]";
        }
        const len = Math.min(MAX_ARRAY_LENGTH2, array2.length);
        const remaining = array2.length - len;
        const items = [];
        for (let i = 0; i < len; ++i) {
          items.push(formatValue2(array2[i], seenValues));
        }
        if (remaining === 1) {
          items.push("... 1 more item");
        } else if (remaining > 1) {
          items.push(`... ${remaining} more items`);
        }
        return "[" + items.join(", ") + "]";
      }
      function getObjectTag2(object2) {
        const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
        if (tag === "Object" && typeof object2.constructor === "function") {
          const name = object2.constructor.name;
          if (typeof name === "string" && name !== "") {
            return name;
          }
        }
        return tag;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/instanceOf.js
  var require_instanceOf = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/instanceOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.instanceOf = void 0;
      var _inspect = require_inspect();
      var instanceOf4 = (
        /* c8 ignore next 6 */
        // FIXME: https://github.com/graphql/graphql-js/issues/2317
        // eslint-disable-next-line no-undef
        process.env.NODE_ENV === "production" ? function instanceOf5(value, constructor) {
          return value instanceof constructor;
        } : function instanceOf5(value, constructor) {
          if (value instanceof constructor) {
            return true;
          }
          if (typeof value === "object" && value !== null) {
            var _value$constructor;
            const className = constructor.prototype[Symbol.toStringTag];
            const valueClassName = (
              // We still need to support constructor's name to detect conflicts with older versions of this library.
              Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
            );
            if (className === valueClassName) {
              const stringifiedValue = (0, _inspect.inspect)(value);
              throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
            }
          }
          return false;
        }
      );
      exports.instanceOf = instanceOf4;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/source.js
  var require_source2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Source = void 0;
      exports.isSource = isSource2;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var Source2 = class {
        constructor(body, name = "GraphQL request", locationOffset = {
          line: 1,
          column: 1
        }) {
          typeof body === "string" || (0, _devAssert.devAssert)(
            false,
            `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`
          );
          this.body = body;
          this.name = name;
          this.locationOffset = locationOffset;
          this.locationOffset.line > 0 || (0, _devAssert.devAssert)(
            false,
            "line in locationOffset is 1-indexed and must be positive."
          );
          this.locationOffset.column > 0 || (0, _devAssert.devAssert)(
            false,
            "column in locationOffset is 1-indexed and must be positive."
          );
        }
        get [Symbol.toStringTag]() {
          return "Source";
        }
      };
      exports.Source = Source2;
      function isSource2(source) {
        return (0, _instanceOf.instanceOf)(source, Source2);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/parser.js
  var require_parser3 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Parser = void 0;
      exports.parse = parse3;
      exports.parseConstValue = parseConstValue2;
      exports.parseType = parseType2;
      exports.parseValue = parseValue2;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast2();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _lexer = require_lexer();
      var _source = require_source2();
      var _tokenKind = require_tokenKind();
      function parse3(source, options) {
        const parser = new Parser2(source, options);
        return parser.parseDocument();
      }
      function parseValue2(source, options) {
        const parser = new Parser2(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseValueLiteral(false);
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseConstValue2(source, options) {
        const parser = new Parser2(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseConstValueLiteral();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseType2(source, options) {
        const parser = new Parser2(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const type3 = parser.parseTypeReference();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return type3;
      }
      var Parser2 = class {
        constructor(source, options = {}) {
          const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
          this._lexer = new _lexer.Lexer(sourceObj);
          this._options = options;
          this._tokenCounter = 0;
        }
        /**
         * Converts a name lex token into a name parse node.
         */
        parseName() {
          const token = this.expectToken(_tokenKind.TokenKind.NAME);
          return this.node(token, {
            kind: _kinds.Kind.NAME,
            value: token.value
          });
        }
        // Implements the parsing rules in the Document section.
        /**
         * Document : Definition+
         */
        parseDocument() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.DOCUMENT,
            definitions: this.many(
              _tokenKind.TokenKind.SOF,
              this.parseDefinition,
              _tokenKind.TokenKind.EOF
            )
          });
        }
        /**
         * Definition :
         *   - ExecutableDefinition
         *   - TypeSystemDefinition
         *   - TypeSystemExtension
         *
         * ExecutableDefinition :
         *   - OperationDefinition
         *   - FragmentDefinition
         *
         * TypeSystemDefinition :
         *   - SchemaDefinition
         *   - TypeDefinition
         *   - DirectiveDefinition
         *
         * TypeDefinition :
         *   - ScalarTypeDefinition
         *   - ObjectTypeDefinition
         *   - InterfaceTypeDefinition
         *   - UnionTypeDefinition
         *   - EnumTypeDefinition
         *   - InputObjectTypeDefinition
         */
        parseDefinition() {
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.parseOperationDefinition();
          }
          const hasDescription = this.peekDescription();
          const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaDefinition();
              case "scalar":
                return this.parseScalarTypeDefinition();
              case "type":
                return this.parseObjectTypeDefinition();
              case "interface":
                return this.parseInterfaceTypeDefinition();
              case "union":
                return this.parseUnionTypeDefinition();
              case "enum":
                return this.parseEnumTypeDefinition();
              case "input":
                return this.parseInputObjectTypeDefinition();
              case "directive":
                return this.parseDirectiveDefinition();
            }
            if (hasDescription) {
              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                this._lexer.token.start,
                "Unexpected description, descriptions are supported only on type definitions."
              );
            }
            switch (keywordToken.value) {
              case "query":
              case "mutation":
              case "subscription":
                return this.parseOperationDefinition();
              case "fragment":
                return this.parseFragmentDefinition();
              case "extend":
                return this.parseTypeSystemExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        // Implements the parsing rules in the Operations section.
        /**
         * OperationDefinition :
         *  - SelectionSet
         *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
         */
        parseOperationDefinition() {
          const start = this._lexer.token;
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.node(start, {
              kind: _kinds.Kind.OPERATION_DEFINITION,
              operation: _ast.OperationTypeNode.QUERY,
              name: void 0,
              variableDefinitions: [],
              directives: [],
              selectionSet: this.parseSelectionSet()
            });
          }
          const operation = this.parseOperationType();
          let name;
          if (this.peek(_tokenKind.TokenKind.NAME)) {
            name = this.parseName();
          }
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation,
            name,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * OperationType : one of query mutation subscription
         */
        parseOperationType() {
          const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
          switch (operationToken.value) {
            case "query":
              return _ast.OperationTypeNode.QUERY;
            case "mutation":
              return _ast.OperationTypeNode.MUTATION;
            case "subscription":
              return _ast.OperationTypeNode.SUBSCRIPTION;
          }
          throw this.unexpected(operationToken);
        }
        /**
         * VariableDefinitions : ( VariableDefinition+ )
         */
        parseVariableDefinitions() {
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            this.parseVariableDefinition,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
         */
        parseVariableDefinition() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
            directives: this.parseConstDirectives()
          });
        }
        /**
         * Variable : $ Name
         */
        parseVariable() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.DOLLAR);
          return this.node(start, {
            kind: _kinds.Kind.VARIABLE,
            name: this.parseName()
          });
        }
        /**
         * ```
         * SelectionSet : { Selection+ }
         * ```
         */
        parseSelectionSet() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.SELECTION_SET,
            selections: this.many(
              _tokenKind.TokenKind.BRACE_L,
              this.parseSelection,
              _tokenKind.TokenKind.BRACE_R
            )
          });
        }
        /**
         * Selection :
         *   - Field
         *   - FragmentSpread
         *   - InlineFragment
         */
        parseSelection() {
          return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
        }
        /**
         * Field : Alias? Name Arguments? Directives? SelectionSet?
         *
         * Alias : Name :
         */
        parseField() {
          const start = this._lexer.token;
          const nameOrAlias = this.parseName();
          let alias;
          let name;
          if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
            alias = nameOrAlias;
            name = this.parseName();
          } else {
            name = nameOrAlias;
          }
          return this.node(start, {
            kind: _kinds.Kind.FIELD,
            alias,
            name,
            arguments: this.parseArguments(false),
            directives: this.parseDirectives(false),
            selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
          });
        }
        /**
         * Arguments[Const] : ( Argument[?Const]+ )
         */
        parseArguments(isConst) {
          const item = isConst ? this.parseConstArgument : this.parseArgument;
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            item,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * Argument[Const] : Name : Value[?Const]
         */
        parseArgument(isConst = false) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.ARGUMENT,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseConstArgument() {
          return this.parseArgument(true);
        }
        // Implements the parsing rules in the Fragments section.
        /**
         * Corresponds to both FragmentSpread and InlineFragment in the spec.
         *
         * FragmentSpread : ... FragmentName Directives?
         *
         * InlineFragment : ... TypeCondition? Directives? SelectionSet
         */
        parseFragment() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.SPREAD);
          const hasTypeCondition = this.expectOptionalKeyword("on");
          if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_SPREAD,
              name: this.parseFragmentName(),
              directives: this.parseDirectives(false)
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.INLINE_FRAGMENT,
            typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * FragmentDefinition :
         *   - fragment FragmentName on TypeCondition Directives? SelectionSet
         *
         * TypeCondition : NamedType
         */
        parseFragmentDefinition() {
          const start = this._lexer.token;
          this.expectKeyword("fragment");
          if (this._options.allowLegacyFragmentVariables === true) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_DEFINITION,
              name: this.parseFragmentName(),
              variableDefinitions: this.parseVariableDefinitions(),
              typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * FragmentName : Name but not `on`
         */
        parseFragmentName() {
          if (this._lexer.token.value === "on") {
            throw this.unexpected();
          }
          return this.parseName();
        }
        // Implements the parsing rules in the Values section.
        /**
         * Value[Const] :
         *   - [~Const] Variable
         *   - IntValue
         *   - FloatValue
         *   - StringValue
         *   - BooleanValue
         *   - NullValue
         *   - EnumValue
         *   - ListValue[?Const]
         *   - ObjectValue[?Const]
         *
         * BooleanValue : one of `true` `false`
         *
         * NullValue : `null`
         *
         * EnumValue : Name but not `true`, `false` or `null`
         */
        parseValueLiteral(isConst) {
          const token = this._lexer.token;
          switch (token.kind) {
            case _tokenKind.TokenKind.BRACKET_L:
              return this.parseList(isConst);
            case _tokenKind.TokenKind.BRACE_L:
              return this.parseObject(isConst);
            case _tokenKind.TokenKind.INT:
              this.advanceLexer();
              return this.node(token, {
                kind: _kinds.Kind.INT,
                value: token.value
              });
            case _tokenKind.TokenKind.FLOAT:
              this.advanceLexer();
              return this.node(token, {
                kind: _kinds.Kind.FLOAT,
                value: token.value
              });
            case _tokenKind.TokenKind.STRING:
            case _tokenKind.TokenKind.BLOCK_STRING:
              return this.parseStringLiteral();
            case _tokenKind.TokenKind.NAME:
              this.advanceLexer();
              switch (token.value) {
                case "true":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: true
                  });
                case "false":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: false
                  });
                case "null":
                  return this.node(token, {
                    kind: _kinds.Kind.NULL
                  });
                default:
                  return this.node(token, {
                    kind: _kinds.Kind.ENUM,
                    value: token.value
                  });
              }
            case _tokenKind.TokenKind.DOLLAR:
              if (isConst) {
                this.expectToken(_tokenKind.TokenKind.DOLLAR);
                if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                  const varName = this._lexer.token.value;
                  throw (0, _syntaxError.syntaxError)(
                    this._lexer.source,
                    token.start,
                    `Unexpected variable "$${varName}" in constant value.`
                  );
                } else {
                  throw this.unexpected(token);
                }
              }
              return this.parseVariable();
            default:
              throw this.unexpected();
          }
        }
        parseConstValueLiteral() {
          return this.parseValueLiteral(true);
        }
        parseStringLiteral() {
          const token = this._lexer.token;
          this.advanceLexer();
          return this.node(token, {
            kind: _kinds.Kind.STRING,
            value: token.value,
            block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
          });
        }
        /**
         * ListValue[Const] :
         *   - [ ]
         *   - [ Value[?Const]+ ]
         */
        parseList(isConst) {
          const item = () => this.parseValueLiteral(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.LIST,
            values: this.any(
              _tokenKind.TokenKind.BRACKET_L,
              item,
              _tokenKind.TokenKind.BRACKET_R
            )
          });
        }
        /**
         * ```
         * ObjectValue[Const] :
         *   - { }
         *   - { ObjectField[?Const]+ }
         * ```
         */
        parseObject(isConst) {
          const item = () => this.parseObjectField(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.OBJECT,
            fields: this.any(
              _tokenKind.TokenKind.BRACE_L,
              item,
              _tokenKind.TokenKind.BRACE_R
            )
          });
        }
        /**
         * ObjectField[Const] : Name : Value[?Const]
         */
        parseObjectField(isConst) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_FIELD,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        // Implements the parsing rules in the Directives section.
        /**
         * Directives[Const] : Directive[?Const]+
         */
        parseDirectives(isConst) {
          const directives = [];
          while (this.peek(_tokenKind.TokenKind.AT)) {
            directives.push(this.parseDirective(isConst));
          }
          return directives;
        }
        parseConstDirectives() {
          return this.parseDirectives(true);
        }
        /**
         * ```
         * Directive[Const] : @ Name Arguments[?Const]?
         * ```
         */
        parseDirective(isConst) {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.AT);
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(isConst)
          });
        }
        // Implements the parsing rules in the Types section.
        /**
         * Type :
         *   - NamedType
         *   - ListType
         *   - NonNullType
         */
        parseTypeReference() {
          const start = this._lexer.token;
          let type3;
          if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
            const innerType = this.parseTypeReference();
            this.expectToken(_tokenKind.TokenKind.BRACKET_R);
            type3 = this.node(start, {
              kind: _kinds.Kind.LIST_TYPE,
              type: innerType
            });
          } else {
            type3 = this.parseNamedType();
          }
          if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
            return this.node(start, {
              kind: _kinds.Kind.NON_NULL_TYPE,
              type: type3
            });
          }
          return type3;
        }
        /**
         * NamedType : Name
         */
        parseNamedType() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.NAMED_TYPE,
            name: this.parseName()
          });
        }
        // Implements the parsing rules in the Type Definition section.
        peekDescription() {
          return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
        }
        /**
         * Description : StringValue
         */
        parseDescription() {
          if (this.peekDescription()) {
            return this.parseStringLiteral();
          }
        }
        /**
         * ```
         * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
         * ```
         */
        parseSchemaDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.many(
            _tokenKind.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_DEFINITION,
            description,
            directives,
            operationTypes
          });
        }
        /**
         * OperationTypeDefinition : OperationType : NamedType
         */
        parseOperationTypeDefinition() {
          const start = this._lexer.token;
          const operation = this.parseOperationType();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type3 = this.parseNamedType();
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
            operation,
            type: type3
          });
        }
        /**
         * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
         */
        parseScalarTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
            description,
            name,
            directives
          });
        }
        /**
         * ObjectTypeDefinition :
         *   Description?
         *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
         */
        parseObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * ImplementsInterfaces :
         *   - implements `&`? NamedType
         *   - ImplementsInterfaces & NamedType
         */
        parseImplementsInterfaces() {
          return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
        }
        /**
         * ```
         * FieldsDefinition : { FieldDefinition+ }
         * ```
         */
        parseFieldsDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseFieldDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * FieldDefinition :
         *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
         */
        parseFieldDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type3 = this.parseTypeReference();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.FIELD_DEFINITION,
            description,
            name,
            arguments: args,
            type: type3,
            directives
          });
        }
        /**
         * ArgumentsDefinition : ( InputValueDefinition+ )
         */
        parseArgumentDefs() {
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            this.parseInputValueDef,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * InputValueDefinition :
         *   - Description? Name : Type DefaultValue? Directives[Const]?
         */
        parseInputValueDef() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type3 = this.parseTypeReference();
          let defaultValue;
          if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
            defaultValue = this.parseConstValueLiteral();
          }
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
            description,
            name,
            type: type3,
            defaultValue,
            directives
          });
        }
        /**
         * InterfaceTypeDefinition :
         *   - Description? interface Name Directives[Const]? FieldsDefinition?
         */
        parseInterfaceTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * UnionTypeDefinition :
         *   - Description? union Name Directives[Const]? UnionMemberTypes?
         */
        parseUnionTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types2 = this.parseUnionMemberTypes();
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_DEFINITION,
            description,
            name,
            directives,
            types: types2
          });
        }
        /**
         * UnionMemberTypes :
         *   - = `|`? NamedType
         *   - UnionMemberTypes | NamedType
         */
        parseUnionMemberTypes() {
          return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
        }
        /**
         * EnumTypeDefinition :
         *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
         */
        parseEnumTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
            description,
            name,
            directives,
            values
          });
        }
        /**
         * ```
         * EnumValuesDefinition : { EnumValueDefinition+ }
         * ```
         */
        parseEnumValuesDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseEnumValueDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * EnumValueDefinition : Description? EnumValue Directives[Const]?
         */
        parseEnumValueDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseEnumValueName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
            description,
            name,
            directives
          });
        }
        /**
         * EnumValue : Name but not `true`, `false` or `null`
         */
        parseEnumValueName() {
          if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              `${getTokenDesc2(
                this._lexer.token
              )} is reserved and cannot be used for an enum value.`
            );
          }
          return this.parseName();
        }
        /**
         * InputObjectTypeDefinition :
         *   - Description? input Name Directives[Const]? InputFieldsDefinition?
         */
        parseInputObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            description,
            name,
            directives,
            fields
          });
        }
        /**
         * ```
         * InputFieldsDefinition : { InputValueDefinition+ }
         * ```
         */
        parseInputFieldsDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseInputValueDef,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * TypeSystemExtension :
         *   - SchemaExtension
         *   - TypeExtension
         *
         * TypeExtension :
         *   - ScalarTypeExtension
         *   - ObjectTypeExtension
         *   - InterfaceTypeExtension
         *   - UnionTypeExtension
         *   - EnumTypeExtension
         *   - InputObjectTypeDefinition
         */
        parseTypeSystemExtension() {
          const keywordToken = this._lexer.lookahead();
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaExtension();
              case "scalar":
                return this.parseScalarTypeExtension();
              case "type":
                return this.parseObjectTypeExtension();
              case "interface":
                return this.parseInterfaceTypeExtension();
              case "union":
                return this.parseUnionTypeExtension();
              case "enum":
                return this.parseEnumTypeExtension();
              case "input":
                return this.parseInputObjectTypeExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        /**
         * ```
         * SchemaExtension :
         *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
         *  - extend schema Directives[Const]
         * ```
         */
        parseSchemaExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
          if (directives.length === 0 && operationTypes.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_EXTENSION,
            directives,
            operationTypes
          });
        }
        /**
         * ScalarTypeExtension :
         *   - extend scalar Name Directives[Const]
         */
        parseScalarTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          if (directives.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
            name,
            directives
          });
        }
        /**
         * ObjectTypeExtension :
         *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
         *  - extend type Name ImplementsInterfaces? Directives[Const]
         *  - extend type Name ImplementsInterfaces
         */
        parseObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * InterfaceTypeExtension :
         *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
         *  - extend interface Name ImplementsInterfaces? Directives[Const]
         *  - extend interface Name ImplementsInterfaces
         */
        parseInterfaceTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * UnionTypeExtension :
         *   - extend union Name Directives[Const]? UnionMemberTypes
         *   - extend union Name Directives[Const]
         */
        parseUnionTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types2 = this.parseUnionMemberTypes();
          if (directives.length === 0 && types2.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_EXTENSION,
            name,
            directives,
            types: types2
          });
        }
        /**
         * EnumTypeExtension :
         *   - extend enum Name Directives[Const]? EnumValuesDefinition
         *   - extend enum Name Directives[Const]
         */
        parseEnumTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          if (directives.length === 0 && values.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
            name,
            directives,
            values
          });
        }
        /**
         * InputObjectTypeExtension :
         *   - extend input Name Directives[Const]? InputFieldsDefinition
         *   - extend input Name Directives[Const]
         */
        parseInputObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          if (directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            name,
            directives,
            fields
          });
        }
        /**
         * ```
         * DirectiveDefinition :
         *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
         * ```
         */
        parseDirectiveDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("directive");
          this.expectToken(_tokenKind.TokenKind.AT);
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          const repeatable = this.expectOptionalKeyword("repeatable");
          this.expectKeyword("on");
          const locations = this.parseDirectiveLocations();
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE_DEFINITION,
            description,
            name,
            arguments: args,
            repeatable,
            locations
          });
        }
        /**
         * DirectiveLocations :
         *   - `|`? DirectiveLocation
         *   - DirectiveLocations | DirectiveLocation
         */
        parseDirectiveLocations() {
          return this.delimitedMany(
            _tokenKind.TokenKind.PIPE,
            this.parseDirectiveLocation
          );
        }
        /*
         * DirectiveLocation :
         *   - ExecutableDirectiveLocation
         *   - TypeSystemDirectiveLocation
         *
         * ExecutableDirectiveLocation : one of
         *   `QUERY`
         *   `MUTATION`
         *   `SUBSCRIPTION`
         *   `FIELD`
         *   `FRAGMENT_DEFINITION`
         *   `FRAGMENT_SPREAD`
         *   `INLINE_FRAGMENT`
         *
         * TypeSystemDirectiveLocation : one of
         *   `SCHEMA`
         *   `SCALAR`
         *   `OBJECT`
         *   `FIELD_DEFINITION`
         *   `ARGUMENT_DEFINITION`
         *   `INTERFACE`
         *   `UNION`
         *   `ENUM`
         *   `ENUM_VALUE`
         *   `INPUT_OBJECT`
         *   `INPUT_FIELD_DEFINITION`
         */
        parseDirectiveLocation() {
          const start = this._lexer.token;
          const name = this.parseName();
          if (Object.prototype.hasOwnProperty.call(
            _directiveLocation.DirectiveLocation,
            name.value
          )) {
            return name;
          }
          throw this.unexpected(start);
        }
        // Core parsing utility functions
        /**
         * Returns a node that, if configured to do so, sets a "loc" field as a
         * location object, used to identify the place in the source that created a
         * given parsed object.
         */
        node(startToken, node) {
          if (this._options.noLocation !== true) {
            node.loc = new _ast.Location(
              startToken,
              this._lexer.lastToken,
              this._lexer.source
            );
          }
          return node;
        }
        /**
         * Determines if the next token is of a given kind
         */
        peek(kind) {
          return this._lexer.token.kind === kind;
        }
        /**
         * If the next token is of the given kind, return that token after advancing the lexer.
         * Otherwise, do not change the parser state and throw an error.
         */
        expectToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return token;
          }
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Expected ${getTokenKindDesc2(kind)}, found ${getTokenDesc2(token)}.`
          );
        }
        /**
         * If the next token is of the given kind, return "true" after advancing the lexer.
         * Otherwise, do not change the parser state and return "false".
         */
        expectOptionalToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        /**
         * If the next token is a given keyword, advance the lexer.
         * Otherwise, do not change the parser state and throw an error.
         */
        expectKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
          } else {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              token.start,
              `Expected "${value}", found ${getTokenDesc2(token)}.`
            );
          }
        }
        /**
         * If the next token is a given keyword, return "true" after advancing the lexer.
         * Otherwise, do not change the parser state and return "false".
         */
        expectOptionalKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        /**
         * Helper function for creating an error when an unexpected lexed token is encountered.
         */
        unexpected(atToken) {
          const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
          return (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Unexpected ${getTokenDesc2(token)}.`
          );
        }
        /**
         * Returns a possibly empty list of parse nodes, determined by the parseFn.
         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        any(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          while (!this.expectOptionalToken(closeKind)) {
            nodes.push(parseFn.call(this));
          }
          return nodes;
        }
        /**
         * Returns a list of parse nodes, determined by the parseFn.
         * It can be empty only if open token is missing otherwise it will always return non-empty list
         * that begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        optionalMany(openKind, parseFn, closeKind) {
          if (this.expectOptionalToken(openKind)) {
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (!this.expectOptionalToken(closeKind));
            return nodes;
          }
          return [];
        }
        /**
         * Returns a non-empty list of parse nodes, determined by the parseFn.
         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        many(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        /**
         * Returns a non-empty list of parse nodes, determined by the parseFn.
         * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
         * Advances the parser to the next lex token after last item in the list.
         */
        delimitedMany(delimiterKind, parseFn) {
          this.expectOptionalToken(delimiterKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (this.expectOptionalToken(delimiterKind));
          return nodes;
        }
        advanceLexer() {
          const { maxTokens } = this._options;
          const token = this._lexer.advance();
          if (maxTokens !== void 0 && token.kind !== _tokenKind.TokenKind.EOF) {
            ++this._tokenCounter;
            if (this._tokenCounter > maxTokens) {
              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                token.start,
                `Document contains more that ${maxTokens} tokens. Parsing aborted.`
              );
            }
          }
        }
      };
      exports.Parser = Parser2;
      function getTokenDesc2(token) {
        const value = token.value;
        return getTokenKindDesc2(token.kind) + (value != null ? ` "${value}"` : "");
      }
      function getTokenKindDesc2(kind) {
        return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printString.js
  var require_printString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printString = printString2;
      function printString2(str) {
        return `"${str.replace(escapedRegExp2, escapedReplacer2)}"`;
      }
      var escapedRegExp2 = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
      function escapedReplacer2(str) {
        return escapeSequences2[str.charCodeAt(0)];
      }
      var escapeSequences2 = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000B",
        "\\f",
        "\\r",
        "\\u000E",
        "\\u000F",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001A",
        "\\u001B",
        "\\u001C",
        "\\u001D",
        "\\u001E",
        "\\u001F",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 2F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 3F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 4F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        // 5F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 6F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\u007F",
        "\\u0080",
        "\\u0081",
        "\\u0082",
        "\\u0083",
        "\\u0084",
        "\\u0085",
        "\\u0086",
        "\\u0087",
        "\\u0088",
        "\\u0089",
        "\\u008A",
        "\\u008B",
        "\\u008C",
        "\\u008D",
        "\\u008E",
        "\\u008F",
        "\\u0090",
        "\\u0091",
        "\\u0092",
        "\\u0093",
        "\\u0094",
        "\\u0095",
        "\\u0096",
        "\\u0097",
        "\\u0098",
        "\\u0099",
        "\\u009A",
        "\\u009B",
        "\\u009C",
        "\\u009D",
        "\\u009E",
        "\\u009F"
      ];
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/visitor.js
  var require_visitor2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/visitor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BREAK = void 0;
      exports.getEnterLeaveForKind = getEnterLeaveForKind2;
      exports.getVisitFn = getVisitFn2;
      exports.visit = visit2;
      exports.visitInParallel = visitInParallel2;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _ast = require_ast2();
      var _kinds = require_kinds();
      var BREAK2 = Object.freeze({});
      exports.BREAK = BREAK2;
      function visit2(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
        const enterLeaveMap = /* @__PURE__ */ new Map();
        for (const kind of Object.values(_kinds.Kind)) {
          enterLeaveMap.set(kind, getEnterLeaveForKind2(visitor, kind));
        }
        let stack = void 0;
        let inArray = Array.isArray(root);
        let keys4 = [root];
        let index = -1;
        let edits = [];
        let node = root;
        let key = void 0;
        let parent = void 0;
        const path5 = [];
        const ancestors = [];
        do {
          index++;
          const isLeaving = index === keys4.length;
          const isEdited = isLeaving && edits.length !== 0;
          if (isLeaving) {
            key = ancestors.length === 0 ? void 0 : path5[path5.length - 1];
            node = parent;
            parent = ancestors.pop();
            if (isEdited) {
              if (inArray) {
                node = node.slice();
                let editOffset = 0;
                for (const [editKey, editValue] of edits) {
                  const arrayKey = editKey - editOffset;
                  if (editValue === null) {
                    node.splice(arrayKey, 1);
                    editOffset++;
                  } else {
                    node[arrayKey] = editValue;
                  }
                }
              } else {
                node = Object.defineProperties(
                  {},
                  Object.getOwnPropertyDescriptors(node)
                );
                for (const [editKey, editValue] of edits) {
                  node[editKey] = editValue;
                }
              }
            }
            index = stack.index;
            keys4 = stack.keys;
            edits = stack.edits;
            inArray = stack.inArray;
            stack = stack.prev;
          } else if (parent) {
            key = inArray ? index : keys4[index];
            node = parent[key];
            if (node === null || node === void 0) {
              continue;
            }
            path5.push(key);
          }
          let result;
          if (!Array.isArray(node)) {
            var _enterLeaveMap$get, _enterLeaveMap$get2;
            (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
              false,
              `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
            );
            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path5, ancestors);
            if (result === BREAK2) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path5.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path5.pop();
                  continue;
                }
              }
            }
          }
          if (result === void 0 && isEdited) {
            edits.push([key, node]);
          }
          if (isLeaving) {
            path5.pop();
          } else {
            var _node$kind;
            stack = {
              inArray,
              index,
              keys: keys4,
              edits,
              prev: stack
            };
            inArray = Array.isArray(node);
            keys4 = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
            index = -1;
            edits = [];
            if (parent) {
              ancestors.push(parent);
            }
            parent = node;
          }
        } while (stack !== void 0);
        if (edits.length !== 0) {
          return edits[edits.length - 1][1];
        }
        return root;
      }
      function visitInParallel2(visitors) {
        const skipping = new Array(visitors.length).fill(null);
        const mergedVisitor = /* @__PURE__ */ Object.create(null);
        for (const kind of Object.values(_kinds.Kind)) {
          let hasVisitor = false;
          const enterList = new Array(visitors.length).fill(void 0);
          const leaveList = new Array(visitors.length).fill(void 0);
          for (let i = 0; i < visitors.length; ++i) {
            const { enter, leave } = getEnterLeaveForKind2(visitors[i], kind);
            hasVisitor || (hasVisitor = enter != null || leave != null);
            enterList[i] = enter;
            leaveList[i] = leave;
          }
          if (!hasVisitor) {
            continue;
          }
          const mergedEnterLeave = {
            enter(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _enterList$i;
                  const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                  if (result === false) {
                    skipping[i] = node;
                  } else if (result === BREAK2) {
                    skipping[i] = BREAK2;
                  } else if (result !== void 0) {
                    return result;
                  }
                }
              }
            },
            leave(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _leaveList$i;
                  const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                  if (result === BREAK2) {
                    skipping[i] = BREAK2;
                  } else if (result !== void 0 && result !== false) {
                    return result;
                  }
                } else if (skipping[i] === node) {
                  skipping[i] = null;
                }
              }
            }
          };
          mergedVisitor[kind] = mergedEnterLeave;
        }
        return mergedVisitor;
      }
      function getEnterLeaveForKind2(visitor, kind) {
        const kindVisitor = visitor[kind];
        if (typeof kindVisitor === "object") {
          return kindVisitor;
        } else if (typeof kindVisitor === "function") {
          return {
            enter: kindVisitor,
            leave: void 0
          };
        }
        return {
          enter: visitor.enter,
          leave: visitor.leave
        };
      }
      function getVisitFn2(visitor, kind, isLeaving) {
        const { enter, leave } = getEnterLeaveForKind2(visitor, kind);
        return isLeaving ? leave : enter;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printer.js
  var require_printer2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.print = print2;
      var _blockString = require_blockString();
      var _printString = require_printString();
      var _visitor = require_visitor2();
      function print2(ast) {
        return (0, _visitor.visit)(ast, printDocASTReducer2);
      }
      var MAX_LINE_LENGTH2 = 80;
      var printDocASTReducer2 = {
        Name: {
          leave: (node) => node.value
        },
        Variable: {
          leave: (node) => "$" + node.name
        },
        // Document
        Document: {
          leave: (node) => join10(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave(node) {
            const varDefs = wrap2("(", join10(node.variableDefinitions, ", "), ")");
            const prefix = join10(
              [
                node.operation,
                join10([node.name, varDefs]),
                join10(node.directives, " ")
              ],
              " "
            );
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type: type3, defaultValue, directives }) => variable + ": " + type3 + wrap2(" = ", defaultValue) + wrap2(" ", join10(directives, " "))
        },
        SelectionSet: {
          leave: ({ selections }) => block2(selections)
        },
        Field: {
          leave({ alias, name, arguments: args, directives, selectionSet }) {
            const prefix = wrap2("", alias, ": ") + name;
            let argsLine = prefix + wrap2("(", join10(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH2) {
              argsLine = prefix + wrap2("(\n", indent2(join10(args, "\n")), "\n)");
            }
            return join10([argsLine, join10(directives, " "), selectionSet], " ");
          }
        },
        Argument: {
          leave: ({ name, value }) => name + ": " + value
        },
        // Fragments
        FragmentSpread: {
          leave: ({ name, directives }) => "..." + name + wrap2(" ", join10(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join10(
            [
              "...",
              wrap2("on ", typeCondition),
              join10(directives, " "),
              selectionSet
            ],
            " "
          )
        },
        FragmentDefinition: {
          leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
            // or removed in the future.
            `fragment ${name}${wrap2("(", join10(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join10(directives, " "), " ")}` + selectionSet
          )
        },
        // Value
        IntValue: {
          leave: ({ value }) => value
        },
        FloatValue: {
          leave: ({ value }) => value
        },
        StringValue: {
          leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
        },
        BooleanValue: {
          leave: ({ value }) => value ? "true" : "false"
        },
        NullValue: {
          leave: () => "null"
        },
        EnumValue: {
          leave: ({ value }) => value
        },
        ListValue: {
          leave: ({ values }) => "[" + join10(values, ", ") + "]"
        },
        ObjectValue: {
          leave: ({ fields }) => "{" + join10(fields, ", ") + "}"
        },
        ObjectField: {
          leave: ({ name, value }) => name + ": " + value
        },
        // Directive
        Directive: {
          leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join10(args, ", "), ")")
        },
        // Type
        NamedType: {
          leave: ({ name }) => name
        },
        ListType: {
          leave: ({ type: type3 }) => "[" + type3 + "]"
        },
        NonNullType: {
          leave: ({ type: type3 }) => type3 + "!"
        },
        // Type System Definitions
        SchemaDefinition: {
          leave: ({ description, directives, operationTypes }) => wrap2("", description, "\n") + join10(["schema", join10(directives, " "), block2(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type: type3 }) => operation + ": " + type3
        },
        ScalarTypeDefinition: {
          leave: ({ description, name, directives }) => wrap2("", description, "\n") + join10(["scalar", name, join10(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join10(
            [
              "type",
              name,
              wrap2("implements ", join10(interfaces, " & ")),
              join10(directives, " "),
              block2(fields)
            ],
            " "
          )
        },
        FieldDefinition: {
          leave: ({ description, name, arguments: args, type: type3, directives }) => wrap2("", description, "\n") + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join10(args, "\n")), "\n)") : wrap2("(", join10(args, ", "), ")")) + ": " + type3 + wrap2(" ", join10(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ description, name, type: type3, defaultValue, directives }) => wrap2("", description, "\n") + join10(
            [name + ": " + type3, wrap2("= ", defaultValue), join10(directives, " ")],
            " "
          )
        },
        InterfaceTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join10(
            [
              "interface",
              name,
              wrap2("implements ", join10(interfaces, " & ")),
              join10(directives, " "),
              block2(fields)
            ],
            " "
          )
        },
        UnionTypeDefinition: {
          leave: ({ description, name, directives, types: types2 }) => wrap2("", description, "\n") + join10(
            ["union", name, join10(directives, " "), wrap2("= ", join10(types2, " | "))],
            " "
          )
        },
        EnumTypeDefinition: {
          leave: ({ description, name, directives, values }) => wrap2("", description, "\n") + join10(["enum", name, join10(directives, " "), block2(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ description, name, directives }) => wrap2("", description, "\n") + join10([name, join10(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ description, name, directives, fields }) => wrap2("", description, "\n") + join10(["input", name, join10(directives, " "), block2(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ description, name, arguments: args, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join10(args, "\n")), "\n)") : wrap2("(", join10(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join10(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join10(
            ["extend schema", join10(directives, " "), block2(operationTypes)],
            " "
          )
        },
        ScalarTypeExtension: {
          leave: ({ name, directives }) => join10(["extend scalar", name, join10(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join10(
            [
              "extend type",
              name,
              wrap2("implements ", join10(interfaces, " & ")),
              join10(directives, " "),
              block2(fields)
            ],
            " "
          )
        },
        InterfaceTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join10(
            [
              "extend interface",
              name,
              wrap2("implements ", join10(interfaces, " & ")),
              join10(directives, " "),
              block2(fields)
            ],
            " "
          )
        },
        UnionTypeExtension: {
          leave: ({ name, directives, types: types2 }) => join10(
            [
              "extend union",
              name,
              join10(directives, " "),
              wrap2("= ", join10(types2, " | "))
            ],
            " "
          )
        },
        EnumTypeExtension: {
          leave: ({ name, directives, values }) => join10(["extend enum", name, join10(directives, " "), block2(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name, directives, fields }) => join10(["extend input", name, join10(directives, " "), block2(fields)], " ")
        }
      };
      function join10(maybeArray, separator = "") {
        var _maybeArray$filter$jo;
        return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
      }
      function block2(array2) {
        return wrap2("{\n", indent2(join10(array2, "\n")), "\n}");
      }
      function wrap2(start, maybeString, end = "") {
        return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
      }
      function indent2(str) {
        return wrap2("  ", str.replace(/\n/g, "\n  "));
      }
      function hasMultilineItems2(maybeArray) {
        var _maybeArray$some;
        return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
      }
    }
  });

  // ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/ReactNativeFile.js
  var require_ReactNativeFile = __commonJS({
    "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/ReactNativeFile.js"(exports, module) {
      "use strict";
      module.exports = function ReactNativeFile(_ref) {
        var uri = _ref.uri, name = _ref.name, type3 = _ref.type;
        this.uri = uri;
        this.name = name;
        this.type = type3;
      };
    }
  });

  // ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/isExtractableFile.js
  var require_isExtractableFile = __commonJS({
    "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/isExtractableFile.js"(exports, module) {
      "use strict";
      var ReactNativeFile = require_ReactNativeFile();
      module.exports = function isExtractableFile(value) {
        return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile;
      };
    }
  });

  // ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/extractFiles.js
  var require_extractFiles = __commonJS({
    "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/extractFiles.js"(exports, module) {
      "use strict";
      var defaultIsExtractableFile = require_isExtractableFile();
      module.exports = function extractFiles(value, path5, isExtractableFile) {
        if (path5 === void 0) {
          path5 = "";
        }
        if (isExtractableFile === void 0) {
          isExtractableFile = defaultIsExtractableFile;
        }
        var clone5;
        var files = /* @__PURE__ */ new Map();
        function addFile(paths, file) {
          var storedPaths = files.get(file);
          if (storedPaths)
            storedPaths.push.apply(storedPaths, paths);
          else
            files.set(file, paths);
        }
        if (isExtractableFile(value)) {
          clone5 = null;
          addFile([path5], value);
        } else {
          var prefix = path5 ? path5 + "." : "";
          if (typeof FileList !== "undefined" && value instanceof FileList)
            clone5 = Array.prototype.map.call(value, function(file, i2) {
              addFile(["" + prefix + i2], file);
              return null;
            });
          else if (Array.isArray(value))
            clone5 = value.map(function(child, i2) {
              var result2 = extractFiles(child, "" + prefix + i2, isExtractableFile);
              result2.files.forEach(addFile);
              return result2.clone;
            });
          else if (value && value.constructor === Object) {
            clone5 = {};
            for (var i in value) {
              var result = extractFiles(value[i], "" + prefix + i, isExtractableFile);
              result.files.forEach(addFile);
              clone5[i] = result.clone;
            }
          } else
            clone5 = value;
        }
        return {
          clone: clone5,
          files
        };
      };
    }
  });

  // ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/index.js
  var require_public = __commonJS({
    "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/index.js"(exports) {
      "use strict";
      exports.ReactNativeFile = require_ReactNativeFile();
      exports.extractFiles = require_extractFiles();
      exports.isExtractableFile = require_isExtractableFile();
    }
  });

  // ../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
  var require_delayed_stream = __commonJS({
    "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
      var Stream3 = __require2("stream").Stream;
      var util = __require2("util");
      module.exports = DelayedStream;
      function DelayedStream() {
        this.source = null;
        this.dataSize = 0;
        this.maxDataSize = 1024 * 1024;
        this.pauseStream = true;
        this._maxDataSizeExceeded = false;
        this._released = false;
        this._bufferedEvents = [];
      }
      util.inherits(DelayedStream, Stream3);
      DelayedStream.create = function(source, options) {
        var delayedStream = new this();
        options = options || {};
        for (var option in options) {
          delayedStream[option] = options[option];
        }
        delayedStream.source = source;
        var realEmit = source.emit;
        source.emit = function() {
          delayedStream._handleEmit(arguments);
          return realEmit.apply(source, arguments);
        };
        source.on("error", function() {
        });
        if (delayedStream.pauseStream) {
          source.pause();
        }
        return delayedStream;
      };
      Object.defineProperty(DelayedStream.prototype, "readable", {
        configurable: true,
        enumerable: true,
        get: function() {
          return this.source.readable;
        }
      });
      DelayedStream.prototype.setEncoding = function() {
        return this.source.setEncoding.apply(this.source, arguments);
      };
      DelayedStream.prototype.resume = function() {
        if (!this._released) {
          this.release();
        }
        this.source.resume();
      };
      DelayedStream.prototype.pause = function() {
        this.source.pause();
      };
      DelayedStream.prototype.release = function() {
        this._released = true;
        this._bufferedEvents.forEach(function(args) {
          this.emit.apply(this, args);
        }.bind(this));
        this._bufferedEvents = [];
      };
      DelayedStream.prototype.pipe = function() {
        var r = Stream3.prototype.pipe.apply(this, arguments);
        this.resume();
        return r;
      };
      DelayedStream.prototype._handleEmit = function(args) {
        if (this._released) {
          this.emit.apply(this, args);
          return;
        }
        if (args[0] === "data") {
          this.dataSize += args[1].length;
          this._checkIfMaxDataSizeExceeded();
        }
        this._bufferedEvents.push(args);
      };
      DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
        if (this._maxDataSizeExceeded) {
          return;
        }
        if (this.dataSize <= this.maxDataSize) {
          return;
        }
        this._maxDataSizeExceeded = true;
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this.emit("error", new Error(message));
      };
    }
  });

  // ../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
  var require_combined_stream = __commonJS({
    "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
      var util = __require2("util");
      var Stream3 = __require2("stream").Stream;
      var DelayedStream = require_delayed_stream();
      module.exports = CombinedStream;
      function CombinedStream() {
        this.writable = false;
        this.readable = true;
        this.dataSize = 0;
        this.maxDataSize = 2 * 1024 * 1024;
        this.pauseStreams = true;
        this._released = false;
        this._streams = [];
        this._currentStream = null;
        this._insideLoop = false;
        this._pendingNext = false;
      }
      util.inherits(CombinedStream, Stream3);
      CombinedStream.create = function(options) {
        var combinedStream = new this();
        options = options || {};
        for (var option in options) {
          combinedStream[option] = options[option];
        }
        return combinedStream;
      };
      CombinedStream.isStreamLike = function(stream2) {
        return typeof stream2 !== "function" && typeof stream2 !== "string" && typeof stream2 !== "boolean" && typeof stream2 !== "number" && !Buffer.isBuffer(stream2);
      };
      CombinedStream.prototype.append = function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          if (!(stream2 instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream2, {
              maxDataSize: Infinity,
              pauseStream: this.pauseStreams
            });
            stream2.on("data", this._checkDataSize.bind(this));
            stream2 = newStream;
          }
          this._handleErrors(stream2);
          if (this.pauseStreams) {
            stream2.pause();
          }
        }
        this._streams.push(stream2);
        return this;
      };
      CombinedStream.prototype.pipe = function(dest, options) {
        Stream3.prototype.pipe.call(this, dest, options);
        this.resume();
        return dest;
      };
      CombinedStream.prototype._getNext = function() {
        this._currentStream = null;
        if (this._insideLoop) {
          this._pendingNext = true;
          return;
        }
        this._insideLoop = true;
        try {
          do {
            this._pendingNext = false;
            this._realGetNext();
          } while (this._pendingNext);
        } finally {
          this._insideLoop = false;
        }
      };
      CombinedStream.prototype._realGetNext = function() {
        var stream2 = this._streams.shift();
        if (typeof stream2 == "undefined") {
          this.end();
          return;
        }
        if (typeof stream2 !== "function") {
          this._pipeNext(stream2);
          return;
        }
        var getStream = stream2;
        getStream(function(stream3) {
          var isStreamLike = CombinedStream.isStreamLike(stream3);
          if (isStreamLike) {
            stream3.on("data", this._checkDataSize.bind(this));
            this._handleErrors(stream3);
          }
          this._pipeNext(stream3);
        }.bind(this));
      };
      CombinedStream.prototype._pipeNext = function(stream2) {
        this._currentStream = stream2;
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("end", this._getNext.bind(this));
          stream2.pipe(this, { end: false });
          return;
        }
        var value = stream2;
        this.write(value);
        this._getNext();
      };
      CombinedStream.prototype._handleErrors = function(stream2) {
        var self2 = this;
        stream2.on("error", function(err) {
          self2._emitError(err);
        });
      };
      CombinedStream.prototype.write = function(data) {
        this.emit("data", data);
      };
      CombinedStream.prototype.pause = function() {
        if (!this.pauseStreams) {
          return;
        }
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
          this._currentStream.pause();
        this.emit("pause");
      };
      CombinedStream.prototype.resume = function() {
        if (!this._released) {
          this._released = true;
          this.writable = true;
          this._getNext();
        }
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
          this._currentStream.resume();
        this.emit("resume");
      };
      CombinedStream.prototype.end = function() {
        this._reset();
        this.emit("end");
      };
      CombinedStream.prototype.destroy = function() {
        this._reset();
        this.emit("close");
      };
      CombinedStream.prototype._reset = function() {
        this.writable = false;
        this._streams = [];
        this._currentStream = null;
      };
      CombinedStream.prototype._checkDataSize = function() {
        this._updateDataSize();
        if (this.dataSize <= this.maxDataSize) {
          return;
        }
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this._emitError(new Error(message));
      };
      CombinedStream.prototype._updateDataSize = function() {
        this.dataSize = 0;
        var self2 = this;
        this._streams.forEach(function(stream2) {
          if (!stream2.dataSize) {
            return;
          }
          self2.dataSize += stream2.dataSize;
        });
        if (this._currentStream && this._currentStream.dataSize) {
          this.dataSize += this._currentStream.dataSize;
        }
      };
      CombinedStream.prototype._emitError = function(err) {
        this._reset();
        this.emit("error", err);
      };
    }
  });

  // ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
  var require_db = __commonJS({
    "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports, module) {
      module.exports = {
        "application/1d-interleaved-parityfec": {
          source: "iana"
        },
        "application/3gpdash-qoe-report+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/3gpp-ims+xml": {
          source: "iana",
          compressible: true
        },
        "application/3gpphal+json": {
          source: "iana",
          compressible: true
        },
        "application/3gpphalforms+json": {
          source: "iana",
          compressible: true
        },
        "application/a2l": {
          source: "iana"
        },
        "application/ace+cbor": {
          source: "iana"
        },
        "application/activemessage": {
          source: "iana"
        },
        "application/activity+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-directory+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcost+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcostparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointprop+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointpropparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-error+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamcontrol+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamparams+json": {
          source: "iana",
          compressible: true
        },
        "application/aml": {
          source: "iana"
        },
        "application/andrew-inset": {
          source: "iana",
          extensions: ["ez"]
        },
        "application/applefile": {
          source: "iana"
        },
        "application/applixware": {
          source: "apache",
          extensions: ["aw"]
        },
        "application/at+jwt": {
          source: "iana"
        },
        "application/atf": {
          source: "iana"
        },
        "application/atfx": {
          source: "iana"
        },
        "application/atom+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atom"]
        },
        "application/atomcat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomcat"]
        },
        "application/atomdeleted+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomdeleted"]
        },
        "application/atomicmail": {
          source: "iana"
        },
        "application/atomsvc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomsvc"]
        },
        "application/atsc-dwd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dwd"]
        },
        "application/atsc-dynamic-event-message": {
          source: "iana"
        },
        "application/atsc-held+xml": {
          source: "iana",
          compressible: true,
          extensions: ["held"]
        },
        "application/atsc-rdt+json": {
          source: "iana",
          compressible: true
        },
        "application/atsc-rsat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsat"]
        },
        "application/atxml": {
          source: "iana"
        },
        "application/auth-policy+xml": {
          source: "iana",
          compressible: true
        },
        "application/bacnet-xdd+zip": {
          source: "iana",
          compressible: false
        },
        "application/batch-smtp": {
          source: "iana"
        },
        "application/bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/beep+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/calendar+json": {
          source: "iana",
          compressible: true
        },
        "application/calendar+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xcs"]
        },
        "application/call-completion": {
          source: "iana"
        },
        "application/cals-1840": {
          source: "iana"
        },
        "application/captive+json": {
          source: "iana",
          compressible: true
        },
        "application/cbor": {
          source: "iana"
        },
        "application/cbor-seq": {
          source: "iana"
        },
        "application/cccex": {
          source: "iana"
        },
        "application/ccmp+xml": {
          source: "iana",
          compressible: true
        },
        "application/ccxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ccxml"]
        },
        "application/cdfx+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdfx"]
        },
        "application/cdmi-capability": {
          source: "iana",
          extensions: ["cdmia"]
        },
        "application/cdmi-container": {
          source: "iana",
          extensions: ["cdmic"]
        },
        "application/cdmi-domain": {
          source: "iana",
          extensions: ["cdmid"]
        },
        "application/cdmi-object": {
          source: "iana",
          extensions: ["cdmio"]
        },
        "application/cdmi-queue": {
          source: "iana",
          extensions: ["cdmiq"]
        },
        "application/cdni": {
          source: "iana"
        },
        "application/cea": {
          source: "iana"
        },
        "application/cea-2018+xml": {
          source: "iana",
          compressible: true
        },
        "application/cellml+xml": {
          source: "iana",
          compressible: true
        },
        "application/cfw": {
          source: "iana"
        },
        "application/city+json": {
          source: "iana",
          compressible: true
        },
        "application/clr": {
          source: "iana"
        },
        "application/clue+xml": {
          source: "iana",
          compressible: true
        },
        "application/clue_info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cms": {
          source: "iana"
        },
        "application/cnrp+xml": {
          source: "iana",
          compressible: true
        },
        "application/coap-group+json": {
          source: "iana",
          compressible: true
        },
        "application/coap-payload": {
          source: "iana"
        },
        "application/commonground": {
          source: "iana"
        },
        "application/conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cose": {
          source: "iana"
        },
        "application/cose-key": {
          source: "iana"
        },
        "application/cose-key-set": {
          source: "iana"
        },
        "application/cpl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cpl"]
        },
        "application/csrattrs": {
          source: "iana"
        },
        "application/csta+xml": {
          source: "iana",
          compressible: true
        },
        "application/cstadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/csvm+json": {
          source: "iana",
          compressible: true
        },
        "application/cu-seeme": {
          source: "apache",
          extensions: ["cu"]
        },
        "application/cwt": {
          source: "iana"
        },
        "application/cybercash": {
          source: "iana"
        },
        "application/dart": {
          compressible: true
        },
        "application/dash+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpd"]
        },
        "application/dash-patch+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpp"]
        },
        "application/dashdelta": {
          source: "iana"
        },
        "application/davmount+xml": {
          source: "iana",
          compressible: true,
          extensions: ["davmount"]
        },
        "application/dca-rft": {
          source: "iana"
        },
        "application/dcd": {
          source: "iana"
        },
        "application/dec-dx": {
          source: "iana"
        },
        "application/dialog-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/dicom": {
          source: "iana"
        },
        "application/dicom+json": {
          source: "iana",
          compressible: true
        },
        "application/dicom+xml": {
          source: "iana",
          compressible: true
        },
        "application/dii": {
          source: "iana"
        },
        "application/dit": {
          source: "iana"
        },
        "application/dns": {
          source: "iana"
        },
        "application/dns+json": {
          source: "iana",
          compressible: true
        },
        "application/dns-message": {
          source: "iana"
        },
        "application/docbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dbk"]
        },
        "application/dots+cbor": {
          source: "iana"
        },
        "application/dskpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/dssc+der": {
          source: "iana",
          extensions: ["dssc"]
        },
        "application/dssc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdssc"]
        },
        "application/dvcs": {
          source: "iana"
        },
        "application/ecmascript": {
          source: "iana",
          compressible: true,
          extensions: ["es", "ecma"]
        },
        "application/edi-consent": {
          source: "iana"
        },
        "application/edi-x12": {
          source: "iana",
          compressible: false
        },
        "application/edifact": {
          source: "iana",
          compressible: false
        },
        "application/efi": {
          source: "iana"
        },
        "application/elm+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/elm+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.cap+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/emergencycalldata.comment+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.control+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.deviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.ecall.msd": {
          source: "iana"
        },
        "application/emergencycalldata.providerinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.serviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.subscriberinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.veds+xml": {
          source: "iana",
          compressible: true
        },
        "application/emma+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emma"]
        },
        "application/emotionml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emotionml"]
        },
        "application/encaprtp": {
          source: "iana"
        },
        "application/epp+xml": {
          source: "iana",
          compressible: true
        },
        "application/epub+zip": {
          source: "iana",
          compressible: false,
          extensions: ["epub"]
        },
        "application/eshop": {
          source: "iana"
        },
        "application/exi": {
          source: "iana",
          extensions: ["exi"]
        },
        "application/expect-ct-report+json": {
          source: "iana",
          compressible: true
        },
        "application/express": {
          source: "iana",
          extensions: ["exp"]
        },
        "application/fastinfoset": {
          source: "iana"
        },
        "application/fastsoap": {
          source: "iana"
        },
        "application/fdt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fdt"]
        },
        "application/fhir+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fhir+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fido.trusted-apps+json": {
          compressible: true
        },
        "application/fits": {
          source: "iana"
        },
        "application/flexfec": {
          source: "iana"
        },
        "application/font-sfnt": {
          source: "iana"
        },
        "application/font-tdpfr": {
          source: "iana",
          extensions: ["pfr"]
        },
        "application/font-woff": {
          source: "iana",
          compressible: false
        },
        "application/framework-attributes+xml": {
          source: "iana",
          compressible: true
        },
        "application/geo+json": {
          source: "iana",
          compressible: true,
          extensions: ["geojson"]
        },
        "application/geo+json-seq": {
          source: "iana"
        },
        "application/geopackage+sqlite3": {
          source: "iana"
        },
        "application/geoxacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/gltf-buffer": {
          source: "iana"
        },
        "application/gml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["gml"]
        },
        "application/gpx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["gpx"]
        },
        "application/gxf": {
          source: "apache",
          extensions: ["gxf"]
        },
        "application/gzip": {
          source: "iana",
          compressible: false,
          extensions: ["gz"]
        },
        "application/h224": {
          source: "iana"
        },
        "application/held+xml": {
          source: "iana",
          compressible: true
        },
        "application/hjson": {
          extensions: ["hjson"]
        },
        "application/http": {
          source: "iana"
        },
        "application/hyperstudio": {
          source: "iana",
          extensions: ["stk"]
        },
        "application/ibe-key-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pkg-reply+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pp-data": {
          source: "iana"
        },
        "application/iges": {
          source: "iana"
        },
        "application/im-iscomposing+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/index": {
          source: "iana"
        },
        "application/index.cmd": {
          source: "iana"
        },
        "application/index.obj": {
          source: "iana"
        },
        "application/index.response": {
          source: "iana"
        },
        "application/index.vnd": {
          source: "iana"
        },
        "application/inkml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ink", "inkml"]
        },
        "application/iotp": {
          source: "iana"
        },
        "application/ipfix": {
          source: "iana",
          extensions: ["ipfix"]
        },
        "application/ipp": {
          source: "iana"
        },
        "application/isup": {
          source: "iana"
        },
        "application/its+xml": {
          source: "iana",
          compressible: true,
          extensions: ["its"]
        },
        "application/java-archive": {
          source: "apache",
          compressible: false,
          extensions: ["jar", "war", "ear"]
        },
        "application/java-serialized-object": {
          source: "apache",
          compressible: false,
          extensions: ["ser"]
        },
        "application/java-vm": {
          source: "apache",
          compressible: false,
          extensions: ["class"]
        },
        "application/javascript": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["js", "mjs"]
        },
        "application/jf2feed+json": {
          source: "iana",
          compressible: true
        },
        "application/jose": {
          source: "iana"
        },
        "application/jose+json": {
          source: "iana",
          compressible: true
        },
        "application/jrd+json": {
          source: "iana",
          compressible: true
        },
        "application/jscalendar+json": {
          source: "iana",
          compressible: true
        },
        "application/json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["json", "map"]
        },
        "application/json-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/json-seq": {
          source: "iana"
        },
        "application/json5": {
          extensions: ["json5"]
        },
        "application/jsonml+json": {
          source: "apache",
          compressible: true,
          extensions: ["jsonml"]
        },
        "application/jwk+json": {
          source: "iana",
          compressible: true
        },
        "application/jwk-set+json": {
          source: "iana",
          compressible: true
        },
        "application/jwt": {
          source: "iana"
        },
        "application/kpml-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/kpml-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/ld+json": {
          source: "iana",
          compressible: true,
          extensions: ["jsonld"]
        },
        "application/lgr+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lgr"]
        },
        "application/link-format": {
          source: "iana"
        },
        "application/load-control+xml": {
          source: "iana",
          compressible: true
        },
        "application/lost+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lostxml"]
        },
        "application/lostsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/lpf+zip": {
          source: "iana",
          compressible: false
        },
        "application/lxf": {
          source: "iana"
        },
        "application/mac-binhex40": {
          source: "iana",
          extensions: ["hqx"]
        },
        "application/mac-compactpro": {
          source: "apache",
          extensions: ["cpt"]
        },
        "application/macwriteii": {
          source: "iana"
        },
        "application/mads+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mads"]
        },
        "application/manifest+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["webmanifest"]
        },
        "application/marc": {
          source: "iana",
          extensions: ["mrc"]
        },
        "application/marcxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mrcx"]
        },
        "application/mathematica": {
          source: "iana",
          extensions: ["ma", "nb", "mb"]
        },
        "application/mathml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mathml"]
        },
        "application/mathml-content+xml": {
          source: "iana",
          compressible: true
        },
        "application/mathml-presentation+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-associated-procedure-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-deregister+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-envelope+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-protection-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-reception-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-schedule+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-user-service-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbox": {
          source: "iana",
          extensions: ["mbox"]
        },
        "application/media-policy-dataset+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpf"]
        },
        "application/media_control+xml": {
          source: "iana",
          compressible: true
        },
        "application/mediaservercontrol+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mscml"]
        },
        "application/merge-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/metalink+xml": {
          source: "apache",
          compressible: true,
          extensions: ["metalink"]
        },
        "application/metalink4+xml": {
          source: "iana",
          compressible: true,
          extensions: ["meta4"]
        },
        "application/mets+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mets"]
        },
        "application/mf4": {
          source: "iana"
        },
        "application/mikey": {
          source: "iana"
        },
        "application/mipc": {
          source: "iana"
        },
        "application/missing-blocks+cbor-seq": {
          source: "iana"
        },
        "application/mmt-aei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["maei"]
        },
        "application/mmt-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musd"]
        },
        "application/mods+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mods"]
        },
        "application/moss-keys": {
          source: "iana"
        },
        "application/moss-signature": {
          source: "iana"
        },
        "application/mosskey-data": {
          source: "iana"
        },
        "application/mosskey-request": {
          source: "iana"
        },
        "application/mp21": {
          source: "iana",
          extensions: ["m21", "mp21"]
        },
        "application/mp4": {
          source: "iana",
          extensions: ["mp4s", "m4p"]
        },
        "application/mpeg4-generic": {
          source: "iana"
        },
        "application/mpeg4-iod": {
          source: "iana"
        },
        "application/mpeg4-iod-xmt": {
          source: "iana"
        },
        "application/mrb-consumer+xml": {
          source: "iana",
          compressible: true
        },
        "application/mrb-publish+xml": {
          source: "iana",
          compressible: true
        },
        "application/msc-ivr+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msc-mixer+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msword": {
          source: "iana",
          compressible: false,
          extensions: ["doc", "dot"]
        },
        "application/mud+json": {
          source: "iana",
          compressible: true
        },
        "application/multipart-core": {
          source: "iana"
        },
        "application/mxf": {
          source: "iana",
          extensions: ["mxf"]
        },
        "application/n-quads": {
          source: "iana",
          extensions: ["nq"]
        },
        "application/n-triples": {
          source: "iana",
          extensions: ["nt"]
        },
        "application/nasdata": {
          source: "iana"
        },
        "application/news-checkgroups": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-groupinfo": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-transmission": {
          source: "iana"
        },
        "application/nlsml+xml": {
          source: "iana",
          compressible: true
        },
        "application/node": {
          source: "iana",
          extensions: ["cjs"]
        },
        "application/nss": {
          source: "iana"
        },
        "application/oauth-authz-req+jwt": {
          source: "iana"
        },
        "application/oblivious-dns-message": {
          source: "iana"
        },
        "application/ocsp-request": {
          source: "iana"
        },
        "application/ocsp-response": {
          source: "iana"
        },
        "application/octet-stream": {
          source: "iana",
          compressible: false,
          extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
        },
        "application/oda": {
          source: "iana",
          extensions: ["oda"]
        },
        "application/odm+xml": {
          source: "iana",
          compressible: true
        },
        "application/odx": {
          source: "iana"
        },
        "application/oebps-package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["opf"]
        },
        "application/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogx"]
        },
        "application/omdoc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["omdoc"]
        },
        "application/onenote": {
          source: "apache",
          extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
        },
        "application/opc-nodeset+xml": {
          source: "iana",
          compressible: true
        },
        "application/oscore": {
          source: "iana"
        },
        "application/oxps": {
          source: "iana",
          extensions: ["oxps"]
        },
        "application/p21": {
          source: "iana"
        },
        "application/p21+zip": {
          source: "iana",
          compressible: false
        },
        "application/p2p-overlay+xml": {
          source: "iana",
          compressible: true,
          extensions: ["relo"]
        },
        "application/parityfec": {
          source: "iana"
        },
        "application/passport": {
          source: "iana"
        },
        "application/patch-ops-error+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xer"]
        },
        "application/pdf": {
          source: "iana",
          compressible: false,
          extensions: ["pdf"]
        },
        "application/pdx": {
          source: "iana"
        },
        "application/pem-certificate-chain": {
          source: "iana"
        },
        "application/pgp-encrypted": {
          source: "iana",
          compressible: false,
          extensions: ["pgp"]
        },
        "application/pgp-keys": {
          source: "iana",
          extensions: ["asc"]
        },
        "application/pgp-signature": {
          source: "iana",
          extensions: ["asc", "sig"]
        },
        "application/pics-rules": {
          source: "apache",
          extensions: ["prf"]
        },
        "application/pidf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pidf-diff+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pkcs10": {
          source: "iana",
          extensions: ["p10"]
        },
        "application/pkcs12": {
          source: "iana"
        },
        "application/pkcs7-mime": {
          source: "iana",
          extensions: ["p7m", "p7c"]
        },
        "application/pkcs7-signature": {
          source: "iana",
          extensions: ["p7s"]
        },
        "application/pkcs8": {
          source: "iana",
          extensions: ["p8"]
        },
        "application/pkcs8-encrypted": {
          source: "iana"
        },
        "application/pkix-attr-cert": {
          source: "iana",
          extensions: ["ac"]
        },
        "application/pkix-cert": {
          source: "iana",
          extensions: ["cer"]
        },
        "application/pkix-crl": {
          source: "iana",
          extensions: ["crl"]
        },
        "application/pkix-pkipath": {
          source: "iana",
          extensions: ["pkipath"]
        },
        "application/pkixcmp": {
          source: "iana",
          extensions: ["pki"]
        },
        "application/pls+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pls"]
        },
        "application/poc-settings+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/postscript": {
          source: "iana",
          compressible: true,
          extensions: ["ai", "eps", "ps"]
        },
        "application/ppsp-tracker+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+xml": {
          source: "iana",
          compressible: true
        },
        "application/provenance+xml": {
          source: "iana",
          compressible: true,
          extensions: ["provx"]
        },
        "application/prs.alvestrand.titrax-sheet": {
          source: "iana"
        },
        "application/prs.cww": {
          source: "iana",
          extensions: ["cww"]
        },
        "application/prs.cyn": {
          source: "iana",
          charset: "7-BIT"
        },
        "application/prs.hpub+zip": {
          source: "iana",
          compressible: false
        },
        "application/prs.nprend": {
          source: "iana"
        },
        "application/prs.plucker": {
          source: "iana"
        },
        "application/prs.rdf-xml-crypt": {
          source: "iana"
        },
        "application/prs.xsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/pskc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pskcxml"]
        },
        "application/pvd+json": {
          source: "iana",
          compressible: true
        },
        "application/qsig": {
          source: "iana"
        },
        "application/raml+yaml": {
          compressible: true,
          extensions: ["raml"]
        },
        "application/raptorfec": {
          source: "iana"
        },
        "application/rdap+json": {
          source: "iana",
          compressible: true
        },
        "application/rdf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rdf", "owl"]
        },
        "application/reginfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rif"]
        },
        "application/relax-ng-compact-syntax": {
          source: "iana",
          extensions: ["rnc"]
        },
        "application/remote-printing": {
          source: "iana"
        },
        "application/reputon+json": {
          source: "iana",
          compressible: true
        },
        "application/resource-lists+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rl"]
        },
        "application/resource-lists-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rld"]
        },
        "application/rfc+xml": {
          source: "iana",
          compressible: true
        },
        "application/riscos": {
          source: "iana"
        },
        "application/rlmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/rls-services+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rs"]
        },
        "application/route-apd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rapd"]
        },
        "application/route-s-tsid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sls"]
        },
        "application/route-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rusd"]
        },
        "application/rpki-ghostbusters": {
          source: "iana",
          extensions: ["gbr"]
        },
        "application/rpki-manifest": {
          source: "iana",
          extensions: ["mft"]
        },
        "application/rpki-publication": {
          source: "iana"
        },
        "application/rpki-roa": {
          source: "iana",
          extensions: ["roa"]
        },
        "application/rpki-updown": {
          source: "iana"
        },
        "application/rsd+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rsd"]
        },
        "application/rss+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rss"]
        },
        "application/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "application/rtploopback": {
          source: "iana"
        },
        "application/rtx": {
          source: "iana"
        },
        "application/samlassertion+xml": {
          source: "iana",
          compressible: true
        },
        "application/samlmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/sarif+json": {
          source: "iana",
          compressible: true
        },
        "application/sarif-external-properties+json": {
          source: "iana",
          compressible: true
        },
        "application/sbe": {
          source: "iana"
        },
        "application/sbml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sbml"]
        },
        "application/scaip+xml": {
          source: "iana",
          compressible: true
        },
        "application/scim+json": {
          source: "iana",
          compressible: true
        },
        "application/scvp-cv-request": {
          source: "iana",
          extensions: ["scq"]
        },
        "application/scvp-cv-response": {
          source: "iana",
          extensions: ["scs"]
        },
        "application/scvp-vp-request": {
          source: "iana",
          extensions: ["spq"]
        },
        "application/scvp-vp-response": {
          source: "iana",
          extensions: ["spp"]
        },
        "application/sdp": {
          source: "iana",
          extensions: ["sdp"]
        },
        "application/secevent+jwt": {
          source: "iana"
        },
        "application/senml+cbor": {
          source: "iana"
        },
        "application/senml+json": {
          source: "iana",
          compressible: true
        },
        "application/senml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["senmlx"]
        },
        "application/senml-etch+cbor": {
          source: "iana"
        },
        "application/senml-etch+json": {
          source: "iana",
          compressible: true
        },
        "application/senml-exi": {
          source: "iana"
        },
        "application/sensml+cbor": {
          source: "iana"
        },
        "application/sensml+json": {
          source: "iana",
          compressible: true
        },
        "application/sensml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sensmlx"]
        },
        "application/sensml-exi": {
          source: "iana"
        },
        "application/sep+xml": {
          source: "iana",
          compressible: true
        },
        "application/sep-exi": {
          source: "iana"
        },
        "application/session-info": {
          source: "iana"
        },
        "application/set-payment": {
          source: "iana"
        },
        "application/set-payment-initiation": {
          source: "iana",
          extensions: ["setpay"]
        },
        "application/set-registration": {
          source: "iana"
        },
        "application/set-registration-initiation": {
          source: "iana",
          extensions: ["setreg"]
        },
        "application/sgml": {
          source: "iana"
        },
        "application/sgml-open-catalog": {
          source: "iana"
        },
        "application/shf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["shf"]
        },
        "application/sieve": {
          source: "iana",
          extensions: ["siv", "sieve"]
        },
        "application/simple-filter+xml": {
          source: "iana",
          compressible: true
        },
        "application/simple-message-summary": {
          source: "iana"
        },
        "application/simplesymbolcontainer": {
          source: "iana"
        },
        "application/sipc": {
          source: "iana"
        },
        "application/slate": {
          source: "iana"
        },
        "application/smil": {
          source: "iana"
        },
        "application/smil+xml": {
          source: "iana",
          compressible: true,
          extensions: ["smi", "smil"]
        },
        "application/smpte336m": {
          source: "iana"
        },
        "application/soap+fastinfoset": {
          source: "iana"
        },
        "application/soap+xml": {
          source: "iana",
          compressible: true
        },
        "application/sparql-query": {
          source: "iana",
          extensions: ["rq"]
        },
        "application/sparql-results+xml": {
          source: "iana",
          compressible: true,
          extensions: ["srx"]
        },
        "application/spdx+json": {
          source: "iana",
          compressible: true
        },
        "application/spirits-event+xml": {
          source: "iana",
          compressible: true
        },
        "application/sql": {
          source: "iana"
        },
        "application/srgs": {
          source: "iana",
          extensions: ["gram"]
        },
        "application/srgs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["grxml"]
        },
        "application/sru+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sru"]
        },
        "application/ssdl+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ssdl"]
        },
        "application/ssml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ssml"]
        },
        "application/stix+json": {
          source: "iana",
          compressible: true
        },
        "application/swid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["swidtag"]
        },
        "application/tamp-apex-update": {
          source: "iana"
        },
        "application/tamp-apex-update-confirm": {
          source: "iana"
        },
        "application/tamp-community-update": {
          source: "iana"
        },
        "application/tamp-community-update-confirm": {
          source: "iana"
        },
        "application/tamp-error": {
          source: "iana"
        },
        "application/tamp-sequence-adjust": {
          source: "iana"
        },
        "application/tamp-sequence-adjust-confirm": {
          source: "iana"
        },
        "application/tamp-status-query": {
          source: "iana"
        },
        "application/tamp-status-response": {
          source: "iana"
        },
        "application/tamp-update": {
          source: "iana"
        },
        "application/tamp-update-confirm": {
          source: "iana"
        },
        "application/tar": {
          compressible: true
        },
        "application/taxii+json": {
          source: "iana",
          compressible: true
        },
        "application/td+json": {
          source: "iana",
          compressible: true
        },
        "application/tei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tei", "teicorpus"]
        },
        "application/tetra_isi": {
          source: "iana"
        },
        "application/thraud+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tfi"]
        },
        "application/timestamp-query": {
          source: "iana"
        },
        "application/timestamp-reply": {
          source: "iana"
        },
        "application/timestamped-data": {
          source: "iana",
          extensions: ["tsd"]
        },
        "application/tlsrpt+gzip": {
          source: "iana"
        },
        "application/tlsrpt+json": {
          source: "iana",
          compressible: true
        },
        "application/tnauthlist": {
          source: "iana"
        },
        "application/token-introspection+jwt": {
          source: "iana"
        },
        "application/toml": {
          compressible: true,
          extensions: ["toml"]
        },
        "application/trickle-ice-sdpfrag": {
          source: "iana"
        },
        "application/trig": {
          source: "iana",
          extensions: ["trig"]
        },
        "application/ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ttml"]
        },
        "application/tve-trigger": {
          source: "iana"
        },
        "application/tzif": {
          source: "iana"
        },
        "application/tzif-leap": {
          source: "iana"
        },
        "application/ubjson": {
          compressible: false,
          extensions: ["ubj"]
        },
        "application/ulpfec": {
          source: "iana"
        },
        "application/urc-grpsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/urc-ressheet+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsheet"]
        },
        "application/urc-targetdesc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["td"]
        },
        "application/urc-uisocketdesc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vcard+json": {
          source: "iana",
          compressible: true
        },
        "application/vcard+xml": {
          source: "iana",
          compressible: true
        },
        "application/vemmi": {
          source: "iana"
        },
        "application/vividence.scriptfile": {
          source: "apache"
        },
        "application/vnd.1000minds.decision-model+xml": {
          source: "iana",
          compressible: true,
          extensions: ["1km"]
        },
        "application/vnd.3gpp-prose+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-prose-pc3ch+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-v2x-local-service-information": {
          source: "iana"
        },
        "application/vnd.3gpp.5gnas": {
          source: "iana"
        },
        "application/vnd.3gpp.access-transfer-events+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.bsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gmop+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gtpc": {
          source: "iana"
        },
        "application/vnd.3gpp.interworking-data": {
          source: "iana"
        },
        "application/vnd.3gpp.lpp": {
          source: "iana"
        },
        "application/vnd.3gpp.mc-signalling-ear": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-payload": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-signalling": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-floor-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-signed+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-init-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-transmission-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mid-call+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ngap": {
          source: "iana"
        },
        "application/vnd.3gpp.pfcp": {
          source: "iana"
        },
        "application/vnd.3gpp.pic-bw-large": {
          source: "iana",
          extensions: ["plb"]
        },
        "application/vnd.3gpp.pic-bw-small": {
          source: "iana",
          extensions: ["psb"]
        },
        "application/vnd.3gpp.pic-bw-var": {
          source: "iana",
          extensions: ["pvb"]
        },
        "application/vnd.3gpp.s1ap": {
          source: "iana"
        },
        "application/vnd.3gpp.sms": {
          source: "iana"
        },
        "application/vnd.3gpp.sms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-ext+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.state-and-event-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ussd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.bcmcsinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.sms": {
          source: "iana"
        },
        "application/vnd.3gpp2.tcap": {
          source: "iana",
          extensions: ["tcap"]
        },
        "application/vnd.3lightssoftware.imagescal": {
          source: "iana"
        },
        "application/vnd.3m.post-it-notes": {
          source: "iana",
          extensions: ["pwn"]
        },
        "application/vnd.accpac.simply.aso": {
          source: "iana",
          extensions: ["aso"]
        },
        "application/vnd.accpac.simply.imp": {
          source: "iana",
          extensions: ["imp"]
        },
        "application/vnd.acucobol": {
          source: "iana",
          extensions: ["acu"]
        },
        "application/vnd.acucorp": {
          source: "iana",
          extensions: ["atc", "acutc"]
        },
        "application/vnd.adobe.air-application-installer-package+zip": {
          source: "apache",
          compressible: false,
          extensions: ["air"]
        },
        "application/vnd.adobe.flash.movie": {
          source: "iana"
        },
        "application/vnd.adobe.formscentral.fcdt": {
          source: "iana",
          extensions: ["fcdt"]
        },
        "application/vnd.adobe.fxp": {
          source: "iana",
          extensions: ["fxp", "fxpl"]
        },
        "application/vnd.adobe.partial-upload": {
          source: "iana"
        },
        "application/vnd.adobe.xdp+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdp"]
        },
        "application/vnd.adobe.xfdf": {
          source: "iana",
          extensions: ["xfdf"]
        },
        "application/vnd.aether.imp": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata-pagedef": {
          source: "iana"
        },
        "application/vnd.afpc.cmoca-cmresource": {
          source: "iana"
        },
        "application/vnd.afpc.foca-charset": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codedfont": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codepage": {
          source: "iana"
        },
        "application/vnd.afpc.modca": {
          source: "iana"
        },
        "application/vnd.afpc.modca-cmtable": {
          source: "iana"
        },
        "application/vnd.afpc.modca-formdef": {
          source: "iana"
        },
        "application/vnd.afpc.modca-mediummap": {
          source: "iana"
        },
        "application/vnd.afpc.modca-objectcontainer": {
          source: "iana"
        },
        "application/vnd.afpc.modca-overlay": {
          source: "iana"
        },
        "application/vnd.afpc.modca-pagesegment": {
          source: "iana"
        },
        "application/vnd.age": {
          source: "iana",
          extensions: ["age"]
        },
        "application/vnd.ah-barcode": {
          source: "iana"
        },
        "application/vnd.ahead.space": {
          source: "iana",
          extensions: ["ahead"]
        },
        "application/vnd.airzip.filesecure.azf": {
          source: "iana",
          extensions: ["azf"]
        },
        "application/vnd.airzip.filesecure.azs": {
          source: "iana",
          extensions: ["azs"]
        },
        "application/vnd.amadeus+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.amazon.ebook": {
          source: "apache",
          extensions: ["azw"]
        },
        "application/vnd.amazon.mobi8-ebook": {
          source: "iana"
        },
        "application/vnd.americandynamics.acc": {
          source: "iana",
          extensions: ["acc"]
        },
        "application/vnd.amiga.ami": {
          source: "iana",
          extensions: ["ami"]
        },
        "application/vnd.amundsen.maze+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.android.ota": {
          source: "iana"
        },
        "application/vnd.android.package-archive": {
          source: "apache",
          compressible: false,
          extensions: ["apk"]
        },
        "application/vnd.anki": {
          source: "iana"
        },
        "application/vnd.anser-web-certificate-issue-initiation": {
          source: "iana",
          extensions: ["cii"]
        },
        "application/vnd.anser-web-funds-transfer-initiation": {
          source: "apache",
          extensions: ["fti"]
        },
        "application/vnd.antix.game-component": {
          source: "iana",
          extensions: ["atx"]
        },
        "application/vnd.apache.arrow.file": {
          source: "iana"
        },
        "application/vnd.apache.arrow.stream": {
          source: "iana"
        },
        "application/vnd.apache.thrift.binary": {
          source: "iana"
        },
        "application/vnd.apache.thrift.compact": {
          source: "iana"
        },
        "application/vnd.apache.thrift.json": {
          source: "iana"
        },
        "application/vnd.api+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.aplextor.warrp+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apothekende.reservation+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apple.installer+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpkg"]
        },
        "application/vnd.apple.keynote": {
          source: "iana",
          extensions: ["key"]
        },
        "application/vnd.apple.mpegurl": {
          source: "iana",
          extensions: ["m3u8"]
        },
        "application/vnd.apple.numbers": {
          source: "iana",
          extensions: ["numbers"]
        },
        "application/vnd.apple.pages": {
          source: "iana",
          extensions: ["pages"]
        },
        "application/vnd.apple.pkpass": {
          compressible: false,
          extensions: ["pkpass"]
        },
        "application/vnd.arastra.swi": {
          source: "iana"
        },
        "application/vnd.aristanetworks.swi": {
          source: "iana",
          extensions: ["swi"]
        },
        "application/vnd.artisan+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.artsquare": {
          source: "iana"
        },
        "application/vnd.astraea-software.iota": {
          source: "iana",
          extensions: ["iota"]
        },
        "application/vnd.audiograph": {
          source: "iana",
          extensions: ["aep"]
        },
        "application/vnd.autopackage": {
          source: "iana"
        },
        "application/vnd.avalon+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.avistar+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.balsamiq.bmml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["bmml"]
        },
        "application/vnd.balsamiq.bmpr": {
          source: "iana"
        },
        "application/vnd.banana-accounting": {
          source: "iana"
        },
        "application/vnd.bbf.usp.error": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bekitzur-stech+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bint.med-content": {
          source: "iana"
        },
        "application/vnd.biopax.rdf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.blink-idb-value-wrapper": {
          source: "iana"
        },
        "application/vnd.blueice.multipass": {
          source: "iana",
          extensions: ["mpm"]
        },
        "application/vnd.bluetooth.ep.oob": {
          source: "iana"
        },
        "application/vnd.bluetooth.le.oob": {
          source: "iana"
        },
        "application/vnd.bmi": {
          source: "iana",
          extensions: ["bmi"]
        },
        "application/vnd.bpf": {
          source: "iana"
        },
        "application/vnd.bpf3": {
          source: "iana"
        },
        "application/vnd.businessobjects": {
          source: "iana",
          extensions: ["rep"]
        },
        "application/vnd.byu.uapi+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cab-jscript": {
          source: "iana"
        },
        "application/vnd.canon-cpdl": {
          source: "iana"
        },
        "application/vnd.canon-lips": {
          source: "iana"
        },
        "application/vnd.capasystems-pg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cendio.thinlinc.clientconf": {
          source: "iana"
        },
        "application/vnd.century-systems.tcp_stream": {
          source: "iana"
        },
        "application/vnd.chemdraw+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdxml"]
        },
        "application/vnd.chess-pgn": {
          source: "iana"
        },
        "application/vnd.chipnuts.karaoke-mmd": {
          source: "iana",
          extensions: ["mmd"]
        },
        "application/vnd.ciedi": {
          source: "iana"
        },
        "application/vnd.cinderella": {
          source: "iana",
          extensions: ["cdy"]
        },
        "application/vnd.cirpack.isdn-ext": {
          source: "iana"
        },
        "application/vnd.citationstyles.style+xml": {
          source: "iana",
          compressible: true,
          extensions: ["csl"]
        },
        "application/vnd.claymore": {
          source: "iana",
          extensions: ["cla"]
        },
        "application/vnd.cloanto.rp9": {
          source: "iana",
          extensions: ["rp9"]
        },
        "application/vnd.clonk.c4group": {
          source: "iana",
          extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
        },
        "application/vnd.cluetrust.cartomobile-config": {
          source: "iana",
          extensions: ["c11amc"]
        },
        "application/vnd.cluetrust.cartomobile-config-pkg": {
          source: "iana",
          extensions: ["c11amz"]
        },
        "application/vnd.coffeescript": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet-template": {
          source: "iana"
        },
        "application/vnd.collection+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.doc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.next+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.comicbook+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.comicbook-rar": {
          source: "iana"
        },
        "application/vnd.commerce-battelle": {
          source: "iana"
        },
        "application/vnd.commonspace": {
          source: "iana",
          extensions: ["csp"]
        },
        "application/vnd.contact.cmsg": {
          source: "iana",
          extensions: ["cdbcmsg"]
        },
        "application/vnd.coreos.ignition+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cosmocaller": {
          source: "iana",
          extensions: ["cmc"]
        },
        "application/vnd.crick.clicker": {
          source: "iana",
          extensions: ["clkx"]
        },
        "application/vnd.crick.clicker.keyboard": {
          source: "iana",
          extensions: ["clkk"]
        },
        "application/vnd.crick.clicker.palette": {
          source: "iana",
          extensions: ["clkp"]
        },
        "application/vnd.crick.clicker.template": {
          source: "iana",
          extensions: ["clkt"]
        },
        "application/vnd.crick.clicker.wordbank": {
          source: "iana",
          extensions: ["clkw"]
        },
        "application/vnd.criticaltools.wbs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wbs"]
        },
        "application/vnd.cryptii.pipe+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.crypto-shade-file": {
          source: "iana"
        },
        "application/vnd.cryptomator.encrypted": {
          source: "iana"
        },
        "application/vnd.cryptomator.vault": {
          source: "iana"
        },
        "application/vnd.ctc-posml": {
          source: "iana",
          extensions: ["pml"]
        },
        "application/vnd.ctct.ws+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cups-pdf": {
          source: "iana"
        },
        "application/vnd.cups-postscript": {
          source: "iana"
        },
        "application/vnd.cups-ppd": {
          source: "iana",
          extensions: ["ppd"]
        },
        "application/vnd.cups-raster": {
          source: "iana"
        },
        "application/vnd.cups-raw": {
          source: "iana"
        },
        "application/vnd.curl": {
          source: "iana"
        },
        "application/vnd.curl.car": {
          source: "apache",
          extensions: ["car"]
        },
        "application/vnd.curl.pcurl": {
          source: "apache",
          extensions: ["pcurl"]
        },
        "application/vnd.cyan.dean.root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cybank": {
          source: "iana"
        },
        "application/vnd.cyclonedx+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cyclonedx+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.d2l.coursepackage1p0+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.d3m-dataset": {
          source: "iana"
        },
        "application/vnd.d3m-problem": {
          source: "iana"
        },
        "application/vnd.dart": {
          source: "iana",
          compressible: true,
          extensions: ["dart"]
        },
        "application/vnd.data-vision.rdz": {
          source: "iana",
          extensions: ["rdz"]
        },
        "application/vnd.datapackage+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dataresource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dbf": {
          source: "iana",
          extensions: ["dbf"]
        },
        "application/vnd.debian.binary-package": {
          source: "iana"
        },
        "application/vnd.dece.data": {
          source: "iana",
          extensions: ["uvf", "uvvf", "uvd", "uvvd"]
        },
        "application/vnd.dece.ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uvt", "uvvt"]
        },
        "application/vnd.dece.unspecified": {
          source: "iana",
          extensions: ["uvx", "uvvx"]
        },
        "application/vnd.dece.zip": {
          source: "iana",
          extensions: ["uvz", "uvvz"]
        },
        "application/vnd.denovo.fcselayout-link": {
          source: "iana",
          extensions: ["fe_launch"]
        },
        "application/vnd.desmume.movie": {
          source: "iana"
        },
        "application/vnd.dir-bi.plate-dl-nosuffix": {
          source: "iana"
        },
        "application/vnd.dm.delegation+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dna": {
          source: "iana",
          extensions: ["dna"]
        },
        "application/vnd.document+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dolby.mlp": {
          source: "apache",
          extensions: ["mlp"]
        },
        "application/vnd.dolby.mobile.1": {
          source: "iana"
        },
        "application/vnd.dolby.mobile.2": {
          source: "iana"
        },
        "application/vnd.doremir.scorecloud-binary-document": {
          source: "iana"
        },
        "application/vnd.dpgraph": {
          source: "iana",
          extensions: ["dpg"]
        },
        "application/vnd.dreamfactory": {
          source: "iana",
          extensions: ["dfac"]
        },
        "application/vnd.drive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ds-keypoint": {
          source: "apache",
          extensions: ["kpxx"]
        },
        "application/vnd.dtg.local": {
          source: "iana"
        },
        "application/vnd.dtg.local.flash": {
          source: "iana"
        },
        "application/vnd.dtg.local.html": {
          source: "iana"
        },
        "application/vnd.dvb.ait": {
          source: "iana",
          extensions: ["ait"]
        },
        "application/vnd.dvb.dvbisl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.dvbj": {
          source: "iana"
        },
        "application/vnd.dvb.esgcontainer": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcdftnotifaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess2": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgpdd": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcroaming": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-base": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-enhancement": {
          source: "iana"
        },
        "application/vnd.dvb.notif-aggregate-root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-container+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-generic+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-msglist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-init+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.pfr": {
          source: "iana"
        },
        "application/vnd.dvb.service": {
          source: "iana",
          extensions: ["svc"]
        },
        "application/vnd.dxr": {
          source: "iana"
        },
        "application/vnd.dynageo": {
          source: "iana",
          extensions: ["geo"]
        },
        "application/vnd.dzr": {
          source: "iana"
        },
        "application/vnd.easykaraoke.cdgdownload": {
          source: "iana"
        },
        "application/vnd.ecdis-update": {
          source: "iana"
        },
        "application/vnd.ecip.rlp": {
          source: "iana"
        },
        "application/vnd.eclipse.ditto+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ecowin.chart": {
          source: "iana",
          extensions: ["mag"]
        },
        "application/vnd.ecowin.filerequest": {
          source: "iana"
        },
        "application/vnd.ecowin.fileupdate": {
          source: "iana"
        },
        "application/vnd.ecowin.series": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesrequest": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesupdate": {
          source: "iana"
        },
        "application/vnd.efi.img": {
          source: "iana"
        },
        "application/vnd.efi.iso": {
          source: "iana"
        },
        "application/vnd.emclient.accessrequest+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.enliven": {
          source: "iana",
          extensions: ["nml"]
        },
        "application/vnd.enphase.envoy": {
          source: "iana"
        },
        "application/vnd.eprints.data+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.epson.esf": {
          source: "iana",
          extensions: ["esf"]
        },
        "application/vnd.epson.msf": {
          source: "iana",
          extensions: ["msf"]
        },
        "application/vnd.epson.quickanime": {
          source: "iana",
          extensions: ["qam"]
        },
        "application/vnd.epson.salt": {
          source: "iana",
          extensions: ["slt"]
        },
        "application/vnd.epson.ssf": {
          source: "iana",
          extensions: ["ssf"]
        },
        "application/vnd.ericsson.quickcall": {
          source: "iana"
        },
        "application/vnd.espass-espass+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.eszigno3+xml": {
          source: "iana",
          compressible: true,
          extensions: ["es3", "et3"]
        },
        "application/vnd.etsi.aoc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.asic-e+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.asic-s+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.cug+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvcommand+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-bc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-cod+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-npvr+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvservice+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mcid+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mheg5": {
          source: "iana"
        },
        "application/vnd.etsi.overload-control-policy-dataset+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.pstn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.sci+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.simservs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.timestamp-token": {
          source: "iana"
        },
        "application/vnd.etsi.tsl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.tsl.der": {
          source: "iana"
        },
        "application/vnd.eu.kasparian.car+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.eudora.data": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.profile": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.settings": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.theme": {
          source: "iana"
        },
        "application/vnd.exstream-empower+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.exstream-package": {
          source: "iana"
        },
        "application/vnd.ezpix-album": {
          source: "iana",
          extensions: ["ez2"]
        },
        "application/vnd.ezpix-package": {
          source: "iana",
          extensions: ["ez3"]
        },
        "application/vnd.f-secure.mobile": {
          source: "iana"
        },
        "application/vnd.familysearch.gedcom+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.fastcopy-disk-image": {
          source: "iana"
        },
        "application/vnd.fdf": {
          source: "iana",
          extensions: ["fdf"]
        },
        "application/vnd.fdsn.mseed": {
          source: "iana",
          extensions: ["mseed"]
        },
        "application/vnd.fdsn.seed": {
          source: "iana",
          extensions: ["seed", "dataless"]
        },
        "application/vnd.ffsns": {
          source: "iana"
        },
        "application/vnd.ficlab.flb+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.filmit.zfc": {
          source: "iana"
        },
        "application/vnd.fints": {
          source: "iana"
        },
        "application/vnd.firemonkeys.cloudcell": {
          source: "iana"
        },
        "application/vnd.flographit": {
          source: "iana",
          extensions: ["gph"]
        },
        "application/vnd.fluxtime.clip": {
          source: "iana",
          extensions: ["ftc"]
        },
        "application/vnd.font-fontforge-sfd": {
          source: "iana"
        },
        "application/vnd.framemaker": {
          source: "iana",
          extensions: ["fm", "frame", "maker", "book"]
        },
        "application/vnd.frogans.fnc": {
          source: "iana",
          extensions: ["fnc"]
        },
        "application/vnd.frogans.ltf": {
          source: "iana",
          extensions: ["ltf"]
        },
        "application/vnd.fsc.weblaunch": {
          source: "iana",
          extensions: ["fsc"]
        },
        "application/vnd.fujifilm.fb.docuworks": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.binder": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.jfi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fujitsu.oasys": {
          source: "iana",
          extensions: ["oas"]
        },
        "application/vnd.fujitsu.oasys2": {
          source: "iana",
          extensions: ["oa2"]
        },
        "application/vnd.fujitsu.oasys3": {
          source: "iana",
          extensions: ["oa3"]
        },
        "application/vnd.fujitsu.oasysgp": {
          source: "iana",
          extensions: ["fg5"]
        },
        "application/vnd.fujitsu.oasysprs": {
          source: "iana",
          extensions: ["bh2"]
        },
        "application/vnd.fujixerox.art-ex": {
          source: "iana"
        },
        "application/vnd.fujixerox.art4": {
          source: "iana"
        },
        "application/vnd.fujixerox.ddd": {
          source: "iana",
          extensions: ["ddd"]
        },
        "application/vnd.fujixerox.docuworks": {
          source: "iana",
          extensions: ["xdw"]
        },
        "application/vnd.fujixerox.docuworks.binder": {
          source: "iana",
          extensions: ["xbd"]
        },
        "application/vnd.fujixerox.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujixerox.hbpl": {
          source: "iana"
        },
        "application/vnd.fut-misnet": {
          source: "iana"
        },
        "application/vnd.futoin+cbor": {
          source: "iana"
        },
        "application/vnd.futoin+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fuzzysheet": {
          source: "iana",
          extensions: ["fzs"]
        },
        "application/vnd.genomatix.tuxedo": {
          source: "iana",
          extensions: ["txd"]
        },
        "application/vnd.gentics.grd+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geo+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geocube+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geogebra.file": {
          source: "iana",
          extensions: ["ggb"]
        },
        "application/vnd.geogebra.slides": {
          source: "iana"
        },
        "application/vnd.geogebra.tool": {
          source: "iana",
          extensions: ["ggt"]
        },
        "application/vnd.geometry-explorer": {
          source: "iana",
          extensions: ["gex", "gre"]
        },
        "application/vnd.geonext": {
          source: "iana",
          extensions: ["gxt"]
        },
        "application/vnd.geoplan": {
          source: "iana",
          extensions: ["g2w"]
        },
        "application/vnd.geospace": {
          source: "iana",
          extensions: ["g3w"]
        },
        "application/vnd.gerber": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt-response": {
          source: "iana"
        },
        "application/vnd.gmx": {
          source: "iana",
          extensions: ["gmx"]
        },
        "application/vnd.google-apps.document": {
          compressible: false,
          extensions: ["gdoc"]
        },
        "application/vnd.google-apps.presentation": {
          compressible: false,
          extensions: ["gslides"]
        },
        "application/vnd.google-apps.spreadsheet": {
          compressible: false,
          extensions: ["gsheet"]
        },
        "application/vnd.google-earth.kml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["kml"]
        },
        "application/vnd.google-earth.kmz": {
          source: "iana",
          compressible: false,
          extensions: ["kmz"]
        },
        "application/vnd.gov.sk.e-form+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.gov.sk.e-form+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.gov.sk.xmldatacontainer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.grafeq": {
          source: "iana",
          extensions: ["gqf", "gqs"]
        },
        "application/vnd.gridmp": {
          source: "iana"
        },
        "application/vnd.groove-account": {
          source: "iana",
          extensions: ["gac"]
        },
        "application/vnd.groove-help": {
          source: "iana",
          extensions: ["ghf"]
        },
        "application/vnd.groove-identity-message": {
          source: "iana",
          extensions: ["gim"]
        },
        "application/vnd.groove-injector": {
          source: "iana",
          extensions: ["grv"]
        },
        "application/vnd.groove-tool-message": {
          source: "iana",
          extensions: ["gtm"]
        },
        "application/vnd.groove-tool-template": {
          source: "iana",
          extensions: ["tpl"]
        },
        "application/vnd.groove-vcard": {
          source: "iana",
          extensions: ["vcg"]
        },
        "application/vnd.hal+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hal+xml": {
          source: "iana",
          compressible: true,
          extensions: ["hal"]
        },
        "application/vnd.handheld-entertainment+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zmm"]
        },
        "application/vnd.hbci": {
          source: "iana",
          extensions: ["hbci"]
        },
        "application/vnd.hc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hcl-bireports": {
          source: "iana"
        },
        "application/vnd.hdt": {
          source: "iana"
        },
        "application/vnd.heroku+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hhe.lesson-player": {
          source: "iana",
          extensions: ["les"]
        },
        "application/vnd.hl7cda+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.hl7v2+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.hp-hpgl": {
          source: "iana",
          extensions: ["hpgl"]
        },
        "application/vnd.hp-hpid": {
          source: "iana",
          extensions: ["hpid"]
        },
        "application/vnd.hp-hps": {
          source: "iana",
          extensions: ["hps"]
        },
        "application/vnd.hp-jlyt": {
          source: "iana",
          extensions: ["jlt"]
        },
        "application/vnd.hp-pcl": {
          source: "iana",
          extensions: ["pcl"]
        },
        "application/vnd.hp-pclxl": {
          source: "iana",
          extensions: ["pclxl"]
        },
        "application/vnd.httphone": {
          source: "iana"
        },
        "application/vnd.hydrostatix.sof-data": {
          source: "iana",
          extensions: ["sfd-hdstx"]
        },
        "application/vnd.hyper+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyper-item+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyperdrive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hzn-3d-crossword": {
          source: "iana"
        },
        "application/vnd.ibm.afplinedata": {
          source: "iana"
        },
        "application/vnd.ibm.electronic-media": {
          source: "iana"
        },
        "application/vnd.ibm.minipay": {
          source: "iana",
          extensions: ["mpy"]
        },
        "application/vnd.ibm.modcap": {
          source: "iana",
          extensions: ["afp", "listafp", "list3820"]
        },
        "application/vnd.ibm.rights-management": {
          source: "iana",
          extensions: ["irm"]
        },
        "application/vnd.ibm.secure-container": {
          source: "iana",
          extensions: ["sc"]
        },
        "application/vnd.iccprofile": {
          source: "iana",
          extensions: ["icc", "icm"]
        },
        "application/vnd.ieee.1905": {
          source: "iana"
        },
        "application/vnd.igloader": {
          source: "iana",
          extensions: ["igl"]
        },
        "application/vnd.imagemeter.folder+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.imagemeter.image+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.immervision-ivp": {
          source: "iana",
          extensions: ["ivp"]
        },
        "application/vnd.immervision-ivu": {
          source: "iana",
          extensions: ["ivu"]
        },
        "application/vnd.ims.imsccv1p1": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p2": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p3": {
          source: "iana"
        },
        "application/vnd.ims.lis.v2.result+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy.id+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings.simple+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informedcontrol.rms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informix-visionary": {
          source: "iana"
        },
        "application/vnd.infotech.project": {
          source: "iana"
        },
        "application/vnd.infotech.project+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.innopath.wamp.notification": {
          source: "iana"
        },
        "application/vnd.insors.igm": {
          source: "iana",
          extensions: ["igm"]
        },
        "application/vnd.intercon.formnet": {
          source: "iana",
          extensions: ["xpw", "xpx"]
        },
        "application/vnd.intergeo": {
          source: "iana",
          extensions: ["i2g"]
        },
        "application/vnd.intertrust.digibox": {
          source: "iana"
        },
        "application/vnd.intertrust.nncp": {
          source: "iana"
        },
        "application/vnd.intu.qbo": {
          source: "iana",
          extensions: ["qbo"]
        },
        "application/vnd.intu.qfx": {
          source: "iana",
          extensions: ["qfx"]
        },
        "application/vnd.iptc.g2.catalogitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.conceptitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.knowledgeitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.packageitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.planningitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ipunplugged.rcprofile": {
          source: "iana",
          extensions: ["rcprofile"]
        },
        "application/vnd.irepository.package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["irp"]
        },
        "application/vnd.is-xpr": {
          source: "iana",
          extensions: ["xpr"]
        },
        "application/vnd.isac.fcs": {
          source: "iana",
          extensions: ["fcs"]
        },
        "application/vnd.iso11783-10+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.jam": {
          source: "iana",
          extensions: ["jam"]
        },
        "application/vnd.japannet-directory-service": {
          source: "iana"
        },
        "application/vnd.japannet-jpnstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-payment-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-registration": {
          source: "iana"
        },
        "application/vnd.japannet-registration-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-setstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-verification": {
          source: "iana"
        },
        "application/vnd.japannet-verification-wakeup": {
          source: "iana"
        },
        "application/vnd.jcp.javame.midlet-rms": {
          source: "iana",
          extensions: ["rms"]
        },
        "application/vnd.jisp": {
          source: "iana",
          extensions: ["jisp"]
        },
        "application/vnd.joost.joda-archive": {
          source: "iana",
          extensions: ["joda"]
        },
        "application/vnd.jsk.isdn-ngn": {
          source: "iana"
        },
        "application/vnd.kahootz": {
          source: "iana",
          extensions: ["ktz", "ktr"]
        },
        "application/vnd.kde.karbon": {
          source: "iana",
          extensions: ["karbon"]
        },
        "application/vnd.kde.kchart": {
          source: "iana",
          extensions: ["chrt"]
        },
        "application/vnd.kde.kformula": {
          source: "iana",
          extensions: ["kfo"]
        },
        "application/vnd.kde.kivio": {
          source: "iana",
          extensions: ["flw"]
        },
        "application/vnd.kde.kontour": {
          source: "iana",
          extensions: ["kon"]
        },
        "application/vnd.kde.kpresenter": {
          source: "iana",
          extensions: ["kpr", "kpt"]
        },
        "application/vnd.kde.kspread": {
          source: "iana",
          extensions: ["ksp"]
        },
        "application/vnd.kde.kword": {
          source: "iana",
          extensions: ["kwd", "kwt"]
        },
        "application/vnd.kenameaapp": {
          source: "iana",
          extensions: ["htke"]
        },
        "application/vnd.kidspiration": {
          source: "iana",
          extensions: ["kia"]
        },
        "application/vnd.kinar": {
          source: "iana",
          extensions: ["kne", "knp"]
        },
        "application/vnd.koan": {
          source: "iana",
          extensions: ["skp", "skd", "skt", "skm"]
        },
        "application/vnd.kodak-descriptor": {
          source: "iana",
          extensions: ["sse"]
        },
        "application/vnd.las": {
          source: "iana"
        },
        "application/vnd.las.las+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.las.las+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lasxml"]
        },
        "application/vnd.laszip": {
          source: "iana"
        },
        "application/vnd.leap+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.liberty-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.llamagraphics.life-balance.desktop": {
          source: "iana",
          extensions: ["lbd"]
        },
        "application/vnd.llamagraphics.life-balance.exchange+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lbe"]
        },
        "application/vnd.logipipe.circuit+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.loom": {
          source: "iana"
        },
        "application/vnd.lotus-1-2-3": {
          source: "iana",
          extensions: ["123"]
        },
        "application/vnd.lotus-approach": {
          source: "iana",
          extensions: ["apr"]
        },
        "application/vnd.lotus-freelance": {
          source: "iana",
          extensions: ["pre"]
        },
        "application/vnd.lotus-notes": {
          source: "iana",
          extensions: ["nsf"]
        },
        "application/vnd.lotus-organizer": {
          source: "iana",
          extensions: ["org"]
        },
        "application/vnd.lotus-screencam": {
          source: "iana",
          extensions: ["scm"]
        },
        "application/vnd.lotus-wordpro": {
          source: "iana",
          extensions: ["lwp"]
        },
        "application/vnd.macports.portpkg": {
          source: "iana",
          extensions: ["portpkg"]
        },
        "application/vnd.mapbox-vector-tile": {
          source: "iana",
          extensions: ["mvt"]
        },
        "application/vnd.marlin.drm.actiontoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.conftoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.license+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.mdcf": {
          source: "iana"
        },
        "application/vnd.mason+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.maxar.archive.3tz+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.maxmind.maxmind-db": {
          source: "iana"
        },
        "application/vnd.mcd": {
          source: "iana",
          extensions: ["mcd"]
        },
        "application/vnd.medcalcdata": {
          source: "iana",
          extensions: ["mc1"]
        },
        "application/vnd.mediastation.cdkey": {
          source: "iana",
          extensions: ["cdkey"]
        },
        "application/vnd.meridian-slingshot": {
          source: "iana"
        },
        "application/vnd.mfer": {
          source: "iana",
          extensions: ["mwf"]
        },
        "application/vnd.mfmp": {
          source: "iana",
          extensions: ["mfm"]
        },
        "application/vnd.micro+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.micrografx.flo": {
          source: "iana",
          extensions: ["flo"]
        },
        "application/vnd.micrografx.igx": {
          source: "iana",
          extensions: ["igx"]
        },
        "application/vnd.microsoft.portable-executable": {
          source: "iana"
        },
        "application/vnd.microsoft.windows.thumbnail-cache": {
          source: "iana"
        },
        "application/vnd.miele+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.mif": {
          source: "iana",
          extensions: ["mif"]
        },
        "application/vnd.minisoft-hp3000-save": {
          source: "iana"
        },
        "application/vnd.mitsubishi.misty-guard.trustweb": {
          source: "iana"
        },
        "application/vnd.mobius.daf": {
          source: "iana",
          extensions: ["daf"]
        },
        "application/vnd.mobius.dis": {
          source: "iana",
          extensions: ["dis"]
        },
        "application/vnd.mobius.mbk": {
          source: "iana",
          extensions: ["mbk"]
        },
        "application/vnd.mobius.mqy": {
          source: "iana",
          extensions: ["mqy"]
        },
        "application/vnd.mobius.msl": {
          source: "iana",
          extensions: ["msl"]
        },
        "application/vnd.mobius.plc": {
          source: "iana",
          extensions: ["plc"]
        },
        "application/vnd.mobius.txf": {
          source: "iana",
          extensions: ["txf"]
        },
        "application/vnd.mophun.application": {
          source: "iana",
          extensions: ["mpn"]
        },
        "application/vnd.mophun.certificate": {
          source: "iana",
          extensions: ["mpc"]
        },
        "application/vnd.motorola.flexsuite": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.adsi": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.fis": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.gotap": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.kmr": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.ttc": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.wem": {
          source: "iana"
        },
        "application/vnd.motorola.iprm": {
          source: "iana"
        },
        "application/vnd.mozilla.xul+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xul"]
        },
        "application/vnd.ms-3mfdocument": {
          source: "iana"
        },
        "application/vnd.ms-artgalry": {
          source: "iana",
          extensions: ["cil"]
        },
        "application/vnd.ms-asf": {
          source: "iana"
        },
        "application/vnd.ms-cab-compressed": {
          source: "iana",
          extensions: ["cab"]
        },
        "application/vnd.ms-color.iccprofile": {
          source: "apache"
        },
        "application/vnd.ms-excel": {
          source: "iana",
          compressible: false,
          extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
        },
        "application/vnd.ms-excel.addin.macroenabled.12": {
          source: "iana",
          extensions: ["xlam"]
        },
        "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
          source: "iana",
          extensions: ["xlsb"]
        },
        "application/vnd.ms-excel.sheet.macroenabled.12": {
          source: "iana",
          extensions: ["xlsm"]
        },
        "application/vnd.ms-excel.template.macroenabled.12": {
          source: "iana",
          extensions: ["xltm"]
        },
        "application/vnd.ms-fontobject": {
          source: "iana",
          compressible: true,
          extensions: ["eot"]
        },
        "application/vnd.ms-htmlhelp": {
          source: "iana",
          extensions: ["chm"]
        },
        "application/vnd.ms-ims": {
          source: "iana",
          extensions: ["ims"]
        },
        "application/vnd.ms-lrm": {
          source: "iana",
          extensions: ["lrm"]
        },
        "application/vnd.ms-office.activex+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-officetheme": {
          source: "iana",
          extensions: ["thmx"]
        },
        "application/vnd.ms-opentype": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-outlook": {
          compressible: false,
          extensions: ["msg"]
        },
        "application/vnd.ms-package.obfuscated-opentype": {
          source: "apache"
        },
        "application/vnd.ms-pki.seccat": {
          source: "apache",
          extensions: ["cat"]
        },
        "application/vnd.ms-pki.stl": {
          source: "apache",
          extensions: ["stl"]
        },
        "application/vnd.ms-playready.initiator+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-powerpoint": {
          source: "iana",
          compressible: false,
          extensions: ["ppt", "pps", "pot"]
        },
        "application/vnd.ms-powerpoint.addin.macroenabled.12": {
          source: "iana",
          extensions: ["ppam"]
        },
        "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
          source: "iana",
          extensions: ["pptm"]
        },
        "application/vnd.ms-powerpoint.slide.macroenabled.12": {
          source: "iana",
          extensions: ["sldm"]
        },
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
          source: "iana",
          extensions: ["ppsm"]
        },
        "application/vnd.ms-powerpoint.template.macroenabled.12": {
          source: "iana",
          extensions: ["potm"]
        },
        "application/vnd.ms-printdevicecapabilities+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-printing.printticket+xml": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-printschematicket+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-project": {
          source: "iana",
          extensions: ["mpp", "mpt"]
        },
        "application/vnd.ms-tnef": {
          source: "iana"
        },
        "application/vnd.ms-windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.nwprinting.oob": {
          source: "iana"
        },
        "application/vnd.ms-windows.printerpairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.wsd.oob": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-resp": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-resp": {
          source: "iana"
        },
        "application/vnd.ms-word.document.macroenabled.12": {
          source: "iana",
          extensions: ["docm"]
        },
        "application/vnd.ms-word.template.macroenabled.12": {
          source: "iana",
          extensions: ["dotm"]
        },
        "application/vnd.ms-works": {
          source: "iana",
          extensions: ["wps", "wks", "wcm", "wdb"]
        },
        "application/vnd.ms-wpl": {
          source: "iana",
          extensions: ["wpl"]
        },
        "application/vnd.ms-xpsdocument": {
          source: "iana",
          compressible: false,
          extensions: ["xps"]
        },
        "application/vnd.msa-disk-image": {
          source: "iana"
        },
        "application/vnd.mseq": {
          source: "iana",
          extensions: ["mseq"]
        },
        "application/vnd.msign": {
          source: "iana"
        },
        "application/vnd.multiad.creator": {
          source: "iana"
        },
        "application/vnd.multiad.creator.cif": {
          source: "iana"
        },
        "application/vnd.music-niff": {
          source: "iana"
        },
        "application/vnd.musician": {
          source: "iana",
          extensions: ["mus"]
        },
        "application/vnd.muvee.style": {
          source: "iana",
          extensions: ["msty"]
        },
        "application/vnd.mynfc": {
          source: "iana",
          extensions: ["taglet"]
        },
        "application/vnd.nacamar.ybrid+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ncd.control": {
          source: "iana"
        },
        "application/vnd.ncd.reference": {
          source: "iana"
        },
        "application/vnd.nearst.inv+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nebumind.line": {
          source: "iana"
        },
        "application/vnd.nervana": {
          source: "iana"
        },
        "application/vnd.netfpx": {
          source: "iana"
        },
        "application/vnd.neurolanguage.nlu": {
          source: "iana",
          extensions: ["nlu"]
        },
        "application/vnd.nimn": {
          source: "iana"
        },
        "application/vnd.nintendo.nitro.rom": {
          source: "iana"
        },
        "application/vnd.nintendo.snes.rom": {
          source: "iana"
        },
        "application/vnd.nitf": {
          source: "iana",
          extensions: ["ntf", "nitf"]
        },
        "application/vnd.noblenet-directory": {
          source: "iana",
          extensions: ["nnd"]
        },
        "application/vnd.noblenet-sealer": {
          source: "iana",
          extensions: ["nns"]
        },
        "application/vnd.noblenet-web": {
          source: "iana",
          extensions: ["nnw"]
        },
        "application/vnd.nokia.catalogs": {
          source: "iana"
        },
        "application/vnd.nokia.conml+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.conml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.iptv.config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.isds-radio-presets": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.landmarkcollection+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.n-gage.ac+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ac"]
        },
        "application/vnd.nokia.n-gage.data": {
          source: "iana",
          extensions: ["ngdat"]
        },
        "application/vnd.nokia.n-gage.symbian.install": {
          source: "iana",
          extensions: ["n-gage"]
        },
        "application/vnd.nokia.ncd": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.radio-preset": {
          source: "iana",
          extensions: ["rpst"]
        },
        "application/vnd.nokia.radio-presets": {
          source: "iana",
          extensions: ["rpss"]
        },
        "application/vnd.novadigm.edm": {
          source: "iana",
          extensions: ["edm"]
        },
        "application/vnd.novadigm.edx": {
          source: "iana",
          extensions: ["edx"]
        },
        "application/vnd.novadigm.ext": {
          source: "iana",
          extensions: ["ext"]
        },
        "application/vnd.ntt-local.content-share": {
          source: "iana"
        },
        "application/vnd.ntt-local.file-transfer": {
          source: "iana"
        },
        "application/vnd.ntt-local.ogw_remote-access": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_remote": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_tcp_stream": {
          source: "iana"
        },
        "application/vnd.oasis.opendocument.chart": {
          source: "iana",
          extensions: ["odc"]
        },
        "application/vnd.oasis.opendocument.chart-template": {
          source: "iana",
          extensions: ["otc"]
        },
        "application/vnd.oasis.opendocument.database": {
          source: "iana",
          extensions: ["odb"]
        },
        "application/vnd.oasis.opendocument.formula": {
          source: "iana",
          extensions: ["odf"]
        },
        "application/vnd.oasis.opendocument.formula-template": {
          source: "iana",
          extensions: ["odft"]
        },
        "application/vnd.oasis.opendocument.graphics": {
          source: "iana",
          compressible: false,
          extensions: ["odg"]
        },
        "application/vnd.oasis.opendocument.graphics-template": {
          source: "iana",
          extensions: ["otg"]
        },
        "application/vnd.oasis.opendocument.image": {
          source: "iana",
          extensions: ["odi"]
        },
        "application/vnd.oasis.opendocument.image-template": {
          source: "iana",
          extensions: ["oti"]
        },
        "application/vnd.oasis.opendocument.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["odp"]
        },
        "application/vnd.oasis.opendocument.presentation-template": {
          source: "iana",
          extensions: ["otp"]
        },
        "application/vnd.oasis.opendocument.spreadsheet": {
          source: "iana",
          compressible: false,
          extensions: ["ods"]
        },
        "application/vnd.oasis.opendocument.spreadsheet-template": {
          source: "iana",
          extensions: ["ots"]
        },
        "application/vnd.oasis.opendocument.text": {
          source: "iana",
          compressible: false,
          extensions: ["odt"]
        },
        "application/vnd.oasis.opendocument.text-master": {
          source: "iana",
          extensions: ["odm"]
        },
        "application/vnd.oasis.opendocument.text-template": {
          source: "iana",
          extensions: ["ott"]
        },
        "application/vnd.oasis.opendocument.text-web": {
          source: "iana",
          extensions: ["oth"]
        },
        "application/vnd.obn": {
          source: "iana"
        },
        "application/vnd.ocf+cbor": {
          source: "iana"
        },
        "application/vnd.oci.image.manifest.v1+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oftn.l10n+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessdownload+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessstreaming+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.cspg-hexbinary": {
          source: "iana"
        },
        "application/vnd.oipf.dae.svg+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.dae.xhtml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.mippvcontrolmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.pae.gem": {
          source: "iana"
        },
        "application/vnd.oipf.spdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.spdlist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.ueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.userprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.olpc-sugar": {
          source: "iana",
          extensions: ["xo"]
        },
        "application/vnd.oma-scws-config": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-request": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-response": {
          source: "iana"
        },
        "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.drm-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.imd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.ltkm": {
          source: "iana"
        },
        "application/vnd.oma.bcast.notification+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.provisioningtrigger": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgboot": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgdd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sgdu": {
          source: "iana"
        },
        "application/vnd.oma.bcast.simple-symbol-container": {
          source: "iana"
        },
        "application/vnd.oma.bcast.smartcard-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sprov+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.stkm": {
          source: "iana"
        },
        "application/vnd.oma.cab-address-book+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-feature-handler+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-pcc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-subs-invite+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-user-prefs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.dcd": {
          source: "iana"
        },
        "application/vnd.oma.dcdc": {
          source: "iana"
        },
        "application/vnd.oma.dd2+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dd2"]
        },
        "application/vnd.oma.drm.risd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.group-usage-list+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+cbor": {
          source: "iana"
        },
        "application/vnd.oma.lwm2m+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+tlv": {
          source: "iana"
        },
        "application/vnd.oma.pal+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.detailed-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.final-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.groups+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.invocation-descriptor+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.optimized-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.push": {
          source: "iana"
        },
        "application/vnd.oma.scidm.messages+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.xcap-directory+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.omads-email+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-file+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-folder+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omaloc-supl-init": {
          source: "iana"
        },
        "application/vnd.onepager": {
          source: "iana"
        },
        "application/vnd.onepagertamp": {
          source: "iana"
        },
        "application/vnd.onepagertamx": {
          source: "iana"
        },
        "application/vnd.onepagertat": {
          source: "iana"
        },
        "application/vnd.onepagertatp": {
          source: "iana"
        },
        "application/vnd.onepagertatx": {
          source: "iana"
        },
        "application/vnd.openblox.game+xml": {
          source: "iana",
          compressible: true,
          extensions: ["obgx"]
        },
        "application/vnd.openblox.game-binary": {
          source: "iana"
        },
        "application/vnd.openeye.oeb": {
          source: "iana"
        },
        "application/vnd.openofficeorg.extension": {
          source: "apache",
          extensions: ["oxt"]
        },
        "application/vnd.openstreetmap.data+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osm"]
        },
        "application/vnd.opentimestamps.ots": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawing+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["pptx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide": {
          source: "iana",
          extensions: ["sldx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
          source: "iana",
          extensions: ["ppsx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template": {
          source: "iana",
          extensions: ["potx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
          source: "iana",
          compressible: false,
          extensions: ["xlsx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
          source: "iana",
          extensions: ["xltx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.theme+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.vmldrawing": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
          source: "iana",
          compressible: false,
          extensions: ["docx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
          source: "iana",
          extensions: ["dotx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.core-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.relationships+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oracle.resource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.orange.indata": {
          source: "iana"
        },
        "application/vnd.osa.netdeploy": {
          source: "iana"
        },
        "application/vnd.osgeo.mapguide.package": {
          source: "iana",
          extensions: ["mgp"]
        },
        "application/vnd.osgi.bundle": {
          source: "iana"
        },
        "application/vnd.osgi.dp": {
          source: "iana",
          extensions: ["dp"]
        },
        "application/vnd.osgi.subsystem": {
          source: "iana",
          extensions: ["esa"]
        },
        "application/vnd.otps.ct-kip+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oxli.countgraph": {
          source: "iana"
        },
        "application/vnd.pagerduty+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.palm": {
          source: "iana",
          extensions: ["pdb", "pqa", "oprc"]
        },
        "application/vnd.panoply": {
          source: "iana"
        },
        "application/vnd.paos.xml": {
          source: "iana"
        },
        "application/vnd.patentdive": {
          source: "iana"
        },
        "application/vnd.patientecommsdoc": {
          source: "iana"
        },
        "application/vnd.pawaafile": {
          source: "iana",
          extensions: ["paw"]
        },
        "application/vnd.pcos": {
          source: "iana"
        },
        "application/vnd.pg.format": {
          source: "iana",
          extensions: ["str"]
        },
        "application/vnd.pg.osasli": {
          source: "iana",
          extensions: ["ei6"]
        },
        "application/vnd.piaccess.application-licence": {
          source: "iana"
        },
        "application/vnd.picsel": {
          source: "iana",
          extensions: ["efif"]
        },
        "application/vnd.pmi.widget": {
          source: "iana",
          extensions: ["wg"]
        },
        "application/vnd.poc.group-advertisement+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.pocketlearn": {
          source: "iana",
          extensions: ["plf"]
        },
        "application/vnd.powerbuilder6": {
          source: "iana",
          extensions: ["pbd"]
        },
        "application/vnd.powerbuilder6-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder7": {
          source: "iana"
        },
        "application/vnd.powerbuilder7-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder75": {
          source: "iana"
        },
        "application/vnd.powerbuilder75-s": {
          source: "iana"
        },
        "application/vnd.preminet": {
          source: "iana"
        },
        "application/vnd.previewsystems.box": {
          source: "iana",
          extensions: ["box"]
        },
        "application/vnd.proteus.magazine": {
          source: "iana",
          extensions: ["mgz"]
        },
        "application/vnd.psfs": {
          source: "iana"
        },
        "application/vnd.publishare-delta-tree": {
          source: "iana",
          extensions: ["qps"]
        },
        "application/vnd.pvi.ptid1": {
          source: "iana",
          extensions: ["ptid"]
        },
        "application/vnd.pwg-multiplexed": {
          source: "iana"
        },
        "application/vnd.pwg-xhtml-print+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.qualcomm.brew-app-res": {
          source: "iana"
        },
        "application/vnd.quarantainenet": {
          source: "iana"
        },
        "application/vnd.quark.quarkxpress": {
          source: "iana",
          extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
        },
        "application/vnd.quobject-quoxdocument": {
          source: "iana"
        },
        "application/vnd.radisys.moml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-stream+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-base+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-detect+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-group+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-speech+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-transform+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rainstor.data": {
          source: "iana"
        },
        "application/vnd.rapid": {
          source: "iana"
        },
        "application/vnd.rar": {
          source: "iana",
          extensions: ["rar"]
        },
        "application/vnd.realvnc.bed": {
          source: "iana",
          extensions: ["bed"]
        },
        "application/vnd.recordare.musicxml": {
          source: "iana",
          extensions: ["mxl"]
        },
        "application/vnd.recordare.musicxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musicxml"]
        },
        "application/vnd.renlearn.rlprint": {
          source: "iana"
        },
        "application/vnd.resilient.logic": {
          source: "iana"
        },
        "application/vnd.restful+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rig.cryptonote": {
          source: "iana",
          extensions: ["cryptonote"]
        },
        "application/vnd.rim.cod": {
          source: "apache",
          extensions: ["cod"]
        },
        "application/vnd.rn-realmedia": {
          source: "apache",
          extensions: ["rm"]
        },
        "application/vnd.rn-realmedia-vbr": {
          source: "apache",
          extensions: ["rmvb"]
        },
        "application/vnd.route66.link66+xml": {
          source: "iana",
          compressible: true,
          extensions: ["link66"]
        },
        "application/vnd.rs-274x": {
          source: "iana"
        },
        "application/vnd.ruckus.download": {
          source: "iana"
        },
        "application/vnd.s3sms": {
          source: "iana"
        },
        "application/vnd.sailingtracker.track": {
          source: "iana",
          extensions: ["st"]
        },
        "application/vnd.sar": {
          source: "iana"
        },
        "application/vnd.sbm.cid": {
          source: "iana"
        },
        "application/vnd.sbm.mid2": {
          source: "iana"
        },
        "application/vnd.scribus": {
          source: "iana"
        },
        "application/vnd.sealed.3df": {
          source: "iana"
        },
        "application/vnd.sealed.csf": {
          source: "iana"
        },
        "application/vnd.sealed.doc": {
          source: "iana"
        },
        "application/vnd.sealed.eml": {
          source: "iana"
        },
        "application/vnd.sealed.mht": {
          source: "iana"
        },
        "application/vnd.sealed.net": {
          source: "iana"
        },
        "application/vnd.sealed.ppt": {
          source: "iana"
        },
        "application/vnd.sealed.tiff": {
          source: "iana"
        },
        "application/vnd.sealed.xls": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.html": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.pdf": {
          source: "iana"
        },
        "application/vnd.seemail": {
          source: "iana",
          extensions: ["see"]
        },
        "application/vnd.seis+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.sema": {
          source: "iana",
          extensions: ["sema"]
        },
        "application/vnd.semd": {
          source: "iana",
          extensions: ["semd"]
        },
        "application/vnd.semf": {
          source: "iana",
          extensions: ["semf"]
        },
        "application/vnd.shade-save-file": {
          source: "iana"
        },
        "application/vnd.shana.informed.formdata": {
          source: "iana",
          extensions: ["ifm"]
        },
        "application/vnd.shana.informed.formtemplate": {
          source: "iana",
          extensions: ["itp"]
        },
        "application/vnd.shana.informed.interchange": {
          source: "iana",
          extensions: ["iif"]
        },
        "application/vnd.shana.informed.package": {
          source: "iana",
          extensions: ["ipk"]
        },
        "application/vnd.shootproof+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shopkick+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shp": {
          source: "iana"
        },
        "application/vnd.shx": {
          source: "iana"
        },
        "application/vnd.sigrok.session": {
          source: "iana"
        },
        "application/vnd.simtech-mindmapper": {
          source: "iana",
          extensions: ["twd", "twds"]
        },
        "application/vnd.siren+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.smaf": {
          source: "iana",
          extensions: ["mmf"]
        },
        "application/vnd.smart.notebook": {
          source: "iana"
        },
        "application/vnd.smart.teacher": {
          source: "iana",
          extensions: ["teacher"]
        },
        "application/vnd.snesdev-page-table": {
          source: "iana"
        },
        "application/vnd.software602.filler.form+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fo"]
        },
        "application/vnd.software602.filler.form-xml-zip": {
          source: "iana"
        },
        "application/vnd.solent.sdkm+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sdkm", "sdkd"]
        },
        "application/vnd.spotfire.dxp": {
          source: "iana",
          extensions: ["dxp"]
        },
        "application/vnd.spotfire.sfs": {
          source: "iana",
          extensions: ["sfs"]
        },
        "application/vnd.sqlite3": {
          source: "iana"
        },
        "application/vnd.sss-cod": {
          source: "iana"
        },
        "application/vnd.sss-dtf": {
          source: "iana"
        },
        "application/vnd.sss-ntf": {
          source: "iana"
        },
        "application/vnd.stardivision.calc": {
          source: "apache",
          extensions: ["sdc"]
        },
        "application/vnd.stardivision.draw": {
          source: "apache",
          extensions: ["sda"]
        },
        "application/vnd.stardivision.impress": {
          source: "apache",
          extensions: ["sdd"]
        },
        "application/vnd.stardivision.math": {
          source: "apache",
          extensions: ["smf"]
        },
        "application/vnd.stardivision.writer": {
          source: "apache",
          extensions: ["sdw", "vor"]
        },
        "application/vnd.stardivision.writer-global": {
          source: "apache",
          extensions: ["sgl"]
        },
        "application/vnd.stepmania.package": {
          source: "iana",
          extensions: ["smzip"]
        },
        "application/vnd.stepmania.stepchart": {
          source: "iana",
          extensions: ["sm"]
        },
        "application/vnd.street-stream": {
          source: "iana"
        },
        "application/vnd.sun.wadl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wadl"]
        },
        "application/vnd.sun.xml.calc": {
          source: "apache",
          extensions: ["sxc"]
        },
        "application/vnd.sun.xml.calc.template": {
          source: "apache",
          extensions: ["stc"]
        },
        "application/vnd.sun.xml.draw": {
          source: "apache",
          extensions: ["sxd"]
        },
        "application/vnd.sun.xml.draw.template": {
          source: "apache",
          extensions: ["std"]
        },
        "application/vnd.sun.xml.impress": {
          source: "apache",
          extensions: ["sxi"]
        },
        "application/vnd.sun.xml.impress.template": {
          source: "apache",
          extensions: ["sti"]
        },
        "application/vnd.sun.xml.math": {
          source: "apache",
          extensions: ["sxm"]
        },
        "application/vnd.sun.xml.writer": {
          source: "apache",
          extensions: ["sxw"]
        },
        "application/vnd.sun.xml.writer.global": {
          source: "apache",
          extensions: ["sxg"]
        },
        "application/vnd.sun.xml.writer.template": {
          source: "apache",
          extensions: ["stw"]
        },
        "application/vnd.sus-calendar": {
          source: "iana",
          extensions: ["sus", "susp"]
        },
        "application/vnd.svd": {
          source: "iana",
          extensions: ["svd"]
        },
        "application/vnd.swiftview-ics": {
          source: "iana"
        },
        "application/vnd.sycle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.syft+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.symbian.install": {
          source: "apache",
          extensions: ["sis", "sisx"]
        },
        "application/vnd.syncml+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xsm"]
        },
        "application/vnd.syncml.dm+wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["bdm"]
        },
        "application/vnd.syncml.dm+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xdm"]
        },
        "application/vnd.syncml.dm.notification": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["ddf"]
        },
        "application/vnd.syncml.dmtnds+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmtnds+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.syncml.ds.notification": {
          source: "iana"
        },
        "application/vnd.tableschema+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tao.intent-module-archive": {
          source: "iana",
          extensions: ["tao"]
        },
        "application/vnd.tcpdump.pcap": {
          source: "iana",
          extensions: ["pcap", "cap", "dmp"]
        },
        "application/vnd.think-cell.ppttc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tmd.mediaflex.api+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tml": {
          source: "iana"
        },
        "application/vnd.tmobile-livetv": {
          source: "iana",
          extensions: ["tmo"]
        },
        "application/vnd.tri.onesource": {
          source: "iana"
        },
        "application/vnd.trid.tpt": {
          source: "iana",
          extensions: ["tpt"]
        },
        "application/vnd.triscape.mxs": {
          source: "iana",
          extensions: ["mxs"]
        },
        "application/vnd.trueapp": {
          source: "iana",
          extensions: ["tra"]
        },
        "application/vnd.truedoc": {
          source: "iana"
        },
        "application/vnd.ubisoft.webplayer": {
          source: "iana"
        },
        "application/vnd.ufdl": {
          source: "iana",
          extensions: ["ufd", "ufdl"]
        },
        "application/vnd.uiq.theme": {
          source: "iana",
          extensions: ["utz"]
        },
        "application/vnd.umajin": {
          source: "iana",
          extensions: ["umj"]
        },
        "application/vnd.unity": {
          source: "iana",
          extensions: ["unityweb"]
        },
        "application/vnd.uoml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uoml"]
        },
        "application/vnd.uplanet.alert": {
          source: "iana"
        },
        "application/vnd.uplanet.alert-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.channel": {
          source: "iana"
        },
        "application/vnd.uplanet.channel-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.list": {
          source: "iana"
        },
        "application/vnd.uplanet.list-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.signal": {
          source: "iana"
        },
        "application/vnd.uri-map": {
          source: "iana"
        },
        "application/vnd.valve.source.material": {
          source: "iana"
        },
        "application/vnd.vcx": {
          source: "iana",
          extensions: ["vcx"]
        },
        "application/vnd.vd-study": {
          source: "iana"
        },
        "application/vnd.vectorworks": {
          source: "iana"
        },
        "application/vnd.vel+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.verimatrix.vcas": {
          source: "iana"
        },
        "application/vnd.veritone.aion+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.veryant.thin": {
          source: "iana"
        },
        "application/vnd.ves.encrypted": {
          source: "iana"
        },
        "application/vnd.vidsoft.vidconference": {
          source: "iana"
        },
        "application/vnd.visio": {
          source: "iana",
          extensions: ["vsd", "vst", "vss", "vsw"]
        },
        "application/vnd.visionary": {
          source: "iana",
          extensions: ["vis"]
        },
        "application/vnd.vividence.scriptfile": {
          source: "iana"
        },
        "application/vnd.vsf": {
          source: "iana",
          extensions: ["vsf"]
        },
        "application/vnd.wap.sic": {
          source: "iana"
        },
        "application/vnd.wap.slc": {
          source: "iana"
        },
        "application/vnd.wap.wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["wbxml"]
        },
        "application/vnd.wap.wmlc": {
          source: "iana",
          extensions: ["wmlc"]
        },
        "application/vnd.wap.wmlscriptc": {
          source: "iana",
          extensions: ["wmlsc"]
        },
        "application/vnd.webturbo": {
          source: "iana",
          extensions: ["wtb"]
        },
        "application/vnd.wfa.dpp": {
          source: "iana"
        },
        "application/vnd.wfa.p2p": {
          source: "iana"
        },
        "application/vnd.wfa.wsc": {
          source: "iana"
        },
        "application/vnd.windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.wmc": {
          source: "iana"
        },
        "application/vnd.wmf.bootstrap": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica.package": {
          source: "iana"
        },
        "application/vnd.wolfram.player": {
          source: "iana",
          extensions: ["nbp"]
        },
        "application/vnd.wordperfect": {
          source: "iana",
          extensions: ["wpd"]
        },
        "application/vnd.wqd": {
          source: "iana",
          extensions: ["wqd"]
        },
        "application/vnd.wrq-hp3000-labelled": {
          source: "iana"
        },
        "application/vnd.wt.stf": {
          source: "iana",
          extensions: ["stf"]
        },
        "application/vnd.wv.csp+wbxml": {
          source: "iana"
        },
        "application/vnd.wv.csp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.wv.ssp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xacml+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xara": {
          source: "iana",
          extensions: ["xar"]
        },
        "application/vnd.xfdl": {
          source: "iana",
          extensions: ["xfdl"]
        },
        "application/vnd.xfdl.webform": {
          source: "iana"
        },
        "application/vnd.xmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xmpie.cpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.dpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.plan": {
          source: "iana"
        },
        "application/vnd.xmpie.ppkg": {
          source: "iana"
        },
        "application/vnd.xmpie.xlim": {
          source: "iana"
        },
        "application/vnd.yamaha.hv-dic": {
          source: "iana",
          extensions: ["hvd"]
        },
        "application/vnd.yamaha.hv-script": {
          source: "iana",
          extensions: ["hvs"]
        },
        "application/vnd.yamaha.hv-voice": {
          source: "iana",
          extensions: ["hvp"]
        },
        "application/vnd.yamaha.openscoreformat": {
          source: "iana",
          extensions: ["osf"]
        },
        "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osfpvg"]
        },
        "application/vnd.yamaha.remote-setup": {
          source: "iana"
        },
        "application/vnd.yamaha.smaf-audio": {
          source: "iana",
          extensions: ["saf"]
        },
        "application/vnd.yamaha.smaf-phrase": {
          source: "iana",
          extensions: ["spf"]
        },
        "application/vnd.yamaha.through-ngn": {
          source: "iana"
        },
        "application/vnd.yamaha.tunnel-udpencap": {
          source: "iana"
        },
        "application/vnd.yaoweme": {
          source: "iana"
        },
        "application/vnd.yellowriver-custom-menu": {
          source: "iana",
          extensions: ["cmp"]
        },
        "application/vnd.youtube.yt": {
          source: "iana"
        },
        "application/vnd.zul": {
          source: "iana",
          extensions: ["zir", "zirz"]
        },
        "application/vnd.zzazz.deck+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zaz"]
        },
        "application/voicexml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["vxml"]
        },
        "application/voucher-cms+json": {
          source: "iana",
          compressible: true
        },
        "application/vq-rtcpxr": {
          source: "iana"
        },
        "application/wasm": {
          source: "iana",
          compressible: true,
          extensions: ["wasm"]
        },
        "application/watcherinfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wif"]
        },
        "application/webpush-options+json": {
          source: "iana",
          compressible: true
        },
        "application/whoispp-query": {
          source: "iana"
        },
        "application/whoispp-response": {
          source: "iana"
        },
        "application/widget": {
          source: "iana",
          extensions: ["wgt"]
        },
        "application/winhlp": {
          source: "apache",
          extensions: ["hlp"]
        },
        "application/wita": {
          source: "iana"
        },
        "application/wordperfect5.1": {
          source: "iana"
        },
        "application/wsdl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wsdl"]
        },
        "application/wspolicy+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wspolicy"]
        },
        "application/x-7z-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["7z"]
        },
        "application/x-abiword": {
          source: "apache",
          extensions: ["abw"]
        },
        "application/x-ace-compressed": {
          source: "apache",
          extensions: ["ace"]
        },
        "application/x-amf": {
          source: "apache"
        },
        "application/x-apple-diskimage": {
          source: "apache",
          extensions: ["dmg"]
        },
        "application/x-arj": {
          compressible: false,
          extensions: ["arj"]
        },
        "application/x-authorware-bin": {
          source: "apache",
          extensions: ["aab", "x32", "u32", "vox"]
        },
        "application/x-authorware-map": {
          source: "apache",
          extensions: ["aam"]
        },
        "application/x-authorware-seg": {
          source: "apache",
          extensions: ["aas"]
        },
        "application/x-bcpio": {
          source: "apache",
          extensions: ["bcpio"]
        },
        "application/x-bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/x-bittorrent": {
          source: "apache",
          extensions: ["torrent"]
        },
        "application/x-blorb": {
          source: "apache",
          extensions: ["blb", "blorb"]
        },
        "application/x-bzip": {
          source: "apache",
          compressible: false,
          extensions: ["bz"]
        },
        "application/x-bzip2": {
          source: "apache",
          compressible: false,
          extensions: ["bz2", "boz"]
        },
        "application/x-cbr": {
          source: "apache",
          extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
        },
        "application/x-cdlink": {
          source: "apache",
          extensions: ["vcd"]
        },
        "application/x-cfs-compressed": {
          source: "apache",
          extensions: ["cfs"]
        },
        "application/x-chat": {
          source: "apache",
          extensions: ["chat"]
        },
        "application/x-chess-pgn": {
          source: "apache",
          extensions: ["pgn"]
        },
        "application/x-chrome-extension": {
          extensions: ["crx"]
        },
        "application/x-cocoa": {
          source: "nginx",
          extensions: ["cco"]
        },
        "application/x-compress": {
          source: "apache"
        },
        "application/x-conference": {
          source: "apache",
          extensions: ["nsc"]
        },
        "application/x-cpio": {
          source: "apache",
          extensions: ["cpio"]
        },
        "application/x-csh": {
          source: "apache",
          extensions: ["csh"]
        },
        "application/x-deb": {
          compressible: false
        },
        "application/x-debian-package": {
          source: "apache",
          extensions: ["deb", "udeb"]
        },
        "application/x-dgc-compressed": {
          source: "apache",
          extensions: ["dgc"]
        },
        "application/x-director": {
          source: "apache",
          extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
        },
        "application/x-doom": {
          source: "apache",
          extensions: ["wad"]
        },
        "application/x-dtbncx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ncx"]
        },
        "application/x-dtbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dtb"]
        },
        "application/x-dtbresource+xml": {
          source: "apache",
          compressible: true,
          extensions: ["res"]
        },
        "application/x-dvi": {
          source: "apache",
          compressible: false,
          extensions: ["dvi"]
        },
        "application/x-envoy": {
          source: "apache",
          extensions: ["evy"]
        },
        "application/x-eva": {
          source: "apache",
          extensions: ["eva"]
        },
        "application/x-font-bdf": {
          source: "apache",
          extensions: ["bdf"]
        },
        "application/x-font-dos": {
          source: "apache"
        },
        "application/x-font-framemaker": {
          source: "apache"
        },
        "application/x-font-ghostscript": {
          source: "apache",
          extensions: ["gsf"]
        },
        "application/x-font-libgrx": {
          source: "apache"
        },
        "application/x-font-linux-psf": {
          source: "apache",
          extensions: ["psf"]
        },
        "application/x-font-pcf": {
          source: "apache",
          extensions: ["pcf"]
        },
        "application/x-font-snf": {
          source: "apache",
          extensions: ["snf"]
        },
        "application/x-font-speedo": {
          source: "apache"
        },
        "application/x-font-sunos-news": {
          source: "apache"
        },
        "application/x-font-type1": {
          source: "apache",
          extensions: ["pfa", "pfb", "pfm", "afm"]
        },
        "application/x-font-vfont": {
          source: "apache"
        },
        "application/x-freearc": {
          source: "apache",
          extensions: ["arc"]
        },
        "application/x-futuresplash": {
          source: "apache",
          extensions: ["spl"]
        },
        "application/x-gca-compressed": {
          source: "apache",
          extensions: ["gca"]
        },
        "application/x-glulx": {
          source: "apache",
          extensions: ["ulx"]
        },
        "application/x-gnumeric": {
          source: "apache",
          extensions: ["gnumeric"]
        },
        "application/x-gramps-xml": {
          source: "apache",
          extensions: ["gramps"]
        },
        "application/x-gtar": {
          source: "apache",
          extensions: ["gtar"]
        },
        "application/x-gzip": {
          source: "apache"
        },
        "application/x-hdf": {
          source: "apache",
          extensions: ["hdf"]
        },
        "application/x-httpd-php": {
          compressible: true,
          extensions: ["php"]
        },
        "application/x-install-instructions": {
          source: "apache",
          extensions: ["install"]
        },
        "application/x-iso9660-image": {
          source: "apache",
          extensions: ["iso"]
        },
        "application/x-iwork-keynote-sffkey": {
          extensions: ["key"]
        },
        "application/x-iwork-numbers-sffnumbers": {
          extensions: ["numbers"]
        },
        "application/x-iwork-pages-sffpages": {
          extensions: ["pages"]
        },
        "application/x-java-archive-diff": {
          source: "nginx",
          extensions: ["jardiff"]
        },
        "application/x-java-jnlp-file": {
          source: "apache",
          compressible: false,
          extensions: ["jnlp"]
        },
        "application/x-javascript": {
          compressible: true
        },
        "application/x-keepass2": {
          extensions: ["kdbx"]
        },
        "application/x-latex": {
          source: "apache",
          compressible: false,
          extensions: ["latex"]
        },
        "application/x-lua-bytecode": {
          extensions: ["luac"]
        },
        "application/x-lzh-compressed": {
          source: "apache",
          extensions: ["lzh", "lha"]
        },
        "application/x-makeself": {
          source: "nginx",
          extensions: ["run"]
        },
        "application/x-mie": {
          source: "apache",
          extensions: ["mie"]
        },
        "application/x-mobipocket-ebook": {
          source: "apache",
          extensions: ["prc", "mobi"]
        },
        "application/x-mpegurl": {
          compressible: false
        },
        "application/x-ms-application": {
          source: "apache",
          extensions: ["application"]
        },
        "application/x-ms-shortcut": {
          source: "apache",
          extensions: ["lnk"]
        },
        "application/x-ms-wmd": {
          source: "apache",
          extensions: ["wmd"]
        },
        "application/x-ms-wmz": {
          source: "apache",
          extensions: ["wmz"]
        },
        "application/x-ms-xbap": {
          source: "apache",
          extensions: ["xbap"]
        },
        "application/x-msaccess": {
          source: "apache",
          extensions: ["mdb"]
        },
        "application/x-msbinder": {
          source: "apache",
          extensions: ["obd"]
        },
        "application/x-mscardfile": {
          source: "apache",
          extensions: ["crd"]
        },
        "application/x-msclip": {
          source: "apache",
          extensions: ["clp"]
        },
        "application/x-msdos-program": {
          extensions: ["exe"]
        },
        "application/x-msdownload": {
          source: "apache",
          extensions: ["exe", "dll", "com", "bat", "msi"]
        },
        "application/x-msmediaview": {
          source: "apache",
          extensions: ["mvb", "m13", "m14"]
        },
        "application/x-msmetafile": {
          source: "apache",
          extensions: ["wmf", "wmz", "emf", "emz"]
        },
        "application/x-msmoney": {
          source: "apache",
          extensions: ["mny"]
        },
        "application/x-mspublisher": {
          source: "apache",
          extensions: ["pub"]
        },
        "application/x-msschedule": {
          source: "apache",
          extensions: ["scd"]
        },
        "application/x-msterminal": {
          source: "apache",
          extensions: ["trm"]
        },
        "application/x-mswrite": {
          source: "apache",
          extensions: ["wri"]
        },
        "application/x-netcdf": {
          source: "apache",
          extensions: ["nc", "cdf"]
        },
        "application/x-ns-proxy-autoconfig": {
          compressible: true,
          extensions: ["pac"]
        },
        "application/x-nzb": {
          source: "apache",
          extensions: ["nzb"]
        },
        "application/x-perl": {
          source: "nginx",
          extensions: ["pl", "pm"]
        },
        "application/x-pilot": {
          source: "nginx",
          extensions: ["prc", "pdb"]
        },
        "application/x-pkcs12": {
          source: "apache",
          compressible: false,
          extensions: ["p12", "pfx"]
        },
        "application/x-pkcs7-certificates": {
          source: "apache",
          extensions: ["p7b", "spc"]
        },
        "application/x-pkcs7-certreqresp": {
          source: "apache",
          extensions: ["p7r"]
        },
        "application/x-pki-message": {
          source: "iana"
        },
        "application/x-rar-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["rar"]
        },
        "application/x-redhat-package-manager": {
          source: "nginx",
          extensions: ["rpm"]
        },
        "application/x-research-info-systems": {
          source: "apache",
          extensions: ["ris"]
        },
        "application/x-sea": {
          source: "nginx",
          extensions: ["sea"]
        },
        "application/x-sh": {
          source: "apache",
          compressible: true,
          extensions: ["sh"]
        },
        "application/x-shar": {
          source: "apache",
          extensions: ["shar"]
        },
        "application/x-shockwave-flash": {
          source: "apache",
          compressible: false,
          extensions: ["swf"]
        },
        "application/x-silverlight-app": {
          source: "apache",
          extensions: ["xap"]
        },
        "application/x-sql": {
          source: "apache",
          extensions: ["sql"]
        },
        "application/x-stuffit": {
          source: "apache",
          compressible: false,
          extensions: ["sit"]
        },
        "application/x-stuffitx": {
          source: "apache",
          extensions: ["sitx"]
        },
        "application/x-subrip": {
          source: "apache",
          extensions: ["srt"]
        },
        "application/x-sv4cpio": {
          source: "apache",
          extensions: ["sv4cpio"]
        },
        "application/x-sv4crc": {
          source: "apache",
          extensions: ["sv4crc"]
        },
        "application/x-t3vm-image": {
          source: "apache",
          extensions: ["t3"]
        },
        "application/x-tads": {
          source: "apache",
          extensions: ["gam"]
        },
        "application/x-tar": {
          source: "apache",
          compressible: true,
          extensions: ["tar"]
        },
        "application/x-tcl": {
          source: "apache",
          extensions: ["tcl", "tk"]
        },
        "application/x-tex": {
          source: "apache",
          extensions: ["tex"]
        },
        "application/x-tex-tfm": {
          source: "apache",
          extensions: ["tfm"]
        },
        "application/x-texinfo": {
          source: "apache",
          extensions: ["texinfo", "texi"]
        },
        "application/x-tgif": {
          source: "apache",
          extensions: ["obj"]
        },
        "application/x-ustar": {
          source: "apache",
          extensions: ["ustar"]
        },
        "application/x-virtualbox-hdd": {
          compressible: true,
          extensions: ["hdd"]
        },
        "application/x-virtualbox-ova": {
          compressible: true,
          extensions: ["ova"]
        },
        "application/x-virtualbox-ovf": {
          compressible: true,
          extensions: ["ovf"]
        },
        "application/x-virtualbox-vbox": {
          compressible: true,
          extensions: ["vbox"]
        },
        "application/x-virtualbox-vbox-extpack": {
          compressible: false,
          extensions: ["vbox-extpack"]
        },
        "application/x-virtualbox-vdi": {
          compressible: true,
          extensions: ["vdi"]
        },
        "application/x-virtualbox-vhd": {
          compressible: true,
          extensions: ["vhd"]
        },
        "application/x-virtualbox-vmdk": {
          compressible: true,
          extensions: ["vmdk"]
        },
        "application/x-wais-source": {
          source: "apache",
          extensions: ["src"]
        },
        "application/x-web-app-manifest+json": {
          compressible: true,
          extensions: ["webapp"]
        },
        "application/x-www-form-urlencoded": {
          source: "iana",
          compressible: true
        },
        "application/x-x509-ca-cert": {
          source: "iana",
          extensions: ["der", "crt", "pem"]
        },
        "application/x-x509-ca-ra-cert": {
          source: "iana"
        },
        "application/x-x509-next-ca-cert": {
          source: "iana"
        },
        "application/x-xfig": {
          source: "apache",
          extensions: ["fig"]
        },
        "application/x-xliff+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/x-xpinstall": {
          source: "apache",
          compressible: false,
          extensions: ["xpi"]
        },
        "application/x-xz": {
          source: "apache",
          extensions: ["xz"]
        },
        "application/x-zmachine": {
          source: "apache",
          extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
        },
        "application/x400-bp": {
          source: "iana"
        },
        "application/xacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/xaml+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xaml"]
        },
        "application/xcap-att+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xav"]
        },
        "application/xcap-caps+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xca"]
        },
        "application/xcap-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdf"]
        },
        "application/xcap-el+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xel"]
        },
        "application/xcap-error+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcap-ns+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xns"]
        },
        "application/xcon-conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcon-conference-info-diff+xml": {
          source: "iana",
          compressible: true
        },
        "application/xenc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xenc"]
        },
        "application/xhtml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xhtml", "xht"]
        },
        "application/xhtml-voice+xml": {
          source: "apache",
          compressible: true
        },
        "application/xliff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml", "xsl", "xsd", "rng"]
        },
        "application/xml-dtd": {
          source: "iana",
          compressible: true,
          extensions: ["dtd"]
        },
        "application/xml-external-parsed-entity": {
          source: "iana"
        },
        "application/xml-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/xmpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/xop+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xop"]
        },
        "application/xproc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xpl"]
        },
        "application/xslt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xsl", "xslt"]
        },
        "application/xspf+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xspf"]
        },
        "application/xv+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mxml", "xhvml", "xvml", "xvm"]
        },
        "application/yang": {
          source: "iana",
          extensions: ["yang"]
        },
        "application/yang-data+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-data+xml": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/yin+xml": {
          source: "iana",
          compressible: true,
          extensions: ["yin"]
        },
        "application/zip": {
          source: "iana",
          compressible: false,
          extensions: ["zip"]
        },
        "application/zlib": {
          source: "iana"
        },
        "application/zstd": {
          source: "iana"
        },
        "audio/1d-interleaved-parityfec": {
          source: "iana"
        },
        "audio/32kadpcm": {
          source: "iana"
        },
        "audio/3gpp": {
          source: "iana",
          compressible: false,
          extensions: ["3gpp"]
        },
        "audio/3gpp2": {
          source: "iana"
        },
        "audio/aac": {
          source: "iana"
        },
        "audio/ac3": {
          source: "iana"
        },
        "audio/adpcm": {
          source: "apache",
          extensions: ["adp"]
        },
        "audio/amr": {
          source: "iana",
          extensions: ["amr"]
        },
        "audio/amr-wb": {
          source: "iana"
        },
        "audio/amr-wb+": {
          source: "iana"
        },
        "audio/aptx": {
          source: "iana"
        },
        "audio/asc": {
          source: "iana"
        },
        "audio/atrac-advanced-lossless": {
          source: "iana"
        },
        "audio/atrac-x": {
          source: "iana"
        },
        "audio/atrac3": {
          source: "iana"
        },
        "audio/basic": {
          source: "iana",
          compressible: false,
          extensions: ["au", "snd"]
        },
        "audio/bv16": {
          source: "iana"
        },
        "audio/bv32": {
          source: "iana"
        },
        "audio/clearmode": {
          source: "iana"
        },
        "audio/cn": {
          source: "iana"
        },
        "audio/dat12": {
          source: "iana"
        },
        "audio/dls": {
          source: "iana"
        },
        "audio/dsr-es201108": {
          source: "iana"
        },
        "audio/dsr-es202050": {
          source: "iana"
        },
        "audio/dsr-es202211": {
          source: "iana"
        },
        "audio/dsr-es202212": {
          source: "iana"
        },
        "audio/dv": {
          source: "iana"
        },
        "audio/dvi4": {
          source: "iana"
        },
        "audio/eac3": {
          source: "iana"
        },
        "audio/encaprtp": {
          source: "iana"
        },
        "audio/evrc": {
          source: "iana"
        },
        "audio/evrc-qcp": {
          source: "iana"
        },
        "audio/evrc0": {
          source: "iana"
        },
        "audio/evrc1": {
          source: "iana"
        },
        "audio/evrcb": {
          source: "iana"
        },
        "audio/evrcb0": {
          source: "iana"
        },
        "audio/evrcb1": {
          source: "iana"
        },
        "audio/evrcnw": {
          source: "iana"
        },
        "audio/evrcnw0": {
          source: "iana"
        },
        "audio/evrcnw1": {
          source: "iana"
        },
        "audio/evrcwb": {
          source: "iana"
        },
        "audio/evrcwb0": {
          source: "iana"
        },
        "audio/evrcwb1": {
          source: "iana"
        },
        "audio/evs": {
          source: "iana"
        },
        "audio/flexfec": {
          source: "iana"
        },
        "audio/fwdred": {
          source: "iana"
        },
        "audio/g711-0": {
          source: "iana"
        },
        "audio/g719": {
          source: "iana"
        },
        "audio/g722": {
          source: "iana"
        },
        "audio/g7221": {
          source: "iana"
        },
        "audio/g723": {
          source: "iana"
        },
        "audio/g726-16": {
          source: "iana"
        },
        "audio/g726-24": {
          source: "iana"
        },
        "audio/g726-32": {
          source: "iana"
        },
        "audio/g726-40": {
          source: "iana"
        },
        "audio/g728": {
          source: "iana"
        },
        "audio/g729": {
          source: "iana"
        },
        "audio/g7291": {
          source: "iana"
        },
        "audio/g729d": {
          source: "iana"
        },
        "audio/g729e": {
          source: "iana"
        },
        "audio/gsm": {
          source: "iana"
        },
        "audio/gsm-efr": {
          source: "iana"
        },
        "audio/gsm-hr-08": {
          source: "iana"
        },
        "audio/ilbc": {
          source: "iana"
        },
        "audio/ip-mr_v2.5": {
          source: "iana"
        },
        "audio/isac": {
          source: "apache"
        },
        "audio/l16": {
          source: "iana"
        },
        "audio/l20": {
          source: "iana"
        },
        "audio/l24": {
          source: "iana",
          compressible: false
        },
        "audio/l8": {
          source: "iana"
        },
        "audio/lpc": {
          source: "iana"
        },
        "audio/melp": {
          source: "iana"
        },
        "audio/melp1200": {
          source: "iana"
        },
        "audio/melp2400": {
          source: "iana"
        },
        "audio/melp600": {
          source: "iana"
        },
        "audio/mhas": {
          source: "iana"
        },
        "audio/midi": {
          source: "apache",
          extensions: ["mid", "midi", "kar", "rmi"]
        },
        "audio/mobile-xmf": {
          source: "iana",
          extensions: ["mxmf"]
        },
        "audio/mp3": {
          compressible: false,
          extensions: ["mp3"]
        },
        "audio/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["m4a", "mp4a"]
        },
        "audio/mp4a-latm": {
          source: "iana"
        },
        "audio/mpa": {
          source: "iana"
        },
        "audio/mpa-robust": {
          source: "iana"
        },
        "audio/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
        },
        "audio/mpeg4-generic": {
          source: "iana"
        },
        "audio/musepack": {
          source: "apache"
        },
        "audio/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["oga", "ogg", "spx", "opus"]
        },
        "audio/opus": {
          source: "iana"
        },
        "audio/parityfec": {
          source: "iana"
        },
        "audio/pcma": {
          source: "iana"
        },
        "audio/pcma-wb": {
          source: "iana"
        },
        "audio/pcmu": {
          source: "iana"
        },
        "audio/pcmu-wb": {
          source: "iana"
        },
        "audio/prs.sid": {
          source: "iana"
        },
        "audio/qcelp": {
          source: "iana"
        },
        "audio/raptorfec": {
          source: "iana"
        },
        "audio/red": {
          source: "iana"
        },
        "audio/rtp-enc-aescm128": {
          source: "iana"
        },
        "audio/rtp-midi": {
          source: "iana"
        },
        "audio/rtploopback": {
          source: "iana"
        },
        "audio/rtx": {
          source: "iana"
        },
        "audio/s3m": {
          source: "apache",
          extensions: ["s3m"]
        },
        "audio/scip": {
          source: "iana"
        },
        "audio/silk": {
          source: "apache",
          extensions: ["sil"]
        },
        "audio/smv": {
          source: "iana"
        },
        "audio/smv-qcp": {
          source: "iana"
        },
        "audio/smv0": {
          source: "iana"
        },
        "audio/sofa": {
          source: "iana"
        },
        "audio/sp-midi": {
          source: "iana"
        },
        "audio/speex": {
          source: "iana"
        },
        "audio/t140c": {
          source: "iana"
        },
        "audio/t38": {
          source: "iana"
        },
        "audio/telephone-event": {
          source: "iana"
        },
        "audio/tetra_acelp": {
          source: "iana"
        },
        "audio/tetra_acelp_bb": {
          source: "iana"
        },
        "audio/tone": {
          source: "iana"
        },
        "audio/tsvcis": {
          source: "iana"
        },
        "audio/uemclip": {
          source: "iana"
        },
        "audio/ulpfec": {
          source: "iana"
        },
        "audio/usac": {
          source: "iana"
        },
        "audio/vdvi": {
          source: "iana"
        },
        "audio/vmr-wb": {
          source: "iana"
        },
        "audio/vnd.3gpp.iufp": {
          source: "iana"
        },
        "audio/vnd.4sb": {
          source: "iana"
        },
        "audio/vnd.audiokoz": {
          source: "iana"
        },
        "audio/vnd.celp": {
          source: "iana"
        },
        "audio/vnd.cisco.nse": {
          source: "iana"
        },
        "audio/vnd.cmles.radio-events": {
          source: "iana"
        },
        "audio/vnd.cns.anp1": {
          source: "iana"
        },
        "audio/vnd.cns.inf1": {
          source: "iana"
        },
        "audio/vnd.dece.audio": {
          source: "iana",
          extensions: ["uva", "uvva"]
        },
        "audio/vnd.digital-winds": {
          source: "iana",
          extensions: ["eol"]
        },
        "audio/vnd.dlna.adts": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.1": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.2": {
          source: "iana"
        },
        "audio/vnd.dolby.mlp": {
          source: "iana"
        },
        "audio/vnd.dolby.mps": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2x": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2z": {
          source: "iana"
        },
        "audio/vnd.dolby.pulse.1": {
          source: "iana"
        },
        "audio/vnd.dra": {
          source: "iana",
          extensions: ["dra"]
        },
        "audio/vnd.dts": {
          source: "iana",
          extensions: ["dts"]
        },
        "audio/vnd.dts.hd": {
          source: "iana",
          extensions: ["dtshd"]
        },
        "audio/vnd.dts.uhd": {
          source: "iana"
        },
        "audio/vnd.dvb.file": {
          source: "iana"
        },
        "audio/vnd.everad.plj": {
          source: "iana"
        },
        "audio/vnd.hns.audio": {
          source: "iana"
        },
        "audio/vnd.lucent.voice": {
          source: "iana",
          extensions: ["lvp"]
        },
        "audio/vnd.ms-playready.media.pya": {
          source: "iana",
          extensions: ["pya"]
        },
        "audio/vnd.nokia.mobile-xmf": {
          source: "iana"
        },
        "audio/vnd.nortel.vbk": {
          source: "iana"
        },
        "audio/vnd.nuera.ecelp4800": {
          source: "iana",
          extensions: ["ecelp4800"]
        },
        "audio/vnd.nuera.ecelp7470": {
          source: "iana",
          extensions: ["ecelp7470"]
        },
        "audio/vnd.nuera.ecelp9600": {
          source: "iana",
          extensions: ["ecelp9600"]
        },
        "audio/vnd.octel.sbc": {
          source: "iana"
        },
        "audio/vnd.presonus.multitrack": {
          source: "iana"
        },
        "audio/vnd.qcelp": {
          source: "iana"
        },
        "audio/vnd.rhetorex.32kadpcm": {
          source: "iana"
        },
        "audio/vnd.rip": {
          source: "iana",
          extensions: ["rip"]
        },
        "audio/vnd.rn-realaudio": {
          compressible: false
        },
        "audio/vnd.sealedmedia.softseal.mpeg": {
          source: "iana"
        },
        "audio/vnd.vmx.cvsd": {
          source: "iana"
        },
        "audio/vnd.wave": {
          compressible: false
        },
        "audio/vorbis": {
          source: "iana",
          compressible: false
        },
        "audio/vorbis-config": {
          source: "iana"
        },
        "audio/wav": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/wave": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/webm": {
          source: "apache",
          compressible: false,
          extensions: ["weba"]
        },
        "audio/x-aac": {
          source: "apache",
          compressible: false,
          extensions: ["aac"]
        },
        "audio/x-aiff": {
          source: "apache",
          extensions: ["aif", "aiff", "aifc"]
        },
        "audio/x-caf": {
          source: "apache",
          compressible: false,
          extensions: ["caf"]
        },
        "audio/x-flac": {
          source: "apache",
          extensions: ["flac"]
        },
        "audio/x-m4a": {
          source: "nginx",
          extensions: ["m4a"]
        },
        "audio/x-matroska": {
          source: "apache",
          extensions: ["mka"]
        },
        "audio/x-mpegurl": {
          source: "apache",
          extensions: ["m3u"]
        },
        "audio/x-ms-wax": {
          source: "apache",
          extensions: ["wax"]
        },
        "audio/x-ms-wma": {
          source: "apache",
          extensions: ["wma"]
        },
        "audio/x-pn-realaudio": {
          source: "apache",
          extensions: ["ram", "ra"]
        },
        "audio/x-pn-realaudio-plugin": {
          source: "apache",
          extensions: ["rmp"]
        },
        "audio/x-realaudio": {
          source: "nginx",
          extensions: ["ra"]
        },
        "audio/x-tta": {
          source: "apache"
        },
        "audio/x-wav": {
          source: "apache",
          extensions: ["wav"]
        },
        "audio/xm": {
          source: "apache",
          extensions: ["xm"]
        },
        "chemical/x-cdx": {
          source: "apache",
          extensions: ["cdx"]
        },
        "chemical/x-cif": {
          source: "apache",
          extensions: ["cif"]
        },
        "chemical/x-cmdf": {
          source: "apache",
          extensions: ["cmdf"]
        },
        "chemical/x-cml": {
          source: "apache",
          extensions: ["cml"]
        },
        "chemical/x-csml": {
          source: "apache",
          extensions: ["csml"]
        },
        "chemical/x-pdb": {
          source: "apache"
        },
        "chemical/x-xyz": {
          source: "apache",
          extensions: ["xyz"]
        },
        "font/collection": {
          source: "iana",
          extensions: ["ttc"]
        },
        "font/otf": {
          source: "iana",
          compressible: true,
          extensions: ["otf"]
        },
        "font/sfnt": {
          source: "iana"
        },
        "font/ttf": {
          source: "iana",
          compressible: true,
          extensions: ["ttf"]
        },
        "font/woff": {
          source: "iana",
          extensions: ["woff"]
        },
        "font/woff2": {
          source: "iana",
          extensions: ["woff2"]
        },
        "image/aces": {
          source: "iana",
          extensions: ["exr"]
        },
        "image/apng": {
          compressible: false,
          extensions: ["apng"]
        },
        "image/avci": {
          source: "iana",
          extensions: ["avci"]
        },
        "image/avcs": {
          source: "iana",
          extensions: ["avcs"]
        },
        "image/avif": {
          source: "iana",
          compressible: false,
          extensions: ["avif"]
        },
        "image/bmp": {
          source: "iana",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/cgm": {
          source: "iana",
          extensions: ["cgm"]
        },
        "image/dicom-rle": {
          source: "iana",
          extensions: ["drle"]
        },
        "image/emf": {
          source: "iana",
          extensions: ["emf"]
        },
        "image/fits": {
          source: "iana",
          extensions: ["fits"]
        },
        "image/g3fax": {
          source: "iana",
          extensions: ["g3"]
        },
        "image/gif": {
          source: "iana",
          compressible: false,
          extensions: ["gif"]
        },
        "image/heic": {
          source: "iana",
          extensions: ["heic"]
        },
        "image/heic-sequence": {
          source: "iana",
          extensions: ["heics"]
        },
        "image/heif": {
          source: "iana",
          extensions: ["heif"]
        },
        "image/heif-sequence": {
          source: "iana",
          extensions: ["heifs"]
        },
        "image/hej2k": {
          source: "iana",
          extensions: ["hej2"]
        },
        "image/hsj2": {
          source: "iana",
          extensions: ["hsj2"]
        },
        "image/ief": {
          source: "iana",
          extensions: ["ief"]
        },
        "image/jls": {
          source: "iana",
          extensions: ["jls"]
        },
        "image/jp2": {
          source: "iana",
          compressible: false,
          extensions: ["jp2", "jpg2"]
        },
        "image/jpeg": {
          source: "iana",
          compressible: false,
          extensions: ["jpeg", "jpg", "jpe"]
        },
        "image/jph": {
          source: "iana",
          extensions: ["jph"]
        },
        "image/jphc": {
          source: "iana",
          extensions: ["jhc"]
        },
        "image/jpm": {
          source: "iana",
          compressible: false,
          extensions: ["jpm"]
        },
        "image/jpx": {
          source: "iana",
          compressible: false,
          extensions: ["jpx", "jpf"]
        },
        "image/jxr": {
          source: "iana",
          extensions: ["jxr"]
        },
        "image/jxra": {
          source: "iana",
          extensions: ["jxra"]
        },
        "image/jxrs": {
          source: "iana",
          extensions: ["jxrs"]
        },
        "image/jxs": {
          source: "iana",
          extensions: ["jxs"]
        },
        "image/jxsc": {
          source: "iana",
          extensions: ["jxsc"]
        },
        "image/jxsi": {
          source: "iana",
          extensions: ["jxsi"]
        },
        "image/jxss": {
          source: "iana",
          extensions: ["jxss"]
        },
        "image/ktx": {
          source: "iana",
          extensions: ["ktx"]
        },
        "image/ktx2": {
          source: "iana",
          extensions: ["ktx2"]
        },
        "image/naplps": {
          source: "iana"
        },
        "image/pjpeg": {
          compressible: false
        },
        "image/png": {
          source: "iana",
          compressible: false,
          extensions: ["png"]
        },
        "image/prs.btif": {
          source: "iana",
          extensions: ["btif"]
        },
        "image/prs.pti": {
          source: "iana",
          extensions: ["pti"]
        },
        "image/pwg-raster": {
          source: "iana"
        },
        "image/sgi": {
          source: "apache",
          extensions: ["sgi"]
        },
        "image/svg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["svg", "svgz"]
        },
        "image/t38": {
          source: "iana",
          extensions: ["t38"]
        },
        "image/tiff": {
          source: "iana",
          compressible: false,
          extensions: ["tif", "tiff"]
        },
        "image/tiff-fx": {
          source: "iana",
          extensions: ["tfx"]
        },
        "image/vnd.adobe.photoshop": {
          source: "iana",
          compressible: true,
          extensions: ["psd"]
        },
        "image/vnd.airzip.accelerator.azv": {
          source: "iana",
          extensions: ["azv"]
        },
        "image/vnd.cns.inf2": {
          source: "iana"
        },
        "image/vnd.dece.graphic": {
          source: "iana",
          extensions: ["uvi", "uvvi", "uvg", "uvvg"]
        },
        "image/vnd.djvu": {
          source: "iana",
          extensions: ["djvu", "djv"]
        },
        "image/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "image/vnd.dwg": {
          source: "iana",
          extensions: ["dwg"]
        },
        "image/vnd.dxf": {
          source: "iana",
          extensions: ["dxf"]
        },
        "image/vnd.fastbidsheet": {
          source: "iana",
          extensions: ["fbs"]
        },
        "image/vnd.fpx": {
          source: "iana",
          extensions: ["fpx"]
        },
        "image/vnd.fst": {
          source: "iana",
          extensions: ["fst"]
        },
        "image/vnd.fujixerox.edmics-mmr": {
          source: "iana",
          extensions: ["mmr"]
        },
        "image/vnd.fujixerox.edmics-rlc": {
          source: "iana",
          extensions: ["rlc"]
        },
        "image/vnd.globalgraphics.pgb": {
          source: "iana"
        },
        "image/vnd.microsoft.icon": {
          source: "iana",
          compressible: true,
          extensions: ["ico"]
        },
        "image/vnd.mix": {
          source: "iana"
        },
        "image/vnd.mozilla.apng": {
          source: "iana"
        },
        "image/vnd.ms-dds": {
          compressible: true,
          extensions: ["dds"]
        },
        "image/vnd.ms-modi": {
          source: "iana",
          extensions: ["mdi"]
        },
        "image/vnd.ms-photo": {
          source: "apache",
          extensions: ["wdp"]
        },
        "image/vnd.net-fpx": {
          source: "iana",
          extensions: ["npx"]
        },
        "image/vnd.pco.b16": {
          source: "iana",
          extensions: ["b16"]
        },
        "image/vnd.radiance": {
          source: "iana"
        },
        "image/vnd.sealed.png": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.gif": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.jpg": {
          source: "iana"
        },
        "image/vnd.svf": {
          source: "iana"
        },
        "image/vnd.tencent.tap": {
          source: "iana",
          extensions: ["tap"]
        },
        "image/vnd.valve.source.texture": {
          source: "iana",
          extensions: ["vtf"]
        },
        "image/vnd.wap.wbmp": {
          source: "iana",
          extensions: ["wbmp"]
        },
        "image/vnd.xiff": {
          source: "iana",
          extensions: ["xif"]
        },
        "image/vnd.zbrush.pcx": {
          source: "iana",
          extensions: ["pcx"]
        },
        "image/webp": {
          source: "apache",
          extensions: ["webp"]
        },
        "image/wmf": {
          source: "iana",
          extensions: ["wmf"]
        },
        "image/x-3ds": {
          source: "apache",
          extensions: ["3ds"]
        },
        "image/x-cmu-raster": {
          source: "apache",
          extensions: ["ras"]
        },
        "image/x-cmx": {
          source: "apache",
          extensions: ["cmx"]
        },
        "image/x-freehand": {
          source: "apache",
          extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
        },
        "image/x-icon": {
          source: "apache",
          compressible: true,
          extensions: ["ico"]
        },
        "image/x-jng": {
          source: "nginx",
          extensions: ["jng"]
        },
        "image/x-mrsid-image": {
          source: "apache",
          extensions: ["sid"]
        },
        "image/x-ms-bmp": {
          source: "nginx",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/x-pcx": {
          source: "apache",
          extensions: ["pcx"]
        },
        "image/x-pict": {
          source: "apache",
          extensions: ["pic", "pct"]
        },
        "image/x-portable-anymap": {
          source: "apache",
          extensions: ["pnm"]
        },
        "image/x-portable-bitmap": {
          source: "apache",
          extensions: ["pbm"]
        },
        "image/x-portable-graymap": {
          source: "apache",
          extensions: ["pgm"]
        },
        "image/x-portable-pixmap": {
          source: "apache",
          extensions: ["ppm"]
        },
        "image/x-rgb": {
          source: "apache",
          extensions: ["rgb"]
        },
        "image/x-tga": {
          source: "apache",
          extensions: ["tga"]
        },
        "image/x-xbitmap": {
          source: "apache",
          extensions: ["xbm"]
        },
        "image/x-xcf": {
          compressible: false
        },
        "image/x-xpixmap": {
          source: "apache",
          extensions: ["xpm"]
        },
        "image/x-xwindowdump": {
          source: "apache",
          extensions: ["xwd"]
        },
        "message/cpim": {
          source: "iana"
        },
        "message/delivery-status": {
          source: "iana"
        },
        "message/disposition-notification": {
          source: "iana",
          extensions: [
            "disposition-notification"
          ]
        },
        "message/external-body": {
          source: "iana"
        },
        "message/feedback-report": {
          source: "iana"
        },
        "message/global": {
          source: "iana",
          extensions: ["u8msg"]
        },
        "message/global-delivery-status": {
          source: "iana",
          extensions: ["u8dsn"]
        },
        "message/global-disposition-notification": {
          source: "iana",
          extensions: ["u8mdn"]
        },
        "message/global-headers": {
          source: "iana",
          extensions: ["u8hdr"]
        },
        "message/http": {
          source: "iana",
          compressible: false
        },
        "message/imdn+xml": {
          source: "iana",
          compressible: true
        },
        "message/news": {
          source: "iana"
        },
        "message/partial": {
          source: "iana",
          compressible: false
        },
        "message/rfc822": {
          source: "iana",
          compressible: true,
          extensions: ["eml", "mime"]
        },
        "message/s-http": {
          source: "iana"
        },
        "message/sip": {
          source: "iana"
        },
        "message/sipfrag": {
          source: "iana"
        },
        "message/tracking-status": {
          source: "iana"
        },
        "message/vnd.si.simp": {
          source: "iana"
        },
        "message/vnd.wfa.wsc": {
          source: "iana",
          extensions: ["wsc"]
        },
        "model/3mf": {
          source: "iana",
          extensions: ["3mf"]
        },
        "model/e57": {
          source: "iana"
        },
        "model/gltf+json": {
          source: "iana",
          compressible: true,
          extensions: ["gltf"]
        },
        "model/gltf-binary": {
          source: "iana",
          compressible: true,
          extensions: ["glb"]
        },
        "model/iges": {
          source: "iana",
          compressible: false,
          extensions: ["igs", "iges"]
        },
        "model/mesh": {
          source: "iana",
          compressible: false,
          extensions: ["msh", "mesh", "silo"]
        },
        "model/mtl": {
          source: "iana",
          extensions: ["mtl"]
        },
        "model/obj": {
          source: "iana",
          extensions: ["obj"]
        },
        "model/step": {
          source: "iana"
        },
        "model/step+xml": {
          source: "iana",
          compressible: true,
          extensions: ["stpx"]
        },
        "model/step+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpz"]
        },
        "model/step-xml+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpxz"]
        },
        "model/stl": {
          source: "iana",
          extensions: ["stl"]
        },
        "model/vnd.collada+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dae"]
        },
        "model/vnd.dwf": {
          source: "iana",
          extensions: ["dwf"]
        },
        "model/vnd.flatland.3dml": {
          source: "iana"
        },
        "model/vnd.gdl": {
          source: "iana",
          extensions: ["gdl"]
        },
        "model/vnd.gs-gdl": {
          source: "apache"
        },
        "model/vnd.gs.gdl": {
          source: "iana"
        },
        "model/vnd.gtw": {
          source: "iana",
          extensions: ["gtw"]
        },
        "model/vnd.moml+xml": {
          source: "iana",
          compressible: true
        },
        "model/vnd.mts": {
          source: "iana",
          extensions: ["mts"]
        },
        "model/vnd.opengex": {
          source: "iana",
          extensions: ["ogex"]
        },
        "model/vnd.parasolid.transmit.binary": {
          source: "iana",
          extensions: ["x_b"]
        },
        "model/vnd.parasolid.transmit.text": {
          source: "iana",
          extensions: ["x_t"]
        },
        "model/vnd.pytha.pyox": {
          source: "iana"
        },
        "model/vnd.rosette.annotated-data-model": {
          source: "iana"
        },
        "model/vnd.sap.vds": {
          source: "iana",
          extensions: ["vds"]
        },
        "model/vnd.usdz+zip": {
          source: "iana",
          compressible: false,
          extensions: ["usdz"]
        },
        "model/vnd.valve.source.compiled-map": {
          source: "iana",
          extensions: ["bsp"]
        },
        "model/vnd.vtu": {
          source: "iana",
          extensions: ["vtu"]
        },
        "model/vrml": {
          source: "iana",
          compressible: false,
          extensions: ["wrl", "vrml"]
        },
        "model/x3d+binary": {
          source: "apache",
          compressible: false,
          extensions: ["x3db", "x3dbz"]
        },
        "model/x3d+fastinfoset": {
          source: "iana",
          extensions: ["x3db"]
        },
        "model/x3d+vrml": {
          source: "apache",
          compressible: false,
          extensions: ["x3dv", "x3dvz"]
        },
        "model/x3d+xml": {
          source: "iana",
          compressible: true,
          extensions: ["x3d", "x3dz"]
        },
        "model/x3d-vrml": {
          source: "iana",
          extensions: ["x3dv"]
        },
        "multipart/alternative": {
          source: "iana",
          compressible: false
        },
        "multipart/appledouble": {
          source: "iana"
        },
        "multipart/byteranges": {
          source: "iana"
        },
        "multipart/digest": {
          source: "iana"
        },
        "multipart/encrypted": {
          source: "iana",
          compressible: false
        },
        "multipart/form-data": {
          source: "iana",
          compressible: false
        },
        "multipart/header-set": {
          source: "iana"
        },
        "multipart/mixed": {
          source: "iana"
        },
        "multipart/multilingual": {
          source: "iana"
        },
        "multipart/parallel": {
          source: "iana"
        },
        "multipart/related": {
          source: "iana",
          compressible: false
        },
        "multipart/report": {
          source: "iana"
        },
        "multipart/signed": {
          source: "iana",
          compressible: false
        },
        "multipart/vnd.bint.med-plus": {
          source: "iana"
        },
        "multipart/voice-message": {
          source: "iana"
        },
        "multipart/x-mixed-replace": {
          source: "iana"
        },
        "text/1d-interleaved-parityfec": {
          source: "iana"
        },
        "text/cache-manifest": {
          source: "iana",
          compressible: true,
          extensions: ["appcache", "manifest"]
        },
        "text/calendar": {
          source: "iana",
          extensions: ["ics", "ifb"]
        },
        "text/calender": {
          compressible: true
        },
        "text/cmd": {
          compressible: true
        },
        "text/coffeescript": {
          extensions: ["coffee", "litcoffee"]
        },
        "text/cql": {
          source: "iana"
        },
        "text/cql-expression": {
          source: "iana"
        },
        "text/cql-identifier": {
          source: "iana"
        },
        "text/css": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["css"]
        },
        "text/csv": {
          source: "iana",
          compressible: true,
          extensions: ["csv"]
        },
        "text/csv-schema": {
          source: "iana"
        },
        "text/directory": {
          source: "iana"
        },
        "text/dns": {
          source: "iana"
        },
        "text/ecmascript": {
          source: "iana"
        },
        "text/encaprtp": {
          source: "iana"
        },
        "text/enriched": {
          source: "iana"
        },
        "text/fhirpath": {
          source: "iana"
        },
        "text/flexfec": {
          source: "iana"
        },
        "text/fwdred": {
          source: "iana"
        },
        "text/gff3": {
          source: "iana"
        },
        "text/grammar-ref-list": {
          source: "iana"
        },
        "text/html": {
          source: "iana",
          compressible: true,
          extensions: ["html", "htm", "shtml"]
        },
        "text/jade": {
          extensions: ["jade"]
        },
        "text/javascript": {
          source: "iana",
          compressible: true
        },
        "text/jcr-cnd": {
          source: "iana"
        },
        "text/jsx": {
          compressible: true,
          extensions: ["jsx"]
        },
        "text/less": {
          compressible: true,
          extensions: ["less"]
        },
        "text/markdown": {
          source: "iana",
          compressible: true,
          extensions: ["markdown", "md"]
        },
        "text/mathml": {
          source: "nginx",
          extensions: ["mml"]
        },
        "text/mdx": {
          compressible: true,
          extensions: ["mdx"]
        },
        "text/mizar": {
          source: "iana"
        },
        "text/n3": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["n3"]
        },
        "text/parameters": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/parityfec": {
          source: "iana"
        },
        "text/plain": {
          source: "iana",
          compressible: true,
          extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
        },
        "text/provenance-notation": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/prs.fallenstein.rst": {
          source: "iana"
        },
        "text/prs.lines.tag": {
          source: "iana",
          extensions: ["dsc"]
        },
        "text/prs.prop.logic": {
          source: "iana"
        },
        "text/raptorfec": {
          source: "iana"
        },
        "text/red": {
          source: "iana"
        },
        "text/rfc822-headers": {
          source: "iana"
        },
        "text/richtext": {
          source: "iana",
          compressible: true,
          extensions: ["rtx"]
        },
        "text/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "text/rtp-enc-aescm128": {
          source: "iana"
        },
        "text/rtploopback": {
          source: "iana"
        },
        "text/rtx": {
          source: "iana"
        },
        "text/sgml": {
          source: "iana",
          extensions: ["sgml", "sgm"]
        },
        "text/shaclc": {
          source: "iana"
        },
        "text/shex": {
          source: "iana",
          extensions: ["shex"]
        },
        "text/slim": {
          extensions: ["slim", "slm"]
        },
        "text/spdx": {
          source: "iana",
          extensions: ["spdx"]
        },
        "text/strings": {
          source: "iana"
        },
        "text/stylus": {
          extensions: ["stylus", "styl"]
        },
        "text/t140": {
          source: "iana"
        },
        "text/tab-separated-values": {
          source: "iana",
          compressible: true,
          extensions: ["tsv"]
        },
        "text/troff": {
          source: "iana",
          extensions: ["t", "tr", "roff", "man", "me", "ms"]
        },
        "text/turtle": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["ttl"]
        },
        "text/ulpfec": {
          source: "iana"
        },
        "text/uri-list": {
          source: "iana",
          compressible: true,
          extensions: ["uri", "uris", "urls"]
        },
        "text/vcard": {
          source: "iana",
          compressible: true,
          extensions: ["vcard"]
        },
        "text/vnd.a": {
          source: "iana"
        },
        "text/vnd.abc": {
          source: "iana"
        },
        "text/vnd.ascii-art": {
          source: "iana"
        },
        "text/vnd.curl": {
          source: "iana",
          extensions: ["curl"]
        },
        "text/vnd.curl.dcurl": {
          source: "apache",
          extensions: ["dcurl"]
        },
        "text/vnd.curl.mcurl": {
          source: "apache",
          extensions: ["mcurl"]
        },
        "text/vnd.curl.scurl": {
          source: "apache",
          extensions: ["scurl"]
        },
        "text/vnd.debian.copyright": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.dmclientscript": {
          source: "iana"
        },
        "text/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "text/vnd.esmertec.theme-descriptor": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.familysearch.gedcom": {
          source: "iana",
          extensions: ["ged"]
        },
        "text/vnd.ficlab.flt": {
          source: "iana"
        },
        "text/vnd.fly": {
          source: "iana",
          extensions: ["fly"]
        },
        "text/vnd.fmi.flexstor": {
          source: "iana",
          extensions: ["flx"]
        },
        "text/vnd.gml": {
          source: "iana"
        },
        "text/vnd.graphviz": {
          source: "iana",
          extensions: ["gv"]
        },
        "text/vnd.hans": {
          source: "iana"
        },
        "text/vnd.hgl": {
          source: "iana"
        },
        "text/vnd.in3d.3dml": {
          source: "iana",
          extensions: ["3dml"]
        },
        "text/vnd.in3d.spot": {
          source: "iana",
          extensions: ["spot"]
        },
        "text/vnd.iptc.newsml": {
          source: "iana"
        },
        "text/vnd.iptc.nitf": {
          source: "iana"
        },
        "text/vnd.latex-z": {
          source: "iana"
        },
        "text/vnd.motorola.reflex": {
          source: "iana"
        },
        "text/vnd.ms-mediapackage": {
          source: "iana"
        },
        "text/vnd.net2phone.commcenter.command": {
          source: "iana"
        },
        "text/vnd.radisys.msml-basic-layout": {
          source: "iana"
        },
        "text/vnd.senx.warpscript": {
          source: "iana"
        },
        "text/vnd.si.uricatalogue": {
          source: "iana"
        },
        "text/vnd.sosi": {
          source: "iana"
        },
        "text/vnd.sun.j2me.app-descriptor": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["jad"]
        },
        "text/vnd.trolltech.linguist": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.wap.si": {
          source: "iana"
        },
        "text/vnd.wap.sl": {
          source: "iana"
        },
        "text/vnd.wap.wml": {
          source: "iana",
          extensions: ["wml"]
        },
        "text/vnd.wap.wmlscript": {
          source: "iana",
          extensions: ["wmls"]
        },
        "text/vtt": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["vtt"]
        },
        "text/x-asm": {
          source: "apache",
          extensions: ["s", "asm"]
        },
        "text/x-c": {
          source: "apache",
          extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
        },
        "text/x-component": {
          source: "nginx",
          extensions: ["htc"]
        },
        "text/x-fortran": {
          source: "apache",
          extensions: ["f", "for", "f77", "f90"]
        },
        "text/x-gwt-rpc": {
          compressible: true
        },
        "text/x-handlebars-template": {
          extensions: ["hbs"]
        },
        "text/x-java-source": {
          source: "apache",
          extensions: ["java"]
        },
        "text/x-jquery-tmpl": {
          compressible: true
        },
        "text/x-lua": {
          extensions: ["lua"]
        },
        "text/x-markdown": {
          compressible: true,
          extensions: ["mkd"]
        },
        "text/x-nfo": {
          source: "apache",
          extensions: ["nfo"]
        },
        "text/x-opml": {
          source: "apache",
          extensions: ["opml"]
        },
        "text/x-org": {
          compressible: true,
          extensions: ["org"]
        },
        "text/x-pascal": {
          source: "apache",
          extensions: ["p", "pas"]
        },
        "text/x-processing": {
          compressible: true,
          extensions: ["pde"]
        },
        "text/x-sass": {
          extensions: ["sass"]
        },
        "text/x-scss": {
          extensions: ["scss"]
        },
        "text/x-setext": {
          source: "apache",
          extensions: ["etx"]
        },
        "text/x-sfv": {
          source: "apache",
          extensions: ["sfv"]
        },
        "text/x-suse-ymp": {
          compressible: true,
          extensions: ["ymp"]
        },
        "text/x-uuencode": {
          source: "apache",
          extensions: ["uu"]
        },
        "text/x-vcalendar": {
          source: "apache",
          extensions: ["vcs"]
        },
        "text/x-vcard": {
          source: "apache",
          extensions: ["vcf"]
        },
        "text/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml"]
        },
        "text/xml-external-parsed-entity": {
          source: "iana"
        },
        "text/yaml": {
          compressible: true,
          extensions: ["yaml", "yml"]
        },
        "video/1d-interleaved-parityfec": {
          source: "iana"
        },
        "video/3gpp": {
          source: "iana",
          extensions: ["3gp", "3gpp"]
        },
        "video/3gpp-tt": {
          source: "iana"
        },
        "video/3gpp2": {
          source: "iana",
          extensions: ["3g2"]
        },
        "video/av1": {
          source: "iana"
        },
        "video/bmpeg": {
          source: "iana"
        },
        "video/bt656": {
          source: "iana"
        },
        "video/celb": {
          source: "iana"
        },
        "video/dv": {
          source: "iana"
        },
        "video/encaprtp": {
          source: "iana"
        },
        "video/ffv1": {
          source: "iana"
        },
        "video/flexfec": {
          source: "iana"
        },
        "video/h261": {
          source: "iana",
          extensions: ["h261"]
        },
        "video/h263": {
          source: "iana",
          extensions: ["h263"]
        },
        "video/h263-1998": {
          source: "iana"
        },
        "video/h263-2000": {
          source: "iana"
        },
        "video/h264": {
          source: "iana",
          extensions: ["h264"]
        },
        "video/h264-rcdo": {
          source: "iana"
        },
        "video/h264-svc": {
          source: "iana"
        },
        "video/h265": {
          source: "iana"
        },
        "video/iso.segment": {
          source: "iana",
          extensions: ["m4s"]
        },
        "video/jpeg": {
          source: "iana",
          extensions: ["jpgv"]
        },
        "video/jpeg2000": {
          source: "iana"
        },
        "video/jpm": {
          source: "apache",
          extensions: ["jpm", "jpgm"]
        },
        "video/jxsv": {
          source: "iana"
        },
        "video/mj2": {
          source: "iana",
          extensions: ["mj2", "mjp2"]
        },
        "video/mp1s": {
          source: "iana"
        },
        "video/mp2p": {
          source: "iana"
        },
        "video/mp2t": {
          source: "iana",
          extensions: ["ts"]
        },
        "video/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["mp4", "mp4v", "mpg4"]
        },
        "video/mp4v-es": {
          source: "iana"
        },
        "video/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
        },
        "video/mpeg4-generic": {
          source: "iana"
        },
        "video/mpv": {
          source: "iana"
        },
        "video/nv": {
          source: "iana"
        },
        "video/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogv"]
        },
        "video/parityfec": {
          source: "iana"
        },
        "video/pointer": {
          source: "iana"
        },
        "video/quicktime": {
          source: "iana",
          compressible: false,
          extensions: ["qt", "mov"]
        },
        "video/raptorfec": {
          source: "iana"
        },
        "video/raw": {
          source: "iana"
        },
        "video/rtp-enc-aescm128": {
          source: "iana"
        },
        "video/rtploopback": {
          source: "iana"
        },
        "video/rtx": {
          source: "iana"
        },
        "video/scip": {
          source: "iana"
        },
        "video/smpte291": {
          source: "iana"
        },
        "video/smpte292m": {
          source: "iana"
        },
        "video/ulpfec": {
          source: "iana"
        },
        "video/vc1": {
          source: "iana"
        },
        "video/vc2": {
          source: "iana"
        },
        "video/vnd.cctv": {
          source: "iana"
        },
        "video/vnd.dece.hd": {
          source: "iana",
          extensions: ["uvh", "uvvh"]
        },
        "video/vnd.dece.mobile": {
          source: "iana",
          extensions: ["uvm", "uvvm"]
        },
        "video/vnd.dece.mp4": {
          source: "iana"
        },
        "video/vnd.dece.pd": {
          source: "iana",
          extensions: ["uvp", "uvvp"]
        },
        "video/vnd.dece.sd": {
          source: "iana",
          extensions: ["uvs", "uvvs"]
        },
        "video/vnd.dece.video": {
          source: "iana",
          extensions: ["uvv", "uvvv"]
        },
        "video/vnd.directv.mpeg": {
          source: "iana"
        },
        "video/vnd.directv.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dlna.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dvb.file": {
          source: "iana",
          extensions: ["dvb"]
        },
        "video/vnd.fvt": {
          source: "iana",
          extensions: ["fvt"]
        },
        "video/vnd.hns.video": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsavc": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsmpeg2": {
          source: "iana"
        },
        "video/vnd.motorola.video": {
          source: "iana"
        },
        "video/vnd.motorola.videop": {
          source: "iana"
        },
        "video/vnd.mpegurl": {
          source: "iana",
          extensions: ["mxu", "m4u"]
        },
        "video/vnd.ms-playready.media.pyv": {
          source: "iana",
          extensions: ["pyv"]
        },
        "video/vnd.nokia.interleaved-multimedia": {
          source: "iana"
        },
        "video/vnd.nokia.mp4vr": {
          source: "iana"
        },
        "video/vnd.nokia.videovoip": {
          source: "iana"
        },
        "video/vnd.objectvideo": {
          source: "iana"
        },
        "video/vnd.radgamettools.bink": {
          source: "iana"
        },
        "video/vnd.radgamettools.smacker": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg1": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg4": {
          source: "iana"
        },
        "video/vnd.sealed.swf": {
          source: "iana"
        },
        "video/vnd.sealedmedia.softseal.mov": {
          source: "iana"
        },
        "video/vnd.uvvu.mp4": {
          source: "iana",
          extensions: ["uvu", "uvvu"]
        },
        "video/vnd.vivo": {
          source: "iana",
          extensions: ["viv"]
        },
        "video/vnd.youtube.yt": {
          source: "iana"
        },
        "video/vp8": {
          source: "iana"
        },
        "video/vp9": {
          source: "iana"
        },
        "video/webm": {
          source: "apache",
          compressible: false,
          extensions: ["webm"]
        },
        "video/x-f4v": {
          source: "apache",
          extensions: ["f4v"]
        },
        "video/x-fli": {
          source: "apache",
          extensions: ["fli"]
        },
        "video/x-flv": {
          source: "apache",
          compressible: false,
          extensions: ["flv"]
        },
        "video/x-m4v": {
          source: "apache",
          extensions: ["m4v"]
        },
        "video/x-matroska": {
          source: "apache",
          compressible: false,
          extensions: ["mkv", "mk3d", "mks"]
        },
        "video/x-mng": {
          source: "apache",
          extensions: ["mng"]
        },
        "video/x-ms-asf": {
          source: "apache",
          extensions: ["asf", "asx"]
        },
        "video/x-ms-vob": {
          source: "apache",
          extensions: ["vob"]
        },
        "video/x-ms-wm": {
          source: "apache",
          extensions: ["wm"]
        },
        "video/x-ms-wmv": {
          source: "apache",
          compressible: false,
          extensions: ["wmv"]
        },
        "video/x-ms-wmx": {
          source: "apache",
          extensions: ["wmx"]
        },
        "video/x-ms-wvx": {
          source: "apache",
          extensions: ["wvx"]
        },
        "video/x-msvideo": {
          source: "apache",
          extensions: ["avi"]
        },
        "video/x-sgi-movie": {
          source: "apache",
          extensions: ["movie"]
        },
        "video/x-smv": {
          source: "apache",
          extensions: ["smv"]
        },
        "x-conference/x-cooltalk": {
          source: "apache",
          extensions: ["ice"]
        },
        "x-shader/x-fragment": {
          compressible: true
        },
        "x-shader/x-vertex": {
          compressible: true
        }
      };
    }
  });

  // ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
  var require_mime_db = __commonJS({
    "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports, module) {
      module.exports = require_db();
    }
  });

  // ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
  var require_mime_types = __commonJS({
    "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports) {
      "use strict";
      var db = require_mime_db();
      var extname = __require2("path").extname;
      var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
      var TEXT_TYPE_REGEXP = /^text\//i;
      exports.charset = charset;
      exports.charsets = { lookup: charset };
      exports.contentType = contentType;
      exports.extension = extension;
      exports.extensions = /* @__PURE__ */ Object.create(null);
      exports.lookup = lookup;
      exports.types = /* @__PURE__ */ Object.create(null);
      populateMaps(exports.extensions, exports.types);
      function charset(type3) {
        if (!type3 || typeof type3 !== "string") {
          return false;
        }
        var match3 = EXTRACT_TYPE_REGEXP.exec(type3);
        var mime = match3 && db[match3[1].toLowerCase()];
        if (mime && mime.charset) {
          return mime.charset;
        }
        if (match3 && TEXT_TYPE_REGEXP.test(match3[1])) {
          return "UTF-8";
        }
        return false;
      }
      function contentType(str) {
        if (!str || typeof str !== "string") {
          return false;
        }
        var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
        if (!mime) {
          return false;
        }
        if (mime.indexOf("charset") === -1) {
          var charset2 = exports.charset(mime);
          if (charset2)
            mime += "; charset=" + charset2.toLowerCase();
        }
        return mime;
      }
      function extension(type3) {
        if (!type3 || typeof type3 !== "string") {
          return false;
        }
        var match3 = EXTRACT_TYPE_REGEXP.exec(type3);
        var exts = match3 && exports.extensions[match3[1].toLowerCase()];
        if (!exts || !exts.length) {
          return false;
        }
        return exts[0];
      }
      function lookup(path5) {
        if (!path5 || typeof path5 !== "string") {
          return false;
        }
        var extension2 = extname("x." + path5).toLowerCase().substr(1);
        if (!extension2) {
          return false;
        }
        return exports.types[extension2] || false;
      }
      function populateMaps(extensions, types2) {
        var preference = ["nginx", "apache", void 0, "iana"];
        Object.keys(db).forEach(function forEachMimeType(type3) {
          var mime = db[type3];
          var exts = mime.extensions;
          if (!exts || !exts.length) {
            return;
          }
          extensions[type3] = exts;
          for (var i = 0; i < exts.length; i++) {
            var extension2 = exts[i];
            if (types2[extension2]) {
              var from = preference.indexOf(db[types2[extension2]].source);
              var to = preference.indexOf(mime.source);
              if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
                continue;
              }
            }
            types2[extension2] = type3;
          }
        });
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
  var require_defer = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports, module) {
      module.exports = defer2;
      function defer2(fn) {
        var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
        if (nextTick) {
          nextTick(fn);
        } else {
          setTimeout(fn, 0);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
  var require_async = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports, module) {
      var defer2 = require_defer();
      module.exports = async;
      function async(callback) {
        var isAsync = false;
        defer2(function() {
          isAsync = true;
        });
        return function async_callback(err, result) {
          if (isAsync) {
            callback(err, result);
          } else {
            defer2(function nextTick_callback() {
              callback(err, result);
            });
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
  var require_abort = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports, module) {
      module.exports = abort;
      function abort(state) {
        Object.keys(state.jobs).forEach(clean.bind(state));
        state.jobs = {};
      }
      function clean(key) {
        if (typeof this.jobs[key] == "function") {
          this.jobs[key]();
        }
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
  var require_iterate = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports, module) {
      var async = require_async();
      var abort = require_abort();
      module.exports = iterate2;
      function iterate2(list, iterator, state, callback) {
        var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
        state.jobs[key] = runJob(iterator, key, list[key], function(error2, output3) {
          if (!(key in state.jobs)) {
            return;
          }
          delete state.jobs[key];
          if (error2) {
            abort(state);
          } else {
            state.results[key] = output3;
          }
          callback(error2, state.results);
        });
      }
      function runJob(iterator, key, item, callback) {
        var aborter;
        if (iterator.length == 2) {
          aborter = iterator(item, async(callback));
        } else {
          aborter = iterator(item, key, async(callback));
        }
        return aborter;
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
  var require_state = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports, module) {
      module.exports = state;
      function state(list, sortMethod) {
        var isNamedList = !Array.isArray(list), initState = {
          index: 0,
          keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
          jobs: {},
          results: isNamedList ? {} : [],
          size: isNamedList ? Object.keys(list).length : list.length
        };
        if (sortMethod) {
          initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
          });
        }
        return initState;
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
  var require_terminator = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports, module) {
      var abort = require_abort();
      var async = require_async();
      module.exports = terminator;
      function terminator(callback) {
        if (!Object.keys(this.jobs).length) {
          return;
        }
        this.index = this.size;
        abort(this);
        async(callback)(null, this.results);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
  var require_parallel = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports, module) {
      var iterate2 = require_iterate();
      var initState = require_state();
      var terminator = require_terminator();
      module.exports = parallel;
      function parallel(list, iterator, callback) {
        var state = initState(list);
        while (state.index < (state["keyedList"] || list).length) {
          iterate2(list, iterator, state, function(error2, result) {
            if (error2) {
              callback(error2, result);
              return;
            }
            if (Object.keys(state.jobs).length === 0) {
              callback(null, state.results);
              return;
            }
          });
          state.index++;
        }
        return terminator.bind(state, callback);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
  var require_serialOrdered = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports, module) {
      var iterate2 = require_iterate();
      var initState = require_state();
      var terminator = require_terminator();
      module.exports = serialOrdered;
      module.exports.ascending = ascending;
      module.exports.descending = descending;
      function serialOrdered(list, iterator, sortMethod, callback) {
        var state = initState(list, sortMethod);
        iterate2(list, iterator, state, function iteratorHandler(error2, result) {
          if (error2) {
            callback(error2, result);
            return;
          }
          state.index++;
          if (state.index < (state["keyedList"] || list).length) {
            iterate2(list, iterator, state, iteratorHandler);
            return;
          }
          callback(null, state.results);
        });
        return terminator.bind(state, callback);
      }
      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      function descending(a, b) {
        return -1 * ascending(a, b);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
  var require_serial = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports, module) {
      var serialOrdered = require_serialOrdered();
      module.exports = serial;
      function serial(list, iterator, callback) {
        return serialOrdered(list, iterator, null, callback);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
  var require_asynckit = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports, module) {
      module.exports = {
        parallel: require_parallel(),
        serial: require_serial(),
        serialOrdered: require_serialOrdered()
      };
    }
  });

  // ../../node_modules/.pnpm/form-data@3.0.1/node_modules/form-data/lib/populate.js
  var require_populate = __commonJS({
    "../../node_modules/.pnpm/form-data@3.0.1/node_modules/form-data/lib/populate.js"(exports, module) {
      module.exports = function(dst, src) {
        Object.keys(src).forEach(function(prop) {
          dst[prop] = dst[prop] || src[prop];
        });
        return dst;
      };
    }
  });

  // ../../node_modules/.pnpm/form-data@3.0.1/node_modules/form-data/lib/form_data.js
  var require_form_data = __commonJS({
    "../../node_modules/.pnpm/form-data@3.0.1/node_modules/form-data/lib/form_data.js"(exports, module) {
      var CombinedStream = require_combined_stream();
      var util = __require2("util");
      var path5 = __require2("path");
      var http2 = __require2("http");
      var https2 = __require2("https");
      var parseUrl = __require2("url").parse;
      var fs4 = __require2("fs");
      var mime = require_mime_types();
      var asynckit = require_asynckit();
      var populate = require_populate();
      module.exports = FormData2;
      util.inherits(FormData2, CombinedStream);
      function FormData2(options) {
        if (!(this instanceof FormData2)) {
          return new FormData2(options);
        }
        this._overheadLength = 0;
        this._valueLength = 0;
        this._valuesToMeasure = [];
        CombinedStream.call(this);
        options = options || {};
        for (var option in options) {
          this[option] = options[option];
        }
      }
      FormData2.LINE_BREAK = "\r\n";
      FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
      FormData2.prototype.append = function(field, value, options) {
        options = options || {};
        if (typeof options == "string") {
          options = { filename: options };
        }
        var append = CombinedStream.prototype.append.bind(this);
        if (typeof value == "number") {
          value = "" + value;
        }
        if (util.isArray(value)) {
          this._error(new Error("Arrays are not supported."));
          return;
        }
        var header = this._multiPartHeader(field, value, options);
        var footer = this._multiPartFooter();
        append(header);
        append(value);
        append(footer);
        this._trackLength(header, value, options);
      };
      FormData2.prototype._trackLength = function(header, value, options) {
        var valueLength = 0;
        if (options.knownLength != null) {
          valueLength += +options.knownLength;
        } else if (Buffer.isBuffer(value)) {
          valueLength = value.length;
        } else if (typeof value === "string") {
          valueLength = Buffer.byteLength(value);
        }
        this._valueLength += valueLength;
        this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
        if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
          return;
        }
        if (!options.knownLength) {
          this._valuesToMeasure.push(value);
        }
      };
      FormData2.prototype._lengthRetriever = function(value, callback) {
        if (value.hasOwnProperty("fd")) {
          if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
            callback(null, value.end + 1 - (value.start ? value.start : 0));
          } else {
            fs4.stat(value.path, function(err, stat) {
              var fileSize;
              if (err) {
                callback(err);
                return;
              }
              fileSize = stat.size - (value.start ? value.start : 0);
              callback(null, fileSize);
            });
          }
        } else if (value.hasOwnProperty("httpVersion")) {
          callback(null, +value.headers["content-length"]);
        } else if (value.hasOwnProperty("httpModule")) {
          value.on("response", function(response) {
            value.pause();
            callback(null, +response.headers["content-length"]);
          });
          value.resume();
        } else {
          callback("Unknown stream");
        }
      };
      FormData2.prototype._multiPartHeader = function(field, value, options) {
        if (typeof options.header == "string") {
          return options.header;
        }
        var contentDisposition = this._getContentDisposition(value, options);
        var contentType = this._getContentType(value, options);
        var contents = "";
        var headers = {
          // add custom disposition as third element or keep it two elements if not
          "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
          // if no content type. allow it to be empty array
          "Content-Type": [].concat(contentType || [])
        };
        if (typeof options.header == "object") {
          populate(headers, options.header);
        }
        var header;
        for (var prop in headers) {
          if (!headers.hasOwnProperty(prop))
            continue;
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
        return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
      };
      FormData2.prototype._getContentDisposition = function(value, options) {
        var filename, contentDisposition;
        if (typeof options.filepath === "string") {
          filename = path5.normalize(options.filepath).replace(/\\/g, "/");
        } else if (options.filename || value.name || value.path) {
          filename = path5.basename(options.filename || value.name || value.path);
        } else if (value.readable && value.hasOwnProperty("httpVersion")) {
          filename = path5.basename(value.client._httpMessage.path || "");
        }
        if (filename) {
          contentDisposition = 'filename="' + filename + '"';
        }
        return contentDisposition;
      };
      FormData2.prototype._getContentType = function(value, options) {
        var contentType = options.contentType;
        if (!contentType && value.name) {
          contentType = mime.lookup(value.name);
        }
        if (!contentType && value.path) {
          contentType = mime.lookup(value.path);
        }
        if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
          contentType = value.headers["content-type"];
        }
        if (!contentType && (options.filepath || options.filename)) {
          contentType = mime.lookup(options.filepath || options.filename);
        }
        if (!contentType && typeof value == "object") {
          contentType = FormData2.DEFAULT_CONTENT_TYPE;
        }
        return contentType;
      };
      FormData2.prototype._multiPartFooter = function() {
        return function(next) {
          var footer = FormData2.LINE_BREAK;
          var lastPart = this._streams.length === 0;
          if (lastPart) {
            footer += this._lastBoundary();
          }
          next(footer);
        }.bind(this);
      };
      FormData2.prototype._lastBoundary = function() {
        return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
      };
      FormData2.prototype.getHeaders = function(userHeaders) {
        var header;
        var formHeaders = {
          "content-type": "multipart/form-data; boundary=" + this.getBoundary()
        };
        for (header in userHeaders) {
          if (userHeaders.hasOwnProperty(header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
          }
        }
        return formHeaders;
      };
      FormData2.prototype.setBoundary = function(boundary) {
        this._boundary = boundary;
      };
      FormData2.prototype.getBoundary = function() {
        if (!this._boundary) {
          this._generateBoundary();
        }
        return this._boundary;
      };
      FormData2.prototype.getBuffer = function() {
        var dataBuffer = new Buffer.alloc(0);
        var boundary = this.getBoundary();
        for (var i = 0, len = this._streams.length; i < len; i++) {
          if (typeof this._streams[i] !== "function") {
            if (Buffer.isBuffer(this._streams[i])) {
              dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
            } else {
              dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
            }
            if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
              dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
            }
          }
        }
        return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
      };
      FormData2.prototype._generateBoundary = function() {
        var boundary = "--------------------------";
        for (var i = 0; i < 24; i++) {
          boundary += Math.floor(Math.random() * 10).toString(16);
        }
        this._boundary = boundary;
      };
      FormData2.prototype.getLengthSync = function() {
        var knownLength = this._overheadLength + this._valueLength;
        if (this._streams.length) {
          knownLength += this._lastBoundary().length;
        }
        if (!this.hasKnownLength()) {
          this._error(new Error("Cannot calculate proper length in synchronous way."));
        }
        return knownLength;
      };
      FormData2.prototype.hasKnownLength = function() {
        var hasKnownLength = true;
        if (this._valuesToMeasure.length) {
          hasKnownLength = false;
        }
        return hasKnownLength;
      };
      FormData2.prototype.getLength = function(cb) {
        var knownLength = this._overheadLength + this._valueLength;
        if (this._streams.length) {
          knownLength += this._lastBoundary().length;
        }
        if (!this._valuesToMeasure.length) {
          process.nextTick(cb.bind(this, null, knownLength));
          return;
        }
        asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
          if (err) {
            cb(err);
            return;
          }
          values.forEach(function(length) {
            knownLength += length;
          });
          cb(null, knownLength);
        });
      };
      FormData2.prototype.submit = function(params, cb) {
        var request, options, defaults2 = { method: "post" };
        if (typeof params == "string") {
          params = parseUrl(params);
          options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
          }, defaults2);
        } else {
          options = populate(params, defaults2);
          if (!options.port) {
            options.port = options.protocol == "https:" ? 443 : 80;
          }
        }
        options.headers = this.getHeaders(params.headers);
        if (options.protocol == "https:") {
          request = https2.request(options);
        } else {
          request = http2.request(options);
        }
        this.getLength(function(err, length) {
          if (err) {
            this._error(err);
            return;
          }
          request.setHeader("Content-Length", length);
          this.pipe(request);
          if (cb) {
            var onResponse;
            var callback = function(error2, responce) {
              request.removeListener("error", callback);
              request.removeListener("response", onResponse);
              return cb.call(this, error2, responce);
            };
            onResponse = callback.bind(this, null);
            request.on("error", callback);
            request.on("response", onResponse);
          }
        }.bind(this));
        return request;
      };
      FormData2.prototype._error = function(err) {
        if (!this.error) {
          this.error = err;
          this.pause();
          this.emit("error", err);
        }
      };
      FormData2.prototype.toString = function() {
        return "[object FormData]";
      };
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/defaultJsonSerializer.js
  var require_defaultJsonSerializer = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/defaultJsonSerializer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultJsonSerializer = void 0;
      exports.defaultJsonSerializer = {
        parse: JSON.parse,
        stringify: JSON.stringify
      };
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/createRequestBody.js
  var require_createRequestBody = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/createRequestBody.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var extract_files_1 = require_public();
      var form_data_1 = __importDefault(require_form_data());
      var defaultJsonSerializer_1 = require_defaultJsonSerializer();
      var isExtractableFileEnhanced = function(value) {
        return extract_files_1.isExtractableFile(value) || value !== null && typeof value === "object" && typeof value.pipe === "function";
      };
      function createRequestBody(query, variables, operationName, jsonSerializer) {
        if (jsonSerializer === void 0) {
          jsonSerializer = defaultJsonSerializer_1.defaultJsonSerializer;
        }
        var _a = extract_files_1.extractFiles({ query, variables, operationName }, "", isExtractableFileEnhanced), clone5 = _a.clone, files = _a.files;
        if (files.size === 0) {
          if (!Array.isArray(query)) {
            return jsonSerializer.stringify(clone5);
          }
          if (typeof variables !== "undefined" && !Array.isArray(variables)) {
            throw new Error("Cannot create request body with given variable type, array expected");
          }
          var payload = query.reduce(function(accu, currentQuery, index) {
            accu.push({ query: currentQuery, variables: variables ? variables[index] : void 0 });
            return accu;
          }, []);
          return jsonSerializer.stringify(payload);
        }
        var Form = typeof FormData === "undefined" ? form_data_1.default : FormData;
        var form = new Form();
        form.append("operations", jsonSerializer.stringify(clone5));
        var map2 = {};
        var i = 0;
        files.forEach(function(paths) {
          map2[++i] = paths;
        });
        form.append("map", jsonSerializer.stringify(map2));
        i = 0;
        files.forEach(function(paths, file) {
          form.append("" + ++i, file);
        });
        return form;
      }
      exports.default = createRequestBody;
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/parseArgs.js
  var require_parseArgs = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/parseArgs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseBatchRequestsExtendedArgs = exports.parseRawRequestExtendedArgs = exports.parseRequestExtendedArgs = exports.parseBatchRequestArgs = exports.parseRawRequestArgs = exports.parseRequestArgs = void 0;
      function parseRequestArgs(documentOrOptions, variables, requestHeaders) {
        return documentOrOptions.document ? documentOrOptions : {
          document: documentOrOptions,
          variables,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseRequestArgs = parseRequestArgs;
      function parseRawRequestArgs(queryOrOptions, variables, requestHeaders) {
        return queryOrOptions.query ? queryOrOptions : {
          query: queryOrOptions,
          variables,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseRawRequestArgs = parseRawRequestArgs;
      function parseBatchRequestArgs(documentsOrOptions, requestHeaders) {
        return documentsOrOptions.documents ? documentsOrOptions : {
          documents: documentsOrOptions,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseBatchRequestArgs = parseBatchRequestArgs;
      function parseRequestExtendedArgs(urlOrOptions, document2, variables, requestHeaders) {
        return urlOrOptions.document ? urlOrOptions : {
          url: urlOrOptions,
          document: document2,
          variables,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseRequestExtendedArgs = parseRequestExtendedArgs;
      function parseRawRequestExtendedArgs(urlOrOptions, query, variables, requestHeaders) {
        return urlOrOptions.query ? urlOrOptions : {
          url: urlOrOptions,
          query,
          variables,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseRawRequestExtendedArgs = parseRawRequestExtendedArgs;
      function parseBatchRequestsExtendedArgs(urlOrOptions, documents, requestHeaders) {
        return urlOrOptions.documents ? urlOrOptions : {
          url: urlOrOptions,
          documents,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseBatchRequestsExtendedArgs = parseBatchRequestsExtendedArgs;
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/types.js
  var require_types = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/types.js"(exports) {
      "use strict";
      var __extends = exports && exports.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClientError = void 0;
      var ClientError = (
        /** @class */
        function(_super) {
          __extends(ClientError2, _super);
          function ClientError2(response, request) {
            var _this = this;
            var message = ClientError2.extractMessage(response) + ": " + JSON.stringify({
              response,
              request
            });
            _this = _super.call(this, message) || this;
            Object.setPrototypeOf(_this, ClientError2.prototype);
            _this.response = response;
            _this.request = request;
            if (typeof Error.captureStackTrace === "function") {
              Error.captureStackTrace(_this, ClientError2);
            }
            return _this;
          }
          ClientError2.extractMessage = function(response) {
            try {
              return response.errors[0].message;
            } catch (e) {
              return "GraphQL Error (Code: " + response.status + ")";
            }
          };
          return ClientError2;
        }(Error)
      );
      exports.ClientError = ClientError;
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/graphql-ws.js
  var require_graphql_ws = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/graphql-ws.js"(exports) {
      "use strict";
      var __assign2 = exports && exports.__assign || function() {
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve4) {
            resolve4(value);
          });
        }
        return new (P || (P = Promise))(function(resolve4, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GraphQLWebSocketClient = void 0;
      var types_1 = require_types();
      var _1 = require_dist2();
      var CONNECTION_INIT = "connection_init";
      var CONNECTION_ACK = "connection_ack";
      var PING = "ping";
      var PONG = "pong";
      var SUBSCRIBE = "subscribe";
      var NEXT = "next";
      var ERROR2 = "error";
      var COMPLETE = "complete";
      var GraphQLWebSocketMessage = (
        /** @class */
        function() {
          function GraphQLWebSocketMessage2(type3, payload, id) {
            this._type = type3;
            this._payload = payload;
            this._id = id;
          }
          Object.defineProperty(GraphQLWebSocketMessage2.prototype, "type", {
            get: function() {
              return this._type;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(GraphQLWebSocketMessage2.prototype, "id", {
            get: function() {
              return this._id;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(GraphQLWebSocketMessage2.prototype, "payload", {
            get: function() {
              return this._payload;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(GraphQLWebSocketMessage2.prototype, "text", {
            get: function() {
              var result = { type: this.type };
              if (this.id != null && this.id != void 0)
                result.id = this.id;
              if (this.payload != null && this.payload != void 0)
                result.payload = this.payload;
              return JSON.stringify(result);
            },
            enumerable: false,
            configurable: true
          });
          GraphQLWebSocketMessage2.parse = function(data, f2) {
            var _a = JSON.parse(data), type3 = _a.type, payload = _a.payload, id = _a.id;
            return new GraphQLWebSocketMessage2(type3, f2(payload), id);
          };
          return GraphQLWebSocketMessage2;
        }()
      );
      var GraphQLWebSocketClient = (
        /** @class */
        function() {
          function GraphQLWebSocketClient2(socket, _a) {
            var _this = this;
            var onInit = _a.onInit, onAcknowledged = _a.onAcknowledged, onPing = _a.onPing, onPong = _a.onPong;
            this.socketState = { acknowledged: false, lastRequestId: 0, subscriptions: {} };
            this.socket = socket;
            socket.onopen = function(e) {
              return __awaiter(_this, void 0, void 0, function() {
                var _a2, _b, _c, _d;
                return __generator(this, function(_e) {
                  switch (_e.label) {
                    case 0:
                      this.socketState.acknowledged = false;
                      this.socketState.subscriptions = {};
                      _b = (_a2 = socket).send;
                      _c = ConnectionInit;
                      if (!onInit)
                        return [3, 2];
                      return [4, onInit()];
                    case 1:
                      _d = _e.sent();
                      return [3, 3];
                    case 2:
                      _d = null;
                      _e.label = 3;
                    case 3:
                      _b.apply(_a2, [_c.apply(void 0, [_d]).text]);
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            socket.onclose = function(e) {
              _this.socketState.acknowledged = false;
              _this.socketState.subscriptions = {};
            };
            socket.onerror = function(e) {
              console.error(e);
            };
            socket.onmessage = function(e) {
              try {
                var message = parseMessage(e.data);
                switch (message.type) {
                  case CONNECTION_ACK: {
                    if (_this.socketState.acknowledged) {
                      console.warn("Duplicate CONNECTION_ACK message ignored");
                    } else {
                      _this.socketState.acknowledged = true;
                      if (onAcknowledged)
                        onAcknowledged(message.payload);
                    }
                    return;
                  }
                  case PING: {
                    if (onPing)
                      onPing(message.payload).then(function(r) {
                        return socket.send(Pong(r).text);
                      });
                    else
                      socket.send(Pong(null).text);
                    return;
                  }
                  case PONG: {
                    if (onPong)
                      onPong(message.payload);
                    return;
                  }
                }
                if (!_this.socketState.acknowledged) {
                  return;
                }
                if (message.id === void 0 || message.id === null || !_this.socketState.subscriptions[message.id]) {
                  return;
                }
                var _a2 = _this.socketState.subscriptions[message.id], query = _a2.query, variables = _a2.variables, subscriber = _a2.subscriber;
                switch (message.type) {
                  case NEXT: {
                    if (!message.payload.errors && message.payload.data) {
                      subscriber.next && subscriber.next(message.payload.data);
                    }
                    if (message.payload.errors) {
                      subscriber.error && subscriber.error(new types_1.ClientError(__assign2(__assign2({}, message.payload), { status: 200 }), { query, variables }));
                    } else {
                    }
                    return;
                  }
                  case ERROR2: {
                    subscriber.error && subscriber.error(new types_1.ClientError({ errors: message.payload, status: 200 }, { query, variables }));
                    return;
                  }
                  case COMPLETE: {
                    subscriber.complete && subscriber.complete();
                    delete _this.socketState.subscriptions[message.id];
                    return;
                  }
                }
              } catch (e2) {
                console.error(e2);
                socket.close(1006);
              }
              socket.close(4400, "Unknown graphql-ws message.");
            };
          }
          GraphQLWebSocketClient2.prototype.makeSubscribe = function(query, operationName, variables, subscriber) {
            var _this = this;
            var subscriptionId = (this.socketState.lastRequestId++).toString();
            this.socketState.subscriptions[subscriptionId] = { query, variables, subscriber };
            this.socket.send(Subscribe(subscriptionId, { query, operationName, variables }).text);
            return function() {
              _this.socket.send(Complete(subscriptionId).text);
              delete _this.socketState.subscriptions[subscriptionId];
            };
          };
          GraphQLWebSocketClient2.prototype.rawRequest = function(query, variables) {
            var _this = this;
            return new Promise(function(resolve4, reject) {
              var result;
              _this.rawSubscribe(query, {
                next: function(data, extensions) {
                  return result = { data, extensions };
                },
                error: reject,
                complete: function() {
                  return resolve4(result);
                }
              }, variables);
            });
          };
          GraphQLWebSocketClient2.prototype.request = function(document2, variables) {
            var _this = this;
            return new Promise(function(resolve4, reject) {
              var result;
              _this.subscribe(document2, {
                next: function(data) {
                  return result = data;
                },
                error: reject,
                complete: function() {
                  return resolve4(result);
                }
              }, variables);
            });
          };
          GraphQLWebSocketClient2.prototype.subscribe = function(document2, subscriber, variables) {
            var _a = _1.resolveRequestDocument(document2), query = _a.query, operationName = _a.operationName;
            return this.makeSubscribe(query, operationName, variables, subscriber);
          };
          GraphQLWebSocketClient2.prototype.rawSubscribe = function(query, subscriber, variables) {
            return this.makeSubscribe(query, void 0, variables, subscriber);
          };
          GraphQLWebSocketClient2.prototype.ping = function(payload) {
            this.socket.send(Ping(payload).text);
          };
          GraphQLWebSocketClient2.prototype.close = function() {
            this.socket.close(1e3);
          };
          GraphQLWebSocketClient2.PROTOCOL = "graphql-transport-ws";
          return GraphQLWebSocketClient2;
        }()
      );
      exports.GraphQLWebSocketClient = GraphQLWebSocketClient;
      function parseMessage(data, f2) {
        if (f2 === void 0) {
          f2 = function(a) {
            return a;
          };
        }
        var m = GraphQLWebSocketMessage.parse(data, f2);
        return m;
      }
      function ConnectionInit(payload) {
        return new GraphQLWebSocketMessage(CONNECTION_INIT, payload);
      }
      function Ping(payload) {
        return new GraphQLWebSocketMessage(PING, payload, void 0);
      }
      function Pong(payload) {
        return new GraphQLWebSocketMessage(PONG, payload, void 0);
      }
      function Subscribe(id, payload) {
        return new GraphQLWebSocketMessage(SUBSCRIBE, payload, id);
      }
      function Complete(id) {
        return new GraphQLWebSocketMessage(COMPLETE, void 0, id);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/index.js
  var require_dist2 = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/index.js"(exports) {
      "use strict";
      var __assign2 = exports && exports.__assign || function() {
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve4) {
            resolve4(value);
          });
        }
        return new (P || (P = Promise))(function(resolve4, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      var __importDefault = exports && exports.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GraphQLWebSocketClient = exports.gql = exports.resolveRequestDocument = exports.batchRequests = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;
      var cross_fetch_1 = __importStar(require_node_ponyfill());
      var CrossFetch = cross_fetch_1;
      var parser_1 = require_parser3();
      var printer_1 = require_printer2();
      var createRequestBody_1 = __importDefault(require_createRequestBody());
      var defaultJsonSerializer_1 = require_defaultJsonSerializer();
      var parseArgs_1 = require_parseArgs();
      var types_1 = require_types();
      Object.defineProperty(exports, "ClientError", { enumerable: true, get: function() {
        return types_1.ClientError;
      } });
      var resolveHeaders = function(headers) {
        var oHeaders = {};
        if (headers) {
          if (typeof Headers !== "undefined" && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {
            oHeaders = HeadersInstanceToPlainObject(headers);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(_a) {
              var name = _a[0], value = _a[1];
              oHeaders[name] = value;
            });
          } else {
            oHeaders = headers;
          }
        }
        return oHeaders;
      };
      var queryCleanner = function(str) {
        return str.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim();
      };
      var buildGetQueryParams = function(_a) {
        var query = _a.query, variables = _a.variables, operationName = _a.operationName, jsonSerializer = _a.jsonSerializer;
        if (!Array.isArray(query)) {
          var search = ["query=" + encodeURIComponent(queryCleanner(query))];
          if (variables) {
            search.push("variables=" + encodeURIComponent(jsonSerializer.stringify(variables)));
          }
          if (operationName) {
            search.push("operationName=" + encodeURIComponent(operationName));
          }
          return search.join("&");
        }
        if (typeof variables !== "undefined" && !Array.isArray(variables)) {
          throw new Error("Cannot create query with given variable type, array expected");
        }
        var payload = query.reduce(function(accu, currentQuery, index) {
          accu.push({
            query: queryCleanner(currentQuery),
            variables: variables ? jsonSerializer.stringify(variables[index]) : void 0
          });
          return accu;
        }, []);
        return "query=" + encodeURIComponent(jsonSerializer.stringify(payload));
      };
      var post = function(_a) {
        var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch3 = _a.fetch, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
        return __awaiter(void 0, void 0, void 0, function() {
          var body, options;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                body = createRequestBody_1.default(query, variables, operationName, fetchOptions.jsonSerializer);
                options = __assign2({ method: "POST", headers: __assign2(__assign2({}, typeof body === "string" ? { "Content-Type": "application/json" } : {}), headers), body }, fetchOptions);
                if (!middleware)
                  return [3, 2];
                return [4, Promise.resolve(middleware(options))];
              case 1:
                options = _b.sent();
                _b.label = 2;
              case 2:
                return [4, fetch3(url, options)];
              case 3:
                return [2, _b.sent()];
            }
          });
        });
      };
      var get = function(_a) {
        var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch3 = _a.fetch, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
        return __awaiter(void 0, void 0, void 0, function() {
          var queryParams, options;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                queryParams = buildGetQueryParams({
                  query,
                  variables,
                  operationName,
                  jsonSerializer: fetchOptions.jsonSerializer
                });
                options = __assign2({ method: "GET", headers }, fetchOptions);
                if (!middleware)
                  return [3, 2];
                return [4, Promise.resolve(middleware(options))];
              case 1:
                options = _b.sent();
                _b.label = 2;
              case 2:
                return [4, fetch3(url + "?" + queryParams, options)];
              case 3:
                return [2, _b.sent()];
            }
          });
        });
      };
      var GraphQLClient3 = (
        /** @class */
        function() {
          function GraphQLClient4(url, options) {
            if (options === void 0) {
              options = {};
            }
            this.url = url;
            this.options = options;
          }
          GraphQLClient4.prototype.rawRequest = function(queryOrOptions, variables, requestHeaders) {
            return __awaiter(this, void 0, void 0, function() {
              var rawRequestOptions, _a, headers, _b, fetch3, _c, method, requestMiddleware, responseMiddleware, fetchOptions, url, operationName;
              return __generator(this, function(_d) {
                rawRequestOptions = parseArgs_1.parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
                _a = this.options, headers = _a.headers, _b = _a.fetch, fetch3 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
                url = this.url;
                if (rawRequestOptions.signal !== void 0) {
                  fetchOptions.signal = rawRequestOptions.signal;
                }
                operationName = resolveRequestDocument(rawRequestOptions.query).operationName;
                return [2, makeRequest({
                  url,
                  query: rawRequestOptions.query,
                  variables: rawRequestOptions.variables,
                  headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(rawRequestOptions.requestHeaders)),
                  operationName,
                  fetch: fetch3,
                  method,
                  fetchOptions,
                  middleware: requestMiddleware
                }).then(function(response) {
                  if (responseMiddleware) {
                    responseMiddleware(response);
                  }
                  return response;
                }).catch(function(error2) {
                  if (responseMiddleware) {
                    responseMiddleware(error2);
                  }
                  throw error2;
                })];
              });
            });
          };
          GraphQLClient4.prototype.request = function(documentOrOptions) {
            var variablesAndRequestHeaders = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              variablesAndRequestHeaders[_i - 1] = arguments[_i];
            }
            var variables = variablesAndRequestHeaders[0], requestHeaders = variablesAndRequestHeaders[1];
            var requestOptions = parseArgs_1.parseRequestArgs(documentOrOptions, variables, requestHeaders);
            var _a = this.options, headers = _a.headers, _b = _a.fetch, fetch3 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
            var url = this.url;
            if (requestOptions.signal !== void 0) {
              fetchOptions.signal = requestOptions.signal;
            }
            var _d = resolveRequestDocument(requestOptions.document), query = _d.query, operationName = _d.operationName;
            return makeRequest({
              url,
              query,
              variables: requestOptions.variables,
              headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(requestOptions.requestHeaders)),
              operationName,
              fetch: fetch3,
              method,
              fetchOptions,
              middleware: requestMiddleware
            }).then(function(response) {
              if (responseMiddleware) {
                responseMiddleware(response);
              }
              return response.data;
            }).catch(function(error2) {
              if (responseMiddleware) {
                responseMiddleware(error2);
              }
              throw error2;
            });
          };
          GraphQLClient4.prototype.batchRequests = function(documentsOrOptions, requestHeaders) {
            var batchRequestOptions = parseArgs_1.parseBatchRequestArgs(documentsOrOptions, requestHeaders);
            var _a = this.options, headers = _a.headers, _b = _a.fetch, fetch3 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
            var url = this.url;
            if (batchRequestOptions.signal !== void 0) {
              fetchOptions.signal = batchRequestOptions.signal;
            }
            var queries = batchRequestOptions.documents.map(function(_a2) {
              var document2 = _a2.document;
              return resolveRequestDocument(document2).query;
            });
            var variables = batchRequestOptions.documents.map(function(_a2) {
              var variables2 = _a2.variables;
              return variables2;
            });
            return makeRequest({
              url,
              query: queries,
              variables,
              headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(batchRequestOptions.requestHeaders)),
              operationName: void 0,
              fetch: fetch3,
              method,
              fetchOptions,
              middleware: requestMiddleware
            }).then(function(response) {
              if (responseMiddleware) {
                responseMiddleware(response);
              }
              return response.data;
            }).catch(function(error2) {
              if (responseMiddleware) {
                responseMiddleware(error2);
              }
              throw error2;
            });
          };
          GraphQLClient4.prototype.setHeaders = function(headers) {
            this.options.headers = headers;
            return this;
          };
          GraphQLClient4.prototype.setHeader = function(key, value) {
            var _a;
            var headers = this.options.headers;
            if (headers) {
              headers[key] = value;
            } else {
              this.options.headers = (_a = {}, _a[key] = value, _a);
            }
            return this;
          };
          GraphQLClient4.prototype.setEndpoint = function(value) {
            this.url = value;
            return this;
          };
          return GraphQLClient4;
        }()
      );
      exports.GraphQLClient = GraphQLClient3;
      function makeRequest(_a) {
        var url = _a.url, query = _a.query, variables = _a.variables, headers = _a.headers, operationName = _a.operationName, fetch3 = _a.fetch, _b = _a.method, method = _b === void 0 ? "POST" : _b, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
        return __awaiter(this, void 0, void 0, function() {
          var fetcher, isBathchingQuery, response, result, successfullyReceivedData, successfullyPassedErrorPolicy, headers_1, status_1, errors, rest, data, errorResult;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                fetcher = method.toUpperCase() === "POST" ? post : get;
                isBathchingQuery = Array.isArray(query);
                return [4, fetcher({
                  url,
                  query,
                  variables,
                  operationName,
                  headers,
                  fetch: fetch3,
                  fetchOptions,
                  middleware
                })];
              case 1:
                response = _c.sent();
                return [4, getResult(response, fetchOptions.jsonSerializer)];
              case 2:
                result = _c.sent();
                successfullyReceivedData = isBathchingQuery && Array.isArray(result) ? !result.some(function(_a2) {
                  var data2 = _a2.data;
                  return !data2;
                }) : !!result.data;
                successfullyPassedErrorPolicy = !result.errors || fetchOptions.errorPolicy === "all" || fetchOptions.errorPolicy === "ignore";
                if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {
                  headers_1 = response.headers, status_1 = response.status;
                  errors = result.errors, rest = __rest(result, ["errors"]);
                  data = fetchOptions.errorPolicy === "ignore" ? rest : result;
                  return [2, __assign2(__assign2({}, isBathchingQuery ? { data } : data), { headers: headers_1, status: status_1 })];
                } else {
                  errorResult = typeof result === "string" ? { error: result } : result;
                  throw new types_1.ClientError(__assign2(__assign2({}, errorResult), { status: response.status, headers: response.headers }), { query, variables });
                }
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }
      function rawRequest(urlOrOptions, query, variables, requestHeaders) {
        return __awaiter(this, void 0, void 0, function() {
          var requestOptions, client;
          return __generator(this, function(_a) {
            requestOptions = parseArgs_1.parseRawRequestExtendedArgs(urlOrOptions, query, variables, requestHeaders);
            client = new GraphQLClient3(requestOptions.url);
            return [2, client.rawRequest(__assign2({}, requestOptions))];
          });
        });
      }
      exports.rawRequest = rawRequest;
      function request(urlOrOptions, document2) {
        var variablesAndRequestHeaders = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          variablesAndRequestHeaders[_i - 2] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var variables, requestHeaders, requestOptions, client;
          return __generator(this, function(_a) {
            variables = variablesAndRequestHeaders[0], requestHeaders = variablesAndRequestHeaders[1];
            requestOptions = parseArgs_1.parseRequestExtendedArgs(urlOrOptions, document2, variables, requestHeaders);
            client = new GraphQLClient3(requestOptions.url);
            return [2, client.request(__assign2({}, requestOptions))];
          });
        });
      }
      exports.request = request;
      function batchRequests(urlOrOptions, documents, requestHeaders) {
        return __awaiter(this, void 0, void 0, function() {
          var requestOptions, client;
          return __generator(this, function(_a) {
            requestOptions = parseArgs_1.parseBatchRequestsExtendedArgs(urlOrOptions, documents, requestHeaders);
            client = new GraphQLClient3(requestOptions.url);
            return [2, client.batchRequests(__assign2({}, requestOptions))];
          });
        });
      }
      exports.batchRequests = batchRequests;
      exports.default = request;
      function getResult(response, jsonSerializer) {
        if (jsonSerializer === void 0) {
          jsonSerializer = defaultJsonSerializer_1.defaultJsonSerializer;
        }
        return __awaiter(this, void 0, void 0, function() {
          var contentType, _a, _b;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                response.headers.forEach(function(value, key) {
                  if (key.toLowerCase() === "content-type") {
                    contentType = value;
                  }
                });
                if (!(contentType && contentType.toLowerCase().startsWith("application/json")))
                  return [3, 2];
                _b = (_a = jsonSerializer).parse;
                return [4, response.text()];
              case 1:
                return [2, _b.apply(_a, [_c.sent()])];
              case 2:
                return [2, response.text()];
            }
          });
        });
      }
      function extractOperationName(document2) {
        var _a;
        var operationName = void 0;
        var operationDefinitions = document2.definitions.filter(function(definition) {
          return definition.kind === "OperationDefinition";
        });
        if (operationDefinitions.length === 1) {
          operationName = (_a = operationDefinitions[0].name) === null || _a === void 0 ? void 0 : _a.value;
        }
        return operationName;
      }
      function resolveRequestDocument(document2) {
        if (typeof document2 === "string") {
          var operationName_1 = void 0;
          try {
            var parsedDocument = parser_1.parse(document2);
            operationName_1 = extractOperationName(parsedDocument);
          } catch (err) {
          }
          return { query: document2, operationName: operationName_1 };
        }
        var operationName = extractOperationName(document2);
        return { query: printer_1.print(document2), operationName };
      }
      exports.resolveRequestDocument = resolveRequestDocument;
      function callOrIdentity(value) {
        return typeof value === "function" ? value() : value;
      }
      function gql2(chunks) {
        var variables = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          variables[_i - 1] = arguments[_i];
        }
        return chunks.reduce(function(accumulator, chunk, index) {
          return "" + accumulator + chunk + (index in variables ? variables[index] : "");
        }, "");
      }
      exports.gql = gql2;
      function HeadersInstanceToPlainObject(headers) {
        var o = {};
        headers.forEach(function(v, k) {
          o[k] = v;
        });
        return o;
      }
      var graphql_ws_1 = require_graphql_ws();
      Object.defineProperty(exports, "GraphQLWebSocketClient", { enumerable: true, get: function() {
        return graphql_ws_1.GraphQLWebSocketClient;
      } });
    }
  });

  // ../../node_modules/.pnpm/@fuels+vm-asm@0.42.1/node_modules/@fuels/vm-asm/dist/node/index.cjs
  var require_node = __commonJS({
    "../../node_modules/.pnpm/@fuels+vm-asm@0.42.1/node_modules/@fuels/vm-asm/dist/node/index.cjs"(exports) {
      "use strict";
      var wasm$1;
      var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
        throw Error("TextDecoder not available");
      } };
      if (typeof TextDecoder !== "undefined") {
        cachedTextDecoder.decode();
      }
      var cachedUint8Memory0 = null;
      function getUint8Memory0() {
        if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
          cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
        }
        return cachedUint8Memory0;
      }
      function getStringFromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
      }
      function _assertClass(instance, klass) {
        if (!(instance instanceof klass)) {
          throw new Error(`expected instance of ${klass.name}`);
        }
        return instance.ptr;
      }
      function add2(dst, lhs, rhs) {
        const ret5 = wasm$1.add(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function and(dst, lhs, rhs) {
        const ret5 = wasm$1.and(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function div(dst, lhs, rhs) {
        const ret5 = wasm$1.div(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function eq2(dst, lhs, rhs) {
        const ret5 = wasm$1.eq(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function exp(dst, lhs, rhs) {
        const ret5 = wasm$1.exp(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function gt2(dst, lhs, rhs) {
        const ret5 = wasm$1.gt(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function lt(dst, lhs, rhs) {
        const ret5 = wasm$1.lt(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function mlog(dst, lhs, rhs) {
        const ret5 = wasm$1.mlog(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function mroo(dst, lhs, rhs) {
        const ret5 = wasm$1.mroo(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function mod_(dst, lhs, rhs) {
        const ret5 = wasm$1.mod_(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function move_(dst, src) {
        const ret5 = wasm$1.move_(dst, src);
        return Instruction2.__wrap(ret5);
      }
      function mul(dst, lhs, rhs) {
        const ret5 = wasm$1.mul(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function not(dst, arg) {
        const ret5 = wasm$1.not(dst, arg);
        return Instruction2.__wrap(ret5);
      }
      function or(dst, lhs, rhs) {
        const ret5 = wasm$1.or(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function sll(dst, lhs, rhs) {
        const ret5 = wasm$1.sll(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function srl(dst, lhs, rhs) {
        const ret5 = wasm$1.srl(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function sub(dst, lhs, rhs) {
        const ret5 = wasm$1.sub(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function xor(dst, lhs, rhs) {
        const ret5 = wasm$1.xor(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function mldv(dst, mul_lhs, mul_rhs, divisor) {
        const ret5 = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret5);
      }
      function ret4(value) {
        const ret5 = wasm$1.ret(value);
        return Instruction2.__wrap(ret5);
      }
      function retd2(addr, len) {
        const ret5 = wasm$1.retd(addr, len);
        return Instruction2.__wrap(ret5);
      }
      function aloc(bytes3) {
        const ret5 = wasm$1.aloc(bytes3);
        return Instruction2.__wrap(ret5);
      }
      function mcl(dst_addr, len) {
        const ret5 = wasm$1.mcl(dst_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function mcp(dst_addr, src_addr, len) {
        const ret5 = wasm$1.mcp(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function meq(result, lhs_addr, rhs_addr, len) {
        const ret5 = wasm$1.meq(result, lhs_addr, rhs_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function bhsh(dst, heigth) {
        const ret5 = wasm$1.bhsh(dst, heigth);
        return Instruction2.__wrap(ret5);
      }
      function bhei(dst) {
        const ret5 = wasm$1.bhei(dst);
        return Instruction2.__wrap(ret5);
      }
      function burn(amount, sub_id_addr) {
        const ret5 = wasm$1.burn(amount, sub_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function call2(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        const ret5 = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
        return Instruction2.__wrap(ret5);
      }
      function ccp(dst_addr, contract_id_addr, offset, len) {
        const ret5 = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
        return Instruction2.__wrap(ret5);
      }
      function croo(dst_addr, contract_id_addr) {
        const ret5 = wasm$1.croo(dst_addr, contract_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function csiz(dst, contract_id_addr) {
        const ret5 = wasm$1.csiz(dst, contract_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function cb(dst) {
        const ret5 = wasm$1.cb(dst);
        return Instruction2.__wrap(ret5);
      }
      function ldc(contract_id_addr, offset, len) {
        const ret5 = wasm$1.ldc(contract_id_addr, offset, len);
        return Instruction2.__wrap(ret5);
      }
      function log2(a, b, c, d) {
        const ret5 = wasm$1.log(a, b, c, d);
        return Instruction2.__wrap(ret5);
      }
      function logd(a, b, addr, len) {
        const ret5 = wasm$1.logd(a, b, addr, len);
        return Instruction2.__wrap(ret5);
      }
      function mint(amount, sub_id_addr) {
        const ret5 = wasm$1.mint(amount, sub_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function rvrt(value) {
        const ret5 = wasm$1.rvrt(value);
        return Instruction2.__wrap(ret5);
      }
      function scwq(key_addr, status, lenq) {
        const ret5 = wasm$1.scwq(key_addr, status, lenq);
        return Instruction2.__wrap(ret5);
      }
      function srw(dst, status, key_addr) {
        const ret5 = wasm$1.srw(dst, status, key_addr);
        return Instruction2.__wrap(ret5);
      }
      function srwq(dst_addr, status, key_addr, lenq) {
        const ret5 = wasm$1.srwq(dst_addr, status, key_addr, lenq);
        return Instruction2.__wrap(ret5);
      }
      function sww(key_addr, status, value) {
        const ret5 = wasm$1.sww(key_addr, status, value);
        return Instruction2.__wrap(ret5);
      }
      function swwq(key_addr, status, src_addr, lenq) {
        const ret5 = wasm$1.swwq(key_addr, status, src_addr, lenq);
        return Instruction2.__wrap(ret5);
      }
      function tr3(contract_id_addr, amount, asset_id_addr) {
        const ret5 = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function tro(contract_id_addr, output_index, amount, asset_id_addr) {
        const ret5 = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function eck1(dst_addr, sig_addr, msg_hash_addr) {
        const ret5 = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
        return Instruction2.__wrap(ret5);
      }
      function ecr1(dst_addr, sig_addr, msg_hash_addr) {
        const ret5 = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
        return Instruction2.__wrap(ret5);
      }
      function ed19(pub_key_addr, sig_addr, msg_hash_addr) {
        const ret5 = wasm$1.ed19(pub_key_addr, sig_addr, msg_hash_addr);
        return Instruction2.__wrap(ret5);
      }
      function k256(dst_addr, src_addr, len) {
        const ret5 = wasm$1.k256(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function s256(dst_addr, src_addr, len) {
        const ret5 = wasm$1.s256(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function time(dst, heigth) {
        const ret5 = wasm$1.time(dst, heigth);
        return Instruction2.__wrap(ret5);
      }
      function noop() {
        const ret5 = wasm$1.noop();
        return Instruction2.__wrap(ret5);
      }
      function flag(value) {
        const ret5 = wasm$1.flag(value);
        return Instruction2.__wrap(ret5);
      }
      function bal(dst, asset_id_addr, contract_id_addr) {
        const ret5 = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function jmp(abs_target) {
        const ret5 = wasm$1.jmp(abs_target);
        return Instruction2.__wrap(ret5);
      }
      function jne(abs_target, lhs, rhs) {
        const ret5 = wasm$1.jne(abs_target, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function smo(recipient_addr, data_addr, data_len, coins) {
        const ret5 = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
        return Instruction2.__wrap(ret5);
      }
      function addi3(dst, lhs, rhs) {
        const ret5 = wasm$1.addi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function andi(dst, lhs, rhs) {
        const ret5 = wasm$1.andi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function divi(dst, lhs, rhs) {
        const ret5 = wasm$1.divi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function expi(dst, lhs, rhs) {
        const ret5 = wasm$1.expi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function modi(dst, lhs, rhs) {
        const ret5 = wasm$1.modi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function muli2(dst, lhs, rhs) {
        const ret5 = wasm$1.muli(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function ori(dst, lhs, rhs) {
        const ret5 = wasm$1.ori(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function slli(dst, lhs, rhs) {
        const ret5 = wasm$1.slli(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function srli(dst, lhs, rhs) {
        const ret5 = wasm$1.srli(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function subi(dst, lhs, rhs) {
        const ret5 = wasm$1.subi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function xori(dst, lhs, rhs) {
        const ret5 = wasm$1.xori(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function jnei(cond_lhs, cond_rhs, abs_target) {
        const ret5 = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
        return Instruction2.__wrap(ret5);
      }
      function lb(dst, addr, offset) {
        const ret5 = wasm$1.lb(dst, addr, offset);
        return Instruction2.__wrap(ret5);
      }
      function lw4(dst, addr, offset) {
        const ret5 = wasm$1.lw(dst, addr, offset);
        return Instruction2.__wrap(ret5);
      }
      function sb(addr, value, offset) {
        const ret5 = wasm$1.sb(addr, value, offset);
        return Instruction2.__wrap(ret5);
      }
      function sw(addr, value, offset) {
        const ret5 = wasm$1.sw(addr, value, offset);
        return Instruction2.__wrap(ret5);
      }
      function mcpi(dst_addr, src_addr, len) {
        const ret5 = wasm$1.mcpi(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function gtf3(dst, arg, selector) {
        const ret5 = wasm$1.gtf(dst, arg, selector);
        return Instruction2.__wrap(ret5);
      }
      function mcli(addr, count) {
        const ret5 = wasm$1.mcli(addr, count);
        return Instruction2.__wrap(ret5);
      }
      function gm(dst, selector) {
        const ret5 = wasm$1.gm(dst, selector);
        return Instruction2.__wrap(ret5);
      }
      function movi2(dst, val) {
        const ret5 = wasm$1.movi(dst, val);
        return Instruction2.__wrap(ret5);
      }
      function jnzi(cond_nz, abs_target) {
        const ret5 = wasm$1.jnzi(cond_nz, abs_target);
        return Instruction2.__wrap(ret5);
      }
      function jmpf(dynamic, fixed) {
        const ret5 = wasm$1.jmpf(dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jmpb(dynamic, fixed) {
        const ret5 = wasm$1.jmpb(dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jnzf(cond_nz, dynamic, fixed) {
        const ret5 = wasm$1.jnzf(cond_nz, dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jnzb(cond_nz, dynamic, fixed) {
        const ret5 = wasm$1.jnzb(cond_nz, dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
        const ret5 = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
        const ret5 = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function ji(abs_target) {
        const ret5 = wasm$1.ji(abs_target);
        return Instruction2.__wrap(ret5);
      }
      function cfei(amount) {
        const ret5 = wasm$1.cfei(amount);
        return Instruction2.__wrap(ret5);
      }
      function cfsi(amount) {
        const ret5 = wasm$1.cfsi(amount);
        return Instruction2.__wrap(ret5);
      }
      function cfe(amount) {
        const ret5 = wasm$1.cfe(amount);
        return Instruction2.__wrap(ret5);
      }
      function cfs(amount) {
        const ret5 = wasm$1.cfs(amount);
        return Instruction2.__wrap(ret5);
      }
      function pshl(bitmask) {
        const ret5 = wasm$1.pshl(bitmask);
        return Instruction2.__wrap(ret5);
      }
      function pshh(bitmask) {
        const ret5 = wasm$1.pshh(bitmask);
        return Instruction2.__wrap(ret5);
      }
      function popl(bitmask) {
        const ret5 = wasm$1.popl(bitmask);
        return Instruction2.__wrap(ret5);
      }
      function poph(bitmask) {
        const ret5 = wasm$1.poph(bitmask);
        return Instruction2.__wrap(ret5);
      }
      function wdcm(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wdcm(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wqcm(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wqcm(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wdop(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wdop(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wqop(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wqop(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wdml(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wdml(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wqml(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wqml(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wddv(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wddv(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wqdv(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wqdv(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wdmd(dst, mul_lhs, mul_rhs, divisor) {
        const ret5 = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret5);
      }
      function wqmd(dst, mul_lhs, mul_rhs, divisor) {
        const ret5 = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret5);
      }
      function wdam(dst, add_lhs, add_rhs, modulo) {
        const ret5 = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
        return Instruction2.__wrap(ret5);
      }
      function wqam(dst, add_lhs, add_rhs, modulo) {
        const ret5 = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
        return Instruction2.__wrap(ret5);
      }
      function wdmm(dst, mul_lhs, mul_rhs, modulo) {
        const ret5 = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
        return Instruction2.__wrap(ret5);
      }
      function wqmm(dst, mul_lhs, mul_rhs, modulo) {
        const ret5 = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
        return Instruction2.__wrap(ret5);
      }
      function ecal(a, b, c, d) {
        const ret5 = wasm$1.ecal(a, b, c, d);
        return Instruction2.__wrap(ret5);
      }
      function gm_args(ra, args) {
        const ret5 = wasm$1.gm_args(ra, args);
        return Instruction2.__wrap(ret5);
      }
      function gtf_args(ra, rb, args) {
        const ret5 = wasm$1.gtf_args(ra, rb, args);
        return Instruction2.__wrap(ret5);
      }
      function wdcm_args(ra, rb, rc, args) {
        _assertClass(args, CompareArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wdcm_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wqcm_args(ra, rb, rc, args) {
        _assertClass(args, CompareArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wqcm_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wdop_args(ra, rb, rc, args) {
        _assertClass(args, MathArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wdop_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wqop_args(ra, rb, rc, args) {
        _assertClass(args, MathArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wqop_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wdml_args(ra, rb, rc, args) {
        _assertClass(args, MulArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wdml_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wqml_args(ra, rb, rc, args) {
        _assertClass(args, MulArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wqml_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wddv_args(ra, rb, rc, args) {
        _assertClass(args, DivArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wddv_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wqdv_args(ra, rb, rc, args) {
        _assertClass(args, DivArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wqdv_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      var cachedInt32Memory0 = null;
      function getInt32Memory0() {
        if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
          cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
        }
        return cachedInt32Memory0;
      }
      function getArrayU8FromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
      }
      var GMArgs = Object.freeze({
        /**
        *r" Get if caller is external.
        */
        IsCallerExternal: 1,
        "1": "IsCallerExternal",
        /**
        *r" Get caller's contract ID.
        */
        GetCaller: 2,
        "2": "GetCaller",
        /**
        *r" Get index of current predicate.
        */
        GetVerifyingPredicate: 3,
        "3": "GetVerifyingPredicate",
        /**
        *r" Get the Chain ID this VM is operating within
        */
        GetChainId: 4,
        "4": "GetChainId"
      });
      var GTFArgs3 = Object.freeze({
        /**
        *r" Set `$rA` to `tx.type`
        */
        Type: 1,
        "1": "Type",
        /**
        *r" Set `$rA` to `tx.scriptGasLimit`
        */
        ScriptGasLimit: 2,
        "2": "ScriptGasLimit",
        /**
        *r" Set `$rA` to `tx.scriptLength`
        */
        ScriptLength: 3,
        "3": "ScriptLength",
        /**
        *r" Set `$rA` to `tx.scriptDataLength`
        */
        ScriptDataLength: 4,
        "4": "ScriptDataLength",
        /**
        *r" Set `$rA` to `tx.inputsCount`
        */
        ScriptInputsCount: 5,
        "5": "ScriptInputsCount",
        /**
        *r" Set `$rA` to `tx.outputsCount`
        */
        ScriptOutputsCount: 6,
        "6": "ScriptOutputsCount",
        /**
        *r" Set `$rA` to `tx.witnessesCount`
        */
        ScriptWitnessesCount: 7,
        "7": "ScriptWitnessesCount",
        /**
        *r" Set `$rA` to `Memory address of tx.receiptsRoot`
        */
        ScriptReceiptsRoot: 8,
        "8": "ScriptReceiptsRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.script`
        */
        Script: 9,
        "9": "Script",
        /**
        *r" Set `$rA` to `Memory address of tx.scriptData`
        */
        ScriptData: 10,
        "10": "ScriptData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB]`
        */
        ScriptInputAtIndex: 11,
        "11": "ScriptInputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of t.outputs[$rB]`
        */
        ScriptOutputAtIndex: 12,
        "12": "ScriptOutputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
        */
        ScriptWitnessAtIndex: 13,
        "13": "ScriptWitnessAtIndex",
        /**
        *r" Set `$rA` to `tx.bytecodeLength`
        */
        CreateBytecodeLength: 256,
        "256": "CreateBytecodeLength",
        /**
        *r" Set `$rA` to `tx.bytecodeWitnessIndex`
        */
        CreateBytecodeWitnessIndex: 257,
        "257": "CreateBytecodeWitnessIndex",
        /**
        *r" Set `$rA` to `tx.storageSlotsCount`
        */
        CreateStorageSlotsCount: 258,
        "258": "CreateStorageSlotsCount",
        /**
        *r" Set `$rA` to `tx.inputsCount`
        */
        CreateInputsCount: 259,
        "259": "CreateInputsCount",
        /**
        *r" Set `$rA` to `tx.outputsCount`
        */
        CreateOutputsCount: 260,
        "260": "CreateOutputsCount",
        /**
        *r" Set `$rA` to `tx.witnessesCount`
        */
        CreateWitnessesCount: 261,
        "261": "CreateWitnessesCount",
        /**
        *r" Set `$rA` to `Memory address of tx.salt`
        */
        CreateSalt: 262,
        "262": "CreateSalt",
        /**
        *r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
        */
        CreateStorageSlotAtIndex: 263,
        "263": "CreateStorageSlotAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB]`
        */
        CreateInputAtIndex: 264,
        "264": "CreateInputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of t.outputs[$rB]`
        */
        CreateOutputAtIndex: 265,
        "265": "CreateOutputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
        */
        CreateWitnessAtIndex: 266,
        "266": "CreateWitnessAtIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].type`
        */
        InputType: 512,
        "512": "InputType",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
        */
        InputCoinTxId: 513,
        "513": "InputCoinTxId",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].outputIndex`
        */
        InputCoinOutputIndex: 514,
        "514": "InputCoinOutputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
        */
        InputCoinOwner: 515,
        "515": "InputCoinOwner",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].amount`
        */
        InputCoinAmount: 516,
        "516": "InputCoinAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
        */
        InputCoinAssetId: 517,
        "517": "InputCoinAssetId",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
        */
        InputCoinTxPointer: 518,
        "518": "InputCoinTxPointer",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
        */
        InputCoinWitnessIndex: 519,
        "519": "InputCoinWitnessIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].maturity`
        */
        InputCoinMaturity: 520,
        "520": "InputCoinMaturity",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateLength`
        */
        InputCoinPredicateLength: 521,
        "521": "InputCoinPredicateLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
        */
        InputCoinPredicateDataLength: 522,
        "522": "InputCoinPredicateDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
        */
        InputCoinPredicate: 523,
        "523": "InputCoinPredicate",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
        */
        InputCoinPredicateData: 524,
        "524": "InputCoinPredicateData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
        */
        InputCoinPredicateGasUsed: 525,
        "525": "InputCoinPredicateGasUsed",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
        */
        InputContractTxId: 544,
        "544": "InputContractTxId",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].outputIndex`
        */
        InputContractOutputIndex: 545,
        "545": "InputContractOutputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].balanceRoot`
        */
        InputContractBalanceRoot: 546,
        "546": "InputContractBalanceRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].stateRoot`
        */
        InputContractStateRoot: 547,
        "547": "InputContractStateRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
        */
        InputContractTxPointer: 548,
        "548": "InputContractTxPointer",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
        */
        InputContractId: 549,
        "549": "InputContractId",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
        */
        InputMessageSender: 576,
        "576": "InputMessageSender",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
        */
        InputMessageRecipient: 577,
        "577": "InputMessageRecipient",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].amount`
        */
        InputMessageAmount: 578,
        "578": "InputMessageAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
        */
        InputMessageNonce: 579,
        "579": "InputMessageNonce",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
        */
        InputMessageWitnessIndex: 580,
        "580": "InputMessageWitnessIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].dataLength`
        */
        InputMessageDataLength: 581,
        "581": "InputMessageDataLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateLength`
        */
        InputMessagePredicateLength: 582,
        "582": "InputMessagePredicateLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
        */
        InputMessagePredicateDataLength: 583,
        "583": "InputMessagePredicateDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
        */
        InputMessageData: 584,
        "584": "InputMessageData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
        */
        InputMessagePredicate: 585,
        "585": "InputMessagePredicate",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
        */
        InputMessagePredicateData: 586,
        "586": "InputMessagePredicateData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
        */
        InputMessagePredicateGasUsed: 587,
        "587": "InputMessagePredicateGasUsed",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].type`
        */
        OutputType: 768,
        "768": "OutputType",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
        */
        OutputCoinTo: 769,
        "769": "OutputCoinTo",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].amount`
        */
        OutputCoinAmount: 770,
        "770": "OutputCoinAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
        */
        OutputCoinAssetId: 771,
        "771": "OutputCoinAssetId",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].inputIndex`
        */
        OutputContractInputIndex: 772,
        "772": "OutputContractInputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].balanceRoot`
        */
        OutputContractBalanceRoot: 773,
        "773": "OutputContractBalanceRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
        */
        OutputContractStateRoot: 774,
        "774": "OutputContractStateRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
        */
        OutputContractCreatedContractId: 775,
        "775": "OutputContractCreatedContractId",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
        */
        OutputContractCreatedStateRoot: 776,
        "776": "OutputContractCreatedStateRoot",
        /**
        *r" Set `$rA` to `tx.witnesses[$rB].dataLength`
        */
        WitnessDataLength: 1024,
        "1024": "WitnessDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
        */
        WitnessData: 1025,
        "1025": "WitnessData",
        /**
        *r" Set `$rA` to `tx.policyTypes`
        */
        PolicyTypes: 1280,
        "1280": "PolicyTypes",
        /**
        *r" Set `$rA` to `tx.policies[0x00].gasPrice`
        */
        PolicyGasPrice: 1281,
        "1281": "PolicyGasPrice",
        /**
        *r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
        */
        PolicyWitnessLimit: 1282,
        "1282": "PolicyWitnessLimit",
        /**
        *r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
        */
        PolicyMaturity: 1283,
        "1283": "PolicyMaturity",
        /**
        *r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
        */
        PolicyMaxFee: 1284,
        "1284": "PolicyMaxFee"
      });
      var CompareMode = Object.freeze({
        /**
        * Equality (`==`)
        */
        EQ: 0,
        "0": "EQ",
        /**
        * Inequality (`!=`)
        */
        NE: 1,
        "1": "NE",
        /**
        * Less than (`<`)
        */
        LT: 2,
        "2": "LT",
        /**
        * Greater than (`>`)
        */
        GT: 3,
        "3": "GT",
        /**
        * Less than or equals (`>=`)
        */
        LTE: 4,
        "4": "LTE",
        /**
        * Greater than or equals (`>=`)
        */
        GTE: 5,
        "5": "GTE",
        /**
        * Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
        */
        LZC: 6,
        "6": "LZC"
      });
      var PanicReason = Object.freeze({
        /**
        *r" The byte can't be mapped to any known `PanicReason`.
        */
        UnknownPanicReason: 0,
        "0": "UnknownPanicReason",
        /**
        *r" Found `RVRT` instruction.
        */
        Revert: 1,
        "1": "Revert",
        /**
        *r" Execution ran out of gas.
        */
        OutOfGas: 2,
        "2": "OutOfGas",
        /**
        *r" The transaction validity is violated.
        */
        TransactionValidity: 3,
        "3": "TransactionValidity",
        /**
        *r" Attempt to write outside interpreter memory boundaries.
        */
        MemoryOverflow: 4,
        "4": "MemoryOverflow",
        /**
        *r" Overflow while executing arithmetic operation.
        *r" These errors are ignored using the WRAPPING flag.
        */
        ArithmeticOverflow: 5,
        "5": "ArithmeticOverflow",
        /**
        *r" Designed contract was not found in the storage.
        */
        ContractNotFound: 6,
        "6": "ContractNotFound",
        /**
        *r" Memory ownership rules are violated.
        */
        MemoryOwnership: 7,
        "7": "MemoryOwnership",
        /**
        *r" The asset ID balance isn't enough for the instruction.
        */
        NotEnoughBalance: 8,
        "8": "NotEnoughBalance",
        /**
        *r" The interpreter is expected to be in internal context.
        */
        ExpectedInternalContext: 9,
        "9": "ExpectedInternalContext",
        /**
        *r" The queried asset ID was not found in the state.
        */
        AssetIdNotFound: 10,
        "10": "AssetIdNotFound",
        /**
        *r" The provided input is not found in the transaction.
        */
        InputNotFound: 11,
        "11": "InputNotFound",
        /**
        *r" The provided output is not found in the transaction.
        */
        OutputNotFound: 12,
        "12": "OutputNotFound",
        /**
        *r" The provided witness is not found in the transaction.
        */
        WitnessNotFound: 13,
        "13": "WitnessNotFound",
        /**
        *r" The transaction maturity is not valid for this request.
        */
        TransactionMaturity: 14,
        "14": "TransactionMaturity",
        /**
        *r" The metadata identifier is invalid.
        */
        InvalidMetadataIdentifier: 15,
        "15": "InvalidMetadataIdentifier",
        /**
        *r" The call structure is not valid.
        */
        MalformedCallStructure: 16,
        "16": "MalformedCallStructure",
        /**
        *r" The provided register does not allow write operations.
        */
        ReservedRegisterNotWritable: 17,
        "17": "ReservedRegisterNotWritable",
        /**
        *r" The execution resulted in an erroneous state of the interpreter.
        */
        InvalidFlags: 18,
        "18": "InvalidFlags",
        /**
        *r" The provided immediate value is not valid for this instruction.
        */
        InvalidImmediateValue: 19,
        "19": "InvalidImmediateValue",
        /**
        *r" The provided transaction input is not of type `Coin`.
        */
        ExpectedCoinInput: 20,
        "20": "ExpectedCoinInput",
        /**
        *r" `ECAL` instruction failed.
        */
        EcalError: 21,
        "21": "EcalError",
        /**
        *r" Two segments of the interpreter memory should not intersect for write operations.
        */
        MemoryWriteOverlap: 22,
        "22": "MemoryWriteOverlap",
        /**
        *r" The requested contract is not listed in the transaction inputs.
        */
        ContractNotInInputs: 23,
        "23": "ContractNotInInputs",
        /**
        *r" The internal asset ID balance overflowed with the provided instruction.
        */
        InternalBalanceOverflow: 24,
        "24": "InternalBalanceOverflow",
        /**
        *r" The maximum allowed contract size is violated.
        */
        ContractMaxSize: 25,
        "25": "ContractMaxSize",
        /**
        *r" This instruction expects the stack area to be unallocated for this call.
        */
        ExpectedUnallocatedStack: 26,
        "26": "ExpectedUnallocatedStack",
        /**
        *r" The maximum allowed number of static contracts was reached for this transaction.
        */
        MaxStaticContractsReached: 27,
        "27": "MaxStaticContractsReached",
        /**
        *r" The requested transfer amount cannot be zero.
        */
        TransferAmountCannotBeZero: 28,
        "28": "TransferAmountCannotBeZero",
        /**
        *r" The provided transaction output should be of type `Variable`.
        */
        ExpectedOutputVariable: 29,
        "29": "ExpectedOutputVariable",
        /**
        *r" The expected context of the stack parent is internal.
        */
        ExpectedParentInternalContext: 30,
        "30": "ExpectedParentInternalContext",
        /**
        *r" The predicate returned non `1`. The `1` means successful verification
        *r" of the predicate, all other values means unsuccessful.
        */
        PredicateReturnedNonOne: 31,
        "31": "PredicateReturnedNonOne",
        /**
        *r" The contract ID is already deployed and can't be overwritten.
        */
        ContractIdAlreadyDeployed: 32,
        "32": "ContractIdAlreadyDeployed",
        /**
        *r" The loaded contract mismatch expectations.
        */
        ContractMismatch: 33,
        "33": "ContractMismatch",
        /**
        *r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
        */
        MessageDataTooLong: 34,
        "34": "MessageDataTooLong",
        /**
        *r" Mathematically invalid arguments where given to an arithmetic instruction.
        *r" For instance, division by zero produces this.
        *r" These errors are ignored using the UNSAFEMATH flag.
        */
        ArithmeticError: 35,
        "35": "ArithmeticError",
        /**
        *r" The contract instruction is not allowed in predicates.
        */
        ContractInstructionNotAllowed: 36,
        "36": "ContractInstructionNotAllowed",
        /**
        *r" Transfer of zero coins is not allowed.
        */
        TransferZeroCoins: 37,
        "37": "TransferZeroCoins",
        /**
        *r" Attempted to execute an invalid instruction
        */
        InvalidInstruction: 38,
        "38": "InvalidInstruction",
        /**
        *r" Memory outside $is..$ssp range is not executable
        */
        MemoryNotExecutable: 39,
        "39": "MemoryNotExecutable",
        /**
        *r" The policy is not set.
        */
        PolicyIsNotSet: 40,
        "40": "PolicyIsNotSet",
        /**
        *r" The policy is not found across policies.
        */
        PolicyNotFound: 41,
        "41": "PolicyNotFound",
        /**
        *r" Receipt context is full
        */
        TooManyReceipts: 42,
        "42": "TooManyReceipts",
        /**
        *r" Balance of a contract overflowed
        */
        BalanceOverflow: 43,
        "43": "BalanceOverflow",
        /**
        *r" Block height value is invalid, typically because it is too large
        */
        InvalidBlockHeight: 44,
        "44": "InvalidBlockHeight",
        /**
        *r" Attempt to use sequential memory instructions with too large slot count,
        *r" typically because it cannot fit into usize
        */
        TooManySlots: 45,
        "45": "TooManySlots"
      });
      var MathOp = Object.freeze({
        /**
        * Add
        */
        ADD: 0,
        "0": "ADD",
        /**
        * Subtract
        */
        SUB: 1,
        "1": "SUB",
        /**
        * Invert bits (discards rhs)
        */
        NOT: 2,
        "2": "NOT",
        /**
        * Bitwise or
        */
        OR: 3,
        "3": "OR",
        /**
        * Bitwise exclusive or
        */
        XOR: 4,
        "4": "XOR",
        /**
        * Bitwise and
        */
        AND: 5,
        "5": "AND",
        /**
        * Shift left
        */
        SHL: 6,
        "6": "SHL",
        /**
        * Shift right
        */
        SHR: 7,
        "7": "SHR"
      });
      var ADD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_add_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ADDI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_addi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var ALOC = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_aloc_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} bytes
        */
        constructor(bytes3) {
          _assertClass(bytes3, RegId2);
          var ptr0 = bytes3.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var AND = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_and_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ANDI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_andi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var BAL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bal_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} asset_id_addr
        * @param {RegId} contract_id_addr
        */
        constructor(dst, asset_id_addr, contract_id_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr1 = asset_id_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr2 = contract_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var BHEI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bhei_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        */
        constructor(dst) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var BHSH = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bhsh_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} heigth
        */
        constructor(dst, heigth) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(heigth, RegId2);
          var ptr1 = heigth.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var BURN = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_burn_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        * @param {RegId} sub_id_addr
        */
        constructor(amount, sub_id_addr) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          _assertClass(sub_id_addr, RegId2);
          var ptr1 = sub_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CALL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_call_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} target_struct
        * @param {RegId} fwd_coins
        * @param {RegId} asset_id_addr
        * @param {RegId} fwd_gas
        */
        constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
          _assertClass(target_struct, RegId2);
          var ptr0 = target_struct.__destroy_into_raw();
          _assertClass(fwd_coins, RegId2);
          var ptr1 = fwd_coins.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr2 = asset_id_addr.__destroy_into_raw();
          _assertClass(fwd_gas, RegId2);
          var ptr3 = fwd_gas.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        */
        constructor(dst) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CCP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ccp_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} contract_id_addr
        * @param {RegId} offset
        * @param {RegId} len
        */
        constructor(dst_addr, contract_id_addr, offset, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          _assertClass(offset, RegId2);
          var ptr2 = offset.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CFE = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfe_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        */
        constructor(amount) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CFEI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfei_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} amount
        */
        constructor(amount) {
          _assertClass(amount, Imm24);
          var ptr0 = amount.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var CFS = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfs_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        */
        constructor(amount) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CFSI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfsi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} amount
        */
        constructor(amount) {
          _assertClass(amount, Imm24);
          var ptr0 = amount.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var CROO = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_croo_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} contract_id_addr
        */
        constructor(dst_addr, contract_id_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CSIZ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_csiz_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} contract_id_addr
        */
        constructor(dst, contract_id_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CompareArgs = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CompareArgs.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_compareargs_free(ptr);
        }
        /**
        * Comparison mode
        * @returns {CompareMode}
        */
        get mode() {
          const ret5 = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
          return ret5;
        }
        /**
        * Comparison mode
        * @param {CompareMode} arg0
        */
        set mode(arg0) {
          wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret5 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
        /**
        * Convert to immediate value.
        * @returns {Imm06}
        */
        to_imm() {
          const ptr = this.__destroy_into_raw();
          const ret5 = wasm$1.compareargs_to_imm(ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
        * @param {Imm06} bits
        * @returns {CompareArgs | undefined}
        */
        static from_imm(bits) {
          _assertClass(bits, Imm06);
          var ptr0 = bits.__destroy_into_raw();
          const ret5 = wasm$1.compareargs_from_imm(ptr0);
          return ret5 === 0 ? void 0 : CompareArgs.__wrap(ret5);
        }
      };
      var DIV = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_div_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var DIVI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_divi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var DivArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_divargs_free(ptr);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret5 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var ECAL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ecal_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} a
        * @param {RegId} b
        * @param {RegId} c
        * @param {RegId} d
        */
        constructor(a, b, c, d) {
          _assertClass(a, RegId2);
          var ptr0 = a.__destroy_into_raw();
          _assertClass(b, RegId2);
          var ptr1 = b.__destroy_into_raw();
          _assertClass(c, RegId2);
          var ptr2 = c.__destroy_into_raw();
          _assertClass(d, RegId2);
          var ptr3 = d.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ECK1 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_eck1_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_hash_addr
        */
        constructor(dst_addr, sig_addr, msg_hash_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_hash_addr, RegId2);
          var ptr2 = msg_hash_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ECR1 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ecr1_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_hash_addr
        */
        constructor(dst_addr, sig_addr, msg_hash_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_hash_addr, RegId2);
          var ptr2 = msg_hash_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ED19 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ed19_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} pub_key_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_hash_addr
        */
        constructor(pub_key_addr, sig_addr, msg_hash_addr) {
          _assertClass(pub_key_addr, RegId2);
          var ptr0 = pub_key_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_hash_addr, RegId2);
          var ptr2 = msg_hash_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var EQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_eq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var EXP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_exp_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var EXPI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_expi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var FLAG = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_flag_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var GM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(GM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {Imm18} selector
        */
        constructor(dst, selector) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(selector, Imm18);
          var ptr1 = selector.__destroy_into_raw();
          const ret5 = wasm$1.gm_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
        /**
        * Construct a `GM` instruction from its arguments.
        * @param {RegId} ra
        * @param {GMArgs} args
        * @returns {GM}
        */
        static from_args(ra, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          const ret5 = wasm$1.gm_from_args(ptr0, args);
          return GM.__wrap(ret5);
        }
      };
      var GT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gt_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var GTF = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(GTF.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gtf_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} arg
        * @param {Imm12} selector
        */
        constructor(dst, arg, selector) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(arg, RegId2);
          var ptr1 = arg.__destroy_into_raw();
          _assertClass(selector, Imm12);
          var ptr2 = selector.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
        /**
        * Construct a `GTF` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {GTFArgs} args
        * @returns {GTF}
        */
        static from_args(ra, rb, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          const ret5 = wasm$1.gtf_from_args(ptr0, ptr1, args);
          return GTF.__wrap(ret5);
        }
      };
      var Imm06 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm06.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm06_free(ptr);
        }
      };
      var Imm12 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm12.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm12_free(ptr);
        }
      };
      var Imm18 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm18.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm18_free(ptr);
        }
      };
      var Imm24 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm24.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm24_free(ptr);
        }
      };
      var Instruction2 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Instruction2.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_instruction_free(ptr);
        }
        /**
        * Convenience method for converting to bytes
        * @returns {Uint8Array}
        */
        to_bytes() {
          try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_free(r0, r1 * 1, 1);
            return v1;
          } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
          }
        }
        /**
        * Size of an instruction in bytes
        * @returns {number}
        */
        static size() {
          const ret5 = wasm$1.instruction_size();
          return ret5 >>> 0;
        }
      };
      var JI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ji_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} abs_target
        */
        constructor(abs_target) {
          _assertClass(abs_target, Imm24);
          var ptr0 = abs_target.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var JMP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmp_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} abs_target
        */
        constructor(abs_target) {
          _assertClass(abs_target, RegId2);
          var ptr0 = abs_target.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var JMPB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmpb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dynamic
        * @param {Imm18} fixed
        */
        constructor(dynamic, fixed) {
          _assertClass(dynamic, RegId2);
          var ptr0 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm18);
          var ptr1 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.gm_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var JMPF = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmpf_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dynamic
        * @param {Imm18} fixed
        */
        constructor(dynamic, fixed) {
          _assertClass(dynamic, RegId2);
          var ptr0 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm18);
          var ptr1 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.gm_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var JNE = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jne_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} abs_target
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(abs_target, lhs, rhs) {
          _assertClass(abs_target, RegId2);
          var ptr0 = abs_target.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var JNEB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jneb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {RegId} dynamic
        * @param {Imm06} fixed
        */
        constructor(cond_lhs, cond_rhs, dynamic, fixed) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr2 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm06);
          var ptr3 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var JNEF = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnef_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {RegId} dynamic
        * @param {Imm06} fixed
        */
        constructor(cond_lhs, cond_rhs, dynamic, fixed) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr2 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm06);
          var ptr3 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var JNEI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnei_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {Imm12} abs_target
        */
        constructor(cond_lhs, cond_rhs, abs_target) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(abs_target, Imm12);
          var ptr2 = abs_target.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var JNZB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {RegId} dynamic
        * @param {Imm12} fixed
        */
        constructor(cond_nz, dynamic, fixed) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr1 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm12);
          var ptr2 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var JNZF = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzf_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {RegId} dynamic
        * @param {Imm12} fixed
        */
        constructor(cond_nz, dynamic, fixed) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr1 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm12);
          var ptr2 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var JNZI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {Imm18} abs_target
        */
        constructor(cond_nz, abs_target) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(abs_target, Imm18);
          var ptr1 = abs_target.__destroy_into_raw();
          const ret5 = wasm$1.gm_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var K256 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_k256_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} addr
        * @param {Imm12} offset
        */
        constructor(dst, addr, offset) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr1 = addr.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var LDC = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ldc_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} contract_id_addr
        * @param {RegId} offset
        * @param {RegId} len
        */
        constructor(contract_id_addr, offset, len) {
          _assertClass(contract_id_addr, RegId2);
          var ptr0 = contract_id_addr.__destroy_into_raw();
          _assertClass(offset, RegId2);
          var ptr1 = offset.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LOG = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_log_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} a
        * @param {RegId} b
        * @param {RegId} c
        * @param {RegId} d
        */
        constructor(a, b, c, d) {
          _assertClass(a, RegId2);
          var ptr0 = a.__destroy_into_raw();
          _assertClass(b, RegId2);
          var ptr1 = b.__destroy_into_raw();
          _assertClass(c, RegId2);
          var ptr2 = c.__destroy_into_raw();
          _assertClass(d, RegId2);
          var ptr3 = d.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LOGD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_logd_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} a
        * @param {RegId} b
        * @param {RegId} addr
        * @param {RegId} len
        */
        constructor(a, b, addr, len) {
          _assertClass(a, RegId2);
          var ptr0 = a.__destroy_into_raw();
          _assertClass(b, RegId2);
          var ptr1 = b.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr2 = addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lt_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LW = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lw_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} addr
        * @param {Imm12} offset
        */
        constructor(dst, addr, offset) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr1 = addr.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var MCL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcl_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} len
        */
        constructor(dst_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr1 = len.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MCLI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcli_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {Imm18} count
        */
        constructor(addr, count) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(count, Imm18);
          var ptr1 = count.__destroy_into_raw();
          const ret5 = wasm$1.gm_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var MCP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcp_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MCPI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcpi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {Imm12} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, Imm12);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var MEQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_meq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} result
        * @param {RegId} lhs_addr
        * @param {RegId} rhs_addr
        * @param {RegId} len
        */
        constructor(result, lhs_addr, rhs_addr, len) {
          _assertClass(result, RegId2);
          var ptr0 = result.__destroy_into_raw();
          _assertClass(lhs_addr, RegId2);
          var ptr1 = lhs_addr.__destroy_into_raw();
          _assertClass(rhs_addr, RegId2);
          var ptr2 = rhs_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MINT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mint_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        * @param {RegId} sub_id_addr
        */
        constructor(amount, sub_id_addr) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          _assertClass(sub_id_addr, RegId2);
          var ptr1 = sub_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MLDV = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mldv_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MLOG = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mlog_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MOD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mod_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MODI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_modi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var MOVE = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_move_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} src
        */
        constructor(dst, src) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(src, RegId2);
          var ptr1 = src.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MOVI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_movi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {Imm18} val
        */
        constructor(dst, val) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(val, Imm18);
          var ptr1 = val.__destroy_into_raw();
          const ret5 = wasm$1.gm_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var MROO = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mroo_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MUL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mul_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MULI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_muli_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var MathArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mathargs_free(ptr);
        }
        /**
        * The operation to perform
        * @returns {MathOp}
        */
        get op() {
          const ret5 = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
          return ret5;
        }
        /**
        * The operation to perform
        * @param {MathOp} arg0
        */
        set op(arg0) {
          wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret5 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var MulArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mulargs_free(ptr);
        }
        /**
        * Load LHSS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_lhs() {
          const ret5 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load LHSS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_lhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret5 = wasm$1.__wbg_get_mulargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_mulargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var NOOP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_noop_free(ptr);
        }
        /**
        * Construct the instruction.
        */
        constructor() {
          const ret5 = wasm$1.noop_new_typescript();
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
      };
      var NOT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_not_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} arg
        */
        constructor(dst, arg) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(arg, RegId2);
          var ptr1 = arg.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var OR = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_or_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ORI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ori_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var POPH = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_poph_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var POPL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_popl_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var PSHH = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_pshh_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var PSHL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_pshl_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var PanicInstruction = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_panicinstruction_free(ptr);
        }
        /**
        * Represents an error described by a reason and an instruction.
        * @param {PanicReason} reason
        * @param {number} instruction
        */
        constructor(reason, instruction) {
          const ret5 = wasm$1.panicinstruction_error_typescript(reason, instruction);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Underlying panic reason
        * @returns {PanicReason}
        */
        reason() {
          const ret5 = wasm$1.panicinstruction_reason(this.__wbg_ptr);
          return ret5;
        }
        /**
        * Underlying instruction
        * @returns {number}
        */
        instruction() {
          const ret5 = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
          return ret5 >>> 0;
        }
      };
      var RET = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ret_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var RETD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_retd_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} len
        */
        constructor(addr, len) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr1 = len.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var RVRT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_rvrt_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var RegId2 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(RegId2.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_regid_free(ptr);
        }
        /**
        * Construct a register ID from the given value.
        *
        * Returns `None` if the value is outside the 6-bit value range.
        * @param {number} u
        * @returns {RegId | undefined}
        */
        static new_checked(u) {
          const ret5 = wasm$1.regid_new_checked(u);
          return ret5 === 0 ? void 0 : RegId2.__wrap(ret5);
        }
        /**
        * Received balance for this context.
        * @returns {RegId}
        */
        static bal() {
          const ret5 = wasm$1.regid_bal();
          return RegId2.__wrap(ret5);
        }
        /**
        * Remaining gas in the context.
        * @returns {RegId}
        */
        static cgas() {
          const ret5 = wasm$1.regid_cgas();
          return RegId2.__wrap(ret5);
        }
        /**
        * Error codes for particular operations.
        * @returns {RegId}
        */
        static err() {
          const ret5 = wasm$1.regid_err();
          return RegId2.__wrap(ret5);
        }
        /**
        * Flags register.
        * @returns {RegId}
        */
        static flag() {
          const ret5 = wasm$1.regid_flag();
          return RegId2.__wrap(ret5);
        }
        /**
        * Frame pointer. Memory address of beginning of current call frame.
        * @returns {RegId}
        */
        static fp() {
          const ret5 = wasm$1.regid_fp();
          return RegId2.__wrap(ret5);
        }
        /**
        * Remaining gas globally.
        * @returns {RegId}
        */
        static ggas() {
          const ret5 = wasm$1.regid_ggas();
          return RegId2.__wrap(ret5);
        }
        /**
        * Heap pointer. Memory address below the current bottom of the heap (points to free
        * memory).
        * @returns {RegId}
        */
        static hp() {
          const ret5 = wasm$1.regid_hp();
          return RegId2.__wrap(ret5);
        }
        /**
        * Instructions start. Pointer to the start of the currently-executing code.
        * @returns {RegId}
        */
        static is() {
          const ret5 = wasm$1.regid_is();
          return RegId2.__wrap(ret5);
        }
        /**
        * Contains overflow/underflow of addition, subtraction, and multiplication.
        * @returns {RegId}
        */
        static of() {
          const ret5 = wasm$1.regid_of();
          return RegId2.__wrap(ret5);
        }
        /**
        * Contains one (1), for convenience.
        * @returns {RegId}
        */
        static one() {
          const ret5 = wasm$1.regid_one();
          return RegId2.__wrap(ret5);
        }
        /**
        * The program counter. Memory address of the current instruction.
        * @returns {RegId}
        */
        static pc() {
          const ret5 = wasm$1.regid_pc();
          return RegId2.__wrap(ret5);
        }
        /**
        * Return value or pointer.
        * @returns {RegId}
        */
        static ret() {
          const ret5 = wasm$1.regid_ret();
          return RegId2.__wrap(ret5);
        }
        /**
        * Return value length in bytes.
        * @returns {RegId}
        */
        static retl() {
          const ret5 = wasm$1.regid_retl();
          return RegId2.__wrap(ret5);
        }
        /**
        * Stack pointer. Memory address on top of current writable stack area (points to
        * free memory).
        * @returns {RegId}
        */
        static sp() {
          const ret5 = wasm$1.regid_sp();
          return RegId2.__wrap(ret5);
        }
        /**
        * Stack start pointer. Memory address of bottom of current writable stack area.
        * @returns {RegId}
        */
        static spp() {
          const ret5 = wasm$1.regid_spp();
          return RegId2.__wrap(ret5);
        }
        /**
        * Smallest writable register.
        * @returns {RegId}
        */
        static writable() {
          const ret5 = wasm$1.regid_writable();
          return RegId2.__wrap(ret5);
        }
        /**
        * Contains zero (0), for convenience.
        * @returns {RegId}
        */
        static zero() {
          const ret5 = wasm$1.regid_zero();
          return RegId2.__wrap(ret5);
        }
        /**
        * Construct a register ID from the given value.
        *
        * The given value will be masked to 6 bits.
        * @param {number} u
        */
        constructor(u) {
          const ret5 = wasm$1.regid_new_typescript(u);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * A const alternative to the `Into<u8>` implementation.
        * @returns {number}
        */
        to_u8() {
          const ptr = this.__destroy_into_raw();
          const ret5 = wasm$1.regid_to_u8(ptr);
          return ret5;
        }
      };
      var S256 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_s256_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} value
        * @param {Imm12} offset
        */
        constructor(addr, value, offset) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr1 = value.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SCWQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_scwq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} lenq
        */
        constructor(key_addr, status, lenq) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr2 = lenq.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SLL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sll_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SLLI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_slli_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SMO = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_smo_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} recipient_addr
        * @param {RegId} data_addr
        * @param {RegId} data_len
        * @param {RegId} coins
        */
        constructor(recipient_addr, data_addr, data_len, coins) {
          _assertClass(recipient_addr, RegId2);
          var ptr0 = recipient_addr.__destroy_into_raw();
          _assertClass(data_addr, RegId2);
          var ptr1 = data_addr.__destroy_into_raw();
          _assertClass(data_len, RegId2);
          var ptr2 = data_len.__destroy_into_raw();
          _assertClass(coins, RegId2);
          var ptr3 = coins.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SRL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srl_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SRLI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srli_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SRW = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srw_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} status
        * @param {RegId} key_addr
        */
        constructor(dst, status, key_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(key_addr, RegId2);
          var ptr2 = key_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SRWQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srwq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} status
        * @param {RegId} key_addr
        * @param {RegId} lenq
        */
        constructor(dst_addr, status, key_addr, lenq) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(key_addr, RegId2);
          var ptr2 = key_addr.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr3 = lenq.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SUB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sub_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SUBI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_subi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SW = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sw_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} value
        * @param {Imm12} offset
        */
        constructor(addr, value, offset) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr1 = value.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SWW = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sww_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} value
        */
        constructor(key_addr, status, value) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr2 = value.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SWWQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_swwq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} src_addr
        * @param {RegId} lenq
        */
        constructor(key_addr, status, src_addr, lenq) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr2 = src_addr.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr3 = lenq.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var TIME = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_time_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} heigth
        */
        constructor(dst, heigth) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(heigth, RegId2);
          var ptr1 = heigth.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var TR = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_tr_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} contract_id_addr
        * @param {RegId} amount
        * @param {RegId} asset_id_addr
        */
        constructor(contract_id_addr, amount, asset_id_addr) {
          _assertClass(contract_id_addr, RegId2);
          var ptr0 = contract_id_addr.__destroy_into_raw();
          _assertClass(amount, RegId2);
          var ptr1 = amount.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr2 = asset_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var TRO = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_tro_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} contract_id_addr
        * @param {RegId} output_index
        * @param {RegId} amount
        * @param {RegId} asset_id_addr
        */
        constructor(contract_id_addr, output_index, amount, asset_id_addr) {
          _assertClass(contract_id_addr, RegId2);
          var ptr0 = contract_id_addr.__destroy_into_raw();
          _assertClass(output_index, RegId2);
          var ptr1 = output_index.__destroy_into_raw();
          _assertClass(amount, RegId2);
          var ptr2 = amount.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr3 = asset_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WDAM = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdam_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} add_lhs
        * @param {RegId} add_rhs
        * @param {RegId} modulo
        */
        constructor(dst, add_lhs, add_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(add_lhs, RegId2);
          var ptr1 = add_lhs.__destroy_into_raw();
          _assertClass(add_rhs, RegId2);
          var ptr2 = add_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WDCM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDCM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdcm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct a `WDCM` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {CompareArgs} args
        * @returns {WDCM}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, CompareArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDCM.__wrap(ret5);
        }
      };
      var WDDV = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDDV.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wddv_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct a `WDDV` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {DivArgs} args
        * @returns {WDDV}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, DivArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDDV.__wrap(ret5);
        }
      };
      var WDMD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdmd_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WDML = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDML.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdml_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct a `WDML` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MulArgs} args
        * @returns {WDML}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MulArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDML.__wrap(ret5);
        }
      };
      var WDMM = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdmm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} modulo
        */
        constructor(dst, mul_lhs, mul_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WDOP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDOP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdop_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct a `WDOP` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MathArgs} args
        * @returns {WDOP}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MathArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDOP.__wrap(ret5);
        }
      };
      var WQAM = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqam_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} add_lhs
        * @param {RegId} add_rhs
        * @param {RegId} modulo
        */
        constructor(dst, add_lhs, add_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(add_lhs, RegId2);
          var ptr1 = add_lhs.__destroy_into_raw();
          _assertClass(add_rhs, RegId2);
          var ptr2 = add_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WQCM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQCM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqcm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct a `WQCM` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {CompareArgs} args
        * @returns {WQCM}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, CompareArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQCM.__wrap(ret5);
        }
      };
      var WQDV = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQDV.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqdv_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct a `WQDV` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {DivArgs} args
        * @returns {WQDV}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, DivArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQDV.__wrap(ret5);
        }
      };
      var WQMD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqmd_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WQML = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQML.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqml_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct a `WQML` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MulArgs} args
        * @returns {WQML}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MulArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQML.__wrap(ret5);
        }
      };
      var WQMM = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqmm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} modulo
        */
        constructor(dst, mul_lhs, mul_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WQOP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQOP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqop_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct a `WQOP` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MathArgs} args
        * @returns {WQOP}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MathArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQOP.__wrap(ret5);
        }
      };
      var XOR = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_xor_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var XORI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_xori_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      async function __wbg_load(module2, imports) {
        if (typeof Response === "function" && module2 instanceof Response) {
          if (typeof WebAssembly.instantiateStreaming === "function") {
            try {
              return await WebAssembly.instantiateStreaming(module2, imports);
            } catch (e) {
              if (module2.headers.get("Content-Type") != "application/wasm") {
                console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
              } else {
                throw e;
              }
            }
          }
          const bytes3 = await module2.arrayBuffer();
          return await WebAssembly.instantiate(bytes3, imports);
        } else {
          const instance = await WebAssembly.instantiate(module2, imports);
          if (instance instanceof WebAssembly.Instance) {
            return { instance, module: module2 };
          } else {
            return instance;
          }
        }
      }
      function __wbg_get_imports() {
        const imports = {};
        imports.wbg = {};
        imports.wbg.__wbindgen_throw = function(arg0, arg1) {
          throw new Error(getStringFromWasm0(arg0, arg1));
        };
        return imports;
      }
      function __wbg_finalize_init(instance, module2) {
        wasm$1 = instance.exports;
        __wbg_init.__wbindgen_wasm_module = module2;
        cachedInt32Memory0 = null;
        cachedUint8Memory0 = null;
        return wasm$1;
      }
      function initSync(module2) {
        if (wasm$1 !== void 0)
          return wasm$1;
        const imports = __wbg_get_imports();
        if (!(module2 instanceof WebAssembly.Module)) {
          module2 = new WebAssembly.Module(module2);
        }
        const instance = new WebAssembly.Instance(module2, imports);
        return __wbg_finalize_init(instance, module2);
      }
      async function __wbg_init(input) {
        if (wasm$1 !== void 0)
          return wasm$1;
        const imports = __wbg_get_imports();
        const { instance, module: module2 } = await __wbg_load(await input, imports);
        return __wbg_finalize_init(instance, module2);
      }
      function _loadWasmModule(sync2, filepath, src, imports) {
        function _instantiateOrCompile(source, imports2, stream2) {
          var instantiateFunc = stream2 ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
          var compileFunc = stream2 ? WebAssembly.compileStreaming : WebAssembly.compile;
          if (imports2) {
            return instantiateFunc(source, imports2);
          } else {
            return compileFunc(source);
          }
        }
        var buf = null;
        var isNode2 = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
        if (isNode2) {
          buf = Buffer.from(src, "base64");
        } else {
          var raw = globalThis.atob(src);
          var rawLength = raw.length;
          buf = new Uint8Array(new ArrayBuffer(rawLength));
          for (var i = 0; i < rawLength; i++) {
            buf[i] = raw.charCodeAt(i);
          }
        }
        if (sync2) {
          var mod2 = new WebAssembly.Module(buf);
          return imports ? new WebAssembly.Instance(mod2, imports) : mod2;
        } else {
          return _instantiateOrCompile(buf, imports, false);
        }
      }
      function wasm(imports) {
        return _loadWasmModule(1, null, "AGFzbQEAAAABTw1gA39/fwF/YAF/AX9gAn9/AX9gBH9/f38Bf2ACf38AYAABf2ABfwBgBX9/f39/AX9gA39/fwBgAABgAn5/AX9gBX9/f39/AGAEf39/fwACGAEDd2JnEF9fd2JpbmRnZW5fdGhyb3cABAOBAv8BAQYCBAECAgoDAwMDAwMDAwMDBgQDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAUDAwMDAgICAgICAwMDAwMDAwMDAwMDAwMDAwMDBAMBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICwAADAACAAICAgICAgICAgICAgIEAQEBAQEBAQEBAQEBAQEBAQQBAQEBBAUJAgEABAYEBAMFCQQGBAEEAQIFBQUFBQUFBQUFBQUFBQUFBQEBBAYBAQYIBAYBAQQCCAECBAQEBAECAQEEAQICAgIBBAkJAQEBAQQAAgIBAQUGAggCAwMCBwAHAAECBwcHBAUBcAEXFwUDAQARBgkBfwFBgIDAAAsH803BBQZtZW1vcnkCAA5fX3diZ19hZGRfZnJlZQDFARJhZGRfbmV3X3R5cGVzY3JpcHQAdAZhZGRfcmEAmgEGYWRkX3JiAIsBBmFkZF9yYwCMAQNhZGQAcQNhbmQAVQNkaXYAVgJlcQBXA2V4cABYAmd0AFkCbHQAWgRtbG9nAFsEbXJvbwBcBG1vZF8AXQVtb3ZlXwB6A211bABeA25vdAB7Am9yAF8Dc2xsAGADc3JsAGEDc3ViAGIDeG9yAGMEbWxkdgA6A3JldACPAQRyZXRkAHwTYWxvY19uZXdfdHlwZXNjcmlwdACcAQRhbG9jAJABA21jbAB9A21jcABkA21lcQA7E2Joc2hfbmV3X3R5cGVzY3JpcHQAhAEEYmhzaAB+BGJoZWkAkQEEYnVybgB/E2NhbGxfbmV3X3R5cGVzY3JpcHQATQdjYWxsX3JkAJsBBGNhbGwAPANjY3AAPQRjcm9vAIABBGNzaXoAgQECY2IAkgEDbGRjAGUDbG9nAD4EbG9nZAA/BG1pbnQAggEEcnZydACTAQRzY3dxAGYDc3J3AGcEc3J3cQBAA3N3dwBoBHN3d3EAQQJ0cgBpA3RybwBCBGVjazEAagRlY3IxAGsEZWQxOQBsBGsyNTYAbQRzMjU2AG4EdGltZQCDARNub29wX25ld190eXBlc2NyaXB0AKgBBG5vb3AAngEEZmxhZwCUAQNiYWwAbwNqbXAAlQEDam5lAHADc21vAEMTYWRkaV9uZXdfdHlwZXNjcmlwdAB3CmFkZGlfaW1tMTIAjgEEYWRkaQAbBGFuZGkAHARkaXZpAB0EZXhwaQAeBG1vZGkAHwRtdWxpACADb3JpACEEc2xsaQAiBHNybGkAIwRzdWJpACQEeG9yaQAlBGpuZWkAJgJsYgAnAmx3ACgCc2IAKQJzdwAqBG1jcGkAKwNndGYALARtY2xpADQRZ21fbmV3X3R5cGVzY3JpcHQAhQEIZ21faW1tMTgAiQECZ20ANQRtb3ZpADYEam56aQA3BGptcGYAOARqbXBiADkEam56ZgAtBGpuemIALgRqbmVmAAkEam5lYgAKAmppAE4TY2ZlaV9uZXdfdHlwZXNjcmlwdACNAQpjZmVpX2ltbTI0AIgBBGNmZWkATwRjZnNpAFADY2ZlAJYBA2NmcwCXAQRwc2hsAFEEcHNoaABSBHBvcGwAUwRwb3BoAFQEd2RjbQALBHdxY20ADAR3ZG9wAA0Ed3FvcAAOBHdkbWwADwR3cW1sABAEd2RkdgARBHdxZHYAEgR3ZG1kAEQEd3FtZABFBHdkYW0ARgR3cWFtAEcEd2RtbQBIBHdxbW0ASQRlY2FsAEoTYW5kaV9uZXdfdHlwZXNjcmlwdAB3E2RpdmlfbmV3X3R5cGVzY3JpcHQAdxNleHBpX25ld190eXBlc2NyaXB0AHcTbW9kaV9uZXdfdHlwZXNjcmlwdAB3E211bGlfbmV3X3R5cGVzY3JpcHQAdxJvcmlfbmV3X3R5cGVzY3JpcHQAdxNzbGxpX25ld190eXBlc2NyaXB0AHcTc3JsaV9uZXdfdHlwZXNjcmlwdAB3E3N1YmlfbmV3X3R5cGVzY3JpcHQAdxN4b3JpX25ld190eXBlc2NyaXB0AHcTam5laV9uZXdfdHlwZXNjcmlwdAB3EWxiX25ld190eXBlc2NyaXB0AHcRbHdfbmV3X3R5cGVzY3JpcHQAdxFzYl9uZXdfdHlwZXNjcmlwdAB3EXN3X25ld190eXBlc2NyaXB0AHcTbWNwaV9uZXdfdHlwZXNjcmlwdAB3Emd0Zl9uZXdfdHlwZXNjcmlwdAB3E2puemZfbmV3X3R5cGVzY3JpcHQAdxNqbnpiX25ld190eXBlc2NyaXB0AHcGYW5kX3JjAIwBBmRpdl9yYwCMAQVlcV9yYwCMAQZleHBfcmMAjAEFZ3RfcmMAjAEFbHRfcmMAjAEHbWxvZ19yYwCMAQdtcm9vX3JjAIwBBm1vZF9yYwCMAQZtdWxfcmMAjAEFb3JfcmMAjAEGc2xsX3JjAIwBBnNybF9yYwCMAQZzdWJfcmMAjAEGeG9yX3JjAIwBB21sZHZfcmMAjAEGbWNwX3JjAIwBBm1lcV9yYwCMAQdjYWxsX3JjAIwBBmNjcF9yYwCMAQZsZGNfcmMAjAEGbG9nX3JjAIwBB2xvZ2RfcmMAjAEHc2N3cV9yYwCMAQZzcndfcmMAjAEHc3J3cV9yYwCMAQZzd3dfcmMAjAEHc3d3cV9yYwCMAQV0cl9yYwCMAQZ0cm9fcmMAjAEHZWNrMV9yYwCMAQdlY3IxX3JjAIwBB2VkMTlfcmMAjAEHazI1Nl9yYwCMAQdzMjU2X3JjAIwBBmJhbF9yYwCMAQZqbmVfcmMAjAEGc21vX3JjAIwBB2puZWZfcmMAjAEHam5lYl9yYwCMAQd3ZGNtX3JjAIwBB3dxY21fcmMAjAEHd2RvcF9yYwCMAQd3cW9wX3JjAIwBB3dkbWxfcmMAjAEHd3FtbF9yYwCMAQd3ZGR2X3JjAIwBB3dxZHZfcmMAjAEHd2RtZF9yYwCMAQd3cW1kX3JjAIwBB3dkYW1fcmMAjAEHd3FhbV9yYwCMAQd3ZG1tX3JjAIwBB3dxbW1fcmMAjAEHZWNhbF9yYwCMARNtbGR2X25ld190eXBlc2NyaXB0AE0SbWVxX25ld190eXBlc2NyaXB0AE0SY2NwX25ld190eXBlc2NyaXB0AE0SbG9nX25ld190eXBlc2NyaXB0AE0TbG9nZF9uZXdfdHlwZXNjcmlwdABNE3Nyd3FfbmV3X3R5cGVzY3JpcHQATRNzd3dxX25ld190eXBlc2NyaXB0AE0SdHJvX25ld190eXBlc2NyaXB0AE0Sc21vX25ld190eXBlc2NyaXB0AE0Tam5lZl9uZXdfdHlwZXNjcmlwdABNE2puZWJfbmV3X3R5cGVzY3JpcHQATRN3ZGNtX25ld190eXBlc2NyaXB0AE0Td3FjbV9uZXdfdHlwZXNjcmlwdABNE3dkb3BfbmV3X3R5cGVzY3JpcHQATRN3cW9wX25ld190eXBlc2NyaXB0AE0Td2RtbF9uZXdfdHlwZXNjcmlwdABNE3dxbWxfbmV3X3R5cGVzY3JpcHQATRN3ZGR2X25ld190eXBlc2NyaXB0AE0Td3Fkdl9uZXdfdHlwZXNjcmlwdABNE3dkbWRfbmV3X3R5cGVzY3JpcHQATRN3cW1kX25ld190eXBlc2NyaXB0AE0Td2RhbV9uZXdfdHlwZXNjcmlwdABNE3dxYW1fbmV3X3R5cGVzY3JpcHQATRN3ZG1tX25ld190eXBlc2NyaXB0AE0Td3FtbV9uZXdfdHlwZXNjcmlwdABNE2VjYWxfbmV3X3R5cGVzY3JpcHQATQZhbmRfcmIAiwEGZGl2X3JiAIsBBWVxX3JiAIsBBmV4cF9yYgCLAQVndF9yYgCLAQVsdF9yYgCLAQdtbG9nX3JiAIsBB21yb29fcmIAiwEGbW9kX3JiAIsBB21vdmVfcmIAiwEGbXVsX3JiAIsBBm5vdF9yYgCLAQVvcl9yYgCLAQZzbGxfcmIAiwEGc3JsX3JiAIsBBnN1Yl9yYgCLAQZ4b3JfcmIAiwEHbWxkdl9yYgCLAQdyZXRkX3JiAIsBBm1jbF9yYgCLAQZtY3BfcmIAiwEGbWVxX3JiAIsBB2Joc2hfcmIAiwEHYnVybl9yYgCLAQdjYWxsX3JiAIsBBmNjcF9yYgCLAQdjcm9vX3JiAIsBB2NzaXpfcmIAiwEGbGRjX3JiAIsBBmxvZ19yYgCLAQdsb2dkX3JiAIsBB21pbnRfcmIAiwEHc2N3cV9yYgCLAQZzcndfcmIAiwEHc3J3cV9yYgCLAQZzd3dfcmIAiwEHc3d3cV9yYgCLAQV0cl9yYgCLAQZ0cm9fcmIAiwEHZWNrMV9yYgCLAQdlY3IxX3JiAIsBB2VkMTlfcmIAiwEHazI1Nl9yYgCLAQdzMjU2X3JiAIsBB3RpbWVfcmIAiwEGYmFsX3JiAIsBBmpuZV9yYgCLAQZzbW9fcmIAiwEHYWRkaV9yYgCLAQdhbmRpX3JiAIsBB2RpdmlfcmIAiwEHZXhwaV9yYgCLAQdtb2RpX3JiAIsBB211bGlfcmIAiwEGb3JpX3JiAIsBB3NsbGlfcmIAiwEHc3JsaV9yYgCLAQdzdWJpX3JiAIsBB3hvcmlfcmIAiwEHam5laV9yYgCLAQVsYl9yYgCLAQVsd19yYgCLAQVzYl9yYgCLAQVzd19yYgCLAQdtY3BpX3JiAIsBBmd0Zl9yYgCLAQdqbnpmX3JiAIsBB2puemJfcmIAiwEHam5lZl9yYgCLAQdqbmViX3JiAIsBB3dkY21fcmIAiwEHd3FjbV9yYgCLAQd3ZG9wX3JiAIsBB3dxb3BfcmIAiwEHd2RtbF9yYgCLAQd3cW1sX3JiAIsBB3dkZHZfcmIAiwEHd3Fkdl9yYgCLAQd3ZG1kX3JiAIsBB3dxbWRfcmIAiwEHd2RhbV9yYgCLAQd3cWFtX3JiAIsBB3dkbW1fcmIAiwEHd3FtbV9yYgCLAQdlY2FsX3JiAIsBEm5vdF9uZXdfdHlwZXNjcmlwdACEARNyZXRkX25ld190eXBlc2NyaXB0AIQBE21vdmVfbmV3X3R5cGVzY3JpcHQAhAESbWNsX25ld190eXBlc2NyaXB0AIQBE2J1cm5fbmV3X3R5cGVzY3JpcHQAhAETY3Jvb19uZXdfdHlwZXNjcmlwdACEARNjc2l6X25ld190eXBlc2NyaXB0AIQBE21pbnRfbmV3X3R5cGVzY3JpcHQAhAETdGltZV9uZXdfdHlwZXNjcmlwdACEAQptY2xpX2ltbTE4AIkBCm1vdmlfaW1tMTgAiQEKam56aV9pbW0xOACJAQpqbXBmX2ltbTE4AIkBCmptcGJfaW1tMTgAiQEIamlfaW1tMjQAiAEKY2ZzaV9pbW0yNACIAQpwc2hsX2ltbTI0AIgBCnBzaGhfaW1tMjQAiAEKcG9wbF9pbW0yNACIAQpwb3BoX2ltbTI0AIgBCmFuZGlfaW1tMTIAjgEKZGl2aV9pbW0xMgCOAQpleHBpX2ltbTEyAI4BCm1vZGlfaW1tMTIAjgEKbXVsaV9pbW0xMgCOAQlvcmlfaW1tMTIAjgEKc2xsaV9pbW0xMgCOAQpzcmxpX2ltbTEyAI4BCnN1YmlfaW1tMTIAjgEKeG9yaV9pbW0xMgCOAQpqbmVpX2ltbTEyAI4BCGxiX2ltbTEyAI4BCGx3X2ltbTEyAI4BCHNiX2ltbTEyAI4BCHN3X2ltbTEyAI4BCm1jcGlfaW1tMTIAjgEJZ3RmX2ltbTEyAI4BCmpuemZfaW1tMTIAjgEKam56Yl9pbW0xMgCOARNtY2xpX25ld190eXBlc2NyaXB0AIUBE21vdmlfbmV3X3R5cGVzY3JpcHQAhQETam56aV9uZXdfdHlwZXNjcmlwdACFARNqbXBmX25ld190eXBlc2NyaXB0AIUBE2ptcGJfbmV3X3R5cGVzY3JpcHQAhQEGYW5kX3JhAJoBBmRpdl9yYQCaAQVlcV9yYQCaAQZleHBfcmEAmgEFZ3RfcmEAmgEFbHRfcmEAmgEHbWxvZ19yYQCaAQdtcm9vX3JhAJoBBm1vZF9yYQCaAQdtb3ZlX3JhAJoBBm11bF9yYQCaAQZub3RfcmEAmgEFb3JfcmEAmgEGc2xsX3JhAJoBBnNybF9yYQCaAQZzdWJfcmEAmgEGeG9yX3JhAJoBB21sZHZfcmEAmgEGcmV0X3JhAJoBB3JldGRfcmEAmgEHYWxvY19yYQCaAQZtY2xfcmEAmgEGbWNwX3JhAJoBBm1lcV9yYQCaAQdiaHNoX3JhAJoBB2JoZWlfcmEAmgEHYnVybl9yYQCaAQdjYWxsX3JhAJoBBmNjcF9yYQCaAQdjcm9vX3JhAJoBB2NzaXpfcmEAmgEFY2JfcmEAmgEGbGRjX3JhAJoBBmxvZ19yYQCaAQdsb2dkX3JhAJoBB21pbnRfcmEAmgEHcnZydF9yYQCaAQdzY3dxX3JhAJoBBnNyd19yYQCaAQdzcndxX3JhAJoBBnN3d19yYQCaAQdzd3dxX3JhAJoBBXRyX3JhAJoBBnRyb19yYQCaAQdlY2sxX3JhAJoBB2VjcjFfcmEAmgEHZWQxOV9yYQCaAQdrMjU2X3JhAJoBB3MyNTZfcmEAmgEHdGltZV9yYQCaAQdmbGFnX3JhAJoBBmJhbF9yYQCaAQZqbXBfcmEAmgEGam5lX3JhAJoBBnNtb19yYQCaAQdhZGRpX3JhAJoBB2FuZGlfcmEAmgEHZGl2aV9yYQCaAQdleHBpX3JhAJoBB21vZGlfcmEAmgEHbXVsaV9yYQCaAQZvcmlfcmEAmgEHc2xsaV9yYQCaAQdzcmxpX3JhAJoBB3N1YmlfcmEAmgEHeG9yaV9yYQCaAQdqbmVpX3JhAJoBBWxiX3JhAJoBBWx3X3JhAJoBBXNiX3JhAJoBBXN3X3JhAJoBB21jcGlfcmEAmgEGZ3RmX3JhAJoBB21jbGlfcmEAmgEFZ21fcmEAmgEHbW92aV9yYQCaAQdqbnppX3JhAJoBB2ptcGZfcmEAmgEHam1wYl9yYQCaAQdqbnpmX3JhAJoBB2puemJfcmEAmgEHam5lZl9yYQCaAQdqbmViX3JhAJoBBmNmZV9yYQCaAQZjZnNfcmEAmgEHd2RjbV9yYQCaAQd3cWNtX3JhAJoBB3dkb3BfcmEAmgEHd3FvcF9yYQCaAQd3ZG1sX3JhAJoBB3dxbWxfcmEAmgEHd2Rkdl9yYQCaAQd3cWR2X3JhAJoBB3dkbWRfcmEAmgEHd3FtZF9yYQCaAQd3ZGFtX3JhAJoBB3dxYW1fcmEAmgEHd2RtbV9yYQCaAQd3cW1tX3JhAJoBB2VjYWxfcmEAmgESYW5kX25ld190eXBlc2NyaXB0AHQSZGl2X25ld190eXBlc2NyaXB0AHQRZXFfbmV3X3R5cGVzY3JpcHQAdBJleHBfbmV3X3R5cGVzY3JpcHQAdBFndF9uZXdfdHlwZXNjcmlwdAB0EWx0X25ld190eXBlc2NyaXB0AHQTbWxvZ19uZXdfdHlwZXNjcmlwdAB0E21yb29fbmV3X3R5cGVzY3JpcHQAdBJtb2RfbmV3X3R5cGVzY3JpcHQAdBJtdWxfbmV3X3R5cGVzY3JpcHQAdBFvcl9uZXdfdHlwZXNjcmlwdAB0EnNsbF9uZXdfdHlwZXNjcmlwdAB0EnNybF9uZXdfdHlwZXNjcmlwdAB0EnN1Yl9uZXdfdHlwZXNjcmlwdAB0Enhvcl9uZXdfdHlwZXNjcmlwdAB0Em1jcF9uZXdfdHlwZXNjcmlwdAB0EmxkY19uZXdfdHlwZXNjcmlwdAB0E3Njd3FfbmV3X3R5cGVzY3JpcHQAdBJzcndfbmV3X3R5cGVzY3JpcHQAdBJzd3dfbmV3X3R5cGVzY3JpcHQAdBF0cl9uZXdfdHlwZXNjcmlwdAB0E2VjazFfbmV3X3R5cGVzY3JpcHQAdBNlY3IxX25ld190eXBlc2NyaXB0AHQTZWQxOV9uZXdfdHlwZXNjcmlwdAB0E2syNTZfbmV3X3R5cGVzY3JpcHQAdBNzMjU2X25ld190eXBlc2NyaXB0AHQSYmFsX25ld190eXBlc2NyaXB0AHQSam5lX25ld190eXBlc2NyaXB0AHQHbWxkdl9yZACbAQZtZXFfcmQAmwEGY2NwX3JkAJsBBmxvZ19yZACbAQdsb2dkX3JkAJsBB3Nyd3FfcmQAmwEHc3d3cV9yZACbAQZ0cm9fcmQAmwEGc21vX3JkAJsBCmpuZWZfaW1tMDYAmwEKam5lYl9pbW0wNgCbAQp3ZGNtX2ltbTA2AJsBCndxY21faW1tMDYAmwEKd2RvcF9pbW0wNgCbAQp3cW9wX2ltbTA2AJsBCndkbWxfaW1tMDYAmwEKd3FtbF9pbW0wNgCbAQp3ZGR2X2ltbTA2AJsBCndxZHZfaW1tMDYAmwEHd2RtZF9yZACbAQd3cW1kX3JkAJsBB3dkYW1fcmQAmwEHd3FhbV9yZACbAQd3ZG1tX3JkAJsBB3dxbW1fcmQAmwEHZWNhbF9yZACbARFqaV9uZXdfdHlwZXNjcmlwdACNARNjZnNpX25ld190eXBlc2NyaXB0AI0BE3BzaGxfbmV3X3R5cGVzY3JpcHQAjQETcHNoaF9uZXdfdHlwZXNjcmlwdACNARNwb3BsX25ld190eXBlc2NyaXB0AI0BE3BvcGhfbmV3X3R5cGVzY3JpcHQAjQEOX193YmdfYW5kX2ZyZWUAxQEOX193YmdfZGl2X2ZyZWUAxQENX193YmdfZXFfZnJlZQDFAQ5fX3diZ19leHBfZnJlZQDFAQ1fX3diZ19ndF9mcmVlAMUBDV9fd2JnX2x0X2ZyZWUAxQEPX193YmdfbWxvZ19mcmVlAMUBD19fd2JnX21yb29fZnJlZQDFAQ5fX3diZ19tb2RfZnJlZQDFAQ9fX3diZ19tb3ZlX2ZyZWUAxQEOX193YmdfbXVsX2ZyZWUAxQEOX193Ymdfbm90X2ZyZWUAxQENX193Ymdfb3JfZnJlZQDFAQ5fX3diZ19zbGxfZnJlZQDFAQ5fX3diZ19zcmxfZnJlZQDFAQ5fX3diZ19zdWJfZnJlZQDFAQ5fX3diZ194b3JfZnJlZQDFAQ9fX3diZ19tbGR2X2ZyZWUAxQEOX193YmdfcmV0X2ZyZWUAxQEPX193YmdfcmV0ZF9mcmVlAMUBD19fd2JnX2Fsb2NfZnJlZQDFAQ5fX3diZ19tY2xfZnJlZQDFAQ5fX3diZ19tY3BfZnJlZQDFAQ5fX3diZ19tZXFfZnJlZQDFAQ9fX3diZ19iaHNoX2ZyZWUAxQEPX193YmdfYmhlaV9mcmVlAMUBD19fd2JnX2J1cm5fZnJlZQDFAQ9fX3diZ19jYWxsX2ZyZWUAxQEOX193YmdfY2NwX2ZyZWUAxQEPX193YmdfY3Jvb19mcmVlAMUBD19fd2JnX2NzaXpfZnJlZQDFAQ1fX3diZ19jYl9mcmVlAMUBDl9fd2JnX2xkY19mcmVlAMUBDl9fd2JnX2xvZ19mcmVlAMUBD19fd2JnX2xvZ2RfZnJlZQDFAQ9fX3diZ19taW50X2ZyZWUAxQEPX193YmdfcnZydF9mcmVlAMUBD19fd2JnX3Njd3FfZnJlZQDFAQ5fX3diZ19zcndfZnJlZQDFAQ9fX3diZ19zcndxX2ZyZWUAxQEOX193Ymdfc3d3X2ZyZWUAxQEPX193Ymdfc3d3cV9mcmVlAMUBDV9fd2JnX3RyX2ZyZWUAxQEOX193YmdfdHJvX2ZyZWUAxQEPX193YmdfZWNrMV9mcmVlAMUBD19fd2JnX2VjcjFfZnJlZQDFAQ9fX3diZ19lZDE5X2ZyZWUAxQEPX193YmdfazI1Nl9mcmVlAMUBD19fd2JnX3MyNTZfZnJlZQDFAQ9fX3diZ190aW1lX2ZyZWUAxQEPX193Ymdfbm9vcF9mcmVlAMUBD19fd2JnX2ZsYWdfZnJlZQDFAQ5fX3diZ19iYWxfZnJlZQDFAQ5fX3diZ19qbXBfZnJlZQDFAQ5fX3diZ19qbmVfZnJlZQDFAQ5fX3diZ19zbW9fZnJlZQDFAQ9fX3diZ19hZGRpX2ZyZWUAxQEPX193YmdfYW5kaV9mcmVlAMUBD19fd2JnX2RpdmlfZnJlZQDFAQ9fX3diZ19leHBpX2ZyZWUAxQEPX193YmdfbW9kaV9mcmVlAMUBD19fd2JnX211bGlfZnJlZQDFAQ5fX3diZ19vcmlfZnJlZQDFAQ9fX3diZ19zbGxpX2ZyZWUAxQEPX193Ymdfc3JsaV9mcmVlAMUBD19fd2JnX3N1YmlfZnJlZQDFAQ9fX3diZ194b3JpX2ZyZWUAxQEPX193Ymdfam5laV9mcmVlAMUBDV9fd2JnX2xiX2ZyZWUAxQENX193YmdfbHdfZnJlZQDFAQ1fX3diZ19zYl9mcmVlAMUBDV9fd2JnX3N3X2ZyZWUAxQEPX193YmdfbWNwaV9mcmVlAMUBDl9fd2JnX2d0Zl9mcmVlAMUBD19fd2JnX21jbGlfZnJlZQDFAQ1fX3diZ19nbV9mcmVlAMUBD19fd2JnX21vdmlfZnJlZQDFAQ9fX3diZ19qbnppX2ZyZWUAxQEPX193Ymdfam1wZl9mcmVlAMUBD19fd2JnX2ptcGJfZnJlZQDFAQ9fX3diZ19qbnpmX2ZyZWUAxQEPX193Ymdfam56Yl9mcmVlAMUBD19fd2JnX2puZWZfZnJlZQDFAQ9fX3diZ19qbmViX2ZyZWUAxQENX193YmdfamlfZnJlZQDFAQ9fX3diZ19jZmVpX2ZyZWUAxQEPX193YmdfY2ZzaV9mcmVlAMUBDl9fd2JnX2NmZV9mcmVlAMUBDl9fd2JnX2Nmc19mcmVlAMUBD19fd2JnX3BzaGxfZnJlZQDFAQ9fX3diZ19wc2hoX2ZyZWUAxQEPX193YmdfcG9wbF9mcmVlAMUBD19fd2JnX3BvcGhfZnJlZQDFAQ9fX3diZ193ZGNtX2ZyZWUAxQEPX193Ymdfd3FjbV9mcmVlAMUBD19fd2JnX3dkb3BfZnJlZQDFAQ9fX3diZ193cW9wX2ZyZWUAxQEPX193Ymdfd2RtbF9mcmVlAMUBD19fd2JnX3dxbWxfZnJlZQDFAQ9fX3diZ193ZGR2X2ZyZWUAxQEPX193Ymdfd3Fkdl9mcmVlAMUBD19fd2JnX3dkbWRfZnJlZQDFAQ9fX3diZ193cW1kX2ZyZWUAxQEPX193Ymdfd2RhbV9mcmVlAMUBD19fd2JnX3dxYW1fZnJlZQDFAQ9fX3diZ193ZG1tX2ZyZWUAxQEPX193Ymdfd3FtbV9mcmVlAMUBD19fd2JnX2VjYWxfZnJlZQDFARJyZXRfbmV3X3R5cGVzY3JpcHQAnAETYmhlaV9uZXdfdHlwZXNjcmlwdACcARFjYl9uZXdfdHlwZXNjcmlwdACcARNydnJ0X25ld190eXBlc2NyaXB0AJwBE2ZsYWdfbmV3X3R5cGVzY3JpcHQAnAESam1wX25ld190eXBlc2NyaXB0AJwBEmNmZV9uZXdfdHlwZXNjcmlwdACcARJjZnNfbmV3X3R5cGVzY3JpcHQAnAEWX193YmdfY29tcGFyZWFyZ3NfZnJlZQDFARpfX3diZ19nZXRfY29tcGFyZWFyZ3NfbW9kZQDCARpfX3diZ19zZXRfY29tcGFyZWFyZ3NfbW9kZQClASJfX3diZ19nZXRfY29tcGFyZWFyZ3NfaW5kaXJlY3RfcmhzAMYBIl9fd2JnX3NldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMArgESY29tcGFyZWFyZ3NfdG9faW1tAJkBFGNvbXBhcmVhcmdzX2Zyb21faW1tAIoBFV9fd2JnX2dldF9tYXRoYXJnc19vcADCARVfX3diZ19zZXRfbWF0aGFyZ3Nfb3AApgEeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfcmhzAMIBHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X3JocwCsARtfX3diZ19wYW5pY2luc3RydWN0aW9uX2ZyZWUAxQEhcGFuaWNpbnN0cnVjdGlvbl9lcnJvcl90eXBlc2NyaXB0AKABF3BhbmljaW5zdHJ1Y3Rpb25fcmVhc29uAMMBHHBhbmljaW5zdHJ1Y3Rpb25faW5zdHJ1Y3Rpb24AxwEfX193Ymdfc2V0X21hdGhhcmdzX2luZGlyZWN0X3JocwCuAR5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9saHMArgEeX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAK4BH19fd2JnX2dldF9tYXRoYXJnc19pbmRpcmVjdF9yaHMAxgEeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfbGhzAMYBHl9fd2JnX2dldF9kaXZhcmdzX2luZGlyZWN0X3JocwDGARNfX3diZ19tYXRoYXJnc19mcmVlAMUBEl9fd2JnX211bGFyZ3NfZnJlZQDFARJfX3diZ19kaXZhcmdzX2ZyZWUAxQEQX193YmdfaW1tMDZfZnJlZQDFARFyZWdpZF9uZXdfY2hlY2tlZAChAQlyZWdpZF9iYWwAsQEKcmVnaWRfY2dhcwCyAQlyZWdpZF9lcnIAswEKcmVnaWRfZmxhZwC0AQhyZWdpZF9mcAC1AQpyZWdpZF9nZ2FzALYBCHJlZ2lkX2hwALcBCHJlZ2lkX2lzALgBCHJlZ2lkX29mALkBCXJlZ2lkX29uZQC6AQhyZWdpZF9wYwC7AQlyZWdpZF9yZXQAvAEKcmVnaWRfcmV0bAC9AQhyZWdpZF9zcAC+AQlyZWdpZF9zcHAAvwEOcmVnaWRfd3JpdGFibGUAwAEKcmVnaWRfemVybwDBARRyZWdpZF9uZXdfdHlwZXNjcmlwdACtAQtyZWdpZF90b191OACvARBfX3diZ19yZWdpZF9mcmVlAMUBEF9fd2JnX2ltbTEyX2ZyZWUAxQEQX193YmdfaW1tMThfZnJlZQDFARBfX3diZ19pbW0yNF9mcmVlAMUBDGdtX2Zyb21fYXJncwCGAQ1ndGZfZnJvbV9hcmdzAHkHZ21fYXJncwB4CGd0Zl9hcmdzAHUOd2RjbV9mcm9tX2FyZ3MAMw53ZG9wX2Zyb21fYXJncwAzDndkbWxfZnJvbV9hcmdzADIOd2Rkdl9mcm9tX2FyZ3MASwl3ZGNtX2FyZ3MAFwl3cWNtX2FyZ3MAGAl3ZG9wX2FyZ3MAGQl3cW9wX2FyZ3MAGgl3ZG1sX2FyZ3MAFQl3cW1sX2FyZ3MAFgl3ZGR2X2FyZ3MAMAl3cWR2X2FyZ3MAMRZfX3diZ19pbnN0cnVjdGlvbl9mcmVlAKsBFGluc3RydWN0aW9uX3RvX2J5dGVzAJgBEGluc3RydWN0aW9uX3NpemUA7wEOd3FtbF9mcm9tX2FyZ3MAMg53cWNtX2Zyb21fYXJncwAzDndxb3BfZnJvbV9hcmdzADMOd3Fkdl9mcm9tX2FyZ3MASx9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAOEBD19fd2JpbmRnZW5fZnJlZQDQAQkwAQBBAQsW4AHeAd8BnQHwAaIBB7ABywHTAdQBowHWAcgBTIcB8AHVAd0B2AHwAdUBCvS+Af8B+yECD38BfiMAQRBrIgskAAJAAkACQAJAAkAgAEH1AU8EQEEIQQgQzwEhBkEUQQgQzwEhBUEQQQgQzwEhAUEAQRBBCBDPAUECdGsiAkGAgHwgASAFIAZqamtBd3FBA2siASABIAJLGyAATQ0FIABBBGpBCBDPASEEQZSRwAAoAgBFDQRBACAEayEDAn9BACAEQYACSQ0AGkEfIARB////B0sNABogBEEGIARBCHZnIgBrdkEBcSAAQQF0a0E+agsiBkECdEH4jcAAaigCACIBRQRAQQAhAEEAIQUMAgsgBCAGEM0BdCEHQQAhAEEAIQUDQAJAIAEQ5QEiAiAESQ0AIAIgBGsiAiADTw0AIAEhBSACIgMNAEEAIQMgASEADAQLIAFBFGooAgAiAiAAIAIgASAHQR12QQRxakEQaigCACIBRxsgACACGyEAIAdBAXQhByABDQALDAELQRAgAEEEakEQQQgQzwFBBWsgAEsbQQgQzwEhBEGQkcAAKAIAIgEgBEEDdiIAdiICQQNxBEACQCACQX9zQQFxIABqIgNBA3QiAEGQj8AAaigCACIFQQhqKAIAIgIgAEGIj8AAaiIARwRAIAIgADYCDCAAIAI2AggMAQtBkJHAACABQX4gA3dxNgIACyAFIANBA3QQygEgBRDtASEDDAULIARBmJHAACgCAE0NAwJAAkACQAJAAkACQCACRQRAQZSRwAAoAgAiAEUNCiAAENkBaEECdEH4jcAAaigCACIBEOUBIARrIQMgARDMASIABEADQCAAEOUBIARrIgIgAyACIANJIgIbIQMgACABIAIbIQEgABDMASIADQALCyABIAQQ6wEhBSABEBNBEEEIEM8BIANLDQIgASAEENsBIAUgAxDOAUGYkcAAKAIAIgANAQwFCwJAQQEgAEEfcSIAdBDRASACIAB0cRDZAWgiAkEDdCIAQZCPwABqKAIAIgNBCGooAgAiASAAQYiPwABqIgBHBEAgASAANgIMIAAgATYCCAwBC0GQkcAAQZCRwAAoAgBBfiACd3E2AgALIAMgBBDbASADIAQQ6wEiBSACQQN0IARrIgIQzgFBmJHAACgCACIADQIMAwsgAEF4cUGIj8AAaiEHQaCRwAAoAgAhBgJ/QZCRwAAoAgAiAkEBIABBA3Z0IgBxBEAgBygCCAwBC0GQkcAAIAAgAnI2AgAgBwshACAHIAY2AgggACAGNgIMIAYgBzYCDCAGIAA2AggMAwsgASADIARqEMoBDAMLIABBeHFBiI/AAGohB0GgkcAAKAIAIQYCf0GQkcAAKAIAIgFBASAAQQN2dCIAcQRAIAcoAggMAQtBkJHAACAAIAFyNgIAIAcLIQAgByAGNgIIIAAgBjYCDCAGIAc2AgwgBiAANgIIC0GgkcAAIAU2AgBBmJHAACACNgIAIAMQ7QEhAwwGC0GgkcAAIAU2AgBBmJHAACADNgIACyABEO0BIgNFDQMMBAsgACAFckUEQEEAIQVBASAGdBDRAUGUkcAAKAIAcSIARQ0DIAAQ2QFoQQJ0QfiNwABqKAIAIQALIABFDQELA0AgACAFIAAQ5QEiASAETyABIARrIgIgA0lxIgEbIQUgAiADIAEbIQMgABDMASIADQALCyAFRQ0AIARBmJHAACgCACIATSADIAAgBGtPcQ0AIAUgBBDrASEGIAUQEwJAQRBBCBDPASADTQRAIAUgBBDbASAGIAMQzgEgA0GAAk8EQCAGIAMQFAwCCyADQXhxQYiPwABqIQICf0GQkcAAKAIAIgFBASADQQN2dCIAcQRAIAIoAggMAQtBkJHAACAAIAFyNgIAIAILIQAgAiAGNgIIIAAgBjYCDCAGIAI2AgwgBiAANgIIDAELIAUgAyAEahDKAQsgBRDtASIDDQELAkACQAJAAkACQAJAAkAgBEGYkcAAKAIAIgBLBEAgBEGckcAAKAIAIgBPBEBBCEEIEM8BIARqQRRBCBDPAWpBEEEIEM8BakGAgAQQzwEiAEEQdkAAIQIgC0EEaiIBQQA2AgggAUEAIABBgIB8cSACQX9GIgAbNgIEIAFBACACQRB0IAAbNgIAIAsoAgQiCEUEQEEAIQMMCgsgCygCDCEMQaiRwAAgCygCCCIKQaiRwAAoAgBqIgE2AgBBrJHAAEGskcAAKAIAIgAgASAAIAFLGzYCAAJAAkBBpJHAACgCAARAQfiOwAAhAANAIAAQ3AEgCEYNAiAAKAIIIgANAAsMAgtBtJHAACgCACIARSAAIAhLcg0EDAkLIAAQ5wENACAAEOgBIAxHDQAgACgCACICQaSRwAAoAgAiAU0EfyACIAAoAgRqIAFLBUEACw0EC0G0kcAAQbSRwAAoAgAiACAIIAAgCEkbNgIAIAggCmohAUH4jsAAIQACQAJAA0AgASAAKAIARwRAIAAoAggiAA0BDAILCyAAEOcBDQAgABDoASAMRg0BC0GkkcAAKAIAIQlB+I7AACEAAkADQCAJIAAoAgBPBEAgABDcASAJSw0CCyAAKAIIIgANAAtBACEACyAJIAAQ3AEiBkEUQQgQzwEiD2tBF2siARDtASIAQQgQzwEgAGsgAWoiACAAQRBBCBDPASAJakkbIg0Q7QEhDiANIA8Q6wEhAEEIQQgQzwEhA0EUQQgQzwEhBUEQQQgQzwEhAkGkkcAAIAggCBDtASIBQQgQzwEgAWsiARDrASIHNgIAQZyRwAAgCkEIaiACIAMgBWpqIAFqayIDNgIAIAcgA0EBcjYCBEEIQQgQzwEhBUEUQQgQzwEhAkEQQQgQzwEhASAHIAMQ6wEgASACIAVBCGtqajYCBEGwkcAAQYCAgAE2AgAgDSAPENsBQfiOwAApAgAhECAOQQhqQYCPwAApAgA3AgAgDiAQNwIAQYSPwAAgDDYCAEH8jsAAIAo2AgBB+I7AACAINgIAQYCPwAAgDjYCAANAIABBBBDrASAAQQc2AgQiAEEEaiAGSQ0ACyAJIA1GDQkgCSANIAlrIgAgCSAAEOsBEMkBIABBgAJPBEAgCSAAEBQMCgsgAEF4cUGIj8AAaiECAn9BkJHAACgCACIBQQEgAEEDdnQiAHEEQCACKAIIDAELQZCRwAAgACABcjYCACACCyEAIAIgCTYCCCAAIAk2AgwgCSACNgIMIAkgADYCCAwJCyAAKAIAIQMgACAINgIAIAAgACgCBCAKajYCBCAIEO0BIgVBCBDPASECIAMQ7QEiAUEIEM8BIQAgCCACIAVraiIGIAQQ6wEhByAGIAQQ2wEgAyAAIAFraiIAIAQgBmprIQRBpJHAACgCACAARwRAIABBoJHAACgCAEYNBSAAKAIEQQNxQQFHDQcCQCAAEOUBIgVBgAJPBEAgABATDAELIABBDGooAgAiAiAAQQhqKAIAIgFHBEAgASACNgIMIAIgATYCCAwBC0GQkcAAQZCRwAAoAgBBfiAFQQN2d3E2AgALIAQgBWohBCAAIAUQ6wEhAAwHC0GkkcAAIAc2AgBBnJHAAEGckcAAKAIAIARqIgA2AgAgByAAQQFyNgIEIAYQ7QEhAwwJC0GckcAAIAAgBGsiATYCAEGkkcAAQaSRwAAoAgAiAiAEEOsBIgA2AgAgACABQQFyNgIEIAIgBBDbASACEO0BIQMMCAtBoJHAACgCACECQRBBCBDPASAAIARrIgFLDQMgAiAEEOsBIQBBmJHAACABNgIAQaCRwAAgADYCACAAIAEQzgEgAiAEENsBIAIQ7QEhAwwHC0G0kcAAIAg2AgAMBAsgACAAKAIEIApqNgIEQZyRwAAoAgAgCmohAUGkkcAAKAIAIgAgABDtASIAQQgQzwEgAGsiABDrASEDQZyRwAAgASAAayIFNgIAQaSRwAAgAzYCACADIAVBAXI2AgRBCEEIEM8BIQJBFEEIEM8BIQFBEEEIEM8BIQAgAyAFEOsBIAAgASACQQhramo2AgRBsJHAAEGAgIABNgIADAQLQaCRwAAgBzYCAEGYkcAAQZiRwAAoAgAgBGoiADYCACAHIAAQzgEgBhDtASEDDAQLQaCRwABBADYCAEGYkcAAKAIAIQBBmJHAAEEANgIAIAIgABDKASACEO0BIQMMAwsgByAEIAAQyQEgBEGAAk8EQCAHIAQQFCAGEO0BIQMMAwsgBEF4cUGIj8AAaiECAn9BkJHAACgCACIBQQEgBEEDdnQiAHEEQCACKAIIDAELQZCRwAAgACABcjYCACACCyEAIAIgBzYCCCAAIAc2AgwgByACNgIMIAcgADYCCCAGEO0BIQMMAgtBuJHAAEH/HzYCAEGEj8AAIAw2AgBB/I7AACAKNgIAQfiOwAAgCDYCAEGUj8AAQYiPwAA2AgBBnI/AAEGQj8AANgIAQZCPwABBiI/AADYCAEGkj8AAQZiPwAA2AgBBmI/AAEGQj8AANgIAQayPwABBoI/AADYCAEGgj8AAQZiPwAA2AgBBtI/AAEGoj8AANgIAQaiPwABBoI/AADYCAEG8j8AAQbCPwAA2AgBBsI/AAEGoj8AANgIAQcSPwABBuI/AADYCAEG4j8AAQbCPwAA2AgBBzI/AAEHAj8AANgIAQcCPwABBuI/AADYCAEHUj8AAQciPwAA2AgBByI/AAEHAj8AANgIAQdCPwABByI/AADYCAEHcj8AAQdCPwAA2AgBB2I/AAEHQj8AANgIAQeSPwABB2I/AADYCAEHgj8AAQdiPwAA2AgBB7I/AAEHgj8AANgIAQeiPwABB4I/AADYCAEH0j8AAQeiPwAA2AgBB8I/AAEHoj8AANgIAQfyPwABB8I/AADYCAEH4j8AAQfCPwAA2AgBBhJDAAEH4j8AANgIAQYCQwABB+I/AADYCAEGMkMAAQYCQwAA2AgBBiJDAAEGAkMAANgIAQZSQwABBiJDAADYCAEGckMAAQZCQwAA2AgBBkJDAAEGIkMAANgIAQaSQwABBmJDAADYCAEGYkMAAQZCQwAA2AgBBrJDAAEGgkMAANgIAQaCQwABBmJDAADYCAEG0kMAAQaiQwAA2AgBBqJDAAEGgkMAANgIAQbyQwABBsJDAADYCAEGwkMAAQaiQwAA2AgBBxJDAAEG4kMAANgIAQbiQwABBsJDAADYCAEHMkMAAQcCQwAA2AgBBwJDAAEG4kMAANgIAQdSQwABByJDAADYCAEHIkMAAQcCQwAA2AgBB3JDAAEHQkMAANgIAQdCQwABByJDAADYCAEHkkMAAQdiQwAA2AgBB2JDAAEHQkMAANgIAQeyQwABB4JDAADYCAEHgkMAAQdiQwAA2AgBB9JDAAEHokMAANgIAQeiQwABB4JDAADYCAEH8kMAAQfCQwAA2AgBB8JDAAEHokMAANgIAQYSRwABB+JDAADYCAEH4kMAAQfCQwAA2AgBBjJHAAEGAkcAANgIAQYCRwABB+JDAADYCAEGIkcAAQYCRwAA2AgBBCEEIEM8BIQVBFEEIEM8BIQJBEEEIEM8BIQFBpJHAACAIIAgQ7QEiAEEIEM8BIABrIgAQ6wEiAzYCAEGckcAAIApBCGogASACIAVqaiAAamsiBTYCACADIAVBAXI2AgRBCEEIEM8BIQJBFEEIEM8BIQFBEEEIEM8BIQAgAyAFEOsBIAAgASACQQhramo2AgRBsJHAAEGAgIABNgIAC0EAIQNBnJHAACgCACIAIARNDQBBnJHAACAAIARrIgE2AgBBpJHAAEGkkcAAKAIAIgIgBBDrASIANgIAIAAgAUEBcjYCBCACIAQQ2wEgAhDtASEDCyALQRBqJAAgAwumBwEFfyAAEO4BIgAgABDlASIBEOsBIQICQAJAIAAQ5gENACAAKAIAIQMgABDaAUUEQCABIANqIQEgACADEOwBIgBBoJHAACgCAEYEQCACKAIEQQNxQQNHDQJBmJHAACABNgIAIAAgASACEMkBDwsgA0GAAk8EQCAAEBMMAgsgAEEMaigCACIEIABBCGooAgAiBUcEQCAFIAQ2AgwgBCAFNgIIDAILQZCRwABBkJHAACgCAEF+IANBA3Z3cTYCAAwBCyABIANqQRBqIQAMAQsCQCACENcBBEAgACABIAIQyQEMAQsCQAJAAkBBpJHAACgCACACRwRAIAJBoJHAACgCAEYNASACEOUBIgMgAWohAQJAIANBgAJPBEAgAhATDAELIAJBDGooAgAiBCACQQhqKAIAIgJHBEAgAiAENgIMIAQgAjYCCAwBC0GQkcAAQZCRwAAoAgBBfiADQQN2d3E2AgALIAAgARDOASAAQaCRwAAoAgBHDQRBmJHAACABNgIADwtBpJHAACAANgIAQZyRwABBnJHAACgCACABaiICNgIAIAAgAkEBcjYCBCAAQaCRwAAoAgBGDQEMAgtBoJHAACAANgIAQZiRwABBmJHAACgCACABaiICNgIAIAAgAhDOAQ8LQZiRwABBADYCAEGgkcAAQQA2AgALIAJBsJHAACgCAE0NAUEIQQgQzwEhAEEUQQgQzwEhAkEQQQgQzwEhA0EAQRBBCBDPAUECdGsiAUGAgHwgAyAAIAJqamtBd3FBA2siACAAIAFLG0UNAUGkkcAAKAIARQ0BQQhBCBDPASEAQRRBCBDPASECQRBBCBDPASEBQQAhAwJAQZyRwAAoAgAiBCABIAIgAEEIa2pqIgBNDQAgBCAAa0H//wNqQYCAfHEiBEGAgARrIQJBpJHAACgCACEBQfiOwAAhAAJAA0AgASAAKAIATwRAIAAQ3AEgAUsNAgsgACgCCCIADQALQQAhAAsgABDnAQ0AIAAoAgwaDAALEC9BACADa0cNAUGckcAAKAIAQbCRwAAoAgBNDQFBsJHAAEF/NgIADwsgAUGAAk8EQCAAIAEQFEG4kcAAQbiRwAAoAgBBAWsiADYCACAADQEQLxoPCyABQXhxQYiPwABqIQICf0GQkcAAKAIAIgNBASABQQN2dCIBcQRAIAIoAggMAQtBkJHAACABIANyNgIAIAILIQMgAiAANgIIIAMgADYCDCAAIAI2AgwgACADNgIICwuGBQELfyMAQTBrIgIkACACQSRqQbCHwAA2AgAgAkEDOgAsIAJBIDYCHCACQQA2AiggAiAANgIgIAJBADYCFCACQQA2AgwCfwJAAkAgASgCECIKRQRAIAFBDGooAgAiAEUNASABKAIIIQMgAEEDdCEFIABBAWtB/////wFxQQFqIQcgASgCACEAA0AgAEEEaigCACIEBEAgAigCICAAKAIAIAQgAigCJCgCDBEAAA0ECyADKAIAIAJBDGogA0EEaigCABECAA0DIANBCGohAyAAQQhqIQAgBUEIayIFDQALDAELIAFBFGooAgAiAEUNACAAQQV0IQsgAEEBa0H///8/cUEBaiEHIAEoAgghCCABKAIAIQADQCAAQQRqKAIAIgMEQCACKAIgIAAoAgAgAyACKAIkKAIMEQAADQMLIAIgBSAKaiIDQRBqKAIANgIcIAIgA0Ecai0AADoALCACIANBGGooAgA2AiggA0EMaigCACEGQQAhCUEAIQQCQAJAAkAgA0EIaigCAEEBaw4CAAIBCyAGQQN0IAhqIgwoAgRBE0cNASAMKAIAKAIAIQYLQQEhBAsgAiAGNgIQIAIgBDYCDCADQQRqKAIAIQQCQAJAAkAgAygCAEEBaw4CAAIBCyAEQQN0IAhqIgYoAgRBE0cNASAGKAIAKAIAIQQLQQEhCQsgAiAENgIYIAIgCTYCFCAIIANBFGooAgBBA3RqIgMoAgAgAkEMaiADKAIEEQIADQIgAEEIaiEAIAsgBUEgaiIFRw0ACwsgASgCBCAHSwRAIAIoAiAgASgCACAHQQN0aiIAKAIAIAAoAgQgAigCJCgCDBEAAA0BC0EADAELQQELIAJBMGokAAvXBAEEfyAAIAEQ6wEhAgJAAkACQCAAEOYBDQAgACgCACEDIAAQ2gFFBEAgASADaiEBIAAgAxDsASIAQaCRwAAoAgBGBEAgAigCBEEDcUEDRw0CQZiRwAAgATYCACAAIAEgAhDJAQ8LIANBgAJPBEAgABATDAILIABBDGooAgAiBCAAQQhqKAIAIgVHBEAgBSAENgIMIAQgBTYCCAwCC0GQkcAAQZCRwAAoAgBBfiADQQN2d3E2AgAMAQsgASADakEQaiEADAELIAIQ1wEEQCAAIAEgAhDJAQwCCwJAQaSRwAAoAgAgAkcEQCACQaCRwAAoAgBGDQEgAhDlASIDIAFqIQECQCADQYACTwRAIAIQEwwBCyACQQxqKAIAIgQgAkEIaigCACICRwRAIAIgBDYCDCAEIAI2AggMAQtBkJHAAEGQkcAAKAIAQX4gA0EDdndxNgIACyAAIAEQzgEgAEGgkcAAKAIARw0DQZiRwAAgATYCAAwCC0GkkcAAIAA2AgBBnJHAAEGckcAAKAIAIAFqIgE2AgAgACABQQFyNgIEIABBoJHAACgCAEcNAUGYkcAAQQA2AgBBoJHAAEEANgIADwtBoJHAACAANgIAQZiRwABBmJHAACgCACABaiIBNgIAIAAgARDOAQ8LDwsgAUGAAk8EQCAAIAEQFA8LIAFBeHFBiI/AAGohAgJ/QZCRwAAoAgAiA0EBIAFBA3Z0IgFxBEAgAigCCAwBC0GQkcAAIAEgA3I2AgAgAgshASACIAA2AgggASAANgIMIAAgAjYCDCAAIAE2AggLqgcBAX8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQf8FTARAAkAgAEGAAmsOzAIODxAREhMUFRYXGEpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKGRobHB0eHyAhIiMkJSZKSkpKSkpKSkpKSkpKSkpKSkonKCkqKyxKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKSi0uLzAxMjM0NTY3OAALQQEhASAAQQFrDg1IAQIDBAUGBwgJCgsMSQsCQCAAQYAGaw4JODk6Ozw9Pj9AAAsCQCAAQYAKaw4FQ0RFRkcACyAAQYAIaw4CQEFIC0ECDwtBAw8LQQQPC0EFDwtBBg8LQQcPC0EIDwtBCQ8LQQoPC0ELDwtBDA8LQQ0PC0GAAg8LQYECDwtBggIPC0GDAg8LQYQCDwtBhQIPC0GGAg8LQYcCDwtBiAIPC0GJAg8LQYoCDwtBgAQPC0GBBA8LQYIEDwtBgwQPC0GEBA8LQYUEDwtBhgQPC0GHBA8LQYgEDwtBiQQPC0GKBA8LQYsEDwtBjAQPC0GNBA8LQaAEDwtBoQQPC0GiBA8LQaMEDwtBpAQPC0GlBA8LQcAEDwtBwQQPC0HCBA8LQcMEDwtBxAQPC0HFBA8LQcYEDwtBxwQPC0HIBA8LQckEDwtBygQPC0HLBA8LQYAGDwtBgQYPC0GCBg8LQYMGDwtBhAYPC0GFBg8LQYYGDwtBhwYPC0GIBg8LQYAIDwtBgQgPC0GACg8LQYEKDwtBggoPC0GDCg8LQYQKIQELIAEPC0GshsAAQRkQ4gEAC/cCAQV/QRBBCBDPASAASwRAQRBBCBDPASEAC0EIQQgQzwEhA0EUQQgQzwEhAkEQQQgQzwEhBAJAQQBBEEEIEM8BQQJ0ayIFQYCAfCAEIAIgA2pqa0F3cUEDayIDIAMgBUsbIABrIAFNDQAgAEEQIAFBBGpBEEEIEM8BQQVrIAFLG0EIEM8BIgNqQRBBCBDPAWpBBGsQASICRQ0AIAIQ7gEhAQJAIABBAWsiBCACcUUEQCABIQAMAQsgAiAEakEAIABrcRDuASECQRBBCBDPASEEIAEQ5QEgAiAAQQAgAiABayAETRtqIgAgAWsiAmshBCABENoBRQRAIAAgBBDEASABIAIQxAEgASACEAQMAQsgASgCACEBIAAgBDYCBCAAIAEgAmo2AgALAkAgABDaAQ0AIAAQ5QEiAkEQQQgQzwEgA2pNDQAgACADEOsBIQEgACADEMQBIAEgAiADayIDEMQBIAEgAxAECyAAEO0BIQYgABDaARoLIAYLkAQBBX8jAEEQayIDJAAgACgCACEAAkACfwJAIAFBgAFPBEAgA0EANgIMIAFBgBBJDQEgAUGAgARJBEAgAyABQT9xQYABcjoADiADIAFBDHZB4AFyOgAMIAMgAUEGdkE/cUGAAXI6AA1BAwwDCyADIAFBP3FBgAFyOgAPIAMgAUEGdkE/cUGAAXI6AA4gAyABQQx2QT9xQYABcjoADSADIAFBEnZBB3FB8AFyOgAMQQQMAgsgACgCCCICIAAoAgRGBEAjAEEgayIEJAACQAJAIAJBAWoiAkUNAEEIIAAoAgQiBkEBdCIFIAIgAiAFSRsiAiACQQhNGyIFQX9zQR92IQICQCAGBEAgBCAGNgIcIARBATYCGCAEIAAoAgA2AhQMAQsgBEEANgIYCyAEQQhqIAIgBSAEQRRqEHYgBCgCDCECIAQoAghFBEAgACAFNgIEIAAgAjYCAAwCCyACQYGAgIB4Rg0BIAJFDQAgAiAEQRBqKAIAEOkBAAsQqQEACyAEQSBqJAAgACgCCCECCyAAIAJBAWo2AgggACgCACACaiABOgAADAILIAMgAUE/cUGAAXI6AA0gAyABQQZ2QcABcjoADEECCyEBIAEgACgCBCAAKAIIIgJrSwRAIAAgAiABEHIgACgCCCECCyAAKAIAIAJqIANBDGogARDqARogACABIAJqNgIICyADQRBqJABBAAuxBgIMfwF+IwBBMGsiBiQAQSchAwJAIABCkM4AVARAIAAhDgwBCwNAIAZBCWogA2oiAkEEayAAIABCkM4AgCIOQpDOAH59pyIHQf//A3FB5ABuIgRBAXRB5IvAAGovAAA7AAAgAkECayAHIARB5ABsa0H//wNxQQF0QeSLwABqLwAAOwAAIANBBGshAyAAQv/B1y9WIA4hAA0ACwsgDqciAkHjAEsEQCADQQJrIgMgBkEJamogDqciAiACQf//A3FB5ABuIgJB5ABsa0H//wNxQQF0QeSLwABqLwAAOwAACwJAIAJBCk8EQCADQQJrIgMgBkEJamogAkEBdEHki8AAai8AADsAAAwBCyADQQFrIgMgBkEJamogAkEwajoAAAsCfyAGQQlqIANqIQlBK0GAgMQAIAEiAigCHCIBQQFxIgQbIQcgBEEnIANrIgpqIQNBnIvAAEEAIAFBBHEbIQQCQAJAIAIoAgBFBEBBASEBIAIoAhQiAyACKAIYIgIgByAEEKcBDQEMAgsgAyACKAIEIgVPBEBBASEBIAIoAhQiAyACKAIYIgIgByAEEKcBDQEMAgsgAUEIcQRAIAIoAhAhDCACQTA2AhAgAi0AICENQQEhASACQQE6ACAgAigCFCIIIAIoAhgiCyAHIAQQpwENASAFIANrQQFqIQECQANAIAFBAWsiAUUNASAIQTAgCygCEBECAEUNAAtBAQwEC0EBIQEgCCAJIAogCygCDBEAAA0BIAIgDToAICACIAw2AhBBACEBDAELIAUgA2shAwJAAkACQCACLQAgIgFBAWsOAwABAAILIAMhAUEAIQMMAQsgA0EBdiEBIANBAWpBAXYhAwsgAUEBaiEBIAJBGGooAgAhBSACKAIQIQggAigCFCECAkADQCABQQFrIgFFDQEgAiAIIAUoAhARAgBFDQALQQEMAwtBASEBIAIgBSAHIAQQpwENACACIAkgCiAFKAIMEQAADQBBACEBA0BBACABIANGDQMaIAFBAWohASACIAggBSgCEBECAEUNAAsgAUEBayADSQwCCyABDAELIAMgCSAKIAIoAgwRAAALIAZBMGokAAsQACAAIAEgAiADQdMAEPcBCxAAIAAgASACIANB1AAQ9wELEAAgACABIAIgA0HeABD3AQsQACAAIAEgAiADQd8AEPcBCxAAIAAgASACIANB4AAQ9wELEAAgACABIAIgA0HhABD3AQsQACAAIAEgAiADQeIAEPcBCxAAIAAgASACIANB4wAQ9wELEAAgACABIAIgA0HkABD3AQsQACAAIAEgAiADQeUAEPcBC7sCAQV/IAAoAhghAwJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIEG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogBBshBANAIAQhBSACIgFBFGoiAiABQRBqIAIoAgAiAhshBCABQRRBECACG2ooAgAiAg0ACyAFQQA2AgALAkAgA0UNAAJAIAAgACgCHEECdEH4jcAAaiICKAIARwRAIANBEEEUIAMoAhAgAEYbaiABNgIAIAENAQwCCyACIAE2AgAgAQ0AQZSRwABBlJHAACgCAEF+IAAoAhx3cTYCAA8LIAEgAzYCGCAAKAIQIgIEQCABIAI2AhAgAiABNgIYCyAAQRRqKAIAIgBFDQAgAUEUaiAANgIAIAAgATYCGAsLrgIBBH8gAEIANwIQIAACf0EAIAFBgAJJDQAaQR8gAUH///8HSw0AGiABQQYgAUEIdmciAmt2QQFxIAJBAXRrQT5qCyICNgIcIAJBAnRB+I3AAGohBCAAIQMCQAJAAkACQEGUkcAAKAIAIgBBASACdCIFcQRAIAQoAgAhACACEM0BIQIgABDlASABRw0BIAAhAgwCC0GUkcAAIAAgBXI2AgAgBCADNgIAIAMgBDYCGAwDCyABIAJ0IQQDQCAAIARBHXZBBHFqQRBqIgUoAgAiAkUNAiAEQQF0IQQgAiIAEOUBIAFHDQALCyACKAIIIgAgAzYCDCACIAM2AgggAyACNgIMIAMgADYCCCADQQA2AhgPCyAFIAM2AgAgAyAANgIYCyADIAM2AgggAyADNgIMCxAAIAAgASACIANB4gAQ/wELEAAgACABIAIgA0HjABD/AQsQACAAIAEgAiADQd4AEP0BCxAAIAAgASACIANB3wAQ/QELEAAgACABIAIgA0HgABD9AQsQACAAIAEgAiADQeEAEP0BCw0AIAAgASACQTkQ9AELDQAgACABIAJBOhD0AQsNACAAIAEgAkE7EPQBCw0AIAAgASACQTwQ9AELDQAgACABIAJBPRD0AQsNACAAIAEgAkE+EPQBCw0AIAAgASACQT8Q9AELDgAgACABIAJBwAAQ9AELDgAgACABIAJBwQAQ9AELDgAgACABIAJBwgAQ9AELDgAgACABIAJBwwAQ9AELDgAgACABIAJBxAAQ9AELDgAgACABIAJBxQAQ9AELDgAgACABIAJBxgAQ9AELDgAgACABIAJBxwAQ9AELDgAgACABIAJByAAQ9AELDgAgACABIAJByQAQ9AELDgAgACABIAJBygAQ9AELDgAgACABIAJB0QAQ9AELDgAgACABIAJB0gAQ9AELXQEMf0GAj8AAKAIAIgIEQEH4jsAAIQYDQCACIgEoAgghAiABKAIEIQMgASgCACEEIAEoAgwaIAEhBiAFQQFqIQUgAg0ACwtBuJHAAEH/HyAFIAVB/x9NGzYCAEEACxAAIAAgASACIANB5AAQ/gELEAAgACABIAIgA0HlABD+AQvuAQEDfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQQgABACIAFFDQAgASgCAA0BIAEtAAQhBSABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADQQVqLQAAIQIgAy0ABCEGIAMQAkG9jcAALQAAGkEIQQQQ0gEiAEUNAiAAQQA2AgAgAEEGaiAFQQx0IARBEnRyIgMgAUEGdHIgBkEAR0EEdHIgAkEAR0EFdHIiAToAACAAIANBCHZBgP4DcSABQYD+A3FBCHRyQQh2OwEEIAAPCxDjAQALEOQBAAtBBEEIEOkBAAvoAQEDfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQQgABACIAFFDQAgASgCAA0BIAEtAAQhBSABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADQQVqLQAAIQIgAy0ABCEGIAMQAkG9jcAALQAAGkEIQQQQ0gEiAEUNAiAAQQA2AgAgAEEGaiAFQQx0IARBEnRyIgMgAUEGdHIgAiAGQQBHQQV0cnIiAToAACAAIANBCHZBgP4DcSABQYD+A3FBCHRyQQh2OwEEIAAPCxDjAQALEOQBAAtBBEEIEOkBAAsMACAAIAFBywAQ+AELDAAgACABQcwAEPgBCwwAIAAgAUHNABD4AQsMACAAIAFBzgAQ+AELDAAgACABQc8AEPgBCwwAIAAgAUHQABD4AQsPACAAIAEgAiADQRIQ+QELDwAgACABIAIgA0EYEPkBCw8AIAAgASACIANBHBD5AQsPACAAIAEgAiADQR0Q+QELDwAgACABIAIgA0EiEPkBCw8AIAAgASACIANBIxD5AQsPACAAIAEgAiADQSgQ+QELDwAgACABIAIgA0EqEPkBCw8AIAAgASACIANBLBD5AQsPACAAIAEgAiADQTgQ+QELEAAgACABIAIgA0HmABD5AQsQACAAIAEgAiADQecAEPkBCxAAIAAgASACIANB6AAQ+QELEAAgACABIAIgA0HpABD5AQsQACAAIAEgAiADQeoAEPkBCxAAIAAgASACIANB6wAQ+QELEAAgACABIAIgA0HsABD5AQvbAQECfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQQgABACIAFFDQAgASgCAA0BIAEtAAQhBSABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADLQAEIQIgAxACQb2NwAAtAAAaQQhBBBDSASIARQ0CIABBADYCACAAQQZqIAVBDHQgBEESdHIiAyABQQZ0ciACQQBHQQV0ciIBOgAAIAAgA0EIdkGA/gNxIAFBgP4DcUEIdHJBCHY7AQQgAA8LEOMBAAsQ5AEAC0EEQQgQ6QEAC/cBAgR/AX4jAEEwayICJAAgAUEEaiEEIAEoAgRFBEAgASgCACEDIAJBKGoiBUEANgIAIAJCATcCICACIAJBIGo2AiwgAkEsaiADEAMaIAJBGGogBSgCACIDNgIAIAIgAikCICIGNwMQIARBCGogAzYCACAEIAY3AgALIAJBCGoiAyAEQQhqKAIANgIAIAFBDGpBADYCACAEKQIAIQYgAUIBNwIEQb2NwAAtAAAaIAIgBjcDAEEMQQQQ0gEiAUUEQEEEQQwQ6QEACyABIAIpAwA3AgAgAUEIaiADKAIANgIAIABB/InAADYCBCAAIAE2AgAgAkEwaiQAC9UBAQJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhBCAAEAIgAUUNACABKAIADQEgAS0ABCEFIAEQAiACRQ0AIAIoAgANASACLQAEIQEgAhACIANFDQAgAygCAA0BIAMtAAQhAiADEAJBvY3AAC0AABpBCEEEENIBIgBFDQIgAEEANgIAIABBBmogAiAFQQx0IARBEnRyIgMgAUEGdHJyIgE6AAAgACADQQh2QYD+A3EgAUGA/gNxQQh0ckEIdjsBBCAADwsQ4wEACxDkAQALQQRBCBDpAQALCgAgAEHVABD2AQsKACAAQdYAEPYBCwoAIABB1wAQ9gELCgAgAEHaABD2AQsKACAAQdsAEPYBCwoAIABB3AAQ9gELCgAgAEHdABD2AQsNACAAIAEgAkEBEPUBCw0AIAAgASACQQIQ9QELDQAgACABIAJBAxD1AQsNACAAIAEgAkEEEPUBCw0AIAAgASACQQUQ9QELDQAgACABIAJBBhD1AQsNACAAIAEgAkEHEPUBCw0AIAAgASACQQgQ9QELDQAgACABIAJBCRD1AQsNACAAIAEgAkELEPUBCw0AIAAgASACQQ0Q9QELDQAgACABIAJBDhD1AQsNACAAIAEgAkEPEPUBCw0AIAAgASACQRAQ9QELDQAgACABIAJBERD1AQsNACAAIAEgAkEXEPUBCw0AIAAgASACQSEQ9QELDQAgACABIAJBJhD1AQsNACAAIAEgAkEnEPUBCw0AIAAgASACQSkQ9QELDQAgACABIAJBKxD1AQsNACAAIAEgAkEtEPUBCw0AIAAgASACQS4Q9QELDQAgACABIAJBLxD1AQsNACAAIAEgAkEwEPUBCw0AIAAgASACQTEQ9QELDQAgACABIAJBNRD1AQsNACAAIAEgAkE3EPUBC74BAQF/AkACQAJAIABBwAFxRQRAIAFBwAFxIAJBwAFxcg0DQb2NwAAtAAAaQQRBARDSASIDRQ0BIAMgAkEWdEGAgIAGcSABQQx0IgEgAkEGdEGA/gBxckGA/gNxQQh0IAFBgIA8cSAAQRJ0ckEIdkGA/gNxckEIdnJBCHQ2AABBvY3AAC0AABpBCEEEENIBIgBFDQIgACADNgIEIABBADYCACAADwsMAgtBAUEEEOkBAAtBBEEIEOkBAAsQnwEAC8kBAQJ/IwBBIGsiAyQAAkACQCABIAEgAmoiAUsNAEEIIAAoAgQiAkEBdCIEIAEgASAESRsiASABQQhNGyIEQX9zQR92IQECQCACBEAgAyACNgIcIANBATYCGCADIAAoAgA2AhQMAQsgA0EANgIYCyADQQhqIAEgBCADQRRqEHYgAygCDCEBIAMoAghFBEAgACAENgIEIAAgATYCAAwCCyABQYGAgIB4Rg0BIAFFDQAgASADQRBqKAIAEOkBAAsQqQEACyADQSBqJAAL/QEBAn8jAEEgayIFJABB9I3AAEH0jcAAKAIAIgZBAWo2AgACQAJAIAZBAEgNAEHAkcAALQAADQBBwJHAAEEBOgAAQbyRwABBvJHAACgCAEEBajYCACAFIAI2AhggBUHEisAANgIQIAVB3IfAADYCDCAFIAQ6ABwgBSADNgIUQeSNwAAoAgAiAkEASA0AQeSNwAAgAkEBajYCAEHkjcAAQeyNwAAoAgAEfyAFIAAgASgCEBEEACAFIAUpAwA3AgxB7I3AACgCACAFQQxqQfCNwAAoAgAoAhQRBABB5I3AACgCAEEBawUgAgs2AgBBwJHAAEEAOgAAIAQNAQsACwALuwEBAn8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCEDIAAQAiABRQ0AIAEoAgANASABLQAEIQQgARACIAJFDQAgAigCAA0BIAItAAQhASACEAJBvY3AAC0AABpBCEEEENIBIgBFDQIgAEEANgIAIABBBmogAUEGdCIBOgAAIAAgASAEQQx0IgJyQYD+A3FBCHQgAiADQRJ0ckEIdkGA/gNxckEIdjsBBCAADwsQ4wEACxDkAQALQQRBCBDpAQALuwEBAX8gAhAFIQICQAJAAkAgAEHAAXFFBEAgAUHAAXENAUG9jcAALQAAGkEEQQEQ0gEiA0UNAiADIAJBEHRBgID8B3EgAUEMdCIBIAJyQYD+A3FBCHQgAUGAgDxxIABBEnRyQQh2QYD+A3FyQQh2ckEIdEHKAHI2AABBvY3AAC0AABpBCEEEENIBIgBFDQMgACADNgIEIABBADYCACAADwsQnwEACxCfAQALQQFBBBDpAQALQQRBCBDpAQALtQcBCX8CQAJAIAEEQCACQQBIDQECfyADKAIEBEAgA0EIaigCACIGBEACfyADKAIAIQkCQAJAAkACQAJAIAFBCU8EQCABIAIQBiILDQFBAAwGC0EIQQgQzwEhCkEUQQgQzwEhB0EQQQgQzwEhA0EAQRBBCBDPAUECdGsiBkGAgHwgAyAHIApqamtBd3FBA2siAyADIAZLGyACTQ0DQRAgAkEEakEQQQgQzwFBBWsgAksbQQgQzwEhBSAJEO4BIgQgBBDlASIDEOsBIQgCQAJAAkACQAJAAkAgBBDaAUUEQCADIAVPDQQgCEGkkcAAKAIARg0GIAhBoJHAACgCAEYNAyAIENcBDQkgCBDlASIKIANqIgcgBUkNCSAHIAVrIQwgCkGAAkkNASAIEBMMAgsgBBDlASEDIAVBgAJJDQggAyAFa0GBgAhJIAVBBGogA01xDQQgBCgCABogBUEfakGAgAQQzwEaDAgLIAhBDGooAgAiBiAIQQhqKAIAIgNHBEAgAyAGNgIMIAYgAzYCCAwBC0GQkcAAQZCRwAAoAgBBfiAKQQN2d3E2AgALQRBBCBDPASAMTQRAIAQgBRDrASEDIAQgBRDEASADIAwQxAEgAyAMEAQgBA0JDAcLIAQgBxDEASAEDQgMBgtBmJHAACgCACADaiIDIAVJDQUCQEEQQQgQzwEgAyAFayIHSwRAIAQgAxDEAUEAIQdBACEGDAELIAQgBRDrASIGIAcQ6wEhAyAEIAUQxAEgBiAHEM4BIAMgAygCBEF+cTYCBAtBoJHAACAGNgIAQZiRwAAgBzYCACAEDQcMBQtBEEEIEM8BIAMgBWsiBksNACAEIAUQ6wEhAyAEIAUQxAEgAyAGEMQBIAMgBhAECyAEDQUMAwtBnJHAACgCACADaiIDIAVLDQEMAgsgCyAJIAYgAiACIAZLGxDqARogCRACDAILIAQgBRDrASEGIAQgBRDEASAGIAMgBWsiA0EBcjYCBEGckcAAIAM2AgBBpJHAACAGNgIAIAQNAgsgAhABIgNFDQAgAyAJIAQQ5QFBeEF8IAQQ2gEbaiIDIAIgAiADSxsQ6gEgCRACDAILIAsMAQsgBBDaARogBBDtAQsMAgsLIAEgAkUNABpBvY3AAC0AABogAiABENIBCyIDBEAgACADNgIEIABBCGogAjYCACAAQQA2AgAPCyAAIAE2AgQgAEEIaiACNgIADAILIABBADYCBCAAQQhqIAI2AgAMAQsgAEEANgIECyAAQQE2AgALtgEBAX8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCEDIAAQAiABRQ0AIAEoAgANASABLQAEIQAgARACIAJFDQAgAigCAA0BIAIvAQQhASACEAJBvY3AAC0AABpBCEEEENIBIgJFDQIgAkEANgIAIAJBBmogAToAACACIABBDHQiACABckGA/gNxQQh0IAAgA0ESdHJBCHZBgP4DcXJBCHY7AQQgAg8LEOMBAAsQ5AEAC0EEQQgQ6QEAC7gBAQF/AkACQAJAIAFBAWtBA00EQCAAQcABcQ0BQb2NwAAtAAAaQQRBARDSASICRQ0CIAIgAUEQdEGAgPwHcSAAQRJ0QYCA8B9xIAFyIgBBgP4DcUEIdCAAQQh2QYD+A3FyQQh2ckEIdEHMAHI2AABBvY3AAC0AABpBCEEEENIBIgBFDQMgACACNgIEIABBADYCACAADwtBrIbAAEEZEOIBAAsQnwEAC0EBQQQQ6QEAC0EEQQgQ6QEAC6UBAQF/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhAyAAEAIgAUUNACABKAIADQEgAS0ABCEAIAEQAiACEAUhAUG9jcAALQAAGkEIQQQQ0gEiAkUNAiACQQA2AgAgAkEGaiABOgAAIAIgAEEMdCIAIAFyQYD+A3FBCHQgACADQRJ0ckEIdkGA/gNxckEIdjsBBCACDwsQ4wEACxDkAQALQQRBCBDpAQALCwAgACABQQoQ+gELCwAgACABQQwQ+gELCwAgACABQRQQ+gELCwAgACABQRYQ+gELCwAgACABQRkQ+gELCwAgACABQRsQ+gELCwAgACABQR4Q+gELCwAgACABQR8Q+gELCwAgACABQSQQ+gELCwAgACABQTIQ+gELlQEBAX8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCECIAAQAiABRQ0AIAEoAgANASABLQAEIQAgARACQb2NwAAtAAAaQQhBBBDSASIBRQ0CIAFBADYCACABQQZqQQA6AAAgASAAQQx0IAJBEnRyQQh2QYD+A3EgAEEUdHJBCHY7AQQgAQ8LEOMBAAsQ5AEAC0EEQQgQ6QEAC5cBAQF/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhAiAAEAIgAUUNACABKAIADQEgASgCBCEAIAEQAkG9jcAALQAAGkEIQQQQ0gEiAUUNAiABQQA2AgAgAUEGaiAAOgAAIAEgACACQRJ0ckEIdkGA/gNxIABBgP4DcUEIdHJBCHY7AQQgAQ8LEOMBAAsQ5AEAC0EEQQgQ6QEAC5MBAQF/AkACQCAABEAgACgCAA0BIAAtAAQhAiAAEAIgAUEBa0EDTQRAQb2NwAAtAAAaQQhBBBDSASIARQ0DIABBADYCACAAQQZqIAE6AAAgACACQRJ0IAFyQQh2QYD+A3EgAUGA/gNxQQh0ckEIdjsBBCAADwtBrIbAAEEZEOIBAAsQ4wEACxDkAQALQQRBCBDpAQALkQECA38BfiMAQSBrIgIkACABQQRqIQMgASgCBEUEQCABKAIAIQEgAkEYaiIEQQA2AgAgAkIBNwIQIAIgAkEQajYCHCACQRxqIAEQAxogAkEIaiAEKAIAIgE2AgAgAiACKQIQIgU3AwAgA0EIaiABNgIAIAMgBTcCAAsgAEH8icAANgIEIAAgAzYCACACQSBqJAALhAEBAn8CQAJAIAAEQCAAKAIAQX9GDQFBvY3AAC0AABogAEEGai0AACEBIAAvAAQhAkEIQQQQ0gEiAEUNAiAAQQA2AgAgACACIAFBEHRyIgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3FyQQh2NgIEIAAPCxDjAQALEOQBAAtBBEEIEOkBAAuBAQECfwJAAkAgAARAIAAoAgBBf0YNAUG9jcAALQAAGiAAQQZqLQAAIQEgAC8ABCECQQhBBBDSASIARQ0CIABBADYCACAAIAIgAUEQdHIiAUEQdEGAgAxxIAFBgP4DcSABQQh0QRh2cnI2AgQgAA8LEOMBAAsQ5AEAC0EEQQgQ6QEAC34BAn8CQAJAIAAEQCAAKAIADQEgAC0ABCEBIAAQAkEAIQACQCABQRhxDQAgAUEHcSICQQdGDQBBvY3AAC0AABpBCEEEENIBIgBFDQMgACACOgAFIABBADYCACAAIAFBBXZBAXE6AAQLIAAPCxDjAQALEOQBAAtBBEEIEOkBAAt8AQJ/AkACQCAABEAgACgCAEF/Rg0BQb2NwAAtAAAaIABBBmotAAAhASAALwAEIQJBCEEEENIBIgBFDQIgAEEANgIAIAAgAiABQRB0ciIBQRh0IAFBgOADcUEIdHJBFHZBP3E6AAQgAA8LEOMBAAsQ5AEAC0EEQQgQ6QEAC3UBAn8CQAJAIAAEQCAAKAIAQX9GDQFBvY3AAC0AABogAEEGai0AACEBIAAvAAQhAkEIQQQQ0gEiAEUNAiAAQQA2AgAgACACIAFBEHRyIgFBFnYgAUGAHnFBBnZyOgAEIAAPCxDjAQALEOQBAAtBBEEIEOkBAAt3AQF/AkACQCAABEAgACgCAA0BIAAoAgQhASAAEAJBvY3AAC0AABpBCEEEENIBIgBFDQIgAEEANgIAIABBBmogAToAACAAIAFBCHZBgP4DcSABQYD+A3FBCHRyQQh2OwEEIAAPCxDjAQALEOQBAAtBBEEIEOkBAAt1AQJ/AkACQCAABEAgACgCAEF/Rg0BQb2NwAAtAAAaIABBBmotAAAhASAALwAEIQJBCEEEENIBIgBFDQIgAEEANgIAIAAgAiABQRB0ciIBQYAecSABQQh0QRh2cjsBBCAADwsQ4wEACxDkAQALQQRBCBDpAQALCQAgAEETEPwBCwkAIABBFRD8AQsJACAAQRoQ/AELCQAgAEEgEPwBCwkAIABBJRD8AQsJACAAQTQQ/AELCQAgAEE2EPwBCwoAIABB2AAQ/AELCgAgAEHZABD8AQuPAQECfwJAAkAgAQRAIAEoAgAiAkF/Rg0BIAEgAkEBajYCACABKAIEKAAAIgJBGHRBFnVB+ILAAGooAgAgAkGAfnFyIQNBvY3AAC0AABpBBEEBENIBIgJFDQIgAiADNgAAIAEgASgCAEEBazYCACAAQQQ2AgQgACACNgIADwsQ4wEACxDkAQALQQFBBBDpAQALagECfwJAAkAgAARAIAAoAgANASAAQQVqLQAAIQEgAC0ABCECIAAQAkG9jcAALQAAGkEIQQQQ0gEiAEUNAiAAQQA2AgAgACACQQBHQQV0IAFyOgAEIAAPCxDjAQALEOQBAAtBBEEIEOkBAAsJACAAQQIQ8wELCQAgAEEQEPMBC2gBAX8CQAJAIAAEQCAAKAIADQEgAC0ABCEBIAAQAkG9jcAALQAAGkEIQQQQ0gEiAEUNAiAAQQA2AgAgAEEGakEAOgAAIAAgAUECdEH8AXE7AQQgAA8LEOMBAAsQ5AEAC0EEQQgQ6QEAC4MBAQF/IwBBMGsiACQAQbyNwAAtAAAEQCAAQQI2AiggACABNgIsIAAgAEEsajYCJCMAQSBrIgIkACAAQQxqIgFBADYCECABQQI2AgQgAUGIicAANgIAIAEgAEEkajYCCCABQQxqQQE2AgAgAkEgaiQAIAFBsInAABCqAQALIABBMGokAAtZAQJ/Qb2NwAAtAAAaAkBBBEEBENIBIgEEQCABQTM2AABBvY3AAC0AABpBCEEEENIBIgBFDQEgACABNgIEIABBADYCACAADwtBAUEEEOkBAAtBBEEIEOkBAAt7AQN/IwBBMGsiACQAIABBIjYCDCAAQZmAwAA2AgggAEEUNgIsIAAgAEEIajYCKCMAQSBrIgIkACAAQRBqIgFBADYCECABQQE2AgQgAUHMi8AANgIAIAEgAEEoajYCCCABQQxqQQE2AgAgAkEgaiQAIAFB0IDAABCqAQALTwEBfwJAIABBLkkEQEG9jcAALQAAGkEMQQQQ0gEiAkUNASACIAA6AAggAiABNgIEIAJBADYCACACDwtBgIDAAEEZEOIBAAtBBEEMEOkBAAtEAQF/AkAgAEH/AXFBP00EQEG9jcAALQAAGkEIQQQQ0gEiAUUNASABIABBP3E6AAQgAUEANgIACyABDwtBBEEIEOkBAAtHAQF/IAIgACgCACIAKAIEIAAoAggiA2tLBEAgACADIAIQciAAKAIIIQMLIAAoAgAgA2ogASACEOoBGiAAIAIgA2o2AghBAAtPAQJ/Qb2NwAAtAAAaIAEoAgQhAiABKAIAIQNBCEEEENIBIgFFBEBBBEEIEOkBAAsgASACNgIEIAEgAzYCACAAQYyKwAA2AgQgACABNgIAC0sBAX8jAEEgayIBJAAgAUEMakIANwIAIAFBATYCBCABQZyLwAA2AgggAUErNgIcIAFBuIjAADYCGCABIAFBGGo2AgAgASAAEKoBAAsLACAAIAFBBxDyAQsLACAAIAFBCBDyAQs5AAJAAn8gAkGAgMQARwRAQQEgACACIAEoAhARAgANARoLIAMNAUEACw8LIAAgA0EAIAEoAgwRAAALPAEBf0G9jcAALQAAGkEIQQQQ0gEiAEUEQEEEQQgQ6QEACyAAQQA7AQQgAEEANgIAIABBBmpBADoAACAAC0ABAX8jAEEgayIAJAAgAEEUakIANwIAIABBATYCDCAAQYSLwAA2AgggAEHUisAANgIQIABBCGpBjIvAABCqAQALswIBAn8jAEEgayICJAAgAiAANgIYIAJB1IvAADYCECACQZyLwAA2AgwgAkEBOgAcIAIgATYCFCMAQRBrIgEkAAJAIAJBDGoiACgCCCICBEAgACgCDCIDRQ0BIAEgAjYCDCABIAA2AgggASADNgIEIwBBEGsiACQAIAFBBGoiASgCACICQQxqKAIAIQMCQAJ/AkACQCACKAIEDgIAAQMLIAMNAkEAIQJB3IfAAAwBCyADDQEgAigCACIDKAIEIQIgAygCAAshAyAAIAI2AgQgACADNgIAIABBnIrAACABKAIEIgAoAgwgASgCCCAALQAQEHMACyAAQQA2AgQgACACNgIAIABBsIrAACABKAIEIgAoAgwgASgCCCAALQAQEHMAC0HcicAAEKQBAAtB7InAABCkAQALJwEBfwJAIAAEQCAAKAIADQEgACgCBCAAEAIQAg8LEOMBAAsQ5AEACy4AAkAgAARAIAAoAgANASAAQQA2AgAgAEEFaiABQQBHOgAADwsQ4wEACxDkAQALNQEBf0G9jcAALQAAGkEIQQQQ0gEiAUUEQEEEQQgQ6QEACyABQQA2AgAgASAAQT9xOgAEIAELKwACQCAABEAgACgCAA0BIABBADYCACAAIAFBAEc6AAQPCxDjAQALEOQBAAslAQF/AkAgAARAIAAoAgANASAALQAEIAAQAg8LEOMBAAsQ5AEACycBAX8jAEEQayICJAAgAiAAKAIANgIMIAJBDGogARADIAJBEGokAAsHAEELEPsBCwcAQQoQ+wELBwBBCBD7AQsHAEEPEPsBCwcAQQYQ+wELBwBBCRD7AQsHAEEHEPsBCwcAQQwQ+wELBwBBAhD7AQsHAEEBEPsBCwcAQQMQ+wELBwBBDRD7AQsHAEEOEPsBCwcAQQUQ+wELBwBBBBD7AQsHAEEQEPsBCwcAQQAQ+wELCQAgAEEFEPEBCwkAIABBCBDxAQsnACAAIAAoAgRBAXEgAXJBAnI2AgQgACABaiIAIAAoAgRBAXI2AgQLHgACQCAABEAgACgCAA0BIAAQAg8LEOMBAAsQ5AEACyIAAkAgAARAIAAoAgBBf0YNASAALQAEDwsQ4wEACxDkAQALIgACQCAABEAgACgCAEF/Rg0BIAAoAgQPCxDjAQALEOQBAAsgAQF/AkAgACgCBCIBRQ0AIABBCGooAgBFDQAgARACCwsjACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAseACAAIAFBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQLEQAgACgCBARAIAAoAgAQAgsLGQEBfyAAKAIQIgEEfyABBSAAQRRqKAIACwsSAEEZIABBAXZrQQAgAEEfRxsLFgAgACABQQFyNgIEIAAgAWogATYCAAsQACAAIAFqQQFrQQAgAWtxCwsAIAEEQCAAEAILCw8AIABBAXQiAEEAIABrcgsZAAJ/IAFBCU8EQCABIAAQBgwBCyAAEAELCyEAIABCwsObzq2QwN6mfzcDCCAAQtKCsfj6rOe9djcDAAsgACAAQuTex4WQ0IXefTcDCCAAQsH3+ejMk7LRQTcDAAsgACAAQqv98Zypg8WEZDcDCCAAQvj9x/6DhraIOTcDAAsTACAAQYyKwAA2AgQgACABNgIACw0AIAAtAARBAnFBAXYL5w0BDX8CfyAAKAIAIQUgACgCBCEGAkAgASIHKAIAIgsgASgCCCIAcgRAAkAgAEUNACAFIAZqIQkgAUEMaigCAEEBaiEEIAUhAANAAkAgACEBIARBAWsiBEUNACABIAlGDQICfyABLAAAIgBBAE4EQCAAQf8BcSECIAFBAWoMAQsgAS0AAUE/cSEIIABBH3EhAiAAQV9NBEAgAkEGdCAIciECIAFBAmoMAQsgAS0AAkE/cSAIQQZ0ciEIIABBcEkEQCAIIAJBDHRyIQIgAUEDagwBCyACQRJ0QYCA8ABxIAEtAANBP3EgCEEGdHJyIgJBgIDEAEYNAyABQQRqCyIAIAMgAWtqIQMgAkGAgMQARw0BDAILCyABIAlGDQAgASwAACIAQQBOIABBYElyIABBcElyRQRAIABB/wFxQRJ0QYCA8ABxIAEtAANBP3EgAS0AAkE/cUEGdCABLQABQT9xQQx0cnJyQYCAxABGDQELAkACQCADRQ0AIAMgBk8EQEEAIQEgAyAGRg0BDAILQQAhASADIAVqLAAAQUBIDQELIAUhAQsgAyAGIAEbIQYgASAFIAEbIQULIAtFDQEgBygCBCELAkAgBkEQTwRAAn9BACEEQQAhA0EAIQECQAJAIAYgBUEDakF8cSICIAVrIgpJDQAgBiAKayIJQQRJDQAgCUEDcSEIQQAhAAJAIAIgBUYiDA0AIAIgBUF/c2pBA08EQANAIAAgAyAFaiIELAAAQb9/SmogBEEBaiwAAEG/f0pqIARBAmosAABBv39KaiAEQQNqLAAAQb9/SmohACADQQRqIgMNAAsLIAwNACAFIAJrIQQgAyAFaiECA0AgACACLAAAQb9/SmohACACQQFqIQIgBEEBaiIEDQALCyAFIApqIQMCQCAIRQ0AIAMgCUF8cWoiAiwAAEG/f0ohASAIQQFGDQAgASACLAABQb9/SmohASAIQQJGDQAgASACLAACQb9/SmohAQsgCUECdiEJIAAgAWohBANAIAMhASAJRQ0CQcABIAkgCUHAAU8bIgNBA3EhCCADQQJ0IQwCQCADQfwBcSIKRQRAQQAhAgwBCyABIApBAnRqIQ1BACECIAEhAANAIAIgACgCACIOQX9zQQd2IA5BBnZyQYGChAhxaiAAQQRqKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIABBCGooAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWogAEEMaigCACICQX9zQQd2IAJBBnZyQYGChAhxaiECIABBEGoiACANRw0ACwsgCSADayEJIAEgDGohAyACQQh2Qf+B/AdxIAJB/4H8B3FqQYGABGxBEHYgBGohBCAIRQ0ACwJ/IAEgCkECdGoiACgCACIBQX9zQQd2IAFBBnZyQYGChAhxIgEgCEEBRg0AGiABIAAoAgQiA0F/c0EHdiADQQZ2ckGBgoQIcWoiASAIQQJGDQAaIAAoAggiAEF/c0EHdiAAQQZ2ckGBgoQIcSABagsiAEEIdkH/gRxxIABB/4H8B3FqQYGABGxBEHYgBGohBAwBC0EAIAZFDQEaIAZBA3EhAwJAIAZBBEkEQEEAIQIMAQsgBkF8cSEBQQAhAgNAIAQgAiAFaiIALAAAQb9/SmogAEEBaiwAAEG/f0pqIABBAmosAABBv39KaiAAQQNqLAAAQb9/SmohBCABIAJBBGoiAkcNAAsLIANFDQAgAiAFaiEAA0AgBCAALAAAQb9/SmohBCAAQQFqIQAgA0EBayIDDQALCyAECyEBDAELIAZFBEBBACEBDAELIAZBA3EhBAJAIAZBBEkEQEEAIQFBACECDAELIAZBfHEhA0EAIQFBACECA0AgASACIAVqIgAsAABBv39KaiAAQQFqLAAAQb9/SmogAEECaiwAAEG/f0pqIABBA2osAABBv39KaiEBIAMgAkEEaiICRw0ACwsgBEUNACACIAVqIQADQCABIAAsAABBv39KaiEBIABBAWohACAEQQFrIgQNAAsLAkAgASALSQRAIAsgAWshA0EAIQECQAJAAkAgBy0AIEEBaw4CAAECCyADIQFBACEDDAELIANBAXYhASADQQFqQQF2IQMLIAFBAWohASAHQRhqKAIAIQAgBygCECECIAcoAhQhBwNAIAFBAWsiAUUNAiAHIAIgACgCEBECAEUNAAtBAQwECwwCCyAHIAUgBiAAKAIMEQAABH9BAQVBACEBAn8DQCADIAEgA0YNARogAUEBaiEBIAcgAiAAKAIQEQIARQ0ACyABQQFrCyADSQsMAgsgBygCFCAFIAYgB0EYaigCACgCDBEAAAwBCyAHKAIUIAUgBiAHQRhqKAIAKAIMEQAACwsKAEEAIABrIABxCwsAIAAtAARBA3FFCwwAIAAgAUEDcjYCBAsNACAAKAIAIAAoAgRqCw4AIAAoAgAaA0AMAAsACwsAIAA1AgAgARAICwsAIAAxAAAgARAICwsAIAAzAQAgARAICwsAIAAjAGokACMACwkAIAAgARAAAAsNAEHFhsAAQRsQ4gEACw4AQeCGwABBzwAQ4gEACwoAIAAoAgRBeHELCgAgACgCBEEBcQsKACAAKAIMQQFxCwoAIAAoAgxBAXYLGQAgACABQeCNwAAoAgAiAEEEIAAbEQQAAAu4AgEHfwJAIAIiBEEPTQRAIAAhAgwBCyAAQQAgAGtBA3EiA2ohBSADBEAgACECIAEhBgNAIAIgBi0AADoAACAGQQFqIQYgAkEBaiICIAVJDQALCyAFIAQgA2siCEF8cSIHaiECAkAgASADaiIDQQNxBEAgB0EATA0BIANBA3QiBEEYcSEJIANBfHEiBkEEaiEBQQAgBGtBGHEhBCAGKAIAIQYDQCAFIAYgCXYgASgCACIGIAR0cjYCACABQQRqIQEgBUEEaiIFIAJJDQALDAELIAdBAEwNACADIQEDQCAFIAEoAgA2AgAgAUEEaiEBIAVBBGoiBSACSQ0ACwsgCEEDcSEEIAMgB2ohAQsgBARAIAIgBGohAwNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANJDQALCyAACwcAIAAgAWoLBwAgACABawsHACAAQQhqCwcAIABBCGsLBABBBAsCAAslAAJAIAAEQCAAKAIAQX9GDQEgACABai0AAA8LEOMBAAsQ5AEAC0AAAkACQCAABEAgASACTw0BIAAoAgANAiAAQQA2AgAgAEEFaiABOgAADwsQ4wEAC0GAgMAAQRkQ4gEACxDkAQALbAECfwJAAkAgAARAIAAoAgBBf0YNAUG9jcAALQAAGiAAQQZqLQAAIQIgAC8ABCEDQQhBBBDSASIARQ0CIABBADYCACAAIAMgAkEQdHIgAXZBP3E6AAQgAA8LEOMBAAsQ5AEAC0EEQQgQ6QEAC58CAQJ/IwBBMGsiBCQAAkACQAJAAkAgAEHAAXFFBEAgAUHAAXENASAEIAI7AQ4gAkH//wNxQYAgTw0CQb2NwAAtAAAaQQRBARDSASIFRQ0DIAUgAkEQdEGAgPwHcSABQQx0IgEgAnJBgP4DcUEIdCABQYCAPHEgAEESdHJBCHZBgP4DcXJBCHZyQQh0IANyNgAAQb2NwAAtAAAaQQhBBBDSASIARQ0EIAAgBTYCBCAAQQA2AgAgBEEwaiQAIAAPCxCfAQALEJ8BAAsgBEEcakIBNwIAIARBAjYCFCAEQdCBwAA2AhAgBEEBNgIsIAQgBEEoajYCGCAEIARBDmo2AiggBEEQakHggcAAEKoBAAtBAUEEEOkBAAtBBEEIEOkBAAvBAQEBfwJAAkACQCAAQcABcUUEQCABQcABcSACQcABcXINA0G9jcAALQAAGkEEQQEQ0gEiBEUNASAEIAJBFnRBgICABnEgAUEMdCIBIAJBBnRBgP4AcXJBgP4DcUEIdCABQYCAPHEgAEESdHJBCHZBgP4DcXJBCHZyQQh0IANyNgAAQb2NwAAtAAAaQQhBBBDSASIARQ0CIAAgBDYCBCAAQQA2AgAgAA8LDAILQQFBBBDpAQALQQRBCBDpAQALEJ8BAAvqAQECfyMAQTBrIgIkACACIAA2AgwCQAJAIABBgICACEkEQEG9jcAALQAAGkEEQQEQ0gEiA0UNASADIABBEHRBgID8B3EgAEEIdkGA/gNxIABBgP4DcUEIdHJBCHZyQQh0IAFyNgAAQb2NwAAtAAAaQQhBBBDSASIARQ0CIAAgAzYCBCAAQQA2AgAgAkEwaiQAIAAPCyACQRxqQgE3AgAgAkECNgIUIAJB2ILAADYCECACQQI2AiwgAiACQShqNgIYIAIgAkEMajYCKCACQRBqQeiCwAAQqgEAC0EBQQQQ6QEAC0EEQQgQ6QEAC7gCAQJ/IwBBMGsiBSQAAkACQAJAAkAgAEHAAXFFBEAgAUHAAXEgAkHAAXFyDQQgBSADOgAPIANB/wFxIgZBwABPDQFBvY3AAC0AABpBBEEBENIBIgNFDQIgAyABQQx0QYDgP3EgAEESdEGAgPAfcXIiACACQQZ0QcD/AHFyIAZyIgFBEHRBgID8B3EgAEEIdkGA/gNxIAFBgP4DcUEIdHJBCHZyQQh0IARyNgAAQb2NwAAtAAAaQQhBBBDSASIARQ0DIAAgAzYCBCAAQQA2AgAgBUEwaiQAIAAPCwwDCyAFQRxqQgE3AgAgBUECNgIUIAVBjIHAADYCECAFQQM2AiwgBSAFQShqNgIYIAUgBUEPajYCKCAFQRBqQZyBwAAQqgEAC0EBQQQQ6QEAC0EEQQgQ6QEACxCfAQALhwIBAn8jAEEwayIDJAACQAJAAkAgAEHAAXFFBEAgAyABNgIMIAFBgIAQTw0BQb2NwAAtAAAaQQRBARDSASIERQ0CIAQgAUEQdEGAgPwHcSAAQRJ0QYCA8B9xIAFyIgBBgP4DcUEIdCAAQQh2QYD+A3FyQQh2ckEIdCACcjYAAEG9jcAALQAAGkEIQQQQ0gEiAEUNAyAAIAQ2AgQgAEEANgIAIANBMGokACAADwsQnwEACyADQRxqQgE3AgAgA0ECNgIUIANBlILAADYCECADQQI2AiwgAyADQShqNgIYIAMgA0EMajYCKCADQRBqQaSCwAAQqgEAC0EBQQQQ6QEAC0EEQQgQ6QEAC9gBAQF/AkACQAJAIABBwAFxRQRAIAFBwAFxIAJBwAFxcg0DIANBwAFxDQNBvY3AAC0AABpBBEEBENIBIgVFDQEgBSADQf8BcSABQQx0QYDgP3EgAEESdEGAgPAfcXIiACACQQZ0QcD/AHFyciIBQRB0QYCA/AdxIABBCHZBgP4DcSABQYD+A3FBCHRyQQh2ckEIdCAEcjYAAEG9jcAALQAAGkEIQQQQ0gEiAEUNAiAAIAU2AgQgAEEANgIAIAAPCwwCC0EBQQQQ6QEAC0EEQQgQ6QEACxCfAQALpQEBAX8CQAJAAkAgAEHAAXFFBEAgAUHAAXENAUG9jcAALQAAGkEEQQEQ0gEiA0UNAiADIABBEnRBgIDwB3EgAUEMdEGA4D9xciIAQQh2QYD+A3EgAEGA4ANxQQh0ciACcjYAAEG9jcAALQAAGkEIQQQQ0gEiAEUNAyAAIAM2AgQgAEEANgIAIAAPCxCfAQALEJ8BAAtBAUEEEOkBAAtBBEEIEOkBAAsyAQF/Qb2NwAAtAAAaQQhBBBDSASIBRQRAQQRBCBDpAQALIAEgADoABCABQQA2AgAgAQt1AQF/AkACQCAAQcABcUUEQEG9jcAALQAAGkEEQQEQ0gEiAkUNASACIABBCnRBgPgDcSABcjYAAEG9jcAALQAAGkEIQQQQ0gEiAEUNAiAAIAI2AgQgAEEANgIAIAAPCxCfAQALQQFBBBDpAQALQQRBCBDpAQAL/AEBAn8CQAJAAkACQCADBEAgAygCAA0BIANBBWotAAAhBSADLQAEIQYgAxACIAJBwAFxIABBwAFxIAFBwAFxcnINBEG9jcAALQAAGkEEQQEQ0gEiA0UNAkG9jcAALQAAGiADIAFBDHRBgOA/cSAAQRJ0QYCA8B9xciIAIAJBBnRBwP8AcXIgBSAGQQBHQQV0cnIiAUEQdEGAgPwHcSAAQQh2QYD+A3EgAUGA/gNxQQh0ckEIdnJBCHQgBHI2AABBCEEEENIBIgBFDQMgACADNgIEIABBADYCACAADwsQ4wEACxDkAQALQQFBBBDpAQALQQRBCBDpAQALEJ8BAAvvAQEBfwJAAkACQAJAIAMEQCADKAIADQEgAy0ABCEFIAMQAiACQcABcSAAQcABcSABQcABcXJyDQRBvY3AAC0AABpBBEEBENIBIgNFDQJBvY3AAC0AABogAyABQQx0QYDgP3EgAEESdEGAgPAfcXIiACACQQZ0QcD/AHFyIAVBAEdBBXRyIgFBEHRBgICAB3EgAEEIdkGA/gNxIAFBgP4DcUEIdHJBCHZyQQh0IARyNgAAQQhBBBDSASIARQ0DIAAgAzYCBCAAQQA2AgAgAA8LEOMBAAsQ5AEAC0EBQQQQ6QEAC0EEQQgQ6QEACxCfAQALggIBAn8CQAJAAkACQCADBEAgAygCAA0BIANBBWotAAAhBSADLQAEIQYgAxACIAJBwAFxIABBwAFxIAFBwAFxcnINBEG9jcAALQAAGkEEQQEQ0gEiA0UNAkG9jcAALQAAGiADIAFBDHRBgOA/cSAAQRJ0QYCA8B9xciIAIAJBBnRBwP8AcXIgBkEAR0EEdHIgBUEAR0EFdHIiAUEQdEGAgMAHcSAAQQh2QYD+A3EgAUGA/gNxQQh0ckEIdnJBCHQgBHI2AABBCEEEENIBIgBFDQMgACADNgIEIABBADYCACAADwsQ4wEACxDkAQALQQFBBBDpAQALQQRBCBDpAQALEJ8BAAsLww0BAEGAgMAAC7kNaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZENoZWNrUmVnSWQgd2FzIGdpdmVuIGludmFsaWQgUmVnSWRmdWVsLWFzbS9zcmMvbGliLnJzAAA7ABAAEwAAAGgAAAAiAAAAVmFsdWUgYGAgb3V0IG9mIHJhbmdlIGZvciA2LWJpdCBpbW1lZGlhdGUAAABgABAABwAAAGcAEAAiAAAAOwAQABMAAACjAwAAHAAAAGAgb3V0IG9mIHJhbmdlIGZvciAxMi1iaXQgaW1tZWRpYXRlAGAAEAAHAAAArAAQACMAAAA7ABAAEwAAAKgDAAAcAAAAYCBvdXQgb2YgcmFuZ2UgZm9yIDE4LWJpdCBpbW1lZGlhdGUAYAAQAAcAAADwABAAIwAAADsAEAATAAAArQMAABwAAABgIG91dCBvZiByYW5nZSBmb3IgMjQtYml0IGltbWVkaWF0ZQBgABAABwAAADQBEAAjAAAAOwAQABMAAACyAwAAHAAAABAAAAARAAAAEgAAABMAAAAUAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAIQAAACIAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAAQwAAAEcAAABIAAAASQAAAEoAAABLAAAATAAAAFAAAABRAAAAUgAAAFMAAABUAAAAVQAAAFYAAABXAAAAWAAAAFkAAABaAAAAWwAAAFwAAABdAAAAXgAAAF8AAABgAAAAYQAAAHAAAABxAAAAcgAAAHMAAAB0AAAAdQAAAHYAAAB3AAAAeAAAAHkAAACQAAAAkQAAAJIAAACTAAAAlAAAAJUAAACWAAAAlwAAAJgAAACgAAAAoQAAAKIAAACjAAAApAAAAKUAAACmAAAApwAAAKgAAACpAAAAqgAAAKsAAACsAAAArQAAALAAAABpbnZhbGlkIGVudW0gdmFsdWUgcGFzc2VkbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAAFAAAABAAAAAQAAAAGAAAABwAAAAgAAABpbnZhbGlkIGFyZ3PIAxAADAAAAC9ydXN0Yy9jYzY2YWQ0Njg5NTU3MTdhYjkyNjAwYzc3MGRhOGMxNjAxYTRmZjMzL2xpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwDcAxAASwAAADUBAAANAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZW1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQAAABjBBAAFQAAAHgEEAANAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzmAQQABgAAABUAQAACQAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnPABBAAHAAAAFECAAAfAAAAwAQQABwAAABSAgAAHgAAAAkAAAAMAAAABAAAAAoAAAAFAAAACAAAAAQAAAALAAAABQAAAAgAAAAEAAAADAAAAA0AAAAOAAAAEAAAAAQAAAAPAAAAEAAAABEAAAAAAAAAAQAAABIAAABsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzY2FwYWNpdHkgb3ZlcmZsb3cAAABwBRAAEQAAAFQFEAAcAAAAFgIAAAUAAABpbnZhbGlkIGFyZ3OcBRAADAAAAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwCcBRAAAAAAABUAAAAAAAAAAQAAABYAAAAwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5ObAFEAAbAAAANQEAAA0Abwlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNzMuMCAoY2M2NmFkNDY4IDIwMjMtMTAtMDMpBndhbHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuBjAuMi44OAAsD3RhcmdldF9mZWF0dXJlcwIrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQ=", imports);
      }
      async function initWasm4() {
        return await __wbg_init(wasm());
      }
      initWasm4();
      exports.ADD = ADD;
      exports.ADDI = ADDI;
      exports.ALOC = ALOC;
      exports.AND = AND;
      exports.ANDI = ANDI;
      exports.BAL = BAL;
      exports.BHEI = BHEI;
      exports.BHSH = BHSH;
      exports.BURN = BURN;
      exports.CALL = CALL;
      exports.CB = CB;
      exports.CCP = CCP;
      exports.CFE = CFE;
      exports.CFEI = CFEI;
      exports.CFS = CFS;
      exports.CFSI = CFSI;
      exports.CROO = CROO;
      exports.CSIZ = CSIZ;
      exports.CompareArgs = CompareArgs;
      exports.CompareMode = CompareMode;
      exports.DIV = DIV;
      exports.DIVI = DIVI;
      exports.DivArgs = DivArgs;
      exports.ECAL = ECAL;
      exports.ECK1 = ECK1;
      exports.ECR1 = ECR1;
      exports.ED19 = ED19;
      exports.EQ = EQ;
      exports.EXP = EXP;
      exports.EXPI = EXPI;
      exports.FLAG = FLAG;
      exports.GM = GM;
      exports.GMArgs = GMArgs;
      exports.GT = GT;
      exports.GTF = GTF;
      exports.GTFArgs = GTFArgs3;
      exports.Imm06 = Imm06;
      exports.Imm12 = Imm12;
      exports.Imm18 = Imm18;
      exports.Imm24 = Imm24;
      exports.Instruction = Instruction2;
      exports.JI = JI;
      exports.JMP = JMP;
      exports.JMPB = JMPB;
      exports.JMPF = JMPF;
      exports.JNE = JNE;
      exports.JNEB = JNEB;
      exports.JNEF = JNEF;
      exports.JNEI = JNEI;
      exports.JNZB = JNZB;
      exports.JNZF = JNZF;
      exports.JNZI = JNZI;
      exports.K256 = K256;
      exports.LB = LB;
      exports.LDC = LDC;
      exports.LOG = LOG;
      exports.LOGD = LOGD;
      exports.LT = LT;
      exports.LW = LW;
      exports.MCL = MCL;
      exports.MCLI = MCLI;
      exports.MCP = MCP;
      exports.MCPI = MCPI;
      exports.MEQ = MEQ;
      exports.MINT = MINT;
      exports.MLDV = MLDV;
      exports.MLOG = MLOG;
      exports.MOD = MOD;
      exports.MODI = MODI;
      exports.MOVE = MOVE;
      exports.MOVI = MOVI;
      exports.MROO = MROO;
      exports.MUL = MUL;
      exports.MULI = MULI;
      exports.MathArgs = MathArgs;
      exports.MathOp = MathOp;
      exports.MulArgs = MulArgs;
      exports.NOOP = NOOP;
      exports.NOT = NOT;
      exports.OR = OR;
      exports.ORI = ORI;
      exports.POPH = POPH;
      exports.POPL = POPL;
      exports.PSHH = PSHH;
      exports.PSHL = PSHL;
      exports.PanicInstruction = PanicInstruction;
      exports.PanicReason = PanicReason;
      exports.RET = RET;
      exports.RETD = RETD;
      exports.RVRT = RVRT;
      exports.RegId = RegId2;
      exports.S256 = S256;
      exports.SB = SB;
      exports.SCWQ = SCWQ;
      exports.SLL = SLL;
      exports.SLLI = SLLI;
      exports.SMO = SMO;
      exports.SRL = SRL;
      exports.SRLI = SRLI;
      exports.SRW = SRW;
      exports.SRWQ = SRWQ;
      exports.SUB = SUB;
      exports.SUBI = SUBI;
      exports.SW = SW;
      exports.SWW = SWW;
      exports.SWWQ = SWWQ;
      exports.TIME = TIME;
      exports.TR = TR;
      exports.TRO = TRO;
      exports.WDAM = WDAM;
      exports.WDCM = WDCM;
      exports.WDDV = WDDV;
      exports.WDMD = WDMD;
      exports.WDML = WDML;
      exports.WDMM = WDMM;
      exports.WDOP = WDOP;
      exports.WQAM = WQAM;
      exports.WQCM = WQCM;
      exports.WQDV = WQDV;
      exports.WQMD = WQMD;
      exports.WQML = WQML;
      exports.WQMM = WQMM;
      exports.WQOP = WQOP;
      exports.XOR = XOR;
      exports.XORI = XORI;
      exports.add = add2;
      exports.addi = addi3;
      exports.aloc = aloc;
      exports.and = and;
      exports.andi = andi;
      exports.bal = bal;
      exports.bhei = bhei;
      exports.bhsh = bhsh;
      exports.burn = burn;
      exports.call = call2;
      exports.cb = cb;
      exports.ccp = ccp;
      exports.cfe = cfe;
      exports.cfei = cfei;
      exports.cfs = cfs;
      exports.cfsi = cfsi;
      exports.croo = croo;
      exports.csiz = csiz;
      exports.div = div;
      exports.divi = divi;
      exports.ecal = ecal;
      exports.eck1 = eck1;
      exports.ecr1 = ecr1;
      exports.ed19 = ed19;
      exports.eq = eq2;
      exports.exp = exp;
      exports.expi = expi;
      exports.flag = flag;
      exports.gm = gm;
      exports.gm_args = gm_args;
      exports.gt = gt2;
      exports.gtf = gtf3;
      exports.gtf_args = gtf_args;
      exports.initSync = initSync;
      exports.initWasm = initWasm4;
      exports.ji = ji;
      exports.jmp = jmp;
      exports.jmpb = jmpb;
      exports.jmpf = jmpf;
      exports.jne = jne;
      exports.jneb = jneb;
      exports.jnef = jnef;
      exports.jnei = jnei;
      exports.jnzb = jnzb;
      exports.jnzf = jnzf;
      exports.jnzi = jnzi;
      exports.k256 = k256;
      exports.lb = lb;
      exports.ldc = ldc;
      exports.log = log2;
      exports.logd = logd;
      exports.lt = lt;
      exports.lw = lw4;
      exports.mcl = mcl;
      exports.mcli = mcli;
      exports.mcp = mcp;
      exports.mcpi = mcpi;
      exports.meq = meq;
      exports.mint = mint;
      exports.mldv = mldv;
      exports.mlog = mlog;
      exports.mod_ = mod_;
      exports.modi = modi;
      exports.move_ = move_;
      exports.movi = movi2;
      exports.mroo = mroo;
      exports.mul = mul;
      exports.muli = muli2;
      exports.noop = noop;
      exports.not = not;
      exports.or = or;
      exports.ori = ori;
      exports.poph = poph;
      exports.popl = popl;
      exports.pshh = pshh;
      exports.pshl = pshl;
      exports.ret = ret4;
      exports.retd = retd2;
      exports.rvrt = rvrt;
      exports.s256 = s256;
      exports.sb = sb;
      exports.scwq = scwq;
      exports.sll = sll;
      exports.slli = slli;
      exports.smo = smo;
      exports.srl = srl;
      exports.srli = srli;
      exports.srw = srw;
      exports.srwq = srwq;
      exports.sub = sub;
      exports.subi = subi;
      exports.sw = sw;
      exports.sww = sww;
      exports.swwq = swwq;
      exports.time = time;
      exports.tr = tr3;
      exports.tro = tro;
      exports.wdam = wdam;
      exports.wdcm = wdcm;
      exports.wdcm_args = wdcm_args;
      exports.wddv = wddv;
      exports.wddv_args = wddv_args;
      exports.wdmd = wdmd;
      exports.wdml = wdml;
      exports.wdml_args = wdml_args;
      exports.wdmm = wdmm;
      exports.wdop = wdop;
      exports.wdop_args = wdop_args;
      exports.wqam = wqam;
      exports.wqcm = wqcm;
      exports.wqcm_args = wqcm_args;
      exports.wqdv = wqdv;
      exports.wqdv_args = wqdv_args;
      exports.wqmd = wqmd;
      exports.wqml = wqml;
      exports.wqml_args = wqml_args;
      exports.wqmm = wqmm;
      exports.wqop = wqop;
      exports.wqop_args = wqop_args;
      exports.xor = xor;
      exports.xori = xori;
    }
  });

  // ../../node_modules/.pnpm/async@2.6.4/node_modules/async/dist/async.js
  var require_async2 = __commonJS({
    "../../node_modules/.pnpm/async@2.6.4/node_modules/async/dist/async.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = global2.async || {});
      })(exports, function(exports2) {
        "use strict";
        function slice(arrayLike, start) {
          start = start | 0;
          var newLen = Math.max(arrayLike.length - start, 0);
          var newArr = Array(newLen);
          for (var idx = 0; idx < newLen; idx++) {
            newArr[idx] = arrayLike[start + idx];
          }
          return newArr;
        }
        var apply = function(fn) {
          var args = slice(arguments, 1);
          return function() {
            var callArgs = slice(arguments);
            return fn.apply(null, args.concat(callArgs));
          };
        };
        var initialParams = function(fn) {
          return function() {
            var args = slice(arguments);
            var callback = args.pop();
            fn.call(this, args, callback);
          };
        };
        function isObject2(value) {
          var type3 = typeof value;
          return value != null && (type3 == "object" || type3 == "function");
        }
        var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
        var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
        function fallback(fn) {
          setTimeout(fn, 0);
        }
        function wrap2(defer2) {
          return function(fn) {
            var args = slice(arguments, 1);
            defer2(function() {
              fn.apply(null, args);
            });
          };
        }
        var _defer;
        if (hasSetImmediate) {
          _defer = setImmediate;
        } else if (hasNextTick) {
          _defer = process.nextTick;
        } else {
          _defer = fallback;
        }
        var setImmediate$1 = wrap2(_defer);
        function asyncify(func) {
          return initialParams(function(args, callback) {
            var result;
            try {
              result = func.apply(this, args);
            } catch (e) {
              return callback(e);
            }
            if (isObject2(result) && typeof result.then === "function") {
              result.then(function(value) {
                invokeCallback(callback, null, value);
              }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
              });
            } else {
              callback(null, result);
            }
          });
        }
        function invokeCallback(callback, error2, value) {
          try {
            callback(error2, value);
          } catch (e) {
            setImmediate$1(rethrow, e);
          }
        }
        function rethrow(error2) {
          throw error2;
        }
        var supportsSymbol = typeof Symbol === "function";
        function isAsync(fn) {
          return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
        }
        function wrapAsync(asyncFn) {
          return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
        }
        function applyEach$1(eachfn) {
          return function(fns) {
            var args = slice(arguments, 1);
            var go = initialParams(function(args2, callback) {
              var that = this;
              return eachfn(fns, function(fn, cb) {
                wrapAsync(fn).apply(that, args2.concat(cb));
              }, callback);
            });
            if (args.length) {
              return go.apply(this, args);
            } else {
              return go;
            }
          };
        }
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var Symbol$1 = root.Symbol;
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
          try {
            value[symToStringTag$1] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag$1] = tag;
            } else {
              delete value[symToStringTag$1];
            }
          }
          return result;
        }
        var objectProto$1 = Object.prototype;
        var nativeObjectToString$1 = objectProto$1.toString;
        function objectToString(value) {
          return nativeObjectToString$1.call(value);
        }
        var nullTag = "[object Null]";
        var undefinedTag = "[object Undefined]";
        var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        var asyncTag = "[object AsyncFunction]";
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var proxyTag = "[object Proxy]";
        function isFunction(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        var MAX_SAFE_INTEGER = 9007199254740991;
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        var breakLoop = {};
        function noop() {
        }
        function once2(fn) {
          return function() {
            if (fn === null)
              return;
            var callFn = fn;
            fn = null;
            callFn.apply(this, arguments);
          };
        }
        var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
        var getIterator = function(coll) {
          return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
        };
        function baseTimes(n, iteratee) {
          var index2 = -1, result = Array(n);
          while (++index2 < n) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function isObjectLike2(value) {
          return value != null && typeof value == "object";
        }
        var argsTag = "[object Arguments]";
        function baseIsArguments(value) {
          return isObjectLike2(value) && baseGetTag(value) == argsTag;
        }
        var objectProto$3 = Object.prototype;
        var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
        var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike2(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array.isArray;
        function stubFalse() {
          return false;
        }
        var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer2 = moduleExports ? root.Buffer : void 0;
        var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
        var isBuffer = nativeIsBuffer || stubFalse;
        var MAX_SAFE_INTEGER$1 = 9007199254740991;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        function isIndex(value, length) {
          var type3 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER$1 : length;
          return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        var argsTag$1 = "[object Arguments]";
        var arrayTag = "[object Array]";
        var boolTag = "[object Boolean]";
        var dateTag = "[object Date]";
        var errorTag = "[object Error]";
        var funcTag$1 = "[object Function]";
        var mapTag = "[object Map]";
        var numberTag = "[object Number]";
        var objectTag = "[object Object]";
        var regexpTag = "[object RegExp]";
        var setTag = "[object Set]";
        var stringTag = "[object String]";
        var weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]";
        var dataViewTag = "[object DataView]";
        var float32Tag = "[object Float32Array]";
        var float64Tag = "[object Float64Array]";
        var int8Tag = "[object Int8Array]";
        var int16Tag = "[object Int16Array]";
        var int32Tag = "[object Int32Array]";
        var uint8Tag = "[object Uint8Array]";
        var uint8ClampedTag = "[object Uint8ClampedArray]";
        var uint16Tag = "[object Uint16Array]";
        var uint32Tag = "[object Uint32Array]";
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        function baseIsTypedArray(value) {
          return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        var freeExports$1 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
        var freeProcess = moduleExports$1 && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        var objectProto$2 = Object.prototype;
        var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        var objectProto$5 = Object.prototype;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
          return value === proto;
        }
        function overArg(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        var nativeKeys = overArg(Object.keys, Object);
        var objectProto$4 = Object.prototype;
        var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result = [];
          for (var key in Object(object2)) {
            if (hasOwnProperty$3.call(object2, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function keys4(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function createArrayIterator(coll) {
          var i = -1;
          var len = coll.length;
          return function next() {
            return ++i < len ? { value: coll[i], key: i } : null;
          };
        }
        function createES2015Iterator(iterator2) {
          var i = -1;
          return function next() {
            var item = iterator2.next();
            if (item.done)
              return null;
            i++;
            return { value: item.value, key: i };
          };
        }
        function createObjectIterator(obj) {
          var okeys = keys4(obj);
          var i = -1;
          var len = okeys.length;
          return function next() {
            var key = okeys[++i];
            if (key === "__proto__") {
              return next();
            }
            return i < len ? { value: obj[key], key } : null;
          };
        }
        function iterator(coll) {
          if (isArrayLike(coll)) {
            return createArrayIterator(coll);
          }
          var iterator2 = getIterator(coll);
          return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
        }
        function onlyOnce(fn) {
          return function() {
            if (fn === null)
              throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null;
            callFn.apply(this, arguments);
          };
        }
        function _eachOfLimit(limit) {
          return function(obj, iteratee, callback) {
            callback = once2(callback || noop);
            if (limit <= 0 || !obj) {
              return callback(null);
            }
            var nextElem = iterator(obj);
            var done = false;
            var running = 0;
            var looping = false;
            function iterateeCallback(err, value) {
              running -= 1;
              if (err) {
                done = true;
                callback(err);
              } else if (value === breakLoop || done && running <= 0) {
                done = true;
                return callback(null);
              } else if (!looping) {
                replenish();
              }
            }
            function replenish() {
              looping = true;
              while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                  done = true;
                  if (running <= 0) {
                    callback(null);
                  }
                  return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
              }
              looping = false;
            }
            replenish();
          };
        }
        function eachOfLimit(coll, limit, iteratee, callback) {
          _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
        }
        function doLimit(fn, limit) {
          return function(iterable, iteratee, callback) {
            return fn(iterable, limit, iteratee, callback);
          };
        }
        function eachOfArrayLike(coll, iteratee, callback) {
          callback = once2(callback || noop);
          var index2 = 0, completed = 0, length = coll.length;
          if (length === 0) {
            callback(null);
          }
          function iteratorCallback(err, value) {
            if (err) {
              callback(err);
            } else if (++completed === length || value === breakLoop) {
              callback(null);
            }
          }
          for (; index2 < length; index2++) {
            iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
          }
        }
        var eachOfGeneric = doLimit(eachOfLimit, Infinity);
        var eachOf = function(coll, iteratee, callback) {
          var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
          eachOfImplementation(coll, wrapAsync(iteratee), callback);
        };
        function doParallel(fn) {
          return function(obj, iteratee, callback) {
            return fn(eachOf, obj, wrapAsync(iteratee), callback);
          };
        }
        function _asyncMap(eachfn, arr, iteratee, callback) {
          callback = callback || noop;
          arr = arr || [];
          var results = [];
          var counter = 0;
          var _iteratee = wrapAsync(iteratee);
          eachfn(arr, function(value, _, callback2) {
            var index2 = counter++;
            _iteratee(value, function(err, v) {
              results[index2] = v;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
        var map2 = doParallel(_asyncMap);
        var applyEach = applyEach$1(map2);
        function doParallelLimit(fn) {
          return function(obj, limit, iteratee, callback) {
            return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
          };
        }
        var mapLimit = doParallelLimit(_asyncMap);
        var mapSeries = doLimit(mapLimit, 1);
        var applyEachSeries = applyEach$1(mapSeries);
        function arrayEach(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (iteratee(array2[index2], index2, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee, keysFunc) {
            var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        var baseFor = createBaseFor();
        function baseForOwn(object2, iteratee) {
          return object2 && baseFor(object2, iteratee, keys4);
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        var auto = function(tasks, concurrency, callback) {
          if (typeof concurrency === "function") {
            callback = concurrency;
            concurrency = null;
          }
          callback = once2(callback || noop);
          var keys$$1 = keys4(tasks);
          var numTasks = keys$$1.length;
          if (!numTasks) {
            return callback(null);
          }
          if (!concurrency) {
            concurrency = numTasks;
          }
          var results = {};
          var runningTasks = 0;
          var hasError = false;
          var listeners = /* @__PURE__ */ Object.create(null);
          var readyTasks = [];
          var readyToCheck = [];
          var uncheckedDependencies = {};
          baseForOwn(tasks, function(task, key) {
            if (!isArray(task)) {
              enqueueTask(key, [task]);
              readyToCheck.push(key);
              return;
            }
            var dependencies = task.slice(0, task.length - 1);
            var remainingDependencies = dependencies.length;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
              readyToCheck.push(key);
              return;
            }
            uncheckedDependencies[key] = remainingDependencies;
            arrayEach(dependencies, function(dependencyName) {
              if (!tasks[dependencyName]) {
                throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
              }
              addListener(dependencyName, function() {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                  enqueueTask(key, task);
                }
              });
            });
          });
          checkForDeadlocks();
          processQueue();
          function enqueueTask(key, task) {
            readyTasks.push(function() {
              runTask(key, task);
            });
          }
          function processQueue() {
            if (readyTasks.length === 0 && runningTasks === 0) {
              return callback(null, results);
            }
            while (readyTasks.length && runningTasks < concurrency) {
              var run2 = readyTasks.shift();
              run2();
            }
          }
          function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            if (!taskListeners) {
              taskListeners = listeners[taskName] = [];
            }
            taskListeners.push(fn);
          }
          function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            arrayEach(taskListeners, function(fn) {
              fn();
            });
            processQueue();
          }
          function runTask(key, task) {
            if (hasError)
              return;
            var taskCallback = onlyOnce(function(err, result) {
              runningTasks--;
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              }
              if (err) {
                var safeResults = {};
                baseForOwn(results, function(val, rkey) {
                  safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = /* @__PURE__ */ Object.create(null);
                callback(err, safeResults);
              } else {
                results[key] = result;
                taskComplete(key);
              }
            });
            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            if (task.length > 1) {
              taskFn(results, taskCallback);
            } else {
              taskFn(taskCallback);
            }
          }
          function checkForDeadlocks() {
            var currentTask;
            var counter = 0;
            while (readyToCheck.length) {
              currentTask = readyToCheck.pop();
              counter++;
              arrayEach(getDependents(currentTask), function(dependent) {
                if (--uncheckedDependencies[dependent] === 0) {
                  readyToCheck.push(dependent);
                }
              });
            }
            if (counter !== numTasks) {
              throw new Error(
                "async.auto cannot execute tasks due to a recursive dependency"
              );
            }
          }
          function getDependents(taskName) {
            var result = [];
            baseForOwn(tasks, function(task, key) {
              if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
                result.push(key);
              }
            });
            return result;
          }
        };
        function arrayMap(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array2[index2], index2, array2);
          }
          return result;
        }
        var symbolTag = "[object Symbol]";
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
        }
        var INFINITY = 1 / 0;
        var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
        var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString2 ? symbolToString2.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function baseSlice(array2, start, end) {
          var index2 = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index2 < length) {
            result[index2] = array2[index2 + start];
          }
          return result;
        }
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === void 0 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function asciiToArray(string2) {
          return string2.split("");
        }
        var rsAstralRange = "\\ud800-\\udfff";
        var rsComboMarksRange = "\\u0300-\\u036f";
        var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange = "\\u20d0-\\u20ff";
        var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
        var rsVarRange = "\\ufe0e\\ufe0f";
        var rsZWJ = "\\u200d";
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        var rsAstralRange$1 = "\\ud800-\\udfff";
        var rsComboMarksRange$1 = "\\u0300-\\u036f";
        var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
        var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
        var rsVarRange$1 = "\\ufe0e\\ufe0f";
        var rsAstral = "[" + rsAstralRange$1 + "]";
        var rsCombo = "[" + rsComboRange$1 + "]";
        var rsFitz = "\\ud83c[\\udffb-\\udfff]";
        var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
        var rsNonAstral = "[^" + rsAstralRange$1 + "]";
        var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
        var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
        var rsZWJ$1 = "\\u200d";
        var reOptMod = rsModifier + "?";
        var rsOptVar = "[" + rsVarRange$1 + "]?";
        var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
        var rsSeq = rsOptVar + reOptMod + rsOptJoin;
        var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        function toString3(value) {
          return value == null ? "" : baseToString(value);
        }
        var reTrim = /^\s+|\s+$/g;
        function trim2(string2, chars, guard) {
          string2 = toString3(string2);
          if (string2 && (guard || chars === void 0)) {
            return string2.replace(reTrim, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
        var FN_ARG_SPLIT = /,/;
        var FN_ARG = /(=.+)?(\s*)$/;
        var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
        function parseParams(func) {
          func = func.toString().replace(STRIP_COMMENTS, "");
          func = func.match(FN_ARGS)[2].replace(" ", "");
          func = func ? func.split(FN_ARG_SPLIT) : [];
          func = func.map(function(arg) {
            return trim2(arg.replace(FN_ARG, ""));
          });
          return func;
        }
        function autoInject(tasks, callback) {
          var newTasks = {};
          baseForOwn(tasks, function(taskFn, key) {
            var params;
            var fnIsAsync = isAsync(taskFn);
            var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
            if (isArray(taskFn)) {
              params = taskFn.slice(0, -1);
              taskFn = taskFn[taskFn.length - 1];
              newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
            } else if (hasNoDeps) {
              newTasks[key] = taskFn;
            } else {
              params = parseParams(taskFn);
              if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
              }
              if (!fnIsAsync)
                params.pop();
              newTasks[key] = params.concat(newTask);
            }
            function newTask(results, taskCb) {
              var newArgs = arrayMap(params, function(name) {
                return results[name];
              });
              newArgs.push(taskCb);
              wrapAsync(taskFn).apply(null, newArgs);
            }
          });
          auto(newTasks, callback);
        }
        function DLL() {
          this.head = this.tail = null;
          this.length = 0;
        }
        function setInitial(dll, node) {
          dll.length = 1;
          dll.head = dll.tail = node;
        }
        DLL.prototype.removeLink = function(node) {
          if (node.prev)
            node.prev.next = node.next;
          else
            this.head = node.next;
          if (node.next)
            node.next.prev = node.prev;
          else
            this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        };
        DLL.prototype.empty = function() {
          while (this.head)
            this.shift();
          return this;
        };
        DLL.prototype.insertAfter = function(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next)
            node.next.prev = newNode;
          else
            this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        };
        DLL.prototype.insertBefore = function(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev)
            node.prev.next = newNode;
          else
            this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        };
        DLL.prototype.unshift = function(node) {
          if (this.head)
            this.insertBefore(this.head, node);
          else
            setInitial(this, node);
        };
        DLL.prototype.push = function(node) {
          if (this.tail)
            this.insertAfter(this.tail, node);
          else
            setInitial(this, node);
        };
        DLL.prototype.shift = function() {
          return this.head && this.removeLink(this.head);
        };
        DLL.prototype.pop = function() {
          return this.tail && this.removeLink(this.tail);
        };
        DLL.prototype.toArray = function() {
          var arr = Array(this.length);
          var curr = this.head;
          for (var idx = 0; idx < this.length; idx++) {
            arr[idx] = curr.data;
            curr = curr.next;
          }
          return arr;
        };
        DLL.prototype.remove = function(testFn) {
          var curr = this.head;
          while (!!curr) {
            var next = curr.next;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        };
        function queue(worker, concurrency, payload) {
          if (concurrency == null) {
            concurrency = 1;
          } else if (concurrency === 0) {
            throw new Error("Concurrency must not be zero");
          }
          var _worker = wrapAsync(worker);
          var numRunning = 0;
          var workersList = [];
          var processingScheduled = false;
          function _insert(data, insertAtFront, callback) {
            if (callback != null && typeof callback !== "function") {
              throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!isArray(data)) {
              data = [data];
            }
            if (data.length === 0 && q.idle()) {
              return setImmediate$1(function() {
                q.drain();
              });
            }
            for (var i = 0, l = data.length; i < l; i++) {
              var item = {
                data: data[i],
                callback: callback || noop
              };
              if (insertAtFront) {
                q._tasks.unshift(item);
              } else {
                q._tasks.push(item);
              }
            }
            if (!processingScheduled) {
              processingScheduled = true;
              setImmediate$1(function() {
                processingScheduled = false;
                q.process();
              });
            }
          }
          function _next(tasks) {
            return function(err) {
              numRunning -= 1;
              for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];
                var index2 = baseIndexOf(workersList, task, 0);
                if (index2 === 0) {
                  workersList.shift();
                } else if (index2 > 0) {
                  workersList.splice(index2, 1);
                }
                task.callback.apply(task, arguments);
                if (err != null) {
                  q.error(err, task.data);
                }
              }
              if (numRunning <= q.concurrency - q.buffer) {
                q.unsaturated();
              }
              if (q.idle()) {
                q.drain();
              }
              q.process();
            };
          }
          var isProcessing = false;
          var q = {
            _tasks: new DLL(),
            concurrency,
            payload,
            saturated: noop,
            unsaturated: noop,
            buffer: concurrency / 4,
            empty: noop,
            drain: noop,
            error: noop,
            started: false,
            paused: false,
            push: function(data, callback) {
              _insert(data, false, callback);
            },
            kill: function() {
              q.drain = noop;
              q._tasks.empty();
            },
            unshift: function(data, callback) {
              _insert(data, true, callback);
            },
            remove: function(testFn) {
              q._tasks.remove(testFn);
            },
            process: function() {
              if (isProcessing) {
                return;
              }
              isProcessing = true;
              while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload)
                  l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                  var node = q._tasks.shift();
                  tasks.push(node);
                  workersList.push(node);
                  data.push(node.data);
                }
                numRunning += 1;
                if (q._tasks.length === 0) {
                  q.empty();
                }
                if (numRunning === q.concurrency) {
                  q.saturated();
                }
                var cb = onlyOnce(_next(tasks));
                _worker(data, cb);
              }
              isProcessing = false;
            },
            length: function() {
              return q._tasks.length;
            },
            running: function() {
              return numRunning;
            },
            workersList: function() {
              return workersList;
            },
            idle: function() {
              return q._tasks.length + numRunning === 0;
            },
            pause: function() {
              q.paused = true;
            },
            resume: function() {
              if (q.paused === false) {
                return;
              }
              q.paused = false;
              setImmediate$1(q.process);
            }
          };
          return q;
        }
        function cargo(worker, payload) {
          return queue(worker, 1, payload);
        }
        var eachOfSeries = doLimit(eachOfLimit, 1);
        function reduce(coll, memo, iteratee, callback) {
          callback = once2(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          eachOfSeries(coll, function(x, i, callback2) {
            _iteratee(memo, x, function(err, v) {
              memo = v;
              callback2(err);
            });
          }, function(err) {
            callback(err, memo);
          });
        }
        function seq() {
          var _functions = arrayMap(arguments, wrapAsync);
          return function() {
            var args = slice(arguments);
            var that = this;
            var cb = args[args.length - 1];
            if (typeof cb == "function") {
              args.pop();
            } else {
              cb = noop;
            }
            reduce(
              _functions,
              args,
              function(newargs, fn, cb2) {
                fn.apply(that, newargs.concat(function(err) {
                  var nextargs = slice(arguments, 1);
                  cb2(err, nextargs);
                }));
              },
              function(err, results) {
                cb.apply(that, [err].concat(results));
              }
            );
          };
        }
        var compose2 = function() {
          return seq.apply(null, slice(arguments).reverse());
        };
        var _concat2 = Array.prototype.concat;
        var concatLimit = function(coll, limit, iteratee, callback) {
          callback = callback || noop;
          var _iteratee = wrapAsync(iteratee);
          mapLimit(coll, limit, function(val, callback2) {
            _iteratee(val, function(err) {
              if (err)
                return callback2(err);
              return callback2(null, slice(arguments, 1));
            });
          }, function(err, mapResults) {
            var result = [];
            for (var i = 0; i < mapResults.length; i++) {
              if (mapResults[i]) {
                result = _concat2.apply(result, mapResults[i]);
              }
            }
            return callback(err, result);
          });
        };
        var concat3 = doLimit(concatLimit, Infinity);
        var concatSeries = doLimit(concatLimit, 1);
        var constant = function() {
          var values = slice(arguments);
          var args = [null].concat(values);
          return function() {
            var callback = arguments[arguments.length - 1];
            return callback.apply(this, args);
          };
        };
        function identity2(value) {
          return value;
        }
        function _createTester(check, getResult) {
          return function(eachfn, arr, iteratee, cb) {
            cb = cb || noop;
            var testPassed = false;
            var testResult;
            eachfn(arr, function(value, _, callback) {
              iteratee(value, function(err, result) {
                if (err) {
                  callback(err);
                } else if (check(result) && !testResult) {
                  testPassed = true;
                  testResult = getResult(true, value);
                  callback(null, breakLoop);
                } else {
                  callback();
                }
              });
            }, function(err) {
              if (err) {
                cb(err);
              } else {
                cb(null, testPassed ? testResult : getResult(false));
              }
            });
          };
        }
        function _findGetResult(v, x) {
          return x;
        }
        var detect = doParallel(_createTester(identity2, _findGetResult));
        var detectLimit = doParallelLimit(_createTester(identity2, _findGetResult));
        var detectSeries = doLimit(detectLimit, 1);
        function consoleFunc(name) {
          return function(fn) {
            var args = slice(arguments, 1);
            args.push(function(err) {
              var args2 = slice(arguments, 1);
              if (typeof console === "object") {
                if (err) {
                  if (console.error) {
                    console.error(err);
                  }
                } else if (console[name]) {
                  arrayEach(args2, function(x) {
                    console[name](x);
                  });
                }
              }
            });
            wrapAsync(fn).apply(null, args);
          };
        }
        var dir = consoleFunc("dir");
        function doDuring(fn, test, callback) {
          callback = onlyOnce(callback || noop);
          var _fn = wrapAsync(fn);
          var _test = wrapAsync(test);
          function next(err) {
            if (err)
              return callback(err);
            var args = slice(arguments, 1);
            args.push(check);
            _test.apply(this, args);
          }
          function check(err, truth) {
            if (err)
              return callback(err);
            if (!truth)
              return callback(null);
            _fn(next);
          }
          check(null, true);
        }
        function doWhilst(iteratee, test, callback) {
          callback = onlyOnce(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          var next = function(err) {
            if (err)
              return callback(err);
            var args = slice(arguments, 1);
            if (test.apply(this, args))
              return _iteratee(next);
            callback.apply(null, [null].concat(args));
          };
          _iteratee(next);
        }
        function doUntil(iteratee, test, callback) {
          doWhilst(iteratee, function() {
            return !test.apply(this, arguments);
          }, callback);
        }
        function during(test, fn, callback) {
          callback = onlyOnce(callback || noop);
          var _fn = wrapAsync(fn);
          var _test = wrapAsync(test);
          function next(err) {
            if (err)
              return callback(err);
            _test(check);
          }
          function check(err, truth) {
            if (err)
              return callback(err);
            if (!truth)
              return callback(null);
            _fn(next);
          }
          _test(check);
        }
        function _withoutIndex(iteratee) {
          return function(value, index2, callback) {
            return iteratee(value, callback);
          };
        }
        function eachLimit(coll, iteratee, callback) {
          eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
        }
        function eachLimit$1(coll, limit, iteratee, callback) {
          _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
        }
        var eachSeries = doLimit(eachLimit$1, 1);
        function ensureAsync(fn) {
          if (isAsync(fn))
            return fn;
          return initialParams(function(args, callback) {
            var sync2 = true;
            args.push(function() {
              var innerArgs = arguments;
              if (sync2) {
                setImmediate$1(function() {
                  callback.apply(null, innerArgs);
                });
              } else {
                callback.apply(null, innerArgs);
              }
            });
            fn.apply(this, args);
            sync2 = false;
          });
        }
        function notId(v) {
          return !v;
        }
        var every = doParallel(_createTester(notId, notId));
        var everyLimit = doParallelLimit(_createTester(notId, notId));
        var everySeries = doLimit(everyLimit, 1);
        function baseProperty(key) {
          return function(object2) {
            return object2 == null ? void 0 : object2[key];
          };
        }
        function filterArray(eachfn, arr, iteratee, callback) {
          var truthValues = new Array(arr.length);
          eachfn(arr, function(x, index2, callback2) {
            iteratee(x, function(err, v) {
              truthValues[index2] = !!v;
              callback2(err);
            });
          }, function(err) {
            if (err)
              return callback(err);
            var results = [];
            for (var i = 0; i < arr.length; i++) {
              if (truthValues[i])
                results.push(arr[i]);
            }
            callback(null, results);
          });
        }
        function filterGeneric(eachfn, coll, iteratee, callback) {
          var results = [];
          eachfn(coll, function(x, index2, callback2) {
            iteratee(x, function(err, v) {
              if (err) {
                callback2(err);
              } else {
                if (v) {
                  results.push({ index: index2, value: x });
                }
                callback2();
              }
            });
          }, function(err) {
            if (err) {
              callback(err);
            } else {
              callback(null, arrayMap(results.sort(function(a, b) {
                return a.index - b.index;
              }), baseProperty("value")));
            }
          });
        }
        function _filter2(eachfn, coll, iteratee, callback) {
          var filter3 = isArrayLike(coll) ? filterArray : filterGeneric;
          filter3(eachfn, coll, wrapAsync(iteratee), callback || noop);
        }
        var filter2 = doParallel(_filter2);
        var filterLimit = doParallelLimit(_filter2);
        var filterSeries = doLimit(filterLimit, 1);
        function forever(fn, errback) {
          var done = onlyOnce(errback || noop);
          var task = wrapAsync(ensureAsync(fn));
          function next(err) {
            if (err)
              return done(err);
            task(next);
          }
          next();
        }
        var groupByLimit = function(coll, limit, iteratee, callback) {
          callback = callback || noop;
          var _iteratee = wrapAsync(iteratee);
          mapLimit(coll, limit, function(val, callback2) {
            _iteratee(val, function(err, key) {
              if (err)
                return callback2(err);
              return callback2(null, { key, val });
            });
          }, function(err, mapResults) {
            var result = {};
            var hasOwnProperty2 = Object.prototype.hasOwnProperty;
            for (var i = 0; i < mapResults.length; i++) {
              if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;
                if (hasOwnProperty2.call(result, key)) {
                  result[key].push(val);
                } else {
                  result[key] = [val];
                }
              }
            }
            return callback(err, result);
          });
        };
        var groupBy = doLimit(groupByLimit, Infinity);
        var groupBySeries = doLimit(groupByLimit, 1);
        var log2 = consoleFunc("log");
        function mapValuesLimit(obj, limit, iteratee, callback) {
          callback = once2(callback || noop);
          var newObj = {};
          var _iteratee = wrapAsync(iteratee);
          eachOfLimit(obj, limit, function(val, key, next) {
            _iteratee(val, key, function(err, result) {
              if (err)
                return next(err);
              newObj[key] = result;
              next();
            });
          }, function(err) {
            callback(err, newObj);
          });
        }
        var mapValues3 = doLimit(mapValuesLimit, Infinity);
        var mapValuesSeries = doLimit(mapValuesLimit, 1);
        function has4(obj, key) {
          return key in obj;
        }
        function memoize(fn, hasher) {
          var memo = /* @__PURE__ */ Object.create(null);
          var queues = /* @__PURE__ */ Object.create(null);
          hasher = hasher || identity2;
          var _fn = wrapAsync(fn);
          var memoized = initialParams(function memoized2(args, callback) {
            var key = hasher.apply(null, args);
            if (has4(memo, key)) {
              setImmediate$1(function() {
                callback.apply(null, memo[key]);
              });
            } else if (has4(queues, key)) {
              queues[key].push(callback);
            } else {
              queues[key] = [callback];
              _fn.apply(null, args.concat(function() {
                var args2 = slice(arguments);
                memo[key] = args2;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                  q[i].apply(null, args2);
                }
              }));
            }
          });
          memoized.memo = memo;
          memoized.unmemoized = fn;
          return memoized;
        }
        var _defer$1;
        if (hasNextTick) {
          _defer$1 = process.nextTick;
        } else if (hasSetImmediate) {
          _defer$1 = setImmediate;
        } else {
          _defer$1 = fallback;
        }
        var nextTick = wrap2(_defer$1);
        function _parallel(eachfn, tasks, callback) {
          callback = callback || noop;
          var results = isArrayLike(tasks) ? [] : {};
          eachfn(tasks, function(task, key, callback2) {
            wrapAsync(task)(function(err, result) {
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              }
              results[key] = result;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
        function parallelLimit(tasks, callback) {
          _parallel(eachOf, tasks, callback);
        }
        function parallelLimit$1(tasks, limit, callback) {
          _parallel(_eachOfLimit(limit), tasks, callback);
        }
        var queue$1 = function(worker, concurrency) {
          var _worker = wrapAsync(worker);
          return queue(function(items, cb) {
            _worker(items[0], cb);
          }, concurrency, 1);
        };
        var priorityQueue = function(worker, concurrency) {
          var q = queue$1(worker, concurrency);
          q.push = function(data, priority, callback) {
            if (callback == null)
              callback = noop;
            if (typeof callback !== "function") {
              throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!isArray(data)) {
              data = [data];
            }
            if (data.length === 0) {
              return setImmediate$1(function() {
                q.drain();
              });
            }
            priority = priority || 0;
            var nextNode = q._tasks.head;
            while (nextNode && priority >= nextNode.priority) {
              nextNode = nextNode.next;
            }
            for (var i = 0, l = data.length; i < l; i++) {
              var item = {
                data: data[i],
                priority,
                callback
              };
              if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
              } else {
                q._tasks.push(item);
              }
            }
            setImmediate$1(q.process);
          };
          delete q.unshift;
          return q;
        };
        function race(tasks, callback) {
          callback = once2(callback || noop);
          if (!isArray(tasks))
            return callback(new TypeError("First argument to race must be an array of functions"));
          if (!tasks.length)
            return callback();
          for (var i = 0, l = tasks.length; i < l; i++) {
            wrapAsync(tasks[i])(callback);
          }
        }
        function reduceRight(array2, memo, iteratee, callback) {
          var reversed = slice(array2).reverse();
          reduce(reversed, memo, iteratee, callback);
        }
        function reflect(fn) {
          var _fn = wrapAsync(fn);
          return initialParams(function reflectOn(args, reflectCallback) {
            args.push(function callback(error2, cbArg) {
              if (error2) {
                reflectCallback(null, { error: error2 });
              } else {
                var value;
                if (arguments.length <= 2) {
                  value = cbArg;
                } else {
                  value = slice(arguments, 1);
                }
                reflectCallback(null, { value });
              }
            });
            return _fn.apply(this, args);
          });
        }
        function reflectAll(tasks) {
          var results;
          if (isArray(tasks)) {
            results = arrayMap(tasks, reflect);
          } else {
            results = {};
            baseForOwn(tasks, function(task, key) {
              results[key] = reflect.call(this, task);
            });
          }
          return results;
        }
        function reject$1(eachfn, arr, iteratee, callback) {
          _filter2(eachfn, arr, function(value, cb) {
            iteratee(value, function(err, v) {
              cb(err, !v);
            });
          }, callback);
        }
        var reject = doParallel(reject$1);
        var rejectLimit = doParallelLimit(reject$1);
        var rejectSeries = doLimit(rejectLimit, 1);
        function constant$1(value) {
          return function() {
            return value;
          };
        }
        function retry(opts, task, callback) {
          var DEFAULT_TIMES = 5;
          var DEFAULT_INTERVAL = 0;
          var options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
          };
          function parseTimes(acc, t) {
            if (typeof t === "object") {
              acc.times = +t.times || DEFAULT_TIMES;
              acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
              acc.errorFilter = t.errorFilter;
            } else if (typeof t === "number" || typeof t === "string") {
              acc.times = +t || DEFAULT_TIMES;
            } else {
              throw new Error("Invalid arguments for async.retry");
            }
          }
          if (arguments.length < 3 && typeof opts === "function") {
            callback = task || noop;
            task = opts;
          } else {
            parseTimes(options, opts);
            callback = callback || noop;
          }
          if (typeof task !== "function") {
            throw new Error("Invalid arguments for async.retry");
          }
          var _task = wrapAsync(task);
          var attempt = 1;
          function retryAttempt() {
            _task(function(err) {
              if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
              } else {
                callback.apply(null, arguments);
              }
            });
          }
          retryAttempt();
        }
        var retryable = function(opts, task) {
          if (!task) {
            task = opts;
            opts = null;
          }
          var _task = wrapAsync(task);
          return initialParams(function(args, callback) {
            function taskFn(cb) {
              _task.apply(null, args.concat(cb));
            }
            if (opts)
              retry(opts, taskFn, callback);
            else
              retry(taskFn, callback);
          });
        };
        function series(tasks, callback) {
          _parallel(eachOfSeries, tasks, callback);
        }
        var some = doParallel(_createTester(Boolean, identity2));
        var someLimit = doParallelLimit(_createTester(Boolean, identity2));
        var someSeries = doLimit(someLimit, 1);
        function sortBy(coll, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          map2(coll, function(x, callback2) {
            _iteratee(x, function(err, criteria) {
              if (err)
                return callback2(err);
              callback2(null, { value: x, criteria });
            });
          }, function(err, results) {
            if (err)
              return callback(err);
            callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
          });
          function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
          }
        }
        function timeout(asyncFn, milliseconds, info) {
          var fn = wrapAsync(asyncFn);
          return initialParams(function(args, callback) {
            var timedOut = false;
            var timer;
            function timeoutCallback() {
              var name = asyncFn.name || "anonymous";
              var error2 = new Error('Callback function "' + name + '" timed out.');
              error2.code = "ETIMEDOUT";
              if (info) {
                error2.info = info;
              }
              timedOut = true;
              callback(error2);
            }
            args.push(function() {
              if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
              }
            });
            timer = setTimeout(timeoutCallback, milliseconds);
            fn.apply(null, args);
          });
        }
        var nativeCeil = Math.ceil;
        var nativeMax = Math.max;
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
          while (length--) {
            result[fromRight ? length : ++index2] = start;
            start += step;
          }
          return result;
        }
        function timeLimit(count, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
        }
        var times = doLimit(timeLimit, Infinity);
        var timesSeries = doLimit(timeLimit, 1);
        function transform(coll, accumulator, iteratee, callback) {
          if (arguments.length <= 3) {
            callback = iteratee;
            iteratee = accumulator;
            accumulator = isArray(coll) ? [] : {};
          }
          callback = once2(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          eachOf(coll, function(v, k, cb) {
            _iteratee(accumulator, v, k, cb);
          }, function(err) {
            callback(err, accumulator);
          });
        }
        function tryEach(tasks, callback) {
          var error2 = null;
          var result;
          callback = callback || noop;
          eachSeries(tasks, function(task, callback2) {
            wrapAsync(task)(function(err, res) {
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              } else {
                result = res;
              }
              error2 = err;
              callback2(!err);
            });
          }, function() {
            callback(error2, result);
          });
        }
        function unmemoize(fn) {
          return function() {
            return (fn.unmemoized || fn).apply(null, arguments);
          };
        }
        function whilst(test, iteratee, callback) {
          callback = onlyOnce(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          if (!test())
            return callback(null);
          var next = function(err) {
            if (err)
              return callback(err);
            if (test())
              return _iteratee(next);
            var args = slice(arguments, 1);
            callback.apply(null, [null].concat(args));
          };
          _iteratee(next);
        }
        function until(test, iteratee, callback) {
          whilst(function() {
            return !test.apply(this, arguments);
          }, iteratee, callback);
        }
        var waterfall = function(tasks, callback) {
          callback = once2(callback || noop);
          if (!isArray(tasks))
            return callback(new Error("First argument to waterfall must be an array of functions"));
          if (!tasks.length)
            return callback();
          var taskIndex = 0;
          function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            args.push(onlyOnce(next));
            task.apply(null, args);
          }
          function next(err) {
            if (err || taskIndex === tasks.length) {
              return callback.apply(null, arguments);
            }
            nextTask(slice(arguments, 1));
          }
          nextTask([]);
        };
        var index = {
          apply,
          applyEach,
          applyEachSeries,
          asyncify,
          auto,
          autoInject,
          cargo,
          compose: compose2,
          concat: concat3,
          concatLimit,
          concatSeries,
          constant,
          detect,
          detectLimit,
          detectSeries,
          dir,
          doDuring,
          doUntil,
          doWhilst,
          during,
          each: eachLimit,
          eachLimit: eachLimit$1,
          eachOf,
          eachOfLimit,
          eachOfSeries,
          eachSeries,
          ensureAsync,
          every,
          everyLimit,
          everySeries,
          filter: filter2,
          filterLimit,
          filterSeries,
          forever,
          groupBy,
          groupByLimit,
          groupBySeries,
          log: log2,
          map: map2,
          mapLimit,
          mapSeries,
          mapValues: mapValues3,
          mapValuesLimit,
          mapValuesSeries,
          memoize,
          nextTick,
          parallel: parallelLimit,
          parallelLimit: parallelLimit$1,
          priorityQueue,
          queue: queue$1,
          race,
          reduce,
          reduceRight,
          reflect,
          reflectAll,
          reject,
          rejectLimit,
          rejectSeries,
          retry,
          retryable,
          seq,
          series,
          setImmediate: setImmediate$1,
          some,
          someLimit,
          someSeries,
          sortBy,
          timeout,
          times,
          timesLimit: timeLimit,
          timesSeries,
          transform,
          tryEach,
          unmemoize,
          until,
          waterfall,
          whilst,
          // aliases
          all: every,
          allLimit: everyLimit,
          allSeries: everySeries,
          any: some,
          anyLimit: someLimit,
          anySeries: someSeries,
          find: detect,
          findLimit: detectLimit,
          findSeries: detectSeries,
          forEach: eachLimit,
          forEachSeries: eachSeries,
          forEachLimit: eachLimit$1,
          forEachOf: eachOf,
          forEachOfSeries: eachOfSeries,
          forEachOfLimit: eachOfLimit,
          inject: reduce,
          foldl: reduce,
          foldr: reduceRight,
          select: filter2,
          selectLimit: filterLimit,
          selectSeries: filterSeries,
          wrapSync: asyncify
        };
        exports2["default"] = index;
        exports2.apply = apply;
        exports2.applyEach = applyEach;
        exports2.applyEachSeries = applyEachSeries;
        exports2.asyncify = asyncify;
        exports2.auto = auto;
        exports2.autoInject = autoInject;
        exports2.cargo = cargo;
        exports2.compose = compose2;
        exports2.concat = concat3;
        exports2.concatLimit = concatLimit;
        exports2.concatSeries = concatSeries;
        exports2.constant = constant;
        exports2.detect = detect;
        exports2.detectLimit = detectLimit;
        exports2.detectSeries = detectSeries;
        exports2.dir = dir;
        exports2.doDuring = doDuring;
        exports2.doUntil = doUntil;
        exports2.doWhilst = doWhilst;
        exports2.during = during;
        exports2.each = eachLimit;
        exports2.eachLimit = eachLimit$1;
        exports2.eachOf = eachOf;
        exports2.eachOfLimit = eachOfLimit;
        exports2.eachOfSeries = eachOfSeries;
        exports2.eachSeries = eachSeries;
        exports2.ensureAsync = ensureAsync;
        exports2.every = every;
        exports2.everyLimit = everyLimit;
        exports2.everySeries = everySeries;
        exports2.filter = filter2;
        exports2.filterLimit = filterLimit;
        exports2.filterSeries = filterSeries;
        exports2.forever = forever;
        exports2.groupBy = groupBy;
        exports2.groupByLimit = groupByLimit;
        exports2.groupBySeries = groupBySeries;
        exports2.log = log2;
        exports2.map = map2;
        exports2.mapLimit = mapLimit;
        exports2.mapSeries = mapSeries;
        exports2.mapValues = mapValues3;
        exports2.mapValuesLimit = mapValuesLimit;
        exports2.mapValuesSeries = mapValuesSeries;
        exports2.memoize = memoize;
        exports2.nextTick = nextTick;
        exports2.parallel = parallelLimit;
        exports2.parallelLimit = parallelLimit$1;
        exports2.priorityQueue = priorityQueue;
        exports2.queue = queue$1;
        exports2.race = race;
        exports2.reduce = reduce;
        exports2.reduceRight = reduceRight;
        exports2.reflect = reflect;
        exports2.reflectAll = reflectAll;
        exports2.reject = reject;
        exports2.rejectLimit = rejectLimit;
        exports2.rejectSeries = rejectSeries;
        exports2.retry = retry;
        exports2.retryable = retryable;
        exports2.seq = seq;
        exports2.series = series;
        exports2.setImmediate = setImmediate$1;
        exports2.some = some;
        exports2.someLimit = someLimit;
        exports2.someSeries = someSeries;
        exports2.sortBy = sortBy;
        exports2.timeout = timeout;
        exports2.times = times;
        exports2.timesLimit = timeLimit;
        exports2.timesSeries = timesSeries;
        exports2.transform = transform;
        exports2.tryEach = tryEach;
        exports2.unmemoize = unmemoize;
        exports2.until = until;
        exports2.waterfall = waterfall;
        exports2.whilst = whilst;
        exports2.all = every;
        exports2.allLimit = everyLimit;
        exports2.allSeries = everySeries;
        exports2.any = some;
        exports2.anyLimit = someLimit;
        exports2.anySeries = someSeries;
        exports2.find = detect;
        exports2.findLimit = detectLimit;
        exports2.findSeries = detectSeries;
        exports2.forEach = eachLimit;
        exports2.forEachSeries = eachSeries;
        exports2.forEachLimit = eachLimit$1;
        exports2.forEachOf = eachOf;
        exports2.forEachOfSeries = eachOfSeries;
        exports2.forEachOfLimit = eachOfLimit;
        exports2.inject = reduce;
        exports2.foldl = reduce;
        exports2.foldr = reduceRight;
        exports2.select = filter2;
        exports2.selectLimit = filterLimit;
        exports2.selectSeries = filterSeries;
        exports2.wrapSync = asyncify;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type3 = typeof val;
        if (type3 === "string" && val.length > 0) {
          return parse3(val);
        } else if (type3 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse3(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match3) {
          return;
        }
        var n = parseFloat(match3[1]);
        var type3 = (match3[2] || "ms").toLowerCase();
        switch (type3) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/common.js
  var require_common2 = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/common.js"(exports, module) {
      "use strict";
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        Object.keys(env).forEach(function(key) {
          createDebug[key] = env[key];
        });
        createDebug.instances = [];
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          var hash4 = 0;
          for (var i = 0; i < namespace.length; i++) {
            hash4 = (hash4 << 5) - hash4 + namespace.charCodeAt(i);
            hash4 |= 0;
          }
          return createDebug.colors[Math.abs(hash4) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          var prevTime;
          function debug2() {
            if (!debug2.enabled) {
              return;
            }
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var self2 = debug2;
            var curr = Number(/* @__PURE__ */ new Date());
            var ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match3, format) {
              if (match3 === "%%") {
                return match3;
              }
              index++;
              var formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                var val = args[index];
                match3 = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match3;
            });
            createDebug.formatArgs.call(self2, args);
            var logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug2.namespace = namespace;
          debug2.enabled = createDebug.enabled(namespace);
          debug2.useColors = createDebug.useColors();
          debug2.color = selectColor(namespace);
          debug2.destroy = destroy;
          debug2.extend = extend;
          if (typeof createDebug.init === "function") {
            createDebug.init(debug2);
          }
          createDebug.instances.push(debug2);
          return debug2;
        }
        function destroy() {
          var index = createDebug.instances.indexOf(this);
          if (index !== -1) {
            createDebug.instances.splice(index, 1);
            return true;
          }
          return false;
        }
        function extend(namespace, delimiter) {
          return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.names = [];
          createDebug.skips = [];
          var i;
          var split4 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          var len = split4.length;
          for (i = 0; i < len; i++) {
            if (!split4[i]) {
              continue;
            }
            namespaces = split4[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
          for (i = 0; i < createDebug.instances.length; i++) {
            var instance = createDebug.instances[i];
            instance.enabled = createDebug.enabled(instance.namespace);
          }
        }
        function disable() {
          createDebug.enable("");
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          var i;
          var len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/browser.js"(exports, module) {
      "use strict";
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      exports.log = log2;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        var c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match3) {
          if (match3 === "%%") {
            return;
          }
          index++;
          if (match3 === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      function log2() {
        var _console;
        return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
      }
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load() {
        var r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module.exports = require_common2()(exports);
      var formatters = module.exports.formatters;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/node.js
  var require_node2 = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/node.js"(exports, module) {
      "use strict";
      var tty = __require2("tty");
      var util = __require2("util");
      exports.init = init2;
      exports.log = log2;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.colors = [6, 2, 3, 4, 5, 1];
      try {
        supportsColor = require_supports_color();
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
        }
      } catch (error2) {
      }
      var supportsColor;
      exports.inspectOpts = Object.keys(process.env).filter(function(key) {
        return /^debug_/i.test(key);
      }).reduce(function(obj, key) {
        var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
          return k.toUpperCase();
        });
        var val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        var name = this.namespace, useColors2 = this.useColors;
        if (useColors2) {
          var c = this.color;
          var colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
          var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return "";
        }
        return (/* @__PURE__ */ new Date()).toISOString() + " ";
      }
      function log2() {
        return process.stderr.write(util.format.apply(util, arguments) + "\n");
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load() {
        return process.env.DEBUG;
      }
      function init2(debug2) {
        debug2.inspectOpts = {};
        var keys4 = Object.keys(exports.inspectOpts);
        for (var i = 0; i < keys4.length; i++) {
          debug2.inspectOpts[keys4[i]] = exports.inspectOpts[keys4[i]];
        }
      }
      module.exports = require_common2()(exports);
      var formatters = module.exports.formatters;
      formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
          return str.trim();
        }).join(" ");
      };
      formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/index.js
  var require_src = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/index.js"(exports, module) {
      "use strict";
      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module.exports = require_browser();
      } else {
        module.exports = require_node2();
      }
    }
  });

  // ../../node_modules/.pnpm/mkdirp@0.5.6/node_modules/mkdirp/index.js
  var require_mkdirp2 = __commonJS({
    "../../node_modules/.pnpm/mkdirp@0.5.6/node_modules/mkdirp/index.js"(exports, module) {
      var path5 = __require2("path");
      var fs4 = __require2("fs");
      var _0777 = parseInt("0777", 8);
      module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
      function mkdirP(p, opts, f2, made) {
        if (typeof opts === "function") {
          f2 = opts;
          opts = {};
        } else if (!opts || typeof opts !== "object") {
          opts = { mode: opts };
        }
        var mode = opts.mode;
        var xfs = opts.fs || fs4;
        if (mode === void 0) {
          mode = _0777;
        }
        if (!made)
          made = null;
        var cb = f2 || /* istanbul ignore next */
        function() {
        };
        p = path5.resolve(p);
        xfs.mkdir(p, mode, function(er) {
          if (!er) {
            made = made || p;
            return cb(null, made);
          }
          switch (er.code) {
            case "ENOENT":
              if (path5.dirname(p) === p)
                return cb(er);
              mkdirP(path5.dirname(p), opts, function(er2, made2) {
                if (er2)
                  cb(er2, made2);
                else
                  mkdirP(p, opts, cb, made2);
              });
              break;
            default:
              xfs.stat(p, function(er2, stat) {
                if (er2 || !stat.isDirectory())
                  cb(er, made);
                else
                  cb(null, made);
              });
              break;
          }
        });
      }
      mkdirP.sync = function sync2(p, opts, made) {
        if (!opts || typeof opts !== "object") {
          opts = { mode: opts };
        }
        var mode = opts.mode;
        var xfs = opts.fs || fs4;
        if (mode === void 0) {
          mode = _0777;
        }
        if (!made)
          made = null;
        p = path5.resolve(p);
        try {
          xfs.mkdirSync(p, mode);
          made = made || p;
        } catch (err0) {
          switch (err0.code) {
            case "ENOENT":
              made = sync2(path5.dirname(p), opts, made);
              sync2(p, opts, made);
              break;
            default:
              var stat;
              try {
                stat = xfs.statSync(p);
              } catch (err1) {
                throw err0;
              }
              if (!stat.isDirectory())
                throw err0;
              break;
          }
        }
        return made;
      };
    }
  });

  // ../../node_modules/.pnpm/portfinder@1.0.32/node_modules/portfinder/lib/portfinder.js
  var require_portfinder = __commonJS({
    "../../node_modules/.pnpm/portfinder@1.0.32/node_modules/portfinder/lib/portfinder.js"(exports) {
      "use strict";
      var fs4 = __require2("fs");
      var os2 = __require2("os");
      var net = __require2("net");
      var path5 = __require2("path");
      var _async = require_async2();
      var debug2 = require_src();
      var mkdirp3 = require_mkdirp2().mkdirp;
      var debugTestPort = debug2("portfinder:testPort");
      var debugGetPort = debug2("portfinder:getPort");
      var debugDefaultHosts = debug2("portfinder:defaultHosts");
      var internals = {};
      internals.testPort = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.server = options.server || net.createServer(function() {
        });
        debugTestPort("entered testPort(): trying", options.host, "port", options.port);
        function onListen() {
          debugTestPort("done w/ testPort(): OK", options.host, "port", options.port);
          options.server.removeListener("error", onError);
          options.server.close();
          callback(null, options.port);
        }
        function onError(err) {
          debugTestPort("done w/ testPort(): failed", options.host, "w/ port", options.port, "with error", err.code);
          options.server.removeListener("listening", onListen);
          if (!(err.code == "EADDRINUSE" || err.code == "EACCES")) {
            return callback(err);
          }
          var nextPort = exports.nextPort(options.port);
          if (nextPort > exports.highestPort) {
            return callback(new Error("No open ports available"));
          }
          internals.testPort({
            port: nextPort,
            host: options.host,
            server: options.server
          }, callback);
        }
        options.server.once("error", onError);
        options.server.once("listening", onListen);
        if (options.host) {
          options.server.listen(options.port, options.host);
        } else {
          options.server.listen(options.port);
        }
      };
      exports.basePort = 8e3;
      exports.setBasePort = function(port) {
        exports.basePort = port;
      };
      exports.highestPort = 65535;
      exports.setHighestPort = function(port) {
        exports.highestPort = port;
      };
      exports.basePath = "/tmp/portfinder";
      exports.getPort = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.port = Number(options.port) || Number(exports.basePort);
        options.host = options.host || null;
        options.stopPort = Number(options.stopPort) || Number(exports.highestPort);
        if (!options.startPort) {
          options.startPort = Number(options.port);
          if (options.startPort < 0) {
            throw Error("Provided options.startPort(" + options.startPort + ") is less than 0, which are cannot be bound.");
          }
          if (options.stopPort < options.startPort) {
            throw Error("Provided options.stopPort(" + options.stopPort + "is less than options.startPort (" + options.startPort + ")");
          }
        }
        if (options.host) {
          if (exports._defaultHosts.indexOf(options.host) !== -1) {
            exports._defaultHosts.push(options.host);
          }
        }
        var openPorts = [], currentHost;
        return _async.eachSeries(exports._defaultHosts, function(host, next) {
          debugGetPort("in eachSeries() iteration callback: host is", host);
          return internals.testPort({ host, port: options.port }, function(err, port) {
            if (err) {
              debugGetPort("in eachSeries() iteration callback testPort() callback", "with an err:", err.code);
              currentHost = host;
              return next(err);
            } else {
              debugGetPort(
                "in eachSeries() iteration callback testPort() callback",
                "with a success for port",
                port
              );
              openPorts.push(port);
              return next();
            }
          });
        }, function(err) {
          if (err) {
            debugGetPort("in eachSeries() result callback: err is", err);
            if (err.code === "EADDRNOTAVAIL" || err.code === "EINVAL") {
              if (options.host === currentHost) {
                var msg = "Provided host " + options.host + " could NOT be bound. Please provide a different host address or hostname";
                return callback(Error(msg));
              } else {
                var idx = exports._defaultHosts.indexOf(currentHost);
                exports._defaultHosts.splice(idx, 1);
                return exports.getPort(options, callback);
              }
            } else {
              return callback(err);
            }
          }
          openPorts.sort(function(a, b) {
            return a - b;
          });
          debugGetPort("in eachSeries() result callback: openPorts is", openPorts);
          if (openPorts[0] === openPorts[openPorts.length - 1]) {
            if (openPorts[0] <= options.stopPort) {
              return callback(null, openPorts[0]);
            } else {
              var msg = "No open ports found in between " + options.startPort + " and " + options.stopPort;
              return callback(Error(msg));
            }
          } else {
            return exports.getPort({ port: openPorts.pop(), host: options.host, startPort: options.startPort, stopPort: options.stopPort }, callback);
          }
        });
      };
      exports.getPortPromise = function(options) {
        if (typeof Promise !== "function") {
          throw Error("Native promise support is not available in this version of node.Please install a polyfill and assign Promise to global.Promise before calling this method");
        }
        if (!options) {
          options = {};
        }
        return new Promise(function(resolve4, reject) {
          exports.getPort(options, function(err, port) {
            if (err) {
              return reject(err);
            }
            resolve4(port);
          });
        });
      };
      exports.getPorts = function(count, options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        var lastPort = null;
        _async.timesSeries(count, function(index, asyncCallback) {
          if (lastPort) {
            options.port = exports.nextPort(lastPort);
          }
          exports.getPort(options, function(err, port) {
            if (err) {
              asyncCallback(err);
            } else {
              lastPort = port;
              asyncCallback(null, port);
            }
          });
        }, callback);
      };
      exports.getSocket = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.mod = options.mod || parseInt(755, 8);
        options.path = options.path || exports.basePath + ".sock";
        function testSocket() {
          fs4.stat(options.path, function(err) {
            if (err) {
              if (err.code == "ENOENT") {
                callback(null, options.path);
              } else {
                callback(err);
              }
            } else {
              options.path = exports.nextSocket(options.path);
              exports.getSocket(options, callback);
            }
          });
        }
        function createAndTestSocket(dir) {
          mkdirp3(dir, options.mod, function(err) {
            if (err) {
              return callback(err);
            }
            options.exists = true;
            testSocket();
          });
        }
        function checkAndTestSocket() {
          var dir = path5.dirname(options.path);
          fs4.stat(dir, function(err, stats) {
            if (err || !stats.isDirectory()) {
              return createAndTestSocket(dir);
            }
            options.exists = true;
            testSocket();
          });
        }
        return options.exists ? testSocket() : checkAndTestSocket();
      };
      exports.nextPort = function(port) {
        return port + 1;
      };
      exports.nextSocket = function(socketPath) {
        var dir = path5.dirname(socketPath), name = path5.basename(socketPath, ".sock"), match3 = name.match(/^([a-zA-z]+)(\d*)$/i), index = parseInt(match3[2]), base = match3[1];
        if (isNaN(index)) {
          index = 0;
        }
        index += 1;
        return path5.join(dir, base + index + ".sock");
      };
      exports._defaultHosts = function() {
        var interfaces = {};
        try {
          interfaces = os2.networkInterfaces();
        } catch (e) {
          if (e.syscall === "uv_interface_addresses") {
          } else {
            throw e;
          }
        }
        var interfaceNames = Object.keys(interfaces), hiddenButImportantHost = "0.0.0.0", results = [hiddenButImportantHost];
        for (var i = 0; i < interfaceNames.length; i++) {
          var _interface = interfaces[interfaceNames[i]];
          for (var j = 0; j < _interface.length; j++) {
            var curr = _interface[j];
            results.push(curr.address);
          }
        }
        results.push(null);
        debugDefaultHosts("exports._defaultHosts is: %o", results);
        return results;
      }();
    }
  });

  // ../../node_modules/.pnpm/tree-kill@1.2.2/node_modules/tree-kill/index.js
  var require_tree_kill = __commonJS({
    "../../node_modules/.pnpm/tree-kill@1.2.2/node_modules/tree-kill/index.js"(exports, module) {
      "use strict";
      var childProcess = __require2("child_process");
      var spawn3 = childProcess.spawn;
      var exec = childProcess.exec;
      module.exports = function(pid, signal, callback) {
        if (typeof signal === "function" && callback === void 0) {
          callback = signal;
          signal = void 0;
        }
        pid = parseInt(pid);
        if (Number.isNaN(pid)) {
          if (callback) {
            return callback(new Error("pid must be a number"));
          } else {
            throw new Error("pid must be a number");
          }
        }
        var tree = {};
        var pidsToProcess = {};
        tree[pid] = [];
        pidsToProcess[pid] = 1;
        switch (process.platform) {
          case "win32":
            exec("taskkill /pid " + pid + " /T /F", callback);
            break;
          case "darwin":
            buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
              return spawn3("pgrep", ["-P", parentPid]);
            }, function() {
              killAll(tree, signal, callback);
            });
            break;
          default:
            buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
              return spawn3("ps", ["-o", "pid", "--no-headers", "--ppid", parentPid]);
            }, function() {
              killAll(tree, signal, callback);
            });
            break;
        }
      };
      function killAll(tree, signal, callback) {
        var killed = {};
        try {
          Object.keys(tree).forEach(function(pid) {
            tree[pid].forEach(function(pidpid) {
              if (!killed[pidpid]) {
                killPid(pidpid, signal);
                killed[pidpid] = 1;
              }
            });
            if (!killed[pid]) {
              killPid(pid, signal);
              killed[pid] = 1;
            }
          });
        } catch (err) {
          if (callback) {
            return callback(err);
          } else {
            throw err;
          }
        }
        if (callback) {
          return callback();
        }
      }
      function killPid(pid, signal) {
        try {
          process.kill(parseInt(pid, 10), signal);
        } catch (err) {
          if (err.code !== "ESRCH")
            throw err;
        }
      }
      function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
        var ps = spawnChildProcessesList(parentPid);
        var allData = "";
        ps.stdout.on("data", function(data) {
          var data = data.toString("ascii");
          allData += data;
        });
        var onClose = function(code) {
          delete pidsToProcess[parentPid];
          if (code != 0) {
            if (Object.keys(pidsToProcess).length == 0) {
              cb();
            }
            return;
          }
          allData.match(/\d+/g).forEach(function(pid) {
            pid = parseInt(pid, 10);
            tree[parentPid].push(pid);
            tree[pid] = [];
            pidsToProcess[pid] = 1;
            buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
          });
        };
        ps.on("close", onClose);
      }
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
  var require_constants = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports, module) {
      "use strict";
      var path5 = __require2("path");
      var WIN_SLASH = "\\\\/";
      var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
      var DOT_LITERAL = "\\.";
      var PLUS_LITERAL = "\\+";
      var QMARK_LITERAL = "\\?";
      var SLASH_LITERAL = "\\/";
      var ONE_CHAR = "(?=.)";
      var QMARK = "[^/]";
      var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
      var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
      var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
      var NO_DOT = `(?!${DOT_LITERAL})`;
      var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
      var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
      var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
      var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
      var STAR = `${QMARK}*?`;
      var POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      };
      var WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
      };
      var POSIX_REGEX_SOURCE = {
        alnum: "a-zA-Z0-9",
        alpha: "a-zA-Z",
        ascii: "\\x00-\\x7F",
        blank: " \\t",
        cntrl: "\\x00-\\x1F\\x7F",
        digit: "0-9",
        graph: "\\x21-\\x7E",
        lower: "a-z",
        print: "\\x20-\\x7E ",
        punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
        space: " \\t\\r\\n\\v\\f",
        upper: "A-Z",
        word: "A-Za-z0-9_",
        xdigit: "A-Fa-f0-9"
      };
      module.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        // regular expressions
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        // Replace globs with equivalent patterns to reduce parsing time.
        REPLACEMENTS: {
          "***": "*",
          "**/**": "**",
          "**/**/**": "**"
        },
        // Digits
        CHAR_0: 48,
        /* 0 */
        CHAR_9: 57,
        /* 9 */
        // Alphabet chars.
        CHAR_UPPERCASE_A: 65,
        /* A */
        CHAR_LOWERCASE_A: 97,
        /* a */
        CHAR_UPPERCASE_Z: 90,
        /* Z */
        CHAR_LOWERCASE_Z: 122,
        /* z */
        CHAR_LEFT_PARENTHESES: 40,
        /* ( */
        CHAR_RIGHT_PARENTHESES: 41,
        /* ) */
        CHAR_ASTERISK: 42,
        /* * */
        // Non-alphabetic chars.
        CHAR_AMPERSAND: 38,
        /* & */
        CHAR_AT: 64,
        /* @ */
        CHAR_BACKWARD_SLASH: 92,
        /* \ */
        CHAR_CARRIAGE_RETURN: 13,
        /* \r */
        CHAR_CIRCUMFLEX_ACCENT: 94,
        /* ^ */
        CHAR_COLON: 58,
        /* : */
        CHAR_COMMA: 44,
        /* , */
        CHAR_DOT: 46,
        /* . */
        CHAR_DOUBLE_QUOTE: 34,
        /* " */
        CHAR_EQUAL: 61,
        /* = */
        CHAR_EXCLAMATION_MARK: 33,
        /* ! */
        CHAR_FORM_FEED: 12,
        /* \f */
        CHAR_FORWARD_SLASH: 47,
        /* / */
        CHAR_GRAVE_ACCENT: 96,
        /* ` */
        CHAR_HASH: 35,
        /* # */
        CHAR_HYPHEN_MINUS: 45,
        /* - */
        CHAR_LEFT_ANGLE_BRACKET: 60,
        /* < */
        CHAR_LEFT_CURLY_BRACE: 123,
        /* { */
        CHAR_LEFT_SQUARE_BRACKET: 91,
        /* [ */
        CHAR_LINE_FEED: 10,
        /* \n */
        CHAR_NO_BREAK_SPACE: 160,
        /* \u00A0 */
        CHAR_PERCENT: 37,
        /* % */
        CHAR_PLUS: 43,
        /* + */
        CHAR_QUESTION_MARK: 63,
        /* ? */
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        /* > */
        CHAR_RIGHT_CURLY_BRACE: 125,
        /* } */
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        /* ] */
        CHAR_SEMICOLON: 59,
        /* ; */
        CHAR_SINGLE_QUOTE: 39,
        /* ' */
        CHAR_SPACE: 32,
        /*   */
        CHAR_TAB: 9,
        /* \t */
        CHAR_UNDERSCORE: 95,
        /* _ */
        CHAR_VERTICAL_LINE: 124,
        /* | */
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        /* \uFEFF */
        SEP: path5.sep,
        /**
         * Create EXTGLOB_CHARS
         */
        extglobChars(chars) {
          return {
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" }
          };
        },
        /**
         * Create GLOB_CHARS
         */
        globChars(win322) {
          return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
  var require_utils4 = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports) {
      "use strict";
      var path5 = __require2("path");
      var win322 = process.platform === "win32";
      var {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = require_constants();
      exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
      exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match3) => {
          return match3 === "\\" ? "" : match3;
        });
      };
      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports.isWindows = (options) => {
        if (options && typeof options.windows === "boolean") {
          return options.windows;
        }
        return win322 === true || path5.sep === "\\";
      };
      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports.removePrefix = (input, state = {}) => {
        let output3 = input;
        if (output3.startsWith("./")) {
          output3 = output3.slice(2);
          state.prefix = "./";
        }
        return output3;
      };
      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend = options.contains ? "" : "^";
        const append = options.contains ? "" : "$";
        let output3 = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
          output3 = `(?:^(?!${output3}).*$)`;
        }
        return output3;
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
  var require_scan = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports, module) {
      "use strict";
      var utils = require_utils4();
      var {
        CHAR_ASTERISK,
        /* * */
        CHAR_AT,
        /* @ */
        CHAR_BACKWARD_SLASH,
        /* \ */
        CHAR_COMMA,
        /* , */
        CHAR_DOT,
        /* . */
        CHAR_EXCLAMATION_MARK,
        /* ! */
        CHAR_FORWARD_SLASH,
        /* / */
        CHAR_LEFT_CURLY_BRACE,
        /* { */
        CHAR_LEFT_PARENTHESES,
        /* ( */
        CHAR_LEFT_SQUARE_BRACKET,
        /* [ */
        CHAR_PLUS,
        /* + */
        CHAR_QUESTION_MARK,
        /* ? */
        CHAR_RIGHT_CURLY_BRACE,
        /* } */
        CHAR_RIGHT_PARENTHESES,
        /* ) */
        CHAR_RIGHT_SQUARE_BRACKET
        /* ] */
      } = require_constants();
      var isPathSeparator = (code) => {
        return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
      };
      var depth = (token) => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1;
        }
      };
      var scan = (input, options) => {
        const opts = options || {};
        const length = input.length - 1;
        const scanToEnd = opts.parts === true || opts.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let negatedExtglob = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = { value: "", depth: 0, isGlob: false };
        const eos = () => index >= length;
        const peek = () => str.charCodeAt(index + 1);
        const advance = () => {
          prev = code;
          return str.charCodeAt(++index);
        };
        while (index < length) {
          code = advance();
          let next;
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true;
            }
            continue;
          }
          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                continue;
              }
              if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--;
                if (braces === 0) {
                  braceEscaped = false;
                  isBrace = token.isBrace = true;
                  finished = true;
                  break;
                }
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = { value: "", depth: 0, isGlob: false };
            if (finished === true)
              continue;
            if (prev === CHAR_DOT && index === start + 1) {
              start += 2;
              continue;
            }
            lastIndex = index + 1;
            continue;
          }
          if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true;
              isExtglob = token.isExtglob = true;
              finished = true;
              if (code === CHAR_EXCLAMATION_MARK && index === start) {
                negatedExtglob = true;
              }
              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                  }
                }
                continue;
              }
              break;
            }
          }
          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK)
              isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true;
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
          }
          if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
          if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
        if (opts.noext === true) {
          isExtglob = false;
          isGlob = false;
        }
        let base = str;
        let prefix = "";
        let glob2 = "";
        if (start > 0) {
          prefix = str.slice(0, start);
          str = str.slice(start);
          lastIndex -= start;
        }
        if (base && isGlob === true && lastIndex > 0) {
          base = str.slice(0, lastIndex);
          glob2 = str.slice(lastIndex);
        } else if (isGlob === true) {
          base = "";
          glob2 = str;
        } else {
          base = str;
        }
        if (base && base !== "" && base !== "/" && base !== str) {
          if (isPathSeparator(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
          }
        }
        if (opts.unescape === true) {
          if (glob2)
            glob2 = utils.removeBackslashes(glob2);
          if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
          }
        }
        const state = {
          prefix,
          input,
          start,
          base,
          glob: glob2,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated,
          negatedExtglob
        };
        if (opts.tokens === true) {
          state.maxDepth = 0;
          if (!isPathSeparator(code)) {
            tokens.push(token);
          }
          state.tokens = tokens;
        }
        if (opts.parts === true || opts.tokens === true) {
          let prevIndex;
          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true;
                tokens[idx].value = prefix;
              } else {
                tokens[idx].value = value;
              }
              depth(tokens[idx]);
              state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") {
              parts.push(value);
            }
            prevIndex = i;
          }
          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
              tokens[tokens.length - 1].value = value;
              depth(tokens[tokens.length - 1]);
              state.maxDepth += tokens[tokens.length - 1].depth;
            }
          }
          state.slashes = slashes;
          state.parts = parts;
        }
        return state;
      };
      module.exports = scan;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
  var require_parse = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var utils = require_utils4();
      var {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS
      } = constants;
      var expandRange = (args, options) => {
        if (typeof options.expandRange === "function") {
          return options.expandRange(...args, options);
        }
        args.sort();
        const value = `[${args.join("-")}]`;
        try {
          new RegExp(value);
        } catch (ex) {
          return args.map((v) => utils.escapeRegex(v)).join("..");
        }
        return value;
      };
      var syntaxError2 = (type3, char) => {
        return `Missing ${type3}: "${char}" - use "\\\\${char}" to match literal characters`;
      };
      var parse3 = (input, options) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        input = REPLACEMENTS[input] || input;
        const opts = { ...options };
        const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max2) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
        }
        const bos = { type: "bos", value: "", output: opts.prepend || "" };
        const tokens = [bos];
        const capture = opts.capture ? "" : "?:";
        const win322 = utils.isWindows(options);
        const PLATFORM_CHARS = constants.globChars(win322);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        } = PLATFORM_CHARS;
        const globstar = (opts2) => {
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const nodot = opts.dot ? "" : NO_DOT;
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
        let star3 = opts.bash === true ? globstar(opts) : STAR;
        if (opts.capture) {
          star3 = `(${star3})`;
        }
        if (typeof opts.noext === "boolean") {
          opts.noextglob = opts.noext;
        }
        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts.dot === true,
          consumed: "",
          output: "",
          prefix: "",
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = () => state.index === len - 1;
        const peek = state.peek = (n = 1) => input[state.index + n];
        const advance = state.advance = () => input[++state.index] || "";
        const remaining = () => input.slice(state.index + 1);
        const consume = (value2 = "", num = 0) => {
          state.consumed += value2;
          state.index += num;
        };
        const append = (token) => {
          state.output += token.output != null ? token.output : token.value;
          consume(token.value);
        };
        const negate = () => {
          let count = 1;
          while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
            advance();
            state.start++;
            count++;
          }
          if (count % 2 === 0) {
            return false;
          }
          state.negated = true;
          state.start++;
          return true;
        };
        const increment = (type3) => {
          state[type3]++;
          stack.push(type3);
        };
        const decrement = (type3) => {
          state[type3]--;
          stack.pop();
        };
        const push = (tok) => {
          if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
              state.output = state.output.slice(0, -prev.output.length);
              prev.type = "star";
              prev.value = "*";
              prev.output = star3;
              state.output += prev.output;
            }
          }
          if (extglobs.length && tok.type !== "paren") {
            extglobs[extglobs.length - 1].inner += tok.value;
          }
          if (tok.value || tok.output)
            append(tok);
          if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
          }
          tok.prev = prev;
          tokens.push(tok);
          prev = tok;
        };
        const extglobOpen = (type3, value2) => {
          const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
          token.prev = prev;
          token.parens = state.parens;
          token.output = state.output;
          const output3 = (opts.capture ? "(" : "") + token.open;
          increment("parens");
          push({ type: type3, value: value2, output: state.output ? "" : ONE_CHAR });
          push({ type: "paren", extglob: true, value: advance(), output: output3 });
          extglobs.push(token);
        };
        const extglobClose = (token) => {
          let output3 = token.close + (opts.capture ? ")" : "");
          let rest;
          if (token.type === "negate") {
            let extglobStar = star3;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
              extglobStar = globstar(opts);
            }
            if (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) {
              output3 = token.close = `)$))${extglobStar}`;
            }
            if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
              const expression = parse3(rest, { ...options, fastpaths: false }).output;
              output3 = token.close = `)${expression})${extglobStar})`;
            }
            if (token.prev.type === "bos") {
              state.negatedExtglob = true;
            }
          }
          push({ type: "paren", extglob: true, value, output: output3 });
          decrement("parens");
        };
        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false;
          let output3 = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
            if (first === "\\") {
              backslashes = true;
              return m;
            }
            if (first === "?") {
              if (esc) {
                return esc + first + (rest ? QMARK.repeat(rest.length) : "");
              }
              if (index === 0) {
                return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
              }
              return QMARK.repeat(chars.length);
            }
            if (first === ".") {
              return DOT_LITERAL.repeat(chars.length);
            }
            if (first === "*") {
              if (esc) {
                return esc + first + (rest ? star3 : "");
              }
              return star3;
            }
            return esc ? m : `\\${m}`;
          });
          if (backslashes === true) {
            if (opts.unescape === true) {
              output3 = output3.replace(/\\/g, "");
            } else {
              output3 = output3.replace(/\\+/g, (m) => {
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
              });
            }
          }
          if (output3 === input && opts.contains === true) {
            state.output = input;
            return state;
          }
          state.output = utils.wrapOutput(output3, state, options);
          return state;
        }
        while (!eos()) {
          value = advance();
          if (value === "\0") {
            continue;
          }
          if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) {
              continue;
            }
            if (next === "." || next === ";") {
              continue;
            }
            if (!next) {
              value += "\\";
              push({ type: "text", value });
              continue;
            }
            const match3 = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match3 && match3[0].length > 2) {
              slashes = match3[0].length;
              state.index += slashes;
              if (slashes % 2 !== 0) {
                value += "\\";
              }
            }
            if (opts.unescape === true) {
              value = advance();
            } else {
              value += advance();
            }
            if (state.brackets === 0) {
              push({ type: "text", value });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
              const inner = prev.value.slice(1);
              if (inner.includes("[")) {
                prev.posix = true;
                if (inner.includes(":")) {
                  const idx = prev.value.lastIndexOf("[");
                  const pre = prev.value.slice(0, idx);
                  const rest2 = prev.value.slice(idx + 2);
                  const posix2 = POSIX_REGEX_SOURCE[rest2];
                  if (posix2) {
                    prev.value = pre + posix2;
                    state.backtrack = true;
                    advance();
                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR;
                    }
                    continue;
                  }
                }
              }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
              value = `\\${value}`;
            }
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
              value = `\\${value}`;
            }
            if (opts.posix === true && value === "!" && prev.value === "[") {
              value = "^";
            }
            prev.value += value;
            append({ value });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
              push({ type: "text", value });
            }
            continue;
          }
          if (value === "(") {
            increment("parens");
            push({ type: "paren", value });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("opening", "("));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
            decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
              if (opts.nobracket !== true && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError2("closing", "]"));
              }
              value = `\\${value}`;
            } else {
              increment("brackets");
            }
            push({ type: "bracket", value });
            continue;
          }
          if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            if (state.brackets === 0) {
              if (opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError2("opening", "["));
              }
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
              value = `/${value}`;
            }
            prev.value += value;
            append({ value });
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
              continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            if (opts.literalBrackets === true) {
              state.output += escaped;
              prev.value = escaped;
              continue;
            }
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
          }
          if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
          }
          if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
              push({ type: "text", value, output: value });
              continue;
            }
            let output3 = ")";
            if (brace.dots === true) {
              const arr = tokens.slice();
              const range = [];
              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop();
                if (arr[i].type === "brace") {
                  break;
                }
                if (arr[i].type !== "dots") {
                  range.unshift(arr[i].value);
                }
              }
              output3 = expandRange(range, opts);
              state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex);
              const toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{";
              value = output3 = "\\}";
              state.output = out;
              for (const t of toks) {
                state.output += t.output || t.value;
              }
            }
            push({ type: "brace", value, output: output3 });
            decrement("braces");
            braces.pop();
            continue;
          }
          if (value === "|") {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === ",") {
            let output3 = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
              brace.comma = true;
              output3 = "|";
            }
            push({ type: "comma", value, output: output3 });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1;
              state.consumed = "";
              state.output = "";
              tokens.pop();
              prev = bos;
              continue;
            }
            push({ type: "slash", value, output: SLASH_LITERAL });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              if (prev.value === ".")
                prev.output = DOT_LITERAL;
              const brace = braces[braces.length - 1];
              prev.type = "dots";
              prev.output += value;
              prev.value += value;
              brace.dots = true;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({ type: "text", value, output: DOT_LITERAL });
              continue;
            }
            push({ type: "dot", value, output: DOT_LITERAL });
            continue;
          }
          if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              const next = peek();
              let output3 = value;
              if (next === "<" && !utils.supportsLookbehinds()) {
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              }
              if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                output3 = `\\${value}`;
              }
              push({ type: "text", value, output: output3 });
              continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
              push({ type: "qmark", value, output: QMARK_NO_DOT });
              continue;
            }
            push({ type: "qmark", value, output: QMARK });
            continue;
          }
          if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
              if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                extglobOpen("negate", value);
                continue;
              }
            }
            if (opts.nonegate !== true && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
              push({ type: "plus", value, output: PLUS_LITERAL });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({ type: "plus", value });
              continue;
            }
            push({ type: "plus", value: PLUS_LITERAL });
            continue;
          }
          if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              push({ type: "at", extglob: true, value, output: "" });
              continue;
            }
            push({ type: "text", value });
            continue;
          }
          if (value !== "*") {
            if (value === "$" || value === "^") {
              value = `\\${value}`;
            }
            const match3 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match3) {
              value += match3[0];
              state.index += match3[0].length;
            }
            push({ type: "text", value });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star3;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
          }
          let rest = remaining();
          if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts.noglobstar === true) {
              consume(value);
              continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
              push({ type: "star", value, output: "" });
              continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({ type: "star", value, output: "" });
              continue;
            }
            while (rest.slice(0, 3) === "/**") {
              const after = input[state.index + 4];
              if (after && after !== "/") {
                break;
              }
              rest = rest.slice(3);
              consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar";
              prev.value += value;
              prev.output = globstar(opts);
              state.output = prev.output;
              state.globstar = true;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
              prev.value += value;
              state.globstar = true;
              state.output += prior.output + prev.output;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
              const end = rest[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
              prev.value += value;
              state.output += prior.output + prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
              prev.type = "globstar";
              prev.value += value;
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
              state.output = prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          const token = { type: "star", value, output: star3 };
          if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") {
              token.output = nodot + token.output;
            }
            push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
          }
          if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
              state.output += NO_DOT_SLASH;
              prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
              state.output += NO_DOTS_SLASH;
              prev.output += NO_DOTS_SLASH;
            } else {
              state.output += nodot;
              prev.output += nodot;
            }
            if (peek() !== "*") {
              state.output += ONE_CHAR;
              prev.output += ONE_CHAR;
            }
          }
          push(token);
        }
        while (state.brackets > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", "]"));
          state.output = utils.escapeLast(state.output, "[");
          decrement("brackets");
        }
        while (state.parens > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", ")"));
          state.output = utils.escapeLast(state.output, "(");
          decrement("parens");
        }
        while (state.braces > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", "}"));
          state.output = utils.escapeLast(state.output, "{");
          decrement("braces");
        }
        if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
          push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
        }
        if (state.backtrack === true) {
          state.output = "";
          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
              state.output += token.suffix;
            }
          }
        }
        return state;
      };
      parse3.fastpaths = (input, options) => {
        const opts = { ...options };
        const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max2) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
        }
        input = REPLACEMENTS[input] || input;
        const win322 = utils.isWindows(options);
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR
        } = constants.globChars(win322);
        const nodot = opts.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts.capture ? "" : "?:";
        const state = { negated: false, prefix: "" };
        let star3 = opts.bash === true ? ".*?" : STAR;
        if (opts.capture) {
          star3 = `(${star3})`;
        }
        const globstar = (opts2) => {
          if (opts2.noglobstar === true)
            return star3;
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const create10 = (str) => {
          switch (str) {
            case "*":
              return `${nodot}${ONE_CHAR}${star3}`;
            case ".*":
              return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "*.*":
              return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "*/*":
              return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
            case "**":
              return nodot + globstar(opts);
            case "**/*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
            case "**/*.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "**/.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
            default: {
              const match3 = /^(.*?)\.(\w+)$/.exec(str);
              if (!match3)
                return;
              const source2 = create10(match3[1]);
              if (!source2)
                return;
              return source2 + DOT_LITERAL + match3[2];
            }
          }
        };
        const output3 = utils.removePrefix(input, state);
        let source = create10(output3);
        if (source && opts.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`;
        }
        return source;
      };
      module.exports = parse3;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
  var require_picomatch = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports, module) {
      "use strict";
      var path5 = __require2("path");
      var scan = require_scan();
      var parse3 = require_parse();
      var utils = require_utils4();
      var constants = require_constants();
      var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
      var picomatch = (glob2, options, returnState = false) => {
        if (Array.isArray(glob2)) {
          const fns = glob2.map((input) => picomatch(input, options, returnState));
          const arrayMatcher = (str) => {
            for (const isMatch of fns) {
              const state2 = isMatch(str);
              if (state2)
                return state2;
            }
            return false;
          };
          return arrayMatcher;
        }
        const isState = isObject2(glob2) && glob2.tokens && glob2.input;
        if (glob2 === "" || typeof glob2 !== "string" && !isState) {
          throw new TypeError("Expected pattern to be a non-empty string");
        }
        const opts = options || {};
        const posix2 = utils.isWindows(options);
        const regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored = () => false;
        if (opts.ignore) {
          const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
          isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
        }
        const matcher = (input, returnObject = false) => {
          const { isMatch, match: match3, output: output3 } = picomatch.test(input, regex, options, { glob: glob2, posix: posix2 });
          const result = { glob: glob2, state, regex, posix: posix2, input, output: output3, match: match3, isMatch };
          if (typeof opts.onResult === "function") {
            opts.onResult(result);
          }
          if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") {
              opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (typeof opts.onMatch === "function") {
            opts.onMatch(result);
          }
          return returnObject ? result : true;
        };
        if (returnState) {
          matcher.state = state;
        }
        return matcher;
      };
      picomatch.test = (input, regex, options, { glob: glob2, posix: posix2 } = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected input to be a string");
        }
        if (input === "") {
          return { isMatch: false, output: "" };
        }
        const opts = options || {};
        const format = opts.format || (posix2 ? utils.toPosixSlashes : null);
        let match3 = input === glob2;
        let output3 = match3 && format ? format(input) : input;
        if (match3 === false) {
          output3 = format ? format(input) : input;
          match3 = output3 === glob2;
        }
        if (match3 === false || opts.capture === true) {
          if (opts.matchBase === true || opts.basename === true) {
            match3 = picomatch.matchBase(input, regex, options, posix2);
          } else {
            match3 = regex.exec(output3);
          }
        }
        return { isMatch: Boolean(match3), match: match3, output: output3 };
      };
      picomatch.matchBase = (input, glob2, options, posix2 = utils.isWindows(options)) => {
        const regex = glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options);
        return regex.test(path5.basename(input));
      };
      picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
      picomatch.parse = (pattern, options) => {
        if (Array.isArray(pattern))
          return pattern.map((p) => picomatch.parse(p, options));
        return parse3(pattern, { ...options, fastpaths: false });
      };
      picomatch.scan = (input, options) => scan(input, options);
      picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
        if (returnOutput === true) {
          return state.output;
        }
        const opts = options || {};
        const prepend = opts.contains ? "" : "^";
        const append = opts.contains ? "" : "$";
        let source = `${prepend}(?:${state.output})${append}`;
        if (state && state.negated === true) {
          source = `^(?!${source}).*$`;
        }
        const regex = picomatch.toRegex(source, options);
        if (returnState === true) {
          regex.state = state;
        }
        return regex;
      };
      picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
        if (!input || typeof input !== "string") {
          throw new TypeError("Expected a non-empty string");
        }
        let parsed = { negated: false, fastpaths: true };
        if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
          parsed.output = parse3.fastpaths(input, options);
        }
        if (!parsed.output) {
          parsed = parse3(input, options);
        }
        return picomatch.compileRe(parsed, options, returnOutput, returnState);
      };
      picomatch.toRegex = (source, options) => {
        try {
          const opts = options || {};
          return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
        } catch (err) {
          if (options && options.debug === true)
            throw err;
          return /$^/;
        }
      };
      picomatch.constants = constants;
      module.exports = picomatch;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
  var require_picomatch2 = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports, module) {
      "use strict";
      module.exports = require_picomatch();
    }
  });

  // ../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js
  var require_readdirp = __commonJS({
    "../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js"(exports, module) {
      "use strict";
      var fs4 = __require2("fs");
      var { Readable: Readable2 } = __require2("stream");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var picomatch = require_picomatch2();
      var readdir2 = promisify(fs4.readdir);
      var stat = promisify(fs4.stat);
      var lstat2 = promisify(fs4.lstat);
      var realpath2 = promisify(fs4.realpath);
      var BANG = "!";
      var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
      var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
      var FILE_TYPE = "files";
      var DIR_TYPE = "directories";
      var FILE_DIR_TYPE = "files_directories";
      var EVERYTHING_TYPE = "all";
      var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
      var isNormalFlowError = (error2) => NORMAL_FLOW_ERRORS.has(error2.code);
      var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n) => Number.parseInt(n, 10));
      var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
      var normalizeFilter = (filter2) => {
        if (filter2 === void 0)
          return;
        if (typeof filter2 === "function")
          return filter2;
        if (typeof filter2 === "string") {
          const glob2 = picomatch(filter2.trim());
          return (entry) => glob2(entry.basename);
        }
        if (Array.isArray(filter2)) {
          const positive = [];
          const negative = [];
          for (const item of filter2) {
            const trimmed = item.trim();
            if (trimmed.charAt(0) === BANG) {
              negative.push(picomatch(trimmed.slice(1)));
            } else {
              positive.push(picomatch(trimmed));
            }
          }
          if (negative.length > 0) {
            if (positive.length > 0) {
              return (entry) => positive.some((f2) => f2(entry.basename)) && !negative.some((f2) => f2(entry.basename));
            }
            return (entry) => !negative.some((f2) => f2(entry.basename));
          }
          return (entry) => positive.some((f2) => f2(entry.basename));
        }
      };
      var ReaddirpStream = class extends Readable2 {
        static get defaultOptions() {
          return {
            root: ".",
            /* eslint-disable no-unused-vars */
            fileFilter: (path5) => true,
            directoryFilter: (path5) => true,
            /* eslint-enable no-unused-vars */
            type: FILE_TYPE,
            lstat: false,
            depth: 2147483648,
            alwaysStat: false
          };
        }
        constructor(options = {}) {
          super({
            objectMode: true,
            autoDestroy: true,
            highWaterMark: options.highWaterMark || 4096
          });
          const opts = { ...ReaddirpStream.defaultOptions, ...options };
          const { root, type: type3 } = opts;
          this._fileFilter = normalizeFilter(opts.fileFilter);
          this._directoryFilter = normalizeFilter(opts.directoryFilter);
          const statMethod = opts.lstat ? lstat2 : stat;
          if (wantBigintFsStats) {
            this._stat = (path5) => statMethod(path5, { bigint: true });
          } else {
            this._stat = statMethod;
          }
          this._maxDepth = opts.depth;
          this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type3);
          this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type3);
          this._wantsEverything = type3 === EVERYTHING_TYPE;
          this._root = sysPath.resolve(root);
          this._isDirent = "Dirent" in fs4 && !opts.alwaysStat;
          this._statsProp = this._isDirent ? "dirent" : "stats";
          this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
          this.parents = [this._exploreDir(root, 1)];
          this.reading = false;
          this.parent = void 0;
        }
        async _read(batch) {
          if (this.reading)
            return;
          this.reading = true;
          try {
            while (!this.destroyed && batch > 0) {
              const { path: path5, depth, files = [] } = this.parent || {};
              if (files.length > 0) {
                const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path5));
                for (const entry of await Promise.all(slice)) {
                  if (this.destroyed)
                    return;
                  const entryType = await this._getEntryType(entry);
                  if (entryType === "directory" && this._directoryFilter(entry)) {
                    if (depth <= this._maxDepth) {
                      this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                    }
                    if (this._wantsDir) {
                      this.push(entry);
                      batch--;
                    }
                  } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                    if (this._wantsFile) {
                      this.push(entry);
                      batch--;
                    }
                  }
                }
              } else {
                const parent = this.parents.pop();
                if (!parent) {
                  this.push(null);
                  break;
                }
                this.parent = await parent;
                if (this.destroyed)
                  return;
              }
            }
          } catch (error2) {
            this.destroy(error2);
          } finally {
            this.reading = false;
          }
        }
        async _exploreDir(path5, depth) {
          let files;
          try {
            files = await readdir2(path5, this._rdOptions);
          } catch (error2) {
            this._onError(error2);
          }
          return { files, depth, path: path5 };
        }
        async _formatEntry(dirent, path5) {
          let entry;
          try {
            const basename3 = this._isDirent ? dirent.name : dirent;
            const fullPath = sysPath.resolve(sysPath.join(path5, basename3));
            entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename: basename3 };
            entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
          } catch (err) {
            this._onError(err);
          }
          return entry;
        }
        _onError(err) {
          if (isNormalFlowError(err) && !this.destroyed) {
            this.emit("warn", err);
          } else {
            this.destroy(err);
          }
        }
        async _getEntryType(entry) {
          const stats = entry && entry[this._statsProp];
          if (!stats) {
            return;
          }
          if (stats.isFile()) {
            return "file";
          }
          if (stats.isDirectory()) {
            return "directory";
          }
          if (stats && stats.isSymbolicLink()) {
            const full = entry.fullPath;
            try {
              const entryRealPath = await realpath2(full);
              const entryRealPathStats = await lstat2(entryRealPath);
              if (entryRealPathStats.isFile()) {
                return "file";
              }
              if (entryRealPathStats.isDirectory()) {
                const len = entryRealPath.length;
                if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                  const recursiveError = new Error(
                    `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                  );
                  recursiveError.code = RECURSIVE_ERROR_CODE;
                  return this._onError(recursiveError);
                }
                return "directory";
              }
            } catch (error2) {
              this._onError(error2);
            }
          }
        }
        _includeAsFile(entry) {
          const stats = entry && entry[this._statsProp];
          return stats && this._wantsEverything && !stats.isDirectory();
        }
      };
      var readdirp = (root, options = {}) => {
        let type3 = options.entryType || options.type;
        if (type3 === "both")
          type3 = FILE_DIR_TYPE;
        if (type3)
          options.type = type3;
        if (!root) {
          throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
        } else if (typeof root !== "string") {
          throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
        } else if (type3 && !ALL_TYPES.includes(type3)) {
          throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
        }
        options.root = root;
        return new ReaddirpStream(options);
      };
      var readdirpPromise = (root, options = {}) => {
        return new Promise((resolve4, reject) => {
          const files = [];
          readdirp(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve4(files)).on("error", (error2) => reject(error2));
        });
      };
      readdirp.promise = readdirpPromise;
      readdirp.ReaddirpStream = ReaddirpStream;
      readdirp.default = readdirp;
      module.exports = readdirp;
    }
  });

  // ../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
  var require_normalize_path = __commonJS({
    "../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js"(exports, module) {
      module.exports = function(path5, stripTrailing) {
        if (typeof path5 !== "string") {
          throw new TypeError("expected path to be a string");
        }
        if (path5 === "\\" || path5 === "/")
          return "/";
        var len = path5.length;
        if (len <= 1)
          return path5;
        var prefix = "";
        if (len > 4 && path5[3] === "\\") {
          var ch = path5[2];
          if ((ch === "?" || ch === ".") && path5.slice(0, 2) === "\\\\") {
            path5 = path5.slice(2);
            prefix = "//";
          }
        }
        var segs = path5.split(/[/\\]+/);
        if (stripTrailing !== false && segs[segs.length - 1] === "") {
          segs.pop();
        }
        return prefix + segs.join("/");
      };
    }
  });

  // ../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js
  var require_anymatch = __commonJS({
    "../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var picomatch = require_picomatch2();
      var normalizePath = require_normalize_path();
      var BANG = "!";
      var DEFAULT_OPTIONS = { returnIndex: false };
      var arrify = (item) => Array.isArray(item) ? item : [item];
      var createPattern = (matcher, options) => {
        if (typeof matcher === "function") {
          return matcher;
        }
        if (typeof matcher === "string") {
          const glob2 = picomatch(matcher, options);
          return (string2) => matcher === string2 || glob2(string2);
        }
        if (matcher instanceof RegExp) {
          return (string2) => matcher.test(string2);
        }
        return (string2) => false;
      };
      var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
        const isList = Array.isArray(args);
        const _path = isList ? args[0] : args;
        if (!isList && typeof _path !== "string") {
          throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
        }
        const path5 = normalizePath(_path, false);
        for (let index = 0; index < negPatterns.length; index++) {
          const nglob = negPatterns[index];
          if (nglob(path5)) {
            return returnIndex ? -1 : false;
          }
        }
        const applied = isList && [path5].concat(args.slice(1));
        for (let index = 0; index < patterns.length; index++) {
          const pattern = patterns[index];
          if (isList ? pattern(...applied) : pattern(path5)) {
            return returnIndex ? index : true;
          }
        }
        return returnIndex ? -1 : false;
      };
      var anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
        if (matchers == null) {
          throw new TypeError("anymatch: specify first argument");
        }
        const opts = typeof options === "boolean" ? { returnIndex: options } : options;
        const returnIndex = opts.returnIndex || false;
        const mtchers = arrify(matchers);
        const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
        const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
        if (testString == null) {
          return (testString2, ri = false) => {
            const returnIndex2 = typeof ri === "boolean" ? ri : false;
            return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
          };
        }
        return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
      };
      anymatch.default = anymatch;
      module.exports = anymatch;
    }
  });

  // ../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
  var require_is_extglob = __commonJS({
    "../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js"(exports, module) {
      module.exports = function isExtglob(str) {
        if (typeof str !== "string" || str === "") {
          return false;
        }
        var match3;
        while (match3 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
          if (match3[2])
            return true;
          str = str.slice(match3.index + match3[0].length);
        }
        return false;
      };
    }
  });

  // ../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js
  var require_is_glob = __commonJS({
    "../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js"(exports, module) {
      var isExtglob = require_is_extglob();
      var chars = { "{": "}", "(": ")", "[": "]" };
      var strictCheck = function(str) {
        if (str[0] === "!") {
          return true;
        }
        var index = 0;
        var pipeIndex = -2;
        var closeSquareIndex = -2;
        var closeCurlyIndex = -2;
        var closeParenIndex = -2;
        var backSlashIndex = -2;
        while (index < str.length) {
          if (str[index] === "*") {
            return true;
          }
          if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
            return true;
          }
          if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
            if (closeSquareIndex < index) {
              closeSquareIndex = str.indexOf("]", index);
            }
            if (closeSquareIndex > index) {
              if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                return true;
              }
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                return true;
              }
            }
          }
          if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
            closeCurlyIndex = str.indexOf("}", index);
            if (closeCurlyIndex > index) {
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
                return true;
              }
            }
          }
          if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
            closeParenIndex = str.indexOf(")", index);
            if (closeParenIndex > index) {
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
          if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
            if (pipeIndex < index) {
              pipeIndex = str.indexOf("|", index);
            }
            if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
              closeParenIndex = str.indexOf(")", pipeIndex);
              if (closeParenIndex > pipeIndex) {
                backSlashIndex = str.indexOf("\\", pipeIndex);
                if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                  return true;
                }
              }
            }
          }
          if (str[index] === "\\") {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
              var n = str.indexOf(close, index);
              if (n !== -1) {
                index = n + 1;
              }
            }
            if (str[index] === "!") {
              return true;
            }
          } else {
            index++;
          }
        }
        return false;
      };
      var relaxedCheck = function(str) {
        if (str[0] === "!") {
          return true;
        }
        var index = 0;
        while (index < str.length) {
          if (/[*?{}()[\]]/.test(str[index])) {
            return true;
          }
          if (str[index] === "\\") {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
              var n = str.indexOf(close, index);
              if (n !== -1) {
                index = n + 1;
              }
            }
            if (str[index] === "!") {
              return true;
            }
          } else {
            index++;
          }
        }
        return false;
      };
      module.exports = function isGlob(str, options) {
        if (typeof str !== "string" || str === "") {
          return false;
        }
        if (isExtglob(str)) {
          return true;
        }
        var check = strictCheck;
        if (options && options.strict === false) {
          check = relaxedCheck;
        }
        return check(str);
      };
    }
  });

  // ../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
  var require_glob_parent = __commonJS({
    "../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js"(exports, module) {
      "use strict";
      var isGlob = require_is_glob();
      var pathPosixDirname = __require2("path").posix.dirname;
      var isWin32 = __require2("os").platform() === "win32";
      var slash = "/";
      var backslash = /\\/g;
      var enclosure = /[\{\[].*[\}\]]$/;
      var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
      var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
      module.exports = function globParent(str, opts) {
        var options = Object.assign({ flipBackslashes: true }, opts);
        if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
          str = str.replace(backslash, slash);
        }
        if (enclosure.test(str)) {
          str += slash;
        }
        str += "a";
        do {
          str = pathPosixDirname(str);
        } while (isGlob(str) || globby.test(str));
        return str.replace(escaped, "$1");
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js
  var require_utils5 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js"(exports) {
      "use strict";
      exports.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports.find = (node, type3) => node.nodes.find((node2) => node2.type === type3);
      exports.exceedsLimit = (min, max2, step = 1, limit) => {
        if (limit === false)
          return false;
        if (!exports.isInteger(min) || !exports.isInteger(max2))
          return false;
        return (Number(max2) - Number(min)) / Number(step) >= limit;
      };
      exports.escapeNode = (block2, n = 0, type3) => {
        let node = block2.nodes[n];
        if (!node)
          return;
        if (type3 && node.type === type3 || node.type === "open" || node.type === "close") {
          if (node.escaped !== true) {
            node.value = "\\" + node.value;
            node.escaped = true;
          }
        }
      };
      exports.encloseBrace = (node) => {
        if (node.type !== "brace")
          return false;
        if (node.commas >> 0 + node.ranges >> 0 === 0) {
          node.invalid = true;
          return true;
        }
        return false;
      };
      exports.isInvalidBrace = (block2) => {
        if (block2.type !== "brace")
          return false;
        if (block2.invalid === true || block2.dollar)
          return true;
        if (block2.commas >> 0 + block2.ranges >> 0 === 0) {
          block2.invalid = true;
          return true;
        }
        if (block2.open !== true || block2.close !== true) {
          block2.invalid = true;
          return true;
        }
        return false;
      };
      exports.isOpenOrClose = (node) => {
        if (node.type === "open" || node.type === "close") {
          return true;
        }
        return node.open === true || node.close === true;
      };
      exports.reduce = (nodes) => nodes.reduce((acc, node) => {
        if (node.type === "text")
          acc.push(node.value);
        if (node.type === "range")
          node.type = "text";
        return acc;
      }, []);
      exports.flatten = (...args) => {
        const result = [];
        const flat = (arr) => {
          for (let i = 0; i < arr.length; i++) {
            let ele = arr[i];
            Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
          }
          return result;
        };
        flat(args);
        return result;
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js
  var require_stringify = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      module.exports = (ast, options = {}) => {
        let stringify2 = (node, parent = {}) => {
          let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
          let invalidNode = node.invalid === true && options.escapeInvalid === true;
          let output3 = "";
          if (node.value) {
            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
              return "\\" + node.value;
            }
            return node.value;
          }
          if (node.value) {
            return node.value;
          }
          if (node.nodes) {
            for (let child of node.nodes) {
              output3 += stringify2(child);
            }
          }
          return output3;
        };
        return stringify2(ast);
      };
    }
  });

  // ../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
  var require_is_number = __commonJS({
    "../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js"(exports, module) {
      "use strict";
      module.exports = function(num) {
        if (typeof num === "number") {
          return num - num === 0;
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
        }
        return false;
      };
    }
  });

  // ../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
  var require_to_regex_range = __commonJS({
    "../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"(exports, module) {
      "use strict";
      var isNumber = require_is_number();
      var toRegexRange = (min, max2, options) => {
        if (isNumber(min) === false) {
          throw new TypeError("toRegexRange: expected the first argument to be a number");
        }
        if (max2 === void 0 || min === max2) {
          return String(min);
        }
        if (isNumber(max2) === false) {
          throw new TypeError("toRegexRange: expected the second argument to be a number.");
        }
        let opts = { relaxZeros: true, ...options };
        if (typeof opts.strictZeros === "boolean") {
          opts.relaxZeros = opts.strictZeros === false;
        }
        let relax = String(opts.relaxZeros);
        let shorthand = String(opts.shorthand);
        let capture = String(opts.capture);
        let wrap2 = String(opts.wrap);
        let cacheKey = min + ":" + max2 + "=" + relax + shorthand + capture + wrap2;
        if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
          return toRegexRange.cache[cacheKey].result;
        }
        let a = Math.min(min, max2);
        let b = Math.max(min, max2);
        if (Math.abs(a - b) === 1) {
          let result = min + "|" + max2;
          if (opts.capture) {
            return `(${result})`;
          }
          if (opts.wrap === false) {
            return result;
          }
          return `(?:${result})`;
        }
        let isPadded = hasPadding(min) || hasPadding(max2);
        let state = { min, max: max2, a, b };
        let positives = [];
        let negatives = [];
        if (isPadded) {
          state.isPadded = isPadded;
          state.maxLen = String(state.max).length;
        }
        if (a < 0) {
          let newMin = b < 0 ? Math.abs(b) : 1;
          negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
          a = state.a = 0;
        }
        if (b >= 0) {
          positives = splitToPatterns(a, b, state, opts);
        }
        state.negatives = negatives;
        state.positives = positives;
        state.result = collatePatterns(negatives, positives, opts);
        if (opts.capture === true) {
          state.result = `(${state.result})`;
        } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
          state.result = `(?:${state.result})`;
        }
        toRegexRange.cache[cacheKey] = state;
        return state.result;
      };
      function collatePatterns(neg, pos, options) {
        let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
        let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
        let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
        let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
        return subpatterns.join("|");
      }
      function splitToRanges(min, max2) {
        let nines = 1;
        let zeros = 1;
        let stop = countNines(min, nines);
        let stops = /* @__PURE__ */ new Set([max2]);
        while (min <= stop && stop <= max2) {
          stops.add(stop);
          nines += 1;
          stop = countNines(min, nines);
        }
        stop = countZeros(max2 + 1, zeros) - 1;
        while (min < stop && stop <= max2) {
          stops.add(stop);
          zeros += 1;
          stop = countZeros(max2 + 1, zeros) - 1;
        }
        stops = [...stops];
        stops.sort(compare);
        return stops;
      }
      function rangeToPattern(start, stop, options) {
        if (start === stop) {
          return { pattern: start, count: [], digits: 0 };
        }
        let zipped = zip(start, stop);
        let digits = zipped.length;
        let pattern = "";
        let count = 0;
        for (let i = 0; i < digits; i++) {
          let [startDigit, stopDigit] = zipped[i];
          if (startDigit === stopDigit) {
            pattern += startDigit;
          } else if (startDigit !== "0" || stopDigit !== "9") {
            pattern += toCharacterClass(startDigit, stopDigit, options);
          } else {
            count++;
          }
        }
        if (count) {
          pattern += options.shorthand === true ? "\\d" : "[0-9]";
        }
        return { pattern, count: [count], digits };
      }
      function splitToPatterns(min, max2, tok, options) {
        let ranges = splitToRanges(min, max2);
        let tokens = [];
        let start = min;
        let prev;
        for (let i = 0; i < ranges.length; i++) {
          let max3 = ranges[i];
          let obj = rangeToPattern(String(start), String(max3), options);
          let zeros = "";
          if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.count.length > 1) {
              prev.count.pop();
            }
            prev.count.push(obj.count[0]);
            prev.string = prev.pattern + toQuantifier(prev.count);
            start = max3 + 1;
            continue;
          }
          if (tok.isPadded) {
            zeros = padZeros(max3, tok, options);
          }
          obj.string = zeros + obj.pattern + toQuantifier(obj.count);
          tokens.push(obj);
          start = max3 + 1;
          prev = obj;
        }
        return tokens;
      }
      function filterPatterns(arr, comparison, prefix, intersection, options) {
        let result = [];
        for (let ele of arr) {
          let { string: string2 } = ele;
          if (!intersection && !contains3(comparison, "string", string2)) {
            result.push(prefix + string2);
          }
          if (intersection && contains3(comparison, "string", string2)) {
            result.push(prefix + string2);
          }
        }
        return result;
      }
      function zip(a, b) {
        let arr = [];
        for (let i = 0; i < a.length; i++)
          arr.push([a[i], b[i]]);
        return arr;
      }
      function compare(a, b) {
        return a > b ? 1 : b > a ? -1 : 0;
      }
      function contains3(arr, key, val) {
        return arr.some((ele) => ele[key] === val);
      }
      function countNines(min, len) {
        return Number(String(min).slice(0, -len) + "9".repeat(len));
      }
      function countZeros(integer, zeros) {
        return integer - integer % Math.pow(10, zeros);
      }
      function toQuantifier(digits) {
        let [start = 0, stop = ""] = digits;
        if (stop || start > 1) {
          return `{${start + (stop ? "," + stop : "")}}`;
        }
        return "";
      }
      function toCharacterClass(a, b, options) {
        return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
      }
      function hasPadding(str) {
        return /^-?(0+)\d/.test(str);
      }
      function padZeros(value, tok, options) {
        if (!tok.isPadded) {
          return value;
        }
        let diff = Math.abs(tok.maxLen - String(value).length);
        let relax = options.relaxZeros !== false;
        switch (diff) {
          case 0:
            return "";
          case 1:
            return relax ? "0?" : "0";
          case 2:
            return relax ? "0{0,2}" : "00";
          default: {
            return relax ? `0{0,${diff}}` : `0{${diff}}`;
          }
        }
      }
      toRegexRange.cache = {};
      toRegexRange.clearCache = () => toRegexRange.cache = {};
      module.exports = toRegexRange;
    }
  });

  // ../../node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js
  var require_fill_range = __commonJS({
    "../../node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js"(exports, module) {
      "use strict";
      var util = __require2("util");
      var toRegexRange = require_to_regex_range();
      var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      var transform = (toNumber3) => {
        return (value) => toNumber3 === true ? Number(value) : String(value);
      };
      var isValidValue = (value) => {
        return typeof value === "number" || typeof value === "string" && value !== "";
      };
      var isNumber = (num) => Number.isInteger(+num);
      var zeros = (input) => {
        let value = `${input}`;
        let index = -1;
        if (value[0] === "-")
          value = value.slice(1);
        if (value === "0")
          return false;
        while (value[++index] === "0")
          ;
        return index > 0;
      };
      var stringify2 = (start, end, options) => {
        if (typeof start === "string" || typeof end === "string") {
          return true;
        }
        return options.stringify === true;
      };
      var pad3 = (input, maxLength, toNumber3) => {
        if (maxLength > 0) {
          let dash = input[0] === "-" ? "-" : "";
          if (dash)
            input = input.slice(1);
          input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
        }
        if (toNumber3 === false) {
          return String(input);
        }
        return input;
      };
      var toMaxLen = (input, maxLength) => {
        let negative = input[0] === "-" ? "-" : "";
        if (negative) {
          input = input.slice(1);
          maxLength--;
        }
        while (input.length < maxLength)
          input = "0" + input;
        return negative ? "-" + input : input;
      };
      var toSequence = (parts, options) => {
        parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
        parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
        let prefix = options.capture ? "" : "?:";
        let positives = "";
        let negatives = "";
        let result;
        if (parts.positives.length) {
          positives = parts.positives.join("|");
        }
        if (parts.negatives.length) {
          negatives = `-(${prefix}${parts.negatives.join("|")})`;
        }
        if (positives && negatives) {
          result = `${positives}|${negatives}`;
        } else {
          result = positives || negatives;
        }
        if (options.wrap) {
          return `(${prefix}${result})`;
        }
        return result;
      };
      var toRange = (a, b, isNumbers, options) => {
        if (isNumbers) {
          return toRegexRange(a, b, { wrap: false, ...options });
        }
        let start = String.fromCharCode(a);
        if (a === b)
          return start;
        let stop = String.fromCharCode(b);
        return `[${start}-${stop}]`;
      };
      var toRegex = (start, end, options) => {
        if (Array.isArray(start)) {
          let wrap2 = options.wrap === true;
          let prefix = options.capture ? "" : "?:";
          return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
        }
        return toRegexRange(start, end, options);
      };
      var rangeError = (...args) => {
        return new RangeError("Invalid range arguments: " + util.inspect(...args));
      };
      var invalidRange = (start, end, options) => {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      };
      var invalidStep = (step, options) => {
        if (options.strictRanges === true) {
          throw new TypeError(`Expected step "${step}" to be a number`);
        }
        return [];
      };
      var fillNumbers = (start, end, step = 1, options = {}) => {
        let a = Number(start);
        let b = Number(end);
        if (!Number.isInteger(a) || !Number.isInteger(b)) {
          if (options.strictRanges === true)
            throw rangeError([start, end]);
          return [];
        }
        if (a === 0)
          a = 0;
        if (b === 0)
          b = 0;
        let descending = a > b;
        let startString = String(start);
        let endString = String(end);
        let stepString = String(step);
        step = Math.max(Math.abs(step), 1);
        let padded = zeros(startString) || zeros(endString) || zeros(stepString);
        let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
        let toNumber3 = padded === false && stringify2(start, end, options) === false;
        let format = options.transform || transform(toNumber3);
        if (options.toRegex && step === 1) {
          return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
        }
        let parts = { negatives: [], positives: [] };
        let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
        let range = [];
        let index = 0;
        while (descending ? a >= b : a <= b) {
          if (options.toRegex === true && step > 1) {
            push(a);
          } else {
            range.push(pad3(format(a, index), maxLen, toNumber3));
          }
          a = descending ? a - step : a + step;
          index++;
        }
        if (options.toRegex === true) {
          return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
        }
        return range;
      };
      var fillLetters = (start, end, step = 1, options = {}) => {
        if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
          return invalidRange(start, end, options);
        }
        let format = options.transform || ((val) => String.fromCharCode(val));
        let a = `${start}`.charCodeAt(0);
        let b = `${end}`.charCodeAt(0);
        let descending = a > b;
        let min = Math.min(a, b);
        let max2 = Math.max(a, b);
        if (options.toRegex && step === 1) {
          return toRange(min, max2, false, options);
        }
        let range = [];
        let index = 0;
        while (descending ? a >= b : a <= b) {
          range.push(format(a, index));
          a = descending ? a - step : a + step;
          index++;
        }
        if (options.toRegex === true) {
          return toRegex(range, null, { wrap: false, options });
        }
        return range;
      };
      var fill = (start, end, step, options = {}) => {
        if (end == null && isValidValue(start)) {
          return [start];
        }
        if (!isValidValue(start) || !isValidValue(end)) {
          return invalidRange(start, end, options);
        }
        if (typeof step === "function") {
          return fill(start, end, 1, { transform: step });
        }
        if (isObject2(step)) {
          return fill(start, end, 0, step);
        }
        let opts = { ...options };
        if (opts.capture === true)
          opts.wrap = true;
        step = step || opts.step || 1;
        if (!isNumber(step)) {
          if (step != null && !isObject2(step))
            return invalidStep(step, opts);
          return fill(start, end, 1, step);
        }
        if (isNumber(start) && isNumber(end)) {
          return fillNumbers(start, end, step, opts);
        }
        return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
      };
      module.exports = fill;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js
  var require_compile = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js"(exports, module) {
      "use strict";
      var fill = require_fill_range();
      var utils = require_utils5();
      var compile6 = (ast, options = {}) => {
        let walk = (node, parent = {}) => {
          let invalidBlock = utils.isInvalidBrace(parent);
          let invalidNode = node.invalid === true && options.escapeInvalid === true;
          let invalid = invalidBlock === true || invalidNode === true;
          let prefix = options.escapeInvalid === true ? "\\" : "";
          let output3 = "";
          if (node.isOpen === true) {
            return prefix + node.value;
          }
          if (node.isClose === true) {
            return prefix + node.value;
          }
          if (node.type === "open") {
            return invalid ? prefix + node.value : "(";
          }
          if (node.type === "close") {
            return invalid ? prefix + node.value : ")";
          }
          if (node.type === "comma") {
            return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
          }
          if (node.value) {
            return node.value;
          }
          if (node.nodes && node.ranges > 0) {
            let args = utils.reduce(node.nodes);
            let range = fill(...args, { ...options, wrap: false, toRegex: true });
            if (range.length !== 0) {
              return args.length > 1 && range.length > 1 ? `(${range})` : range;
            }
          }
          if (node.nodes) {
            for (let child of node.nodes) {
              output3 += walk(child, node);
            }
          }
          return output3;
        };
        return walk(ast);
      };
      module.exports = compile6;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js
  var require_expand = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js"(exports, module) {
      "use strict";
      var fill = require_fill_range();
      var stringify2 = require_stringify();
      var utils = require_utils5();
      var append = (queue = "", stash = "", enclose = false) => {
        let result = [];
        queue = [].concat(queue);
        stash = [].concat(stash);
        if (!stash.length)
          return queue;
        if (!queue.length) {
          return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
        }
        for (let item of queue) {
          if (Array.isArray(item)) {
            for (let value of item) {
              result.push(append(value, stash, enclose));
            }
          } else {
            for (let ele of stash) {
              if (enclose === true && typeof ele === "string")
                ele = `{${ele}}`;
              result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
            }
          }
        }
        return utils.flatten(result);
      };
      var expand2 = (ast, options = {}) => {
        let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
        let walk = (node, parent = {}) => {
          node.queue = [];
          let p = parent;
          let q = parent.queue;
          while (p.type !== "brace" && p.type !== "root" && p.parent) {
            p = p.parent;
            q = p.queue;
          }
          if (node.invalid || node.dollar) {
            q.push(append(q.pop(), stringify2(node, options)));
            return;
          }
          if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
            q.push(append(q.pop(), ["{}"]));
            return;
          }
          if (node.nodes && node.ranges > 0) {
            let args = utils.reduce(node.nodes);
            if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
              throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
            }
            let range = fill(...args, options);
            if (range.length === 0) {
              range = stringify2(node, options);
            }
            q.push(append(q.pop(), range));
            node.nodes = [];
            return;
          }
          let enclose = utils.encloseBrace(node);
          let queue = node.queue;
          let block2 = node;
          while (block2.type !== "brace" && block2.type !== "root" && block2.parent) {
            block2 = block2.parent;
            queue = block2.queue;
          }
          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i];
            if (child.type === "comma" && node.type === "brace") {
              if (i === 1)
                queue.push("");
              queue.push("");
              continue;
            }
            if (child.type === "close") {
              q.push(append(q.pop(), queue, enclose));
              continue;
            }
            if (child.value && child.type !== "open") {
              queue.push(append(queue.pop(), child.value));
              continue;
            }
            if (child.nodes) {
              walk(child, node);
            }
          }
          return queue;
        };
        return utils.flatten(walk(ast));
      };
      module.exports = expand2;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js
  var require_constants2 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        MAX_LENGTH: 1024 * 64,
        // Digits
        CHAR_0: "0",
        /* 0 */
        CHAR_9: "9",
        /* 9 */
        // Alphabet chars.
        CHAR_UPPERCASE_A: "A",
        /* A */
        CHAR_LOWERCASE_A: "a",
        /* a */
        CHAR_UPPERCASE_Z: "Z",
        /* Z */
        CHAR_LOWERCASE_Z: "z",
        /* z */
        CHAR_LEFT_PARENTHESES: "(",
        /* ( */
        CHAR_RIGHT_PARENTHESES: ")",
        /* ) */
        CHAR_ASTERISK: "*",
        /* * */
        // Non-alphabetic chars.
        CHAR_AMPERSAND: "&",
        /* & */
        CHAR_AT: "@",
        /* @ */
        CHAR_BACKSLASH: "\\",
        /* \ */
        CHAR_BACKTICK: "`",
        /* ` */
        CHAR_CARRIAGE_RETURN: "\r",
        /* \r */
        CHAR_CIRCUMFLEX_ACCENT: "^",
        /* ^ */
        CHAR_COLON: ":",
        /* : */
        CHAR_COMMA: ",",
        /* , */
        CHAR_DOLLAR: "$",
        /* . */
        CHAR_DOT: ".",
        /* . */
        CHAR_DOUBLE_QUOTE: '"',
        /* " */
        CHAR_EQUAL: "=",
        /* = */
        CHAR_EXCLAMATION_MARK: "!",
        /* ! */
        CHAR_FORM_FEED: "\f",
        /* \f */
        CHAR_FORWARD_SLASH: "/",
        /* / */
        CHAR_HASH: "#",
        /* # */
        CHAR_HYPHEN_MINUS: "-",
        /* - */
        CHAR_LEFT_ANGLE_BRACKET: "<",
        /* < */
        CHAR_LEFT_CURLY_BRACE: "{",
        /* { */
        CHAR_LEFT_SQUARE_BRACKET: "[",
        /* [ */
        CHAR_LINE_FEED: "\n",
        /* \n */
        CHAR_NO_BREAK_SPACE: "\xA0",
        /* \u00A0 */
        CHAR_PERCENT: "%",
        /* % */
        CHAR_PLUS: "+",
        /* + */
        CHAR_QUESTION_MARK: "?",
        /* ? */
        CHAR_RIGHT_ANGLE_BRACKET: ">",
        /* > */
        CHAR_RIGHT_CURLY_BRACE: "}",
        /* } */
        CHAR_RIGHT_SQUARE_BRACKET: "]",
        /* ] */
        CHAR_SEMICOLON: ";",
        /* ; */
        CHAR_SINGLE_QUOTE: "'",
        /* ' */
        CHAR_SPACE: " ",
        /*   */
        CHAR_TAB: "	",
        /* \t */
        CHAR_UNDERSCORE: "_",
        /* _ */
        CHAR_VERTICAL_LINE: "|",
        /* | */
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
        /* \uFEFF */
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js
  var require_parse2 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js"(exports, module) {
      "use strict";
      var stringify2 = require_stringify();
      var {
        MAX_LENGTH,
        CHAR_BACKSLASH,
        /* \ */
        CHAR_BACKTICK,
        /* ` */
        CHAR_COMMA,
        /* , */
        CHAR_DOT,
        /* . */
        CHAR_LEFT_PARENTHESES,
        /* ( */
        CHAR_RIGHT_PARENTHESES,
        /* ) */
        CHAR_LEFT_CURLY_BRACE,
        /* { */
        CHAR_RIGHT_CURLY_BRACE,
        /* } */
        CHAR_LEFT_SQUARE_BRACKET,
        /* [ */
        CHAR_RIGHT_SQUARE_BRACKET,
        /* ] */
        CHAR_DOUBLE_QUOTE,
        /* " */
        CHAR_SINGLE_QUOTE,
        /* ' */
        CHAR_NO_BREAK_SPACE,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE
      } = require_constants2();
      var parse3 = (input, options = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        let opts = options || {};
        let max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        if (input.length > max2) {
          throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
        }
        let ast = { type: "root", input, nodes: [] };
        let stack = [ast];
        let block2 = ast;
        let prev = ast;
        let brackets = 0;
        let length = input.length;
        let index = 0;
        let depth = 0;
        let value;
        let memo = {};
        const advance = () => input[index++];
        const push = (node) => {
          if (node.type === "text" && prev.type === "dot") {
            prev.type = "text";
          }
          if (prev && prev.type === "text" && node.type === "text") {
            prev.value += node.value;
            return;
          }
          block2.nodes.push(node);
          node.parent = block2;
          node.prev = prev;
          prev = node;
          return node;
        };
        push({ type: "bos" });
        while (index < length) {
          block2 = stack[stack.length - 1];
          value = advance();
          if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
            continue;
          }
          if (value === CHAR_BACKSLASH) {
            push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
            continue;
          }
          if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({ type: "text", value: "\\" + value });
            continue;
          }
          if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            let closed = true;
            let next;
            while (index < length && (next = advance())) {
              value += next;
              if (next === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                continue;
              }
              if (next === CHAR_BACKSLASH) {
                value += advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                brackets--;
                if (brackets === 0) {
                  break;
                }
              }
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_PARENTHESES) {
            block2 = push({ type: "paren", nodes: [] });
            stack.push(block2);
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_RIGHT_PARENTHESES) {
            if (block2.type !== "paren") {
              push({ type: "text", value });
              continue;
            }
            block2 = stack.pop();
            push({ type: "text", value });
            block2 = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            let open = value;
            let next;
            if (options.keepQuotes !== true) {
              value = "";
            }
            while (index < length && (next = advance())) {
              if (next === CHAR_BACKSLASH) {
                value += next + advance();
                continue;
              }
              if (next === open) {
                if (options.keepQuotes === true)
                  value += next;
                break;
              }
              value += next;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            let dollar = prev.value && prev.value.slice(-1) === "$" || block2.dollar === true;
            let brace = {
              type: "brace",
              open: true,
              close: false,
              dollar,
              depth,
              commas: 0,
              ranges: 0,
              nodes: []
            };
            block2 = push(brace);
            stack.push(block2);
            push({ type: "open", value });
            continue;
          }
          if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block2.type !== "brace") {
              push({ type: "text", value });
              continue;
            }
            let type3 = "close";
            block2 = stack.pop();
            block2.close = true;
            push({ type: type3, value });
            depth--;
            block2 = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_COMMA && depth > 0) {
            if (block2.ranges > 0) {
              block2.ranges = 0;
              let open = block2.nodes.shift();
              block2.nodes = [open, { type: "text", value: stringify2(block2) }];
            }
            push({ type: "comma", value });
            block2.commas++;
            continue;
          }
          if (value === CHAR_DOT && depth > 0 && block2.commas === 0) {
            let siblings = block2.nodes;
            if (depth === 0 || siblings.length === 0) {
              push({ type: "text", value });
              continue;
            }
            if (prev.type === "dot") {
              block2.range = [];
              prev.value += value;
              prev.type = "range";
              if (block2.nodes.length !== 3 && block2.nodes.length !== 5) {
                block2.invalid = true;
                block2.ranges = 0;
                prev.type = "text";
                continue;
              }
              block2.ranges++;
              block2.args = [];
              continue;
            }
            if (prev.type === "range") {
              siblings.pop();
              let before = siblings[siblings.length - 1];
              before.value += prev.value + value;
              prev = before;
              block2.ranges--;
              continue;
            }
            push({ type: "dot", value });
            continue;
          }
          push({ type: "text", value });
        }
        do {
          block2 = stack.pop();
          if (block2.type !== "root") {
            block2.nodes.forEach((node) => {
              if (!node.nodes) {
                if (node.type === "open")
                  node.isOpen = true;
                if (node.type === "close")
                  node.isClose = true;
                if (!node.nodes)
                  node.type = "text";
                node.invalid = true;
              }
            });
            let parent = stack[stack.length - 1];
            let index2 = parent.nodes.indexOf(block2);
            parent.nodes.splice(index2, 1, ...block2.nodes);
          }
        } while (stack.length > 0);
        push({ type: "eos" });
        return ast;
      };
      module.exports = parse3;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js
  var require_braces = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js"(exports, module) {
      "use strict";
      var stringify2 = require_stringify();
      var compile6 = require_compile();
      var expand2 = require_expand();
      var parse3 = require_parse2();
      var braces = (input, options = {}) => {
        let output3 = [];
        if (Array.isArray(input)) {
          for (let pattern of input) {
            let result = braces.create(pattern, options);
            if (Array.isArray(result)) {
              output3.push(...result);
            } else {
              output3.push(result);
            }
          }
        } else {
          output3 = [].concat(braces.create(input, options));
        }
        if (options && options.expand === true && options.nodupes === true) {
          output3 = [...new Set(output3)];
        }
        return output3;
      };
      braces.parse = (input, options = {}) => parse3(input, options);
      braces.stringify = (input, options = {}) => {
        if (typeof input === "string") {
          return stringify2(braces.parse(input, options), options);
        }
        return stringify2(input, options);
      };
      braces.compile = (input, options = {}) => {
        if (typeof input === "string") {
          input = braces.parse(input, options);
        }
        return compile6(input, options);
      };
      braces.expand = (input, options = {}) => {
        if (typeof input === "string") {
          input = braces.parse(input, options);
        }
        let result = expand2(input, options);
        if (options.noempty === true) {
          result = result.filter(Boolean);
        }
        if (options.nodupes === true) {
          result = [...new Set(result)];
        }
        return result;
      };
      braces.create = (input, options = {}) => {
        if (input === "" || input.length < 3) {
          return [input];
        }
        return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
      };
      module.exports = braces;
    }
  });

  // ../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/binary-extensions.json
  var require_binary_extensions = __commonJS({
    "../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/binary-extensions.json"(exports, module) {
      module.exports = [
        "3dm",
        "3ds",
        "3g2",
        "3gp",
        "7z",
        "a",
        "aac",
        "adp",
        "ai",
        "aif",
        "aiff",
        "alz",
        "ape",
        "apk",
        "appimage",
        "ar",
        "arj",
        "asf",
        "au",
        "avi",
        "bak",
        "baml",
        "bh",
        "bin",
        "bk",
        "bmp",
        "btif",
        "bz2",
        "bzip2",
        "cab",
        "caf",
        "cgm",
        "class",
        "cmx",
        "cpio",
        "cr2",
        "cur",
        "dat",
        "dcm",
        "deb",
        "dex",
        "djvu",
        "dll",
        "dmg",
        "dng",
        "doc",
        "docm",
        "docx",
        "dot",
        "dotm",
        "dra",
        "DS_Store",
        "dsk",
        "dts",
        "dtshd",
        "dvb",
        "dwg",
        "dxf",
        "ecelp4800",
        "ecelp7470",
        "ecelp9600",
        "egg",
        "eol",
        "eot",
        "epub",
        "exe",
        "f4v",
        "fbs",
        "fh",
        "fla",
        "flac",
        "flatpak",
        "fli",
        "flv",
        "fpx",
        "fst",
        "fvt",
        "g3",
        "gh",
        "gif",
        "graffle",
        "gz",
        "gzip",
        "h261",
        "h263",
        "h264",
        "icns",
        "ico",
        "ief",
        "img",
        "ipa",
        "iso",
        "jar",
        "jpeg",
        "jpg",
        "jpgv",
        "jpm",
        "jxr",
        "key",
        "ktx",
        "lha",
        "lib",
        "lvp",
        "lz",
        "lzh",
        "lzma",
        "lzo",
        "m3u",
        "m4a",
        "m4v",
        "mar",
        "mdi",
        "mht",
        "mid",
        "midi",
        "mj2",
        "mka",
        "mkv",
        "mmr",
        "mng",
        "mobi",
        "mov",
        "movie",
        "mp3",
        "mp4",
        "mp4a",
        "mpeg",
        "mpg",
        "mpga",
        "mxu",
        "nef",
        "npx",
        "numbers",
        "nupkg",
        "o",
        "odp",
        "ods",
        "odt",
        "oga",
        "ogg",
        "ogv",
        "otf",
        "ott",
        "pages",
        "pbm",
        "pcx",
        "pdb",
        "pdf",
        "pea",
        "pgm",
        "pic",
        "png",
        "pnm",
        "pot",
        "potm",
        "potx",
        "ppa",
        "ppam",
        "ppm",
        "pps",
        "ppsm",
        "ppsx",
        "ppt",
        "pptm",
        "pptx",
        "psd",
        "pya",
        "pyc",
        "pyo",
        "pyv",
        "qt",
        "rar",
        "ras",
        "raw",
        "resources",
        "rgb",
        "rip",
        "rlc",
        "rmf",
        "rmvb",
        "rpm",
        "rtf",
        "rz",
        "s3m",
        "s7z",
        "scpt",
        "sgi",
        "shar",
        "snap",
        "sil",
        "sketch",
        "slk",
        "smv",
        "snk",
        "so",
        "stl",
        "suo",
        "sub",
        "swf",
        "tar",
        "tbz",
        "tbz2",
        "tga",
        "tgz",
        "thmx",
        "tif",
        "tiff",
        "tlz",
        "ttc",
        "ttf",
        "txz",
        "udf",
        "uvh",
        "uvi",
        "uvm",
        "uvp",
        "uvs",
        "uvu",
        "viv",
        "vob",
        "war",
        "wav",
        "wax",
        "wbmp",
        "wdp",
        "weba",
        "webm",
        "webp",
        "whl",
        "wim",
        "wm",
        "wma",
        "wmv",
        "wmx",
        "woff",
        "woff2",
        "wrm",
        "wvx",
        "xbm",
        "xif",
        "xla",
        "xlam",
        "xls",
        "xlsb",
        "xlsm",
        "xlsx",
        "xlt",
        "xltm",
        "xltx",
        "xm",
        "xmind",
        "xpi",
        "xpm",
        "xwd",
        "xz",
        "z",
        "zip",
        "zipx"
      ];
    }
  });

  // ../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/index.js
  var require_binary_extensions2 = __commonJS({
    "../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/index.js"(exports, module) {
      module.exports = require_binary_extensions();
    }
  });

  // ../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js
  var require_is_binary_path = __commonJS({
    "../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js"(exports, module) {
      "use strict";
      var path5 = __require2("path");
      var binaryExtensions = require_binary_extensions2();
      var extensions = new Set(binaryExtensions);
      module.exports = (filePath) => extensions.has(path5.extname(filePath).slice(1).toLowerCase());
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/constants.js
  var require_constants3 = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/constants.js"(exports) {
      "use strict";
      var { sep: sep2 } = __require2("path");
      var { platform } = process;
      var os2 = __require2("os");
      exports.EV_ALL = "all";
      exports.EV_READY = "ready";
      exports.EV_ADD = "add";
      exports.EV_CHANGE = "change";
      exports.EV_ADD_DIR = "addDir";
      exports.EV_UNLINK = "unlink";
      exports.EV_UNLINK_DIR = "unlinkDir";
      exports.EV_RAW = "raw";
      exports.EV_ERROR = "error";
      exports.STR_DATA = "data";
      exports.STR_END = "end";
      exports.STR_CLOSE = "close";
      exports.FSEVENT_CREATED = "created";
      exports.FSEVENT_MODIFIED = "modified";
      exports.FSEVENT_DELETED = "deleted";
      exports.FSEVENT_MOVED = "moved";
      exports.FSEVENT_CLONED = "cloned";
      exports.FSEVENT_UNKNOWN = "unknown";
      exports.FSEVENT_TYPE_FILE = "file";
      exports.FSEVENT_TYPE_DIRECTORY = "directory";
      exports.FSEVENT_TYPE_SYMLINK = "symlink";
      exports.KEY_LISTENERS = "listeners";
      exports.KEY_ERR = "errHandlers";
      exports.KEY_RAW = "rawEmitters";
      exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
      exports.DOT_SLASH = `.${sep2}`;
      exports.BACK_SLASH_RE = /\\/g;
      exports.DOUBLE_SLASH_RE = /\/\//;
      exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
      exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
      exports.REPLACER_RE = /^\.[/\\]/;
      exports.SLASH = "/";
      exports.SLASH_SLASH = "//";
      exports.BRACE_START = "{";
      exports.BANG = "!";
      exports.ONE_DOT = ".";
      exports.TWO_DOTS = "..";
      exports.STAR = "*";
      exports.GLOBSTAR = "**";
      exports.ROOT_GLOBSTAR = "/**/*";
      exports.SLASH_GLOBSTAR = "/**";
      exports.DIR_SUFFIX = "Dir";
      exports.ANYMATCH_OPTS = { dot: true };
      exports.STRING_TYPE = "string";
      exports.FUNCTION_TYPE = "function";
      exports.EMPTY_STR = "";
      exports.EMPTY_FN = () => {
      };
      exports.IDENTITY_FN = (val) => val;
      exports.isWindows = platform === "win32";
      exports.isMacos = platform === "darwin";
      exports.isLinux = platform === "linux";
      exports.isIBMi = os2.type() === "OS400";
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/nodefs-handler.js
  var require_nodefs_handler = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/nodefs-handler.js"(exports, module) {
      "use strict";
      var fs4 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var isBinaryPath = require_is_binary_path();
      var {
        isWindows,
        isLinux,
        EMPTY_FN,
        EMPTY_STR,
        KEY_LISTENERS,
        KEY_ERR,
        KEY_RAW,
        HANDLER_KEYS,
        EV_CHANGE,
        EV_ADD,
        EV_ADD_DIR,
        EV_ERROR,
        STR_DATA,
        STR_END,
        BRACE_START,
        STAR
      } = require_constants3();
      var THROTTLE_MODE_WATCH = "watch";
      var open = promisify(fs4.open);
      var stat = promisify(fs4.stat);
      var lstat2 = promisify(fs4.lstat);
      var close = promisify(fs4.close);
      var fsrealpath = promisify(fs4.realpath);
      var statMethods = { lstat: lstat2, stat };
      var foreach = (val, fn) => {
        if (val instanceof Set) {
          val.forEach(fn);
        } else {
          fn(val);
        }
      };
      var addAndConvert = (main, prop, item) => {
        let container = main[prop];
        if (!(container instanceof Set)) {
          main[prop] = container = /* @__PURE__ */ new Set([container]);
        }
        container.add(item);
      };
      var clearItem = (cont) => (key) => {
        const set2 = cont[key];
        if (set2 instanceof Set) {
          set2.clear();
        } else {
          delete cont[key];
        }
      };
      var delFromSet = (main, prop, item) => {
        const container = main[prop];
        if (container instanceof Set) {
          container.delete(item);
        } else if (container === item) {
          delete main[prop];
        }
      };
      var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
      var FsWatchInstances = /* @__PURE__ */ new Map();
      function createFsWatchInstance(path5, options, listener, errHandler, emitRaw) {
        const handleEvent = (rawEvent, evPath) => {
          listener(path5);
          emitRaw(rawEvent, evPath, { watchedPath: path5 });
          if (evPath && path5 !== evPath) {
            fsWatchBroadcast(
              sysPath.resolve(path5, evPath),
              KEY_LISTENERS,
              sysPath.join(path5, evPath)
            );
          }
        };
        try {
          return fs4.watch(path5, options, handleEvent);
        } catch (error2) {
          errHandler(error2);
        }
      }
      var fsWatchBroadcast = (fullPath, type3, val1, val2, val3) => {
        const cont = FsWatchInstances.get(fullPath);
        if (!cont)
          return;
        foreach(cont[type3], (listener) => {
          listener(val1, val2, val3);
        });
      };
      var setFsWatchListener = (path5, fullPath, options, handlers) => {
        const { listener, errHandler, rawEmitter } = handlers;
        let cont = FsWatchInstances.get(fullPath);
        let watcher;
        if (!options.persistent) {
          watcher = createFsWatchInstance(
            path5,
            options,
            listener,
            errHandler,
            rawEmitter
          );
          return watcher.close.bind(watcher);
        }
        if (cont) {
          addAndConvert(cont, KEY_LISTENERS, listener);
          addAndConvert(cont, KEY_ERR, errHandler);
          addAndConvert(cont, KEY_RAW, rawEmitter);
        } else {
          watcher = createFsWatchInstance(
            path5,
            options,
            fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
            errHandler,
            // no need to use broadcast here
            fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
          );
          if (!watcher)
            return;
          watcher.on(EV_ERROR, async (error2) => {
            const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
            cont.watcherUnusable = true;
            if (isWindows && error2.code === "EPERM") {
              try {
                const fd = await open(path5, "r");
                await close(fd);
                broadcastErr(error2);
              } catch (err) {
              }
            } else {
              broadcastErr(error2);
            }
          });
          cont = {
            listeners: listener,
            errHandlers: errHandler,
            rawEmitters: rawEmitter,
            watcher
          };
          FsWatchInstances.set(fullPath, cont);
        }
        return () => {
          delFromSet(cont, KEY_LISTENERS, listener);
          delFromSet(cont, KEY_ERR, errHandler);
          delFromSet(cont, KEY_RAW, rawEmitter);
          if (isEmptySet(cont.listeners)) {
            cont.watcher.close();
            FsWatchInstances.delete(fullPath);
            HANDLER_KEYS.forEach(clearItem(cont));
            cont.watcher = void 0;
            Object.freeze(cont);
          }
        };
      };
      var FsWatchFileInstances = /* @__PURE__ */ new Map();
      var setFsWatchFileListener = (path5, fullPath, options, handlers) => {
        const { listener, rawEmitter } = handlers;
        let cont = FsWatchFileInstances.get(fullPath);
        let listeners = /* @__PURE__ */ new Set();
        let rawEmitters = /* @__PURE__ */ new Set();
        const copts = cont && cont.options;
        if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
          listeners = cont.listeners;
          rawEmitters = cont.rawEmitters;
          fs4.unwatchFile(fullPath);
          cont = void 0;
        }
        if (cont) {
          addAndConvert(cont, KEY_LISTENERS, listener);
          addAndConvert(cont, KEY_RAW, rawEmitter);
        } else {
          cont = {
            listeners: listener,
            rawEmitters: rawEmitter,
            options,
            watcher: fs4.watchFile(fullPath, options, (curr, prev) => {
              foreach(cont.rawEmitters, (rawEmitter2) => {
                rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
              });
              const currmtime = curr.mtimeMs;
              if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
                foreach(cont.listeners, (listener2) => listener2(path5, curr));
              }
            })
          };
          FsWatchFileInstances.set(fullPath, cont);
        }
        return () => {
          delFromSet(cont, KEY_LISTENERS, listener);
          delFromSet(cont, KEY_RAW, rawEmitter);
          if (isEmptySet(cont.listeners)) {
            FsWatchFileInstances.delete(fullPath);
            fs4.unwatchFile(fullPath);
            cont.options = cont.watcher = void 0;
            Object.freeze(cont);
          }
        };
      };
      var NodeFsHandler = class {
        /**
         * @param {import("../index").FSWatcher} fsW
         */
        constructor(fsW) {
          this.fsw = fsW;
          this._boundHandleError = (error2) => fsW._handleError(error2);
        }
        /**
         * Watch file for changes with fs_watchFile or fs_watch.
         * @param {String} path to file or dir
         * @param {Function} listener on fs change
         * @returns {Function} closer for the watcher instance
         */
        _watchWithNodeFs(path5, listener) {
          const opts = this.fsw.options;
          const directory = sysPath.dirname(path5);
          const basename3 = sysPath.basename(path5);
          const parent = this.fsw._getWatchedDir(directory);
          parent.add(basename3);
          const absolutePath = sysPath.resolve(path5);
          const options = { persistent: opts.persistent };
          if (!listener)
            listener = EMPTY_FN;
          let closer;
          if (opts.usePolling) {
            options.interval = opts.enableBinaryInterval && isBinaryPath(basename3) ? opts.binaryInterval : opts.interval;
            closer = setFsWatchFileListener(path5, absolutePath, options, {
              listener,
              rawEmitter: this.fsw._emitRaw
            });
          } else {
            closer = setFsWatchListener(path5, absolutePath, options, {
              listener,
              errHandler: this._boundHandleError,
              rawEmitter: this.fsw._emitRaw
            });
          }
          return closer;
        }
        /**
         * Watch a file and emit add event if warranted.
         * @param {Path} file Path
         * @param {fs.Stats} stats result of fs_stat
         * @param {Boolean} initialAdd was the file added at watch instantiation?
         * @returns {Function} closer for the watcher instance
         */
        _handleFile(file, stats, initialAdd) {
          if (this.fsw.closed) {
            return;
          }
          const dirname = sysPath.dirname(file);
          const basename3 = sysPath.basename(file);
          const parent = this.fsw._getWatchedDir(dirname);
          let prevStats = stats;
          if (parent.has(basename3))
            return;
          const listener = async (path5, newStats) => {
            if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
              return;
            if (!newStats || newStats.mtimeMs === 0) {
              try {
                const newStats2 = await stat(file);
                if (this.fsw.closed)
                  return;
                const at = newStats2.atimeMs;
                const mt = newStats2.mtimeMs;
                if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                  this.fsw._emit(EV_CHANGE, file, newStats2);
                }
                if (isLinux && prevStats.ino !== newStats2.ino) {
                  this.fsw._closeFile(path5);
                  prevStats = newStats2;
                  this.fsw._addPathCloser(path5, this._watchWithNodeFs(file, listener));
                } else {
                  prevStats = newStats2;
                }
              } catch (error2) {
                this.fsw._remove(dirname, basename3);
              }
            } else if (parent.has(basename3)) {
              const at = newStats.atimeMs;
              const mt = newStats.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats);
              }
              prevStats = newStats;
            }
          };
          const closer = this._watchWithNodeFs(file, listener);
          if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
            if (!this.fsw._throttle(EV_ADD, file, 0))
              return;
            this.fsw._emit(EV_ADD, file, stats);
          }
          return closer;
        }
        /**
         * Handle symlinks encountered while reading a dir.
         * @param {Object} entry returned by readdirp
         * @param {String} directory path of dir being read
         * @param {String} path of this item
         * @param {String} item basename of this item
         * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
         */
        async _handleSymlink(entry, directory, path5, item) {
          if (this.fsw.closed) {
            return;
          }
          const full = entry.fullPath;
          const dir = this.fsw._getWatchedDir(directory);
          if (!this.fsw.options.followSymlinks) {
            this.fsw._incrReadyCount();
            let linkPath;
            try {
              linkPath = await fsrealpath(path5);
            } catch (e) {
              this.fsw._emitReady();
              return true;
            }
            if (this.fsw.closed)
              return;
            if (dir.has(item)) {
              if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                this.fsw._symlinkPaths.set(full, linkPath);
                this.fsw._emit(EV_CHANGE, path5, entry.stats);
              }
            } else {
              dir.add(item);
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_ADD, path5, entry.stats);
            }
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw._symlinkPaths.has(full)) {
            return true;
          }
          this.fsw._symlinkPaths.set(full, true);
        }
        _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
          directory = sysPath.join(directory, EMPTY_STR);
          if (!wh.hasGlob) {
            throttler = this.fsw._throttle("readdir", directory, 1e3);
            if (!throttler)
              return;
          }
          const previous = this.fsw._getWatchedDir(wh.path);
          const current = /* @__PURE__ */ new Set();
          let stream2 = this.fsw._readdirp(directory, {
            fileFilter: (entry) => wh.filterPath(entry),
            directoryFilter: (entry) => wh.filterDir(entry),
            depth: 0
          }).on(STR_DATA, async (entry) => {
            if (this.fsw.closed) {
              stream2 = void 0;
              return;
            }
            const item = entry.path;
            let path5 = sysPath.join(directory, item);
            current.add(item);
            if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path5, item)) {
              return;
            }
            if (this.fsw.closed) {
              stream2 = void 0;
              return;
            }
            if (item === target || !target && !previous.has(item)) {
              this.fsw._incrReadyCount();
              path5 = sysPath.join(dir, sysPath.relative(dir, path5));
              this._addToNodeFs(path5, initialAdd, wh, depth + 1);
            }
          }).on(EV_ERROR, this._boundHandleError);
          return new Promise(
            (resolve4) => stream2.once(STR_END, () => {
              if (this.fsw.closed) {
                stream2 = void 0;
                return;
              }
              const wasThrottled = throttler ? throttler.clear() : false;
              resolve4();
              previous.getChildren().filter((item) => {
                return item !== directory && !current.has(item) && // in case of intersecting globs;
                // a path may have been filtered out of this readdir, but
                // shouldn't be removed because it matches a different glob
                (!wh.hasGlob || wh.filterPath({
                  fullPath: sysPath.resolve(directory, item)
                }));
              }).forEach((item) => {
                this.fsw._remove(directory, item);
              });
              stream2 = void 0;
              if (wasThrottled)
                this._handleRead(directory, false, wh, target, dir, depth, throttler);
            })
          );
        }
        /**
         * Read directory to add / remove files from `@watched` list and re-read it on change.
         * @param {String} dir fs path
         * @param {fs.Stats} stats
         * @param {Boolean} initialAdd
         * @param {Number} depth relative to user-supplied path
         * @param {String} target child path targeted for watch
         * @param {Object} wh Common watch helpers for this path
         * @param {String} realpath
         * @returns {Promise<Function>} closer for the watcher instance.
         */
        async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath2) {
          const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
          const tracked = parentDir.has(sysPath.basename(dir));
          if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
            if (!wh.hasGlob || wh.globFilter(dir))
              this.fsw._emit(EV_ADD_DIR, dir, stats);
          }
          parentDir.add(sysPath.basename(dir));
          this.fsw._getWatchedDir(dir);
          let throttler;
          let closer;
          const oDepth = this.fsw.options.depth;
          if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath2)) {
            if (!target) {
              await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
              if (this.fsw.closed)
                return;
            }
            closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
              if (stats2 && stats2.mtimeMs === 0)
                return;
              this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
            });
          }
          return closer;
        }
        /**
         * Handle added file, directory, or glob pattern.
         * Delegates call to _handleFile / _handleDir after checks.
         * @param {String} path to file or ir
         * @param {Boolean} initialAdd was the file added at watch instantiation?
         * @param {Object} priorWh depth relative to user-supplied path
         * @param {Number} depth Child path actually targeted for watch
         * @param {String=} target Child path actually targeted for watch
         * @returns {Promise}
         */
        async _addToNodeFs(path5, initialAdd, priorWh, depth, target) {
          const ready = this.fsw._emitReady;
          if (this.fsw._isIgnored(path5) || this.fsw.closed) {
            ready();
            return false;
          }
          const wh = this.fsw._getWatchHelpers(path5, depth);
          if (!wh.hasGlob && priorWh) {
            wh.hasGlob = priorWh.hasGlob;
            wh.globFilter = priorWh.globFilter;
            wh.filterPath = (entry) => priorWh.filterPath(entry);
            wh.filterDir = (entry) => priorWh.filterDir(entry);
          }
          try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
              ready();
              return false;
            }
            const follow = this.fsw.options.followSymlinks && !path5.includes(STAR) && !path5.includes(BRACE_START);
            let closer;
            if (stats.isDirectory()) {
              const absPath = sysPath.resolve(path5);
              const targetPath = follow ? await fsrealpath(path5) : path5;
              if (this.fsw.closed)
                return;
              closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
              if (this.fsw.closed)
                return;
              if (absPath !== targetPath && targetPath !== void 0) {
                this.fsw._symlinkPaths.set(absPath, targetPath);
              }
            } else if (stats.isSymbolicLink()) {
              const targetPath = follow ? await fsrealpath(path5) : path5;
              if (this.fsw.closed)
                return;
              const parent = sysPath.dirname(wh.watchPath);
              this.fsw._getWatchedDir(parent).add(wh.watchPath);
              this.fsw._emit(EV_ADD, wh.watchPath, stats);
              closer = await this._handleDir(parent, stats, initialAdd, depth, path5, wh, targetPath);
              if (this.fsw.closed)
                return;
              if (targetPath !== void 0) {
                this.fsw._symlinkPaths.set(sysPath.resolve(path5), targetPath);
              }
            } else {
              closer = this._handleFile(wh.watchPath, stats, initialAdd);
            }
            ready();
            this.fsw._addPathCloser(path5, closer);
            return false;
          } catch (error2) {
            if (this.fsw._handleError(error2)) {
              ready();
              return path5;
            }
          }
        }
      };
      module.exports = NodeFsHandler;
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/fsevents-handler.js
  var require_fsevents_handler = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/fsevents-handler.js"(exports, module) {
      "use strict";
      var fs4 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var fsevents;
      try {
        fsevents = __require2("fsevents");
      } catch (error2) {
        if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
          console.error(error2);
      }
      if (fsevents) {
        const mtch = process.version.match(/v(\d+)\.(\d+)/);
        if (mtch && mtch[1] && mtch[2]) {
          const maj = Number.parseInt(mtch[1], 10);
          const min = Number.parseInt(mtch[2], 10);
          if (maj === 8 && min < 16) {
            fsevents = void 0;
          }
        }
      }
      var {
        EV_ADD,
        EV_CHANGE,
        EV_ADD_DIR,
        EV_UNLINK,
        EV_ERROR,
        STR_DATA,
        STR_END,
        FSEVENT_CREATED,
        FSEVENT_MODIFIED,
        FSEVENT_DELETED,
        FSEVENT_MOVED,
        // FSEVENT_CLONED,
        FSEVENT_UNKNOWN,
        FSEVENT_TYPE_FILE,
        FSEVENT_TYPE_DIRECTORY,
        FSEVENT_TYPE_SYMLINK,
        ROOT_GLOBSTAR,
        DIR_SUFFIX,
        DOT_SLASH,
        FUNCTION_TYPE,
        EMPTY_FN,
        IDENTITY_FN
      } = require_constants3();
      var Depth = (value) => isNaN(value) ? {} : { depth: value };
      var stat = promisify(fs4.stat);
      var lstat2 = promisify(fs4.lstat);
      var realpath2 = promisify(fs4.realpath);
      var statMethods = { stat, lstat: lstat2 };
      var FSEventsWatchers = /* @__PURE__ */ new Map();
      var consolidateThreshhold = 10;
      var wrongEventFlags = /* @__PURE__ */ new Set([
        69888,
        70400,
        71424,
        72704,
        73472,
        131328,
        131840,
        262912
      ]);
      var createFSEventsInstance = (path5, callback) => {
        const stop = fsevents.watch(path5, callback);
        return { stop };
      };
      function setFSEventsListener(path5, realPath, listener, rawEmitter) {
        let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
        const parentPath = sysPath.dirname(watchPath);
        let cont = FSEventsWatchers.get(watchPath);
        if (couldConsolidate(parentPath)) {
          watchPath = parentPath;
        }
        const resolvedPath = sysPath.resolve(path5);
        const hasSymlink = resolvedPath !== realPath;
        const filteredListener = (fullPath, flags, info) => {
          if (hasSymlink)
            fullPath = fullPath.replace(realPath, resolvedPath);
          if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
            listener(fullPath, flags, info);
        };
        let watchedParent = false;
        for (const watchedPath of FSEventsWatchers.keys()) {
          if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
            watchPath = watchedPath;
            cont = FSEventsWatchers.get(watchPath);
            watchedParent = true;
            break;
          }
        }
        if (cont || watchedParent) {
          cont.listeners.add(filteredListener);
        } else {
          cont = {
            listeners: /* @__PURE__ */ new Set([filteredListener]),
            rawEmitter,
            watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
              if (!cont.listeners.size)
                return;
              const info = fsevents.getInfo(fullPath, flags);
              cont.listeners.forEach((list) => {
                list(fullPath, flags, info);
              });
              cont.rawEmitter(info.event, fullPath, info);
            })
          };
          FSEventsWatchers.set(watchPath, cont);
        }
        return () => {
          const lst = cont.listeners;
          lst.delete(filteredListener);
          if (!lst.size) {
            FSEventsWatchers.delete(watchPath);
            if (cont.watcher)
              return cont.watcher.stop().then(() => {
                cont.rawEmitter = cont.watcher = void 0;
                Object.freeze(cont);
              });
          }
        };
      }
      var couldConsolidate = (path5) => {
        let count = 0;
        for (const watchPath of FSEventsWatchers.keys()) {
          if (watchPath.indexOf(path5) === 0) {
            count++;
            if (count >= consolidateThreshhold) {
              return true;
            }
          }
        }
        return false;
      };
      var canUse = () => fsevents && FSEventsWatchers.size < 128;
      var calcDepth = (path5, root) => {
        let i = 0;
        while (!path5.indexOf(root) && (path5 = sysPath.dirname(path5)) !== root)
          i++;
        return i;
      };
      var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
      var FsEventsHandler = class {
        /**
         * @param {import('../index').FSWatcher} fsw
         */
        constructor(fsw) {
          this.fsw = fsw;
        }
        checkIgnored(path5, stats) {
          const ipaths = this.fsw._ignoredPaths;
          if (this.fsw._isIgnored(path5, stats)) {
            ipaths.add(path5);
            if (stats && stats.isDirectory()) {
              ipaths.add(path5 + ROOT_GLOBSTAR);
            }
            return true;
          }
          ipaths.delete(path5);
          ipaths.delete(path5 + ROOT_GLOBSTAR);
        }
        addOrChange(path5, fullPath, realPath, parent, watchedDir, item, info, opts) {
          const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
          this.handleEvent(event, path5, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
        async checkExists(path5, fullPath, realPath, parent, watchedDir, item, info, opts) {
          try {
            const stats = await stat(path5);
            if (this.fsw.closed)
              return;
            if (sameTypes(info, stats)) {
              this.addOrChange(path5, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
              this.handleEvent(EV_UNLINK, path5, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } catch (error2) {
            if (error2.code === "EACCES") {
              this.addOrChange(path5, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
              this.handleEvent(EV_UNLINK, path5, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        }
        handleEvent(event, path5, fullPath, realPath, parent, watchedDir, item, info, opts) {
          if (this.fsw.closed || this.checkIgnored(path5))
            return;
          if (event === EV_UNLINK) {
            const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
            if (isDirectory || watchedDir.has(item)) {
              this.fsw._remove(parent, item, isDirectory);
            }
          } else {
            if (event === EV_ADD) {
              if (info.type === FSEVENT_TYPE_DIRECTORY)
                this.fsw._getWatchedDir(path5);
              if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
                return this._addToFsEvents(path5, false, true, curDepth);
              }
              this.fsw._getWatchedDir(parent).add(item);
            }
            const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
            this.fsw._emit(eventName, path5);
            if (eventName === EV_ADD_DIR)
              this._addToFsEvents(path5, false, true);
          }
        }
        /**
         * Handle symlinks encountered during directory scan
         * @param {String} watchPath  - file/dir path to be watched with fsevents
         * @param {String} realPath   - real path (in case of symlinks)
         * @param {Function} transform  - path transformer
         * @param {Function} globFilter - path filter in case a glob pattern was provided
         * @returns {Function} closer for the watcher instance
        */
        _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
          if (this.fsw.closed || this.fsw._isIgnored(watchPath))
            return;
          const opts = this.fsw.options;
          const watchCallback = async (fullPath, flags, info) => {
            if (this.fsw.closed)
              return;
            if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
              return;
            const path5 = transform(sysPath.join(
              watchPath,
              sysPath.relative(watchPath, fullPath)
            ));
            if (globFilter && !globFilter(path5))
              return;
            const parent = sysPath.dirname(path5);
            const item = sysPath.basename(path5);
            const watchedDir = this.fsw._getWatchedDir(
              info.type === FSEVENT_TYPE_DIRECTORY ? path5 : parent
            );
            if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
              if (typeof opts.ignored === FUNCTION_TYPE) {
                let stats;
                try {
                  stats = await stat(path5);
                } catch (error2) {
                }
                if (this.fsw.closed)
                  return;
                if (this.checkIgnored(path5, stats))
                  return;
                if (sameTypes(info, stats)) {
                  this.addOrChange(path5, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path5, fullPath, realPath, parent, watchedDir, item, info, opts);
                }
              } else {
                this.checkExists(path5, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              switch (info.event) {
                case FSEVENT_CREATED:
                case FSEVENT_MODIFIED:
                  return this.addOrChange(path5, fullPath, realPath, parent, watchedDir, item, info, opts);
                case FSEVENT_DELETED:
                case FSEVENT_MOVED:
                  return this.checkExists(path5, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            }
          };
          const closer = setFSEventsListener(
            watchPath,
            realPath,
            watchCallback,
            this.fsw._emitRaw
          );
          this.fsw._emitReady();
          return closer;
        }
        /**
         * Handle symlinks encountered during directory scan
         * @param {String} linkPath path to symlink
         * @param {String} fullPath absolute path to the symlink
         * @param {Function} transform pre-existing path transformer
         * @param {Number} curDepth level of subdirectories traversed to where symlink is
         * @returns {Promise<void>}
         */
        async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
          if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
            return;
          this.fsw._symlinkPaths.set(fullPath, true);
          this.fsw._incrReadyCount();
          try {
            const linkTarget = await realpath2(linkPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(linkTarget)) {
              return this.fsw._emitReady();
            }
            this.fsw._incrReadyCount();
            this._addToFsEvents(linkTarget || linkPath, (path5) => {
              let aliasedPath = linkPath;
              if (linkTarget && linkTarget !== DOT_SLASH) {
                aliasedPath = path5.replace(linkTarget, linkPath);
              } else if (path5 !== DOT_SLASH) {
                aliasedPath = sysPath.join(linkPath, path5);
              }
              return transform(aliasedPath);
            }, false, curDepth);
          } catch (error2) {
            if (this.fsw._handleError(error2)) {
              return this.fsw._emitReady();
            }
          }
        }
        /**
         *
         * @param {Path} newPath
         * @param {fs.Stats} stats
         */
        emitAdd(newPath, stats, processPath, opts, forceAdd) {
          const pp = processPath(newPath);
          const isDir = stats.isDirectory();
          const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
          const base = sysPath.basename(pp);
          if (isDir)
            this.fsw._getWatchedDir(pp);
          if (dirObj.has(base))
            return;
          dirObj.add(base);
          if (!opts.ignoreInitial || forceAdd === true) {
            this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
          }
        }
        initWatch(realPath, path5, wh, processPath) {
          if (this.fsw.closed)
            return;
          const closer = this._watchWithFsEvents(
            wh.watchPath,
            sysPath.resolve(realPath || wh.watchPath),
            processPath,
            wh.globFilter
          );
          this.fsw._addPathCloser(path5, closer);
        }
        /**
         * Handle added path with fsevents
         * @param {String} path file/dir path or glob pattern
         * @param {Function|Boolean=} transform converts working path to what the user expects
         * @param {Boolean=} forceAdd ensure add is emitted
         * @param {Number=} priorDepth Level of subdirectories already traversed.
         * @returns {Promise<void>}
         */
        async _addToFsEvents(path5, transform, forceAdd, priorDepth) {
          if (this.fsw.closed) {
            return;
          }
          const opts = this.fsw.options;
          const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
          const wh = this.fsw._getWatchHelpers(path5);
          try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
              throw null;
            }
            if (stats.isDirectory()) {
              if (!wh.globFilter)
                this.emitAdd(processPath(path5), stats, processPath, opts, forceAdd);
              if (priorDepth && priorDepth > opts.depth)
                return;
              this.fsw._readdirp(wh.watchPath, {
                fileFilter: (entry) => wh.filterPath(entry),
                directoryFilter: (entry) => wh.filterDir(entry),
                ...Depth(opts.depth - (priorDepth || 0))
              }).on(STR_DATA, (entry) => {
                if (this.fsw.closed) {
                  return;
                }
                if (entry.stats.isDirectory() && !wh.filterPath(entry))
                  return;
                const joinedPath = sysPath.join(wh.watchPath, entry.path);
                const { fullPath } = entry;
                if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                  const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                  this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                } else {
                  this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                }
              }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
                this.fsw._emitReady();
              });
            } else {
              this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
              this.fsw._emitReady();
            }
          } catch (error2) {
            if (!error2 || this.fsw._handleError(error2)) {
              this.fsw._emitReady();
              this.fsw._emitReady();
            }
          }
          if (opts.persistent && forceAdd !== true) {
            if (typeof transform === FUNCTION_TYPE) {
              this.initWatch(void 0, path5, wh, processPath);
            } else {
              let realPath;
              try {
                realPath = await realpath2(wh.watchPath);
              } catch (e) {
              }
              this.initWatch(realPath, path5, wh, processPath);
            }
          }
        }
      };
      module.exports = FsEventsHandler;
      module.exports.canUse = canUse;
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/index.js
  var require_chokidar = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/index.js"(exports) {
      "use strict";
      var { EventEmitter: EventEmitter3 } = __require2("events");
      var fs4 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var readdirp = require_readdirp();
      var anymatch = require_anymatch().default;
      var globParent = require_glob_parent();
      var isGlob = require_is_glob();
      var braces = require_braces();
      var normalizePath = require_normalize_path();
      var NodeFsHandler = require_nodefs_handler();
      var FsEventsHandler = require_fsevents_handler();
      var {
        EV_ALL,
        EV_READY,
        EV_ADD,
        EV_CHANGE,
        EV_UNLINK,
        EV_ADD_DIR,
        EV_UNLINK_DIR,
        EV_RAW,
        EV_ERROR,
        STR_CLOSE,
        STR_END,
        BACK_SLASH_RE,
        DOUBLE_SLASH_RE,
        SLASH_OR_BACK_SLASH_RE,
        DOT_RE,
        REPLACER_RE,
        SLASH,
        SLASH_SLASH,
        BRACE_START,
        BANG,
        ONE_DOT,
        TWO_DOTS,
        GLOBSTAR: GLOBSTAR2,
        SLASH_GLOBSTAR,
        ANYMATCH_OPTS,
        STRING_TYPE,
        FUNCTION_TYPE,
        EMPTY_STR,
        EMPTY_FN,
        isWindows,
        isMacos,
        isIBMi
      } = require_constants3();
      var stat = promisify(fs4.stat);
      var readdir2 = promisify(fs4.readdir);
      var arrify = (value = []) => Array.isArray(value) ? value : [value];
      var flatten = (list, result = []) => {
        list.forEach((item) => {
          if (Array.isArray(item)) {
            flatten(item, result);
          } else {
            result.push(item);
          }
        });
        return result;
      };
      var unifyPaths = (paths_) => {
        const paths = flatten(arrify(paths_));
        if (!paths.every((p) => typeof p === STRING_TYPE)) {
          throw new TypeError(`Non-string provided as watch path: ${paths}`);
        }
        return paths.map(normalizePathToUnix);
      };
      var toUnix = (string2) => {
        let str = string2.replace(BACK_SLASH_RE, SLASH);
        let prepend = false;
        if (str.startsWith(SLASH_SLASH)) {
          prepend = true;
        }
        while (str.match(DOUBLE_SLASH_RE)) {
          str = str.replace(DOUBLE_SLASH_RE, SLASH);
        }
        if (prepend) {
          str = SLASH + str;
        }
        return str;
      };
      var normalizePathToUnix = (path5) => toUnix(sysPath.normalize(toUnix(path5)));
      var normalizeIgnored = (cwd = EMPTY_STR) => (path5) => {
        if (typeof path5 !== STRING_TYPE)
          return path5;
        return normalizePathToUnix(sysPath.isAbsolute(path5) ? path5 : sysPath.join(cwd, path5));
      };
      var getAbsolutePath = (path5, cwd) => {
        if (sysPath.isAbsolute(path5)) {
          return path5;
        }
        if (path5.startsWith(BANG)) {
          return BANG + sysPath.join(cwd, path5.slice(1));
        }
        return sysPath.join(cwd, path5);
      };
      var undef = (opts, key) => opts[key] === void 0;
      var DirEntry = class {
        /**
         * @param {Path} dir
         * @param {Function} removeWatcher
         */
        constructor(dir, removeWatcher) {
          this.path = dir;
          this._removeWatcher = removeWatcher;
          this.items = /* @__PURE__ */ new Set();
        }
        add(item) {
          const { items } = this;
          if (!items)
            return;
          if (item !== ONE_DOT && item !== TWO_DOTS)
            items.add(item);
        }
        async remove(item) {
          const { items } = this;
          if (!items)
            return;
          items.delete(item);
          if (items.size > 0)
            return;
          const dir = this.path;
          try {
            await readdir2(dir);
          } catch (err) {
            if (this._removeWatcher) {
              this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
            }
          }
        }
        has(item) {
          const { items } = this;
          if (!items)
            return;
          return items.has(item);
        }
        /**
         * @returns {Array<String>}
         */
        getChildren() {
          const { items } = this;
          if (!items)
            return;
          return [...items.values()];
        }
        dispose() {
          this.items.clear();
          delete this.path;
          delete this._removeWatcher;
          delete this.items;
          Object.freeze(this);
        }
      };
      var STAT_METHOD_F = "stat";
      var STAT_METHOD_L = "lstat";
      var WatchHelper = class {
        constructor(path5, watchPath, follow, fsw) {
          this.fsw = fsw;
          this.path = path5 = path5.replace(REPLACER_RE, EMPTY_STR);
          this.watchPath = watchPath;
          this.fullWatchPath = sysPath.resolve(watchPath);
          this.hasGlob = watchPath !== path5;
          if (path5 === EMPTY_STR)
            this.hasGlob = false;
          this.globSymlink = this.hasGlob && follow ? void 0 : false;
          this.globFilter = this.hasGlob ? anymatch(path5, void 0, ANYMATCH_OPTS) : false;
          this.dirParts = this.getDirParts(path5);
          this.dirParts.forEach((parts) => {
            if (parts.length > 1)
              parts.pop();
          });
          this.followSymlinks = follow;
          this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
        }
        checkGlobSymlink(entry) {
          if (this.globSymlink === void 0) {
            this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
          }
          if (this.globSymlink) {
            return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
          }
          return entry.fullPath;
        }
        entryPath(entry) {
          return sysPath.join(
            this.watchPath,
            sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
          );
        }
        filterPath(entry) {
          const { stats } = entry;
          if (stats && stats.isSymbolicLink())
            return this.filterDir(entry);
          const resolvedPath = this.entryPath(entry);
          const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
          return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
        }
        getDirParts(path5) {
          if (!this.hasGlob)
            return [];
          const parts = [];
          const expandedPath = path5.includes(BRACE_START) ? braces.expand(path5) : [path5];
          expandedPath.forEach((path6) => {
            parts.push(sysPath.relative(this.watchPath, path6).split(SLASH_OR_BACK_SLASH_RE));
          });
          return parts;
        }
        filterDir(entry) {
          if (this.hasGlob) {
            const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
            let globstar = false;
            this.unmatchedGlob = !this.dirParts.some((parts) => {
              return parts.every((part, i) => {
                if (part === GLOBSTAR2)
                  globstar = true;
                return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
              });
            });
          }
          return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
        }
      };
      var FSWatcher = class extends EventEmitter3 {
        // Not indenting methods for history sake; for now.
        constructor(_opts) {
          super();
          const opts = {};
          if (_opts)
            Object.assign(opts, _opts);
          this._watched = /* @__PURE__ */ new Map();
          this._closers = /* @__PURE__ */ new Map();
          this._ignoredPaths = /* @__PURE__ */ new Set();
          this._throttled = /* @__PURE__ */ new Map();
          this._symlinkPaths = /* @__PURE__ */ new Map();
          this._streams = /* @__PURE__ */ new Set();
          this.closed = false;
          if (undef(opts, "persistent"))
            opts.persistent = true;
          if (undef(opts, "ignoreInitial"))
            opts.ignoreInitial = false;
          if (undef(opts, "ignorePermissionErrors"))
            opts.ignorePermissionErrors = false;
          if (undef(opts, "interval"))
            opts.interval = 100;
          if (undef(opts, "binaryInterval"))
            opts.binaryInterval = 300;
          if (undef(opts, "disableGlobbing"))
            opts.disableGlobbing = false;
          opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
          if (undef(opts, "useFsEvents"))
            opts.useFsEvents = !opts.usePolling;
          const canUseFsEvents = FsEventsHandler.canUse();
          if (!canUseFsEvents)
            opts.useFsEvents = false;
          if (undef(opts, "usePolling") && !opts.useFsEvents) {
            opts.usePolling = isMacos;
          }
          if (isIBMi) {
            opts.usePolling = true;
          }
          const envPoll = process.env.CHOKIDAR_USEPOLLING;
          if (envPoll !== void 0) {
            const envLower = envPoll.toLowerCase();
            if (envLower === "false" || envLower === "0") {
              opts.usePolling = false;
            } else if (envLower === "true" || envLower === "1") {
              opts.usePolling = true;
            } else {
              opts.usePolling = !!envLower;
            }
          }
          const envInterval = process.env.CHOKIDAR_INTERVAL;
          if (envInterval) {
            opts.interval = Number.parseInt(envInterval, 10);
          }
          if (undef(opts, "atomic"))
            opts.atomic = !opts.usePolling && !opts.useFsEvents;
          if (opts.atomic)
            this._pendingUnlinks = /* @__PURE__ */ new Map();
          if (undef(opts, "followSymlinks"))
            opts.followSymlinks = true;
          if (undef(opts, "awaitWriteFinish"))
            opts.awaitWriteFinish = false;
          if (opts.awaitWriteFinish === true)
            opts.awaitWriteFinish = {};
          const awf = opts.awaitWriteFinish;
          if (awf) {
            if (!awf.stabilityThreshold)
              awf.stabilityThreshold = 2e3;
            if (!awf.pollInterval)
              awf.pollInterval = 100;
            this._pendingWrites = /* @__PURE__ */ new Map();
          }
          if (opts.ignored)
            opts.ignored = arrify(opts.ignored);
          let readyCalls = 0;
          this._emitReady = () => {
            readyCalls++;
            if (readyCalls >= this._readyCount) {
              this._emitReady = EMPTY_FN;
              this._readyEmitted = true;
              process.nextTick(() => this.emit(EV_READY));
            }
          };
          this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
          this._readyEmitted = false;
          this.options = opts;
          if (opts.useFsEvents) {
            this._fsEventsHandler = new FsEventsHandler(this);
          } else {
            this._nodeFsHandler = new NodeFsHandler(this);
          }
          Object.freeze(opts);
        }
        // Public methods
        /**
         * Adds paths to be watched on an existing FSWatcher instance
         * @param {Path|Array<Path>} paths_
         * @param {String=} _origAdd private; for handling non-existent paths to be watched
         * @param {Boolean=} _internal private; indicates a non-user add
         * @returns {FSWatcher} for chaining
         */
        add(paths_, _origAdd, _internal) {
          const { cwd, disableGlobbing } = this.options;
          this.closed = false;
          let paths = unifyPaths(paths_);
          if (cwd) {
            paths = paths.map((path5) => {
              const absPath = getAbsolutePath(path5, cwd);
              if (disableGlobbing || !isGlob(path5)) {
                return absPath;
              }
              return normalizePath(absPath);
            });
          }
          paths = paths.filter((path5) => {
            if (path5.startsWith(BANG)) {
              this._ignoredPaths.add(path5.slice(1));
              return false;
            }
            this._ignoredPaths.delete(path5);
            this._ignoredPaths.delete(path5 + SLASH_GLOBSTAR);
            this._userIgnored = void 0;
            return true;
          });
          if (this.options.useFsEvents && this._fsEventsHandler) {
            if (!this._readyCount)
              this._readyCount = paths.length;
            if (this.options.persistent)
              this._readyCount *= 2;
            paths.forEach((path5) => this._fsEventsHandler._addToFsEvents(path5));
          } else {
            if (!this._readyCount)
              this._readyCount = 0;
            this._readyCount += paths.length;
            Promise.all(
              paths.map(async (path5) => {
                const res = await this._nodeFsHandler._addToNodeFs(path5, !_internal, 0, 0, _origAdd);
                if (res)
                  this._emitReady();
                return res;
              })
            ).then((results) => {
              if (this.closed)
                return;
              results.filter((item) => item).forEach((item) => {
                this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
              });
            });
          }
          return this;
        }
        /**
         * Close watchers or start ignoring events from specified paths.
         * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
         * @returns {FSWatcher} for chaining
        */
        unwatch(paths_) {
          if (this.closed)
            return this;
          const paths = unifyPaths(paths_);
          const { cwd } = this.options;
          paths.forEach((path5) => {
            if (!sysPath.isAbsolute(path5) && !this._closers.has(path5)) {
              if (cwd)
                path5 = sysPath.join(cwd, path5);
              path5 = sysPath.resolve(path5);
            }
            this._closePath(path5);
            this._ignoredPaths.add(path5);
            if (this._watched.has(path5)) {
              this._ignoredPaths.add(path5 + SLASH_GLOBSTAR);
            }
            this._userIgnored = void 0;
          });
          return this;
        }
        /**
         * Close watchers and remove all listeners from watched paths.
         * @returns {Promise<void>}.
        */
        close() {
          if (this.closed)
            return this._closePromise;
          this.closed = true;
          this.removeAllListeners();
          const closers = [];
          this._closers.forEach((closerList) => closerList.forEach((closer) => {
            const promise = closer();
            if (promise instanceof Promise)
              closers.push(promise);
          }));
          this._streams.forEach((stream2) => stream2.destroy());
          this._userIgnored = void 0;
          this._readyCount = 0;
          this._readyEmitted = false;
          this._watched.forEach((dirent) => dirent.dispose());
          ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
            this[`_${key}`].clear();
          });
          this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
          return this._closePromise;
        }
        /**
         * Expose list of watched paths
         * @returns {Object} for chaining
        */
        getWatched() {
          const watchList = {};
          this._watched.forEach((entry, dir) => {
            const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
            watchList[key || ONE_DOT] = entry.getChildren().sort();
          });
          return watchList;
        }
        emitWithAll(event, args) {
          this.emit(...args);
          if (event !== EV_ERROR)
            this.emit(EV_ALL, ...args);
        }
        // Common helpers
        // --------------
        /**
         * Normalize and emit events.
         * Calling _emit DOES NOT MEAN emit() would be called!
         * @param {EventName} event Type of event
         * @param {Path} path File or directory path
         * @param {*=} val1 arguments to be passed with event
         * @param {*=} val2
         * @param {*=} val3
         * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
         */
        async _emit(event, path5, val1, val2, val3) {
          if (this.closed)
            return;
          const opts = this.options;
          if (isWindows)
            path5 = sysPath.normalize(path5);
          if (opts.cwd)
            path5 = sysPath.relative(opts.cwd, path5);
          const args = [event, path5];
          if (val3 !== void 0)
            args.push(val1, val2, val3);
          else if (val2 !== void 0)
            args.push(val1, val2);
          else if (val1 !== void 0)
            args.push(val1);
          const awf = opts.awaitWriteFinish;
          let pw;
          if (awf && (pw = this._pendingWrites.get(path5))) {
            pw.lastChange = /* @__PURE__ */ new Date();
            return this;
          }
          if (opts.atomic) {
            if (event === EV_UNLINK) {
              this._pendingUnlinks.set(path5, args);
              setTimeout(() => {
                this._pendingUnlinks.forEach((entry, path6) => {
                  this.emit(...entry);
                  this.emit(EV_ALL, ...entry);
                  this._pendingUnlinks.delete(path6);
                });
              }, typeof opts.atomic === "number" ? opts.atomic : 100);
              return this;
            }
            if (event === EV_ADD && this._pendingUnlinks.has(path5)) {
              event = args[0] = EV_CHANGE;
              this._pendingUnlinks.delete(path5);
            }
          }
          if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
            const awfEmit = (err, stats) => {
              if (err) {
                event = args[0] = EV_ERROR;
                args[1] = err;
                this.emitWithAll(event, args);
              } else if (stats) {
                if (args.length > 2) {
                  args[2] = stats;
                } else {
                  args.push(stats);
                }
                this.emitWithAll(event, args);
              }
            };
            this._awaitWriteFinish(path5, awf.stabilityThreshold, event, awfEmit);
            return this;
          }
          if (event === EV_CHANGE) {
            const isThrottled = !this._throttle(EV_CHANGE, path5, 50);
            if (isThrottled)
              return this;
          }
          if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
            const fullPath = opts.cwd ? sysPath.join(opts.cwd, path5) : path5;
            let stats;
            try {
              stats = await stat(fullPath);
            } catch (err) {
            }
            if (!stats || this.closed)
              return;
            args.push(stats);
          }
          this.emitWithAll(event, args);
          return this;
        }
        /**
         * Common handler for errors
         * @param {Error} error
         * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
         */
        _handleError(error2) {
          const code = error2 && error2.code;
          if (error2 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
            this.emit(EV_ERROR, error2);
          }
          return error2 || this.closed;
        }
        /**
         * Helper utility for throttling
         * @param {ThrottleType} actionType type being throttled
         * @param {Path} path being acted upon
         * @param {Number} timeout duration of time to suppress duplicate actions
         * @returns {Object|false} tracking object or false if action should be suppressed
         */
        _throttle(actionType, path5, timeout) {
          if (!this._throttled.has(actionType)) {
            this._throttled.set(actionType, /* @__PURE__ */ new Map());
          }
          const action = this._throttled.get(actionType);
          const actionPath = action.get(path5);
          if (actionPath) {
            actionPath.count++;
            return false;
          }
          let timeoutObject;
          const clear = () => {
            const item = action.get(path5);
            const count = item ? item.count : 0;
            action.delete(path5);
            clearTimeout(timeoutObject);
            if (item)
              clearTimeout(item.timeoutObject);
            return count;
          };
          timeoutObject = setTimeout(clear, timeout);
          const thr = { timeoutObject, clear, count: 0 };
          action.set(path5, thr);
          return thr;
        }
        _incrReadyCount() {
          return this._readyCount++;
        }
        /**
         * Awaits write operation to finish.
         * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
         * @param {Path} path being acted upon
         * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
         * @param {EventName} event
         * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
         */
        _awaitWriteFinish(path5, threshold, event, awfEmit) {
          let timeoutHandler;
          let fullPath = path5;
          if (this.options.cwd && !sysPath.isAbsolute(path5)) {
            fullPath = sysPath.join(this.options.cwd, path5);
          }
          const now = /* @__PURE__ */ new Date();
          const awaitWriteFinish = (prevStat) => {
            fs4.stat(fullPath, (err, curStat) => {
              if (err || !this._pendingWrites.has(path5)) {
                if (err && err.code !== "ENOENT")
                  awfEmit(err);
                return;
              }
              const now2 = Number(/* @__PURE__ */ new Date());
              if (prevStat && curStat.size !== prevStat.size) {
                this._pendingWrites.get(path5).lastChange = now2;
              }
              const pw = this._pendingWrites.get(path5);
              const df = now2 - pw.lastChange;
              if (df >= threshold) {
                this._pendingWrites.delete(path5);
                awfEmit(void 0, curStat);
              } else {
                timeoutHandler = setTimeout(
                  awaitWriteFinish,
                  this.options.awaitWriteFinish.pollInterval,
                  curStat
                );
              }
            });
          };
          if (!this._pendingWrites.has(path5)) {
            this._pendingWrites.set(path5, {
              lastChange: now,
              cancelWait: () => {
                this._pendingWrites.delete(path5);
                clearTimeout(timeoutHandler);
                return event;
              }
            });
            timeoutHandler = setTimeout(
              awaitWriteFinish,
              this.options.awaitWriteFinish.pollInterval
            );
          }
        }
        _getGlobIgnored() {
          return [...this._ignoredPaths.values()];
        }
        /**
         * Determines whether user has asked to ignore this path.
         * @param {Path} path filepath or dir
         * @param {fs.Stats=} stats result of fs.stat
         * @returns {Boolean}
         */
        _isIgnored(path5, stats) {
          if (this.options.atomic && DOT_RE.test(path5))
            return true;
          if (!this._userIgnored) {
            const { cwd } = this.options;
            const ign = this.options.ignored;
            const ignored = ign && ign.map(normalizeIgnored(cwd));
            const paths = arrify(ignored).filter((path6) => typeof path6 === STRING_TYPE && !isGlob(path6)).map((path6) => path6 + SLASH_GLOBSTAR);
            const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
            this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
          }
          return this._userIgnored([path5, stats]);
        }
        _isntIgnored(path5, stat2) {
          return !this._isIgnored(path5, stat2);
        }
        /**
         * Provides a set of common helpers and properties relating to symlink and glob handling.
         * @param {Path} path file, directory, or glob pattern being watched
         * @param {Number=} depth at any depth > 0, this isn't a glob
         * @returns {WatchHelper} object containing helpers for this path
         */
        _getWatchHelpers(path5, depth) {
          const watchPath = depth || this.options.disableGlobbing || !isGlob(path5) ? path5 : globParent(path5);
          const follow = this.options.followSymlinks;
          return new WatchHelper(path5, watchPath, follow, this);
        }
        // Directory helpers
        // -----------------
        /**
         * Provides directory tracking objects
         * @param {String} directory path of the directory
         * @returns {DirEntry} the directory's tracking object
         */
        _getWatchedDir(directory) {
          if (!this._boundRemove)
            this._boundRemove = this._remove.bind(this);
          const dir = sysPath.resolve(directory);
          if (!this._watched.has(dir))
            this._watched.set(dir, new DirEntry(dir, this._boundRemove));
          return this._watched.get(dir);
        }
        // File helpers
        // ------------
        /**
         * Check for read permissions.
         * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
         * @param {fs.Stats} stats - object, result of fs_stat
         * @returns {Boolean} indicates whether the file can be read
        */
        _hasReadPermissions(stats) {
          if (this.options.ignorePermissionErrors)
            return true;
          const md = stats && Number.parseInt(stats.mode, 10);
          const st = md & 511;
          const it = Number.parseInt(st.toString(8)[0], 10);
          return Boolean(4 & it);
        }
        /**
         * Handles emitting unlink events for
         * files and directories, and via recursion, for
         * files and directories within directories that are unlinked
         * @param {String} directory within which the following item is located
         * @param {String} item      base path of item/directory
         * @returns {void}
        */
        _remove(directory, item, isDirectory) {
          const path5 = sysPath.join(directory, item);
          const fullPath = sysPath.resolve(path5);
          isDirectory = isDirectory != null ? isDirectory : this._watched.has(path5) || this._watched.has(fullPath);
          if (!this._throttle("remove", path5, 100))
            return;
          if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
            this.add(directory, item, true);
          }
          const wp = this._getWatchedDir(path5);
          const nestedDirectoryChildren = wp.getChildren();
          nestedDirectoryChildren.forEach((nested) => this._remove(path5, nested));
          const parent = this._getWatchedDir(directory);
          const wasTracked = parent.has(item);
          parent.remove(item);
          if (this._symlinkPaths.has(fullPath)) {
            this._symlinkPaths.delete(fullPath);
          }
          let relPath = path5;
          if (this.options.cwd)
            relPath = sysPath.relative(this.options.cwd, path5);
          if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
            const event = this._pendingWrites.get(relPath).cancelWait();
            if (event === EV_ADD)
              return;
          }
          this._watched.delete(path5);
          this._watched.delete(fullPath);
          const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
          if (wasTracked && !this._isIgnored(path5))
            this._emit(eventName, path5);
          if (!this.options.useFsEvents) {
            this._closePath(path5);
          }
        }
        /**
         * Closes all watchers for a path
         * @param {Path} path
         */
        _closePath(path5) {
          this._closeFile(path5);
          const dir = sysPath.dirname(path5);
          this._getWatchedDir(dir).remove(sysPath.basename(path5));
        }
        /**
         * Closes only file-specific watchers
         * @param {Path} path
         */
        _closeFile(path5) {
          const closers = this._closers.get(path5);
          if (!closers)
            return;
          closers.forEach((closer) => closer());
          this._closers.delete(path5);
        }
        /**
         *
         * @param {Path} path
         * @param {Function} closer
         */
        _addPathCloser(path5, closer) {
          if (!closer)
            return;
          let list = this._closers.get(path5);
          if (!list) {
            list = [];
            this._closers.set(path5, list);
          }
          list.push(closer);
        }
        _readdirp(root, opts) {
          if (this.closed)
            return;
          const options = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
          let stream2 = readdirp(root, options);
          this._streams.add(stream2);
          stream2.once(STR_CLOSE, () => {
            stream2 = void 0;
          });
          stream2.once(STR_END, () => {
            if (stream2) {
              this._streams.delete(stream2);
              stream2 = void 0;
            }
          });
          return stream2;
        }
      };
      exports.FSWatcher = FSWatcher;
      var watch2 = (paths, options) => {
        const watcher = new FSWatcher(options);
        watcher.add(paths);
        return watcher;
      };
      exports.watch = watch2;
    }
  });

  // ../../node_modules/.pnpm/esbuild@0.19.3/node_modules/esbuild/lib/main.js
  var require_main = __commonJS({
    "../../node_modules/.pnpm/esbuild@0.19.3/node_modules/esbuild/lib/main.js"(exports, module) {
      "use strict";
      var __defProp11 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export3 = (target, all) => {
        for (var name in all)
          __defProp11(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp11(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod2) => __copyProps2(__defProp11({}, "__esModule", { value: true }), mod2);
      var node_exports = {};
      __export3(node_exports, {
        analyzeMetafile: () => analyzeMetafile,
        analyzeMetafileSync: () => analyzeMetafileSync,
        build: () => build3,
        buildSync: () => buildSync,
        context: () => context2,
        default: () => node_default3,
        formatMessages: () => formatMessages,
        formatMessagesSync: () => formatMessagesSync,
        initialize: () => initialize,
        transform: () => transform,
        transformSync: () => transformSync,
        version: () => version2
      });
      module.exports = __toCommonJS2(node_exports);
      function encodePacket(packet) {
        let visit2 = (value) => {
          if (value === null) {
            bb.write8(0);
          } else if (typeof value === "boolean") {
            bb.write8(1);
            bb.write8(+value);
          } else if (typeof value === "number") {
            bb.write8(2);
            bb.write32(value | 0);
          } else if (typeof value === "string") {
            bb.write8(3);
            bb.write(encodeUTF8(value));
          } else if (value instanceof Uint8Array) {
            bb.write8(4);
            bb.write(value);
          } else if (value instanceof Array) {
            bb.write8(5);
            bb.write32(value.length);
            for (let item of value) {
              visit2(item);
            }
          } else {
            let keys4 = Object.keys(value);
            bb.write8(6);
            bb.write32(keys4.length);
            for (let key of keys4) {
              bb.write(encodeUTF8(key));
              visit2(value[key]);
            }
          }
        };
        let bb = new ByteBuffer();
        bb.write32(0);
        bb.write32(packet.id << 1 | +!packet.isRequest);
        visit2(packet.value);
        writeUInt32LE(bb.buf, bb.len - 4, 0);
        return bb.buf.subarray(0, bb.len);
      }
      function decodePacket(bytes3) {
        let visit2 = () => {
          switch (bb.read8()) {
            case 0:
              return null;
            case 1:
              return !!bb.read8();
            case 2:
              return bb.read32();
            case 3:
              return decodeUTF8(bb.read());
            case 4:
              return bb.read();
            case 5: {
              let count = bb.read32();
              let value2 = [];
              for (let i = 0; i < count; i++) {
                value2.push(visit2());
              }
              return value2;
            }
            case 6: {
              let count = bb.read32();
              let value2 = {};
              for (let i = 0; i < count; i++) {
                value2[decodeUTF8(bb.read())] = visit2();
              }
              return value2;
            }
            default:
              throw new Error("Invalid packet");
          }
        };
        let bb = new ByteBuffer(bytes3);
        let id = bb.read32();
        let isRequest2 = (id & 1) === 0;
        id >>>= 1;
        let value = visit2();
        if (bb.ptr !== bytes3.length) {
          throw new Error("Invalid packet");
        }
        return { id, isRequest: isRequest2, value };
      }
      var ByteBuffer = class {
        constructor(buf = new Uint8Array(1024)) {
          this.buf = buf;
          this.len = 0;
          this.ptr = 0;
        }
        _write(delta) {
          if (this.len + delta > this.buf.length) {
            let clone5 = new Uint8Array((this.len + delta) * 2);
            clone5.set(this.buf);
            this.buf = clone5;
          }
          this.len += delta;
          return this.len - delta;
        }
        write8(value) {
          let offset = this._write(1);
          this.buf[offset] = value;
        }
        write32(value) {
          let offset = this._write(4);
          writeUInt32LE(this.buf, value, offset);
        }
        write(bytes3) {
          let offset = this._write(4 + bytes3.length);
          writeUInt32LE(this.buf, bytes3.length, offset);
          this.buf.set(bytes3, offset + 4);
        }
        _read(delta) {
          if (this.ptr + delta > this.buf.length) {
            throw new Error("Invalid packet");
          }
          this.ptr += delta;
          return this.ptr - delta;
        }
        read8() {
          return this.buf[this._read(1)];
        }
        read32() {
          return readUInt32LE(this.buf, this._read(4));
        }
        read() {
          let length = this.read32();
          let bytes3 = new Uint8Array(length);
          let ptr = this._read(bytes3.length);
          bytes3.set(this.buf.subarray(ptr, ptr + length));
          return bytes3;
        }
      };
      var encodeUTF8;
      var decodeUTF8;
      var encodeInvariant;
      if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
        let encoder = new TextEncoder();
        let decoder = new TextDecoder();
        encodeUTF8 = (text) => encoder.encode(text);
        decodeUTF8 = (bytes3) => decoder.decode(bytes3);
        encodeInvariant = 'new TextEncoder().encode("")';
      } else if (typeof Buffer !== "undefined") {
        encodeUTF8 = (text) => Buffer.from(text);
        decodeUTF8 = (bytes3) => {
          let { buffer, byteOffset, byteLength } = bytes3;
          return Buffer.from(buffer, byteOffset, byteLength).toString();
        };
        encodeInvariant = 'Buffer.from("")';
      } else {
        throw new Error("No UTF-8 codec found");
      }
      if (!(encodeUTF8("") instanceof Uint8Array))
        throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
      function readUInt32LE(buffer, offset) {
        return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
      }
      function writeUInt32LE(buffer, value, offset) {
        buffer[offset++] = value;
        buffer[offset++] = value >> 8;
        buffer[offset++] = value >> 16;
        buffer[offset++] = value >> 24;
      }
      var quote = JSON.stringify;
      var buildLogLevelDefault = "warning";
      var transformLogLevelDefault = "silent";
      function validateTarget(target) {
        validateStringValue(target, "target");
        if (target.indexOf(",") >= 0)
          throw new Error(`Invalid target: ${target}`);
        return target;
      }
      var canBeAnything = () => null;
      var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
      var mustBeString = (value) => typeof value === "string" ? null : "a string";
      var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
      var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
      var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
      var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
      var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
      var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
      var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
      var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
      var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
      var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
      var mustBeStringOrArray = (value) => typeof value === "string" || Array.isArray(value) ? null : "a string or an array";
      var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
      var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
      function getFlag(object2, keys4, key, mustBeFn) {
        let value = object2[key];
        keys4[key + ""] = true;
        if (value === void 0)
          return void 0;
        let mustBe = mustBeFn(value);
        if (mustBe !== null)
          throw new Error(`${quote(key)} must be ${mustBe}`);
        return value;
      }
      function checkForInvalidFlags(object2, keys4, where) {
        for (let key in object2) {
          if (!(key in keys4)) {
            throw new Error(`Invalid option ${where}: ${quote(key)}`);
          }
        }
      }
      function validateInitializeOptions(options) {
        let keys4 = /* @__PURE__ */ Object.create(null);
        let wasmURL = getFlag(options, keys4, "wasmURL", mustBeStringOrURL);
        let wasmModule = getFlag(options, keys4, "wasmModule", mustBeWebAssemblyModule);
        let worker = getFlag(options, keys4, "worker", mustBeBoolean);
        checkForInvalidFlags(options, keys4, "in initialize() call");
        return {
          wasmURL,
          wasmModule,
          worker
        };
      }
      function validateMangleCache(mangleCache) {
        let validated;
        if (mangleCache !== void 0) {
          validated = /* @__PURE__ */ Object.create(null);
          for (let key in mangleCache) {
            let value = mangleCache[key];
            if (typeof value === "string" || value === false) {
              validated[key] = value;
            } else {
              throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
            }
          }
        }
        return validated;
      }
      function pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault) {
        let color = getFlag(options, keys4, "color", mustBeBoolean);
        let logLevel = getFlag(options, keys4, "logLevel", mustBeString);
        let logLimit = getFlag(options, keys4, "logLimit", mustBeInteger);
        if (color !== void 0)
          flags.push(`--color=${color}`);
        else if (isTTY2)
          flags.push(`--color=true`);
        flags.push(`--log-level=${logLevel || logLevelDefault}`);
        flags.push(`--log-limit=${logLimit || 0}`);
      }
      function validateStringValue(value, what, key) {
        if (typeof value !== "string") {
          throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
        }
        return value;
      }
      function pushCommonFlags(flags, options, keys4) {
        let legalComments = getFlag(options, keys4, "legalComments", mustBeString);
        let sourceRoot = getFlag(options, keys4, "sourceRoot", mustBeString);
        let sourcesContent = getFlag(options, keys4, "sourcesContent", mustBeBoolean);
        let target = getFlag(options, keys4, "target", mustBeStringOrArray);
        let format = getFlag(options, keys4, "format", mustBeString);
        let globalName = getFlag(options, keys4, "globalName", mustBeString);
        let mangleProps = getFlag(options, keys4, "mangleProps", mustBeRegExp);
        let reserveProps = getFlag(options, keys4, "reserveProps", mustBeRegExp);
        let mangleQuoted = getFlag(options, keys4, "mangleQuoted", mustBeBoolean);
        let minify = getFlag(options, keys4, "minify", mustBeBoolean);
        let minifySyntax = getFlag(options, keys4, "minifySyntax", mustBeBoolean);
        let minifyWhitespace = getFlag(options, keys4, "minifyWhitespace", mustBeBoolean);
        let minifyIdentifiers = getFlag(options, keys4, "minifyIdentifiers", mustBeBoolean);
        let lineLimit = getFlag(options, keys4, "lineLimit", mustBeInteger);
        let drop = getFlag(options, keys4, "drop", mustBeArray);
        let dropLabels = getFlag(options, keys4, "dropLabels", mustBeArray);
        let charset = getFlag(options, keys4, "charset", mustBeString);
        let treeShaking = getFlag(options, keys4, "treeShaking", mustBeBoolean);
        let ignoreAnnotations = getFlag(options, keys4, "ignoreAnnotations", mustBeBoolean);
        let jsx = getFlag(options, keys4, "jsx", mustBeString);
        let jsxFactory = getFlag(options, keys4, "jsxFactory", mustBeString);
        let jsxFragment = getFlag(options, keys4, "jsxFragment", mustBeString);
        let jsxImportSource = getFlag(options, keys4, "jsxImportSource", mustBeString);
        let jsxDev = getFlag(options, keys4, "jsxDev", mustBeBoolean);
        let jsxSideEffects = getFlag(options, keys4, "jsxSideEffects", mustBeBoolean);
        let define2 = getFlag(options, keys4, "define", mustBeObject);
        let logOverride = getFlag(options, keys4, "logOverride", mustBeObject);
        let supported = getFlag(options, keys4, "supported", mustBeObject);
        let pure = getFlag(options, keys4, "pure", mustBeArray);
        let keepNames = getFlag(options, keys4, "keepNames", mustBeBoolean);
        let platform = getFlag(options, keys4, "platform", mustBeString);
        let tsconfigRaw = getFlag(options, keys4, "tsconfigRaw", mustBeStringOrObject);
        if (legalComments)
          flags.push(`--legal-comments=${legalComments}`);
        if (sourceRoot !== void 0)
          flags.push(`--source-root=${sourceRoot}`);
        if (sourcesContent !== void 0)
          flags.push(`--sources-content=${sourcesContent}`);
        if (target) {
          if (Array.isArray(target))
            flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
          else
            flags.push(`--target=${validateTarget(target)}`);
        }
        if (format)
          flags.push(`--format=${format}`);
        if (globalName)
          flags.push(`--global-name=${globalName}`);
        if (platform)
          flags.push(`--platform=${platform}`);
        if (tsconfigRaw)
          flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
        if (minify)
          flags.push("--minify");
        if (minifySyntax)
          flags.push("--minify-syntax");
        if (minifyWhitespace)
          flags.push("--minify-whitespace");
        if (minifyIdentifiers)
          flags.push("--minify-identifiers");
        if (lineLimit)
          flags.push(`--line-limit=${lineLimit}`);
        if (charset)
          flags.push(`--charset=${charset}`);
        if (treeShaking !== void 0)
          flags.push(`--tree-shaking=${treeShaking}`);
        if (ignoreAnnotations)
          flags.push(`--ignore-annotations`);
        if (drop)
          for (let what of drop)
            flags.push(`--drop:${validateStringValue(what, "drop")}`);
        if (dropLabels)
          flags.push(`--drop-labels=${Array.from(dropLabels).map((what) => validateStringValue(what, "dropLabels")).join(",")}`);
        if (mangleProps)
          flags.push(`--mangle-props=${mangleProps.source}`);
        if (reserveProps)
          flags.push(`--reserve-props=${reserveProps.source}`);
        if (mangleQuoted !== void 0)
          flags.push(`--mangle-quoted=${mangleQuoted}`);
        if (jsx)
          flags.push(`--jsx=${jsx}`);
        if (jsxFactory)
          flags.push(`--jsx-factory=${jsxFactory}`);
        if (jsxFragment)
          flags.push(`--jsx-fragment=${jsxFragment}`);
        if (jsxImportSource)
          flags.push(`--jsx-import-source=${jsxImportSource}`);
        if (jsxDev)
          flags.push(`--jsx-dev`);
        if (jsxSideEffects)
          flags.push(`--jsx-side-effects`);
        if (define2) {
          for (let key in define2) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid define: ${key}`);
            flags.push(`--define:${key}=${validateStringValue(define2[key], "define", key)}`);
          }
        }
        if (logOverride) {
          for (let key in logOverride) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid log override: ${key}`);
            flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
          }
        }
        if (supported) {
          for (let key in supported) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid supported: ${key}`);
            const value = supported[key];
            if (typeof value !== "boolean")
              throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
            flags.push(`--supported:${key}=${value}`);
          }
        }
        if (pure)
          for (let fn of pure)
            flags.push(`--pure:${validateStringValue(fn, "pure")}`);
        if (keepNames)
          flags.push(`--keep-names`);
      }
      function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
        var _a2;
        let flags = [];
        let entries = [];
        let keys4 = /* @__PURE__ */ Object.create(null);
        let stdinContents = null;
        let stdinResolveDir = null;
        pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault);
        pushCommonFlags(flags, options, keys4);
        let sourcemap = getFlag(options, keys4, "sourcemap", mustBeStringOrBoolean);
        let bundle = getFlag(options, keys4, "bundle", mustBeBoolean);
        let splitting = getFlag(options, keys4, "splitting", mustBeBoolean);
        let preserveSymlinks = getFlag(options, keys4, "preserveSymlinks", mustBeBoolean);
        let metafile = getFlag(options, keys4, "metafile", mustBeBoolean);
        let outfile = getFlag(options, keys4, "outfile", mustBeString);
        let outdir = getFlag(options, keys4, "outdir", mustBeString);
        let outbase = getFlag(options, keys4, "outbase", mustBeString);
        let tsconfig = getFlag(options, keys4, "tsconfig", mustBeString);
        let resolveExtensions = getFlag(options, keys4, "resolveExtensions", mustBeArray);
        let nodePathsInput = getFlag(options, keys4, "nodePaths", mustBeArray);
        let mainFields = getFlag(options, keys4, "mainFields", mustBeArray);
        let conditions = getFlag(options, keys4, "conditions", mustBeArray);
        let external = getFlag(options, keys4, "external", mustBeArray);
        let packages = getFlag(options, keys4, "packages", mustBeString);
        let alias = getFlag(options, keys4, "alias", mustBeObject);
        let loader = getFlag(options, keys4, "loader", mustBeObject);
        let outExtension = getFlag(options, keys4, "outExtension", mustBeObject);
        let publicPath = getFlag(options, keys4, "publicPath", mustBeString);
        let entryNames = getFlag(options, keys4, "entryNames", mustBeString);
        let chunkNames = getFlag(options, keys4, "chunkNames", mustBeString);
        let assetNames = getFlag(options, keys4, "assetNames", mustBeString);
        let inject = getFlag(options, keys4, "inject", mustBeArray);
        let banner = getFlag(options, keys4, "banner", mustBeObject);
        let footer = getFlag(options, keys4, "footer", mustBeObject);
        let entryPoints = getFlag(options, keys4, "entryPoints", mustBeEntryPoints);
        let absWorkingDir = getFlag(options, keys4, "absWorkingDir", mustBeString);
        let stdin = getFlag(options, keys4, "stdin", mustBeObject);
        let write = (_a2 = getFlag(options, keys4, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
        let allowOverwrite = getFlag(options, keys4, "allowOverwrite", mustBeBoolean);
        let mangleCache = getFlag(options, keys4, "mangleCache", mustBeObject);
        keys4.plugins = true;
        checkForInvalidFlags(options, keys4, `in ${callName}() call`);
        if (sourcemap)
          flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
        if (bundle)
          flags.push("--bundle");
        if (allowOverwrite)
          flags.push("--allow-overwrite");
        if (splitting)
          flags.push("--splitting");
        if (preserveSymlinks)
          flags.push("--preserve-symlinks");
        if (metafile)
          flags.push(`--metafile`);
        if (outfile)
          flags.push(`--outfile=${outfile}`);
        if (outdir)
          flags.push(`--outdir=${outdir}`);
        if (outbase)
          flags.push(`--outbase=${outbase}`);
        if (tsconfig)
          flags.push(`--tsconfig=${tsconfig}`);
        if (packages)
          flags.push(`--packages=${packages}`);
        if (resolveExtensions) {
          let values = [];
          for (let value of resolveExtensions) {
            validateStringValue(value, "resolve extension");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid resolve extension: ${value}`);
            values.push(value);
          }
          flags.push(`--resolve-extensions=${values.join(",")}`);
        }
        if (publicPath)
          flags.push(`--public-path=${publicPath}`);
        if (entryNames)
          flags.push(`--entry-names=${entryNames}`);
        if (chunkNames)
          flags.push(`--chunk-names=${chunkNames}`);
        if (assetNames)
          flags.push(`--asset-names=${assetNames}`);
        if (mainFields) {
          let values = [];
          for (let value of mainFields) {
            validateStringValue(value, "main field");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid main field: ${value}`);
            values.push(value);
          }
          flags.push(`--main-fields=${values.join(",")}`);
        }
        if (conditions) {
          let values = [];
          for (let value of conditions) {
            validateStringValue(value, "condition");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid condition: ${value}`);
            values.push(value);
          }
          flags.push(`--conditions=${values.join(",")}`);
        }
        if (external)
          for (let name of external)
            flags.push(`--external:${validateStringValue(name, "external")}`);
        if (alias) {
          for (let old in alias) {
            if (old.indexOf("=") >= 0)
              throw new Error(`Invalid package name in alias: ${old}`);
            flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
          }
        }
        if (banner) {
          for (let type3 in banner) {
            if (type3.indexOf("=") >= 0)
              throw new Error(`Invalid banner file type: ${type3}`);
            flags.push(`--banner:${type3}=${validateStringValue(banner[type3], "banner", type3)}`);
          }
        }
        if (footer) {
          for (let type3 in footer) {
            if (type3.indexOf("=") >= 0)
              throw new Error(`Invalid footer file type: ${type3}`);
            flags.push(`--footer:${type3}=${validateStringValue(footer[type3], "footer", type3)}`);
          }
        }
        if (inject)
          for (let path32 of inject)
            flags.push(`--inject:${validateStringValue(path32, "inject")}`);
        if (loader) {
          for (let ext2 in loader) {
            if (ext2.indexOf("=") >= 0)
              throw new Error(`Invalid loader extension: ${ext2}`);
            flags.push(`--loader:${ext2}=${validateStringValue(loader[ext2], "loader", ext2)}`);
          }
        }
        if (outExtension) {
          for (let ext2 in outExtension) {
            if (ext2.indexOf("=") >= 0)
              throw new Error(`Invalid out extension: ${ext2}`);
            flags.push(`--out-extension:${ext2}=${validateStringValue(outExtension[ext2], "out extension", ext2)}`);
          }
        }
        if (entryPoints) {
          if (Array.isArray(entryPoints)) {
            for (let i = 0, n = entryPoints.length; i < n; i++) {
              let entryPoint = entryPoints[i];
              if (typeof entryPoint === "object" && entryPoint !== null) {
                let entryPointKeys = /* @__PURE__ */ Object.create(null);
                let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
                let output3 = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
                checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
                if (input === void 0)
                  throw new Error('Missing property "in" for entry point at index ' + i);
                if (output3 === void 0)
                  throw new Error('Missing property "out" for entry point at index ' + i);
                entries.push([output3, input]);
              } else {
                entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
              }
            }
          } else {
            for (let key in entryPoints) {
              entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
            }
          }
        }
        if (stdin) {
          let stdinKeys = /* @__PURE__ */ Object.create(null);
          let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
          let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
          let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
          let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
          checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
          if (sourcefile)
            flags.push(`--sourcefile=${sourcefile}`);
          if (loader2)
            flags.push(`--loader=${loader2}`);
          if (resolveDir)
            stdinResolveDir = resolveDir;
          if (typeof contents === "string")
            stdinContents = encodeUTF8(contents);
          else if (contents instanceof Uint8Array)
            stdinContents = contents;
        }
        let nodePaths = [];
        if (nodePathsInput) {
          for (let value of nodePathsInput) {
            value += "";
            nodePaths.push(value);
          }
        }
        return {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
        let flags = [];
        let keys4 = /* @__PURE__ */ Object.create(null);
        pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault);
        pushCommonFlags(flags, options, keys4);
        let sourcemap = getFlag(options, keys4, "sourcemap", mustBeStringOrBoolean);
        let sourcefile = getFlag(options, keys4, "sourcefile", mustBeString);
        let loader = getFlag(options, keys4, "loader", mustBeString);
        let banner = getFlag(options, keys4, "banner", mustBeString);
        let footer = getFlag(options, keys4, "footer", mustBeString);
        let mangleCache = getFlag(options, keys4, "mangleCache", mustBeObject);
        checkForInvalidFlags(options, keys4, `in ${callName}() call`);
        if (sourcemap)
          flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader)
          flags.push(`--loader=${loader}`);
        if (banner)
          flags.push(`--banner=${banner}`);
        if (footer)
          flags.push(`--footer=${footer}`);
        return {
          flags,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      function createChannel(streamIn) {
        const requestCallbacksByKey = {};
        const closeData = { didClose: false, reason: "" };
        let responseCallbacks = {};
        let nextRequestID = 0;
        let nextBuildKey = 0;
        let stdout = new Uint8Array(16 * 1024);
        let stdoutUsed = 0;
        let readFromStdout = (chunk) => {
          let limit = stdoutUsed + chunk.length;
          if (limit > stdout.length) {
            let swap = new Uint8Array(limit * 2);
            swap.set(stdout);
            stdout = swap;
          }
          stdout.set(chunk, stdoutUsed);
          stdoutUsed += chunk.length;
          let offset = 0;
          while (offset + 4 <= stdoutUsed) {
            let length = readUInt32LE(stdout, offset);
            if (offset + 4 + length > stdoutUsed) {
              break;
            }
            offset += 4;
            handleIncomingPacket(stdout.subarray(offset, offset + length));
            offset += length;
          }
          if (offset > 0) {
            stdout.copyWithin(0, offset, stdoutUsed);
            stdoutUsed -= offset;
          }
        };
        let afterClose = (error2) => {
          closeData.didClose = true;
          if (error2)
            closeData.reason = ": " + (error2.message || error2);
          const text = "The service was stopped" + closeData.reason;
          for (let id in responseCallbacks) {
            responseCallbacks[id](text, null);
          }
          responseCallbacks = {};
        };
        let sendRequest = (refs, value, callback) => {
          if (closeData.didClose)
            return callback("The service is no longer running" + closeData.reason, null);
          let id = nextRequestID++;
          responseCallbacks[id] = (error2, response) => {
            try {
              callback(error2, response);
            } finally {
              if (refs)
                refs.unref();
            }
          };
          if (refs)
            refs.ref();
          streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
        };
        let sendResponse = (id, value) => {
          if (closeData.didClose)
            throw new Error("The service is no longer running" + closeData.reason);
          streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
        };
        let handleRequest = async (id, request) => {
          try {
            if (request.command === "ping") {
              sendResponse(id, {});
              return;
            }
            if (typeof request.key === "number") {
              const requestCallbacks = requestCallbacksByKey[request.key];
              if (!requestCallbacks) {
                return;
              }
              const callback = requestCallbacks[request.command];
              if (callback) {
                await callback(id, request);
                return;
              }
            }
            throw new Error(`Invalid command: ` + request.command);
          } catch (e) {
            const errors = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
            try {
              sendResponse(id, { errors });
            } catch {
            }
          }
        };
        let isFirstPacket = true;
        let handleIncomingPacket = (bytes3) => {
          if (isFirstPacket) {
            isFirstPacket = false;
            let binaryVersion = String.fromCharCode(...bytes3);
            if (binaryVersion !== "0.19.3") {
              throw new Error(`Cannot start service: Host version "${"0.19.3"}" does not match binary version ${quote(binaryVersion)}`);
            }
            return;
          }
          let packet = decodePacket(bytes3);
          if (packet.isRequest) {
            handleRequest(packet.id, packet.value);
          } else {
            let callback = responseCallbacks[packet.id];
            delete responseCallbacks[packet.id];
            if (packet.value.error)
              callback(packet.value.error, {});
            else
              callback(null, packet.value);
          }
        };
        let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
          let refCount = 0;
          const buildKey = nextBuildKey++;
          const requestCallbacks = {};
          const buildRefs = {
            ref() {
              if (++refCount === 1) {
                if (refs)
                  refs.ref();
              }
            },
            unref() {
              if (--refCount === 0) {
                delete requestCallbacksByKey[buildKey];
                if (refs)
                  refs.unref();
              }
            }
          };
          requestCallbacksByKey[buildKey] = requestCallbacks;
          buildRefs.ref();
          buildOrContextImpl(
            callName,
            buildKey,
            sendRequest,
            sendResponse,
            buildRefs,
            streamIn,
            requestCallbacks,
            options,
            isTTY2,
            defaultWD2,
            (err, res) => {
              try {
                callback(err, res);
              } finally {
                buildRefs.unref();
              }
            }
          );
        };
        let transform2 = ({ callName, refs, input, options, isTTY: isTTY2, fs: fs32, callback }) => {
          const details = createObjectStash();
          let start = (inputPath) => {
            try {
              if (typeof input !== "string" && !(input instanceof Uint8Array))
                throw new Error('The input to "transform" must be a string or a Uint8Array');
              let {
                flags,
                mangleCache
              } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
              let request = {
                command: "transform",
                flags,
                inputFS: inputPath !== null,
                input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
              };
              if (mangleCache)
                request.mangleCache = mangleCache;
              sendRequest(refs, request, (error2, response) => {
                if (error2)
                  return callback(new Error(error2), null);
                let errors = replaceDetailsInMessages(response.errors, details);
                let warnings = replaceDetailsInMessages(response.warnings, details);
                let outstanding = 1;
                let next = () => {
                  if (--outstanding === 0) {
                    let result = {
                      warnings,
                      code: response.code,
                      map: response.map,
                      mangleCache: void 0,
                      legalComments: void 0
                    };
                    if ("legalComments" in response)
                      result.legalComments = response == null ? void 0 : response.legalComments;
                    if (response.mangleCache)
                      result.mangleCache = response == null ? void 0 : response.mangleCache;
                    callback(null, result);
                  }
                };
                if (errors.length > 0)
                  return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
                if (response.codeFS) {
                  outstanding++;
                  fs32.readFile(response.code, (err, contents) => {
                    if (err !== null) {
                      callback(err, null);
                    } else {
                      response.code = contents;
                      next();
                    }
                  });
                }
                if (response.mapFS) {
                  outstanding++;
                  fs32.readFile(response.map, (err, contents) => {
                    if (err !== null) {
                      callback(err, null);
                    } else {
                      response.map = contents;
                      next();
                    }
                  });
                }
                next();
              });
            } catch (e) {
              let flags = [];
              try {
                pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
              } catch {
              }
              const error2 = extractErrorMessageV8(e, streamIn, details, void 0, "");
              sendRequest(refs, { command: "error", flags, error: error2 }, () => {
                error2.detail = details.load(error2.detail);
                callback(failureErrorWithLog("Transform failed", [error2], []), null);
              });
            }
          };
          if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
            let next = start;
            start = () => fs32.writeFile(input, next);
          }
          start(null);
        };
        let formatMessages2 = ({ callName, refs, messages, options, callback }) => {
          let result = sanitizeMessages(messages, "messages", null, "");
          if (!options)
            throw new Error(`Missing second argument in ${callName}() call`);
          let keys4 = {};
          let kind = getFlag(options, keys4, "kind", mustBeString);
          let color = getFlag(options, keys4, "color", mustBeBoolean);
          let terminalWidth = getFlag(options, keys4, "terminalWidth", mustBeInteger);
          checkForInvalidFlags(options, keys4, `in ${callName}() call`);
          if (kind === void 0)
            throw new Error(`Missing "kind" in ${callName}() call`);
          if (kind !== "error" && kind !== "warning")
            throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
          let request = {
            command: "format-msgs",
            messages: result,
            isWarning: kind === "warning"
          };
          if (color !== void 0)
            request.color = color;
          if (terminalWidth !== void 0)
            request.terminalWidth = terminalWidth;
          sendRequest(refs, request, (error2, response) => {
            if (error2)
              return callback(new Error(error2), null);
            callback(null, response.messages);
          });
        };
        let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
          if (options === void 0)
            options = {};
          let keys4 = {};
          let color = getFlag(options, keys4, "color", mustBeBoolean);
          let verbose = getFlag(options, keys4, "verbose", mustBeBoolean);
          checkForInvalidFlags(options, keys4, `in ${callName}() call`);
          let request = {
            command: "analyze-metafile",
            metafile
          };
          if (color !== void 0)
            request.color = color;
          if (verbose !== void 0)
            request.verbose = verbose;
          sendRequest(refs, request, (error2, response) => {
            if (error2)
              return callback(new Error(error2), null);
            callback(null, response.result);
          });
        };
        return {
          readFromStdout,
          afterClose,
          service: {
            buildOrContext,
            transform: transform2,
            formatMessages: formatMessages2,
            analyzeMetafile: analyzeMetafile2
          }
        };
      }
      function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
        const details = createObjectStash();
        const isContext = callName === "context";
        const handleError = (e, pluginName) => {
          const flags = [];
          try {
            pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
          } catch {
          }
          const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
          sendRequest(refs, { command: "error", flags, error: message }, () => {
            message.detail = details.load(message.detail);
            callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
          });
        };
        let plugins;
        if (typeof options === "object") {
          const value = options.plugins;
          if (value !== void 0) {
            if (!Array.isArray(value))
              return handleError(new Error(`"plugins" must be an array`), "");
            plugins = value;
          }
        }
        if (plugins && plugins.length > 0) {
          if (streamIn.isSync)
            return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
          handlePlugins(
            buildKey,
            sendRequest,
            sendResponse,
            refs,
            streamIn,
            requestCallbacks,
            options,
            plugins,
            details
          ).then(
            (result) => {
              if (!result.ok)
                return handleError(result.error, result.pluginName);
              try {
                buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
              } catch (e) {
                handleError(e, "");
              }
            },
            (e) => handleError(e, "")
          );
          return;
        }
        try {
          buildOrContextContinue(null, (result, done) => done([], []), () => {
          });
        } catch (e) {
          handleError(e, "");
        }
        function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
          const writeDefault = streamIn.hasFS;
          const {
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir,
            nodePaths,
            mangleCache
          } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
          if (write && !streamIn.hasFS)
            throw new Error(`The "write" option is unavailable in this environment`);
          const request = {
            command: "build",
            key: buildKey,
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir: absWorkingDir || defaultWD2,
            nodePaths,
            context: isContext
          };
          if (requestPlugins)
            request.plugins = requestPlugins;
          if (mangleCache)
            request.mangleCache = mangleCache;
          const buildResponseToResult = (response, callback2) => {
            const result = {
              errors: replaceDetailsInMessages(response.errors, details),
              warnings: replaceDetailsInMessages(response.warnings, details),
              outputFiles: void 0,
              metafile: void 0,
              mangleCache: void 0
            };
            const originalErrors = result.errors.slice();
            const originalWarnings = result.warnings.slice();
            if (response.outputFiles)
              result.outputFiles = response.outputFiles.map(convertOutputFiles);
            if (response.metafile)
              result.metafile = JSON.parse(response.metafile);
            if (response.mangleCache)
              result.mangleCache = response.mangleCache;
            if (response.writeToStdout !== void 0)
              console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
            runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
              if (originalErrors.length > 0 || onEndErrors.length > 0) {
                const error2 = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
                return callback2(error2, null, onEndErrors, onEndWarnings);
              }
              callback2(null, result, onEndErrors, onEndWarnings);
            });
          };
          let latestResultPromise;
          let provideLatestResult;
          if (isContext)
            requestCallbacks["on-end"] = (id, request2) => new Promise((resolve4) => {
              buildResponseToResult(request2, (err, result, onEndErrors, onEndWarnings) => {
                const response = {
                  errors: onEndErrors,
                  warnings: onEndWarnings
                };
                if (provideLatestResult)
                  provideLatestResult(err, result);
                latestResultPromise = void 0;
                provideLatestResult = void 0;
                sendResponse(id, response);
                resolve4();
              });
            });
          sendRequest(refs, request, (error2, response) => {
            if (error2)
              return callback(new Error(error2), null);
            if (!isContext) {
              return buildResponseToResult(response, (err, res) => {
                scheduleOnDisposeCallbacks();
                return callback(err, res);
              });
            }
            if (response.errors.length > 0) {
              return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
            }
            let didDispose = false;
            const result = {
              rebuild: () => {
                if (!latestResultPromise)
                  latestResultPromise = new Promise((resolve4, reject) => {
                    let settlePromise;
                    provideLatestResult = (err, result2) => {
                      if (!settlePromise)
                        settlePromise = () => err ? reject(err) : resolve4(result2);
                    };
                    const triggerAnotherBuild = () => {
                      const request2 = {
                        command: "rebuild",
                        key: buildKey
                      };
                      sendRequest(refs, request2, (error22, response2) => {
                        if (error22) {
                          reject(new Error(error22));
                        } else if (settlePromise) {
                          settlePromise();
                        } else {
                          triggerAnotherBuild();
                        }
                      });
                    };
                    triggerAnotherBuild();
                  });
                return latestResultPromise;
              },
              watch: (options2 = {}) => new Promise((resolve4, reject) => {
                if (!streamIn.hasFS)
                  throw new Error(`Cannot use the "watch" API in this environment`);
                const keys4 = {};
                checkForInvalidFlags(options2, keys4, `in watch() call`);
                const request2 = {
                  command: "watch",
                  key: buildKey
                };
                sendRequest(refs, request2, (error22) => {
                  if (error22)
                    reject(new Error(error22));
                  else
                    resolve4(void 0);
                });
              }),
              serve: (options2 = {}) => new Promise((resolve4, reject) => {
                if (!streamIn.hasFS)
                  throw new Error(`Cannot use the "serve" API in this environment`);
                const keys4 = {};
                const port = getFlag(options2, keys4, "port", mustBeInteger);
                const host = getFlag(options2, keys4, "host", mustBeString);
                const servedir = getFlag(options2, keys4, "servedir", mustBeString);
                const keyfile = getFlag(options2, keys4, "keyfile", mustBeString);
                const certfile = getFlag(options2, keys4, "certfile", mustBeString);
                const fallback = getFlag(options2, keys4, "fallback", mustBeString);
                const onRequest = getFlag(options2, keys4, "onRequest", mustBeFunction);
                checkForInvalidFlags(options2, keys4, `in serve() call`);
                const request2 = {
                  command: "serve",
                  key: buildKey,
                  onRequest: !!onRequest
                };
                if (port !== void 0)
                  request2.port = port;
                if (host !== void 0)
                  request2.host = host;
                if (servedir !== void 0)
                  request2.servedir = servedir;
                if (keyfile !== void 0)
                  request2.keyfile = keyfile;
                if (certfile !== void 0)
                  request2.certfile = certfile;
                if (fallback !== void 0)
                  request2.fallback = fallback;
                sendRequest(refs, request2, (error22, response2) => {
                  if (error22)
                    return reject(new Error(error22));
                  if (onRequest) {
                    requestCallbacks["serve-request"] = (id, request3) => {
                      onRequest(request3.args);
                      sendResponse(id, {});
                    };
                  }
                  resolve4(response2);
                });
              }),
              cancel: () => new Promise((resolve4) => {
                if (didDispose)
                  return resolve4();
                const request2 = {
                  command: "cancel",
                  key: buildKey
                };
                sendRequest(refs, request2, () => {
                  resolve4();
                });
              }),
              dispose: () => new Promise((resolve4) => {
                if (didDispose)
                  return resolve4();
                didDispose = true;
                const request2 = {
                  command: "dispose",
                  key: buildKey
                };
                sendRequest(refs, request2, () => {
                  resolve4();
                  scheduleOnDisposeCallbacks();
                  refs.unref();
                });
              })
            };
            refs.ref();
            callback(null, result);
          });
        }
      }
      var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
        let onStartCallbacks = [];
        let onEndCallbacks = [];
        let onResolveCallbacks = {};
        let onLoadCallbacks = {};
        let onDisposeCallbacks = [];
        let nextCallbackID = 0;
        let i = 0;
        let requestPlugins = [];
        let isSetupDone = false;
        plugins = [...plugins];
        for (let item of plugins) {
          let keys4 = {};
          if (typeof item !== "object")
            throw new Error(`Plugin at index ${i} must be an object`);
          const name = getFlag(item, keys4, "name", mustBeString);
          if (typeof name !== "string" || name === "")
            throw new Error(`Plugin at index ${i} is missing a name`);
          try {
            let setup = getFlag(item, keys4, "setup", mustBeFunction);
            if (typeof setup !== "function")
              throw new Error(`Plugin is missing a setup function`);
            checkForInvalidFlags(item, keys4, `on plugin ${quote(name)}`);
            let plugin = {
              name,
              onStart: false,
              onEnd: false,
              onResolve: [],
              onLoad: []
            };
            i++;
            let resolve4 = (path32, options = {}) => {
              if (!isSetupDone)
                throw new Error('Cannot call "resolve" before plugin setup has completed');
              if (typeof path32 !== "string")
                throw new Error(`The path to resolve must be a string`);
              let keys22 = /* @__PURE__ */ Object.create(null);
              let pluginName = getFlag(options, keys22, "pluginName", mustBeString);
              let importer = getFlag(options, keys22, "importer", mustBeString);
              let namespace = getFlag(options, keys22, "namespace", mustBeString);
              let resolveDir = getFlag(options, keys22, "resolveDir", mustBeString);
              let kind = getFlag(options, keys22, "kind", mustBeString);
              let pluginData = getFlag(options, keys22, "pluginData", canBeAnything);
              checkForInvalidFlags(options, keys22, "in resolve() call");
              return new Promise((resolve22, reject) => {
                const request = {
                  command: "resolve",
                  path: path32,
                  key: buildKey,
                  pluginName: name
                };
                if (pluginName != null)
                  request.pluginName = pluginName;
                if (importer != null)
                  request.importer = importer;
                if (namespace != null)
                  request.namespace = namespace;
                if (resolveDir != null)
                  request.resolveDir = resolveDir;
                if (kind != null)
                  request.kind = kind;
                else
                  throw new Error(`Must specify "kind" when calling "resolve"`);
                if (pluginData != null)
                  request.pluginData = details.store(pluginData);
                sendRequest(refs, request, (error2, response) => {
                  if (error2 !== null)
                    reject(new Error(error2));
                  else
                    resolve22({
                      errors: replaceDetailsInMessages(response.errors, details),
                      warnings: replaceDetailsInMessages(response.warnings, details),
                      path: response.path,
                      external: response.external,
                      sideEffects: response.sideEffects,
                      namespace: response.namespace,
                      suffix: response.suffix,
                      pluginData: details.load(response.pluginData)
                    });
                });
              });
            };
            let promise = setup({
              initialOptions,
              resolve: resolve4,
              onStart(callback) {
                let registeredText = `This error came from the "onStart" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                onStartCallbacks.push({ name, callback, note: registeredNote });
                plugin.onStart = true;
              },
              onEnd(callback) {
                let registeredText = `This error came from the "onEnd" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                onEndCallbacks.push({ name, callback, note: registeredNote });
                plugin.onEnd = true;
              },
              onResolve(options, callback) {
                let registeredText = `This error came from the "onResolve" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                let keys22 = {};
                let filter2 = getFlag(options, keys22, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys22, "namespace", mustBeString);
                checkForInvalidFlags(options, keys22, `in onResolve() call for plugin ${quote(name)}`);
                if (filter2 == null)
                  throw new Error(`onResolve() call is missing a filter`);
                let id = nextCallbackID++;
                onResolveCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onResolve.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              onLoad(options, callback) {
                let registeredText = `This error came from the "onLoad" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                let keys22 = {};
                let filter2 = getFlag(options, keys22, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys22, "namespace", mustBeString);
                checkForInvalidFlags(options, keys22, `in onLoad() call for plugin ${quote(name)}`);
                if (filter2 == null)
                  throw new Error(`onLoad() call is missing a filter`);
                let id = nextCallbackID++;
                onLoadCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onLoad.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              onDispose(callback) {
                onDisposeCallbacks.push(callback);
              },
              esbuild: streamIn.esbuild
            });
            if (promise)
              await promise;
            requestPlugins.push(plugin);
          } catch (e) {
            return { ok: false, error: e, pluginName: name };
          }
        }
        requestCallbacks["on-start"] = async (id, request) => {
          let response = { errors: [], warnings: [] };
          await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
            try {
              let result = await callback();
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let errors = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onStart() callback in plugin ${quote(name)}`);
                if (errors != null)
                  response.errors.push(...sanitizeMessages(errors, "errors", details, name));
                if (warnings != null)
                  response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name));
              }
            } catch (e) {
              response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
            }
          }));
          sendResponse(id, response);
        };
        requestCallbacks["on-resolve"] = async (id, request) => {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onResolveCallbacks[id2]);
              let result = await callback({
                path: request.path,
                importer: request.importer,
                namespace: request.namespace,
                resolveDir: request.resolveDir,
                kind: request.kind,
                pluginData: details.load(request.pluginData)
              });
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let pluginName = getFlag(result, keys4, "pluginName", mustBeString);
                let path32 = getFlag(result, keys4, "path", mustBeString);
                let namespace = getFlag(result, keys4, "namespace", mustBeString);
                let suffix = getFlag(result, keys4, "suffix", mustBeString);
                let external = getFlag(result, keys4, "external", mustBeBoolean);
                let sideEffects = getFlag(result, keys4, "sideEffects", mustBeBoolean);
                let pluginData = getFlag(result, keys4, "pluginData", canBeAnything);
                let errors = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys4, "watchFiles", mustBeArray);
                let watchDirs = getFlag(result, keys4, "watchDirs", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onResolve() callback in plugin ${quote(name)}`);
                response.id = id2;
                if (pluginName != null)
                  response.pluginName = pluginName;
                if (path32 != null)
                  response.path = path32;
                if (namespace != null)
                  response.namespace = namespace;
                if (suffix != null)
                  response.suffix = suffix;
                if (external != null)
                  response.external = external;
                if (sideEffects != null)
                  response.sideEffects = sideEffects;
                if (pluginData != null)
                  response.pluginData = details.store(pluginData);
                if (errors != null)
                  response.errors = sanitizeMessages(errors, "errors", details, name);
                if (warnings != null)
                  response.warnings = sanitizeMessages(warnings, "warnings", details, name);
                if (watchFiles != null)
                  response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null)
                  response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e) {
              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        };
        requestCallbacks["on-load"] = async (id, request) => {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onLoadCallbacks[id2]);
              let result = await callback({
                path: request.path,
                namespace: request.namespace,
                suffix: request.suffix,
                pluginData: details.load(request.pluginData)
              });
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let pluginName = getFlag(result, keys4, "pluginName", mustBeString);
                let contents = getFlag(result, keys4, "contents", mustBeStringOrUint8Array);
                let resolveDir = getFlag(result, keys4, "resolveDir", mustBeString);
                let pluginData = getFlag(result, keys4, "pluginData", canBeAnything);
                let loader = getFlag(result, keys4, "loader", mustBeString);
                let errors = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys4, "watchFiles", mustBeArray);
                let watchDirs = getFlag(result, keys4, "watchDirs", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onLoad() callback in plugin ${quote(name)}`);
                response.id = id2;
                if (pluginName != null)
                  response.pluginName = pluginName;
                if (contents instanceof Uint8Array)
                  response.contents = contents;
                else if (contents != null)
                  response.contents = encodeUTF8(contents);
                if (resolveDir != null)
                  response.resolveDir = resolveDir;
                if (pluginData != null)
                  response.pluginData = details.store(pluginData);
                if (loader != null)
                  response.loader = loader;
                if (errors != null)
                  response.errors = sanitizeMessages(errors, "errors", details, name);
                if (warnings != null)
                  response.warnings = sanitizeMessages(warnings, "warnings", details, name);
                if (watchFiles != null)
                  response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null)
                  response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e) {
              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        };
        let runOnEndCallbacks = (result, done) => done([], []);
        if (onEndCallbacks.length > 0) {
          runOnEndCallbacks = (result, done) => {
            (async () => {
              const onEndErrors = [];
              const onEndWarnings = [];
              for (const { name, callback, note } of onEndCallbacks) {
                let newErrors;
                let newWarnings;
                try {
                  const value = await callback(result);
                  if (value != null) {
                    if (typeof value !== "object")
                      throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
                    let keys4 = {};
                    let errors = getFlag(value, keys4, "errors", mustBeArray);
                    let warnings = getFlag(value, keys4, "warnings", mustBeArray);
                    checkForInvalidFlags(value, keys4, `from onEnd() callback in plugin ${quote(name)}`);
                    if (errors != null)
                      newErrors = sanitizeMessages(errors, "errors", details, name);
                    if (warnings != null)
                      newWarnings = sanitizeMessages(warnings, "warnings", details, name);
                  }
                } catch (e) {
                  newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];
                }
                if (newErrors) {
                  onEndErrors.push(...newErrors);
                  try {
                    result.errors.push(...newErrors);
                  } catch {
                  }
                }
                if (newWarnings) {
                  onEndWarnings.push(...newWarnings);
                  try {
                    result.warnings.push(...newWarnings);
                  } catch {
                  }
                }
              }
              done(onEndErrors, onEndWarnings);
            })();
          };
        }
        let scheduleOnDisposeCallbacks = () => {
          for (const cb of onDisposeCallbacks) {
            setTimeout(() => cb(), 0);
          }
        };
        isSetupDone = true;
        return {
          ok: true,
          requestPlugins,
          runOnEndCallbacks,
          scheduleOnDisposeCallbacks
        };
      };
      function createObjectStash() {
        const map2 = /* @__PURE__ */ new Map();
        let nextID = 0;
        return {
          load(id) {
            return map2.get(id);
          },
          store(value) {
            if (value === void 0)
              return -1;
            const id = nextID++;
            map2.set(id, value);
            return id;
          }
        };
      }
      function extractCallerV8(e, streamIn, ident) {
        let note;
        let tried = false;
        return () => {
          if (tried)
            return note;
          tried = true;
          try {
            let lines = (e.stack + "").split("\n");
            lines.splice(1, 1);
            let location = parseStackLinesV8(streamIn, lines, ident);
            if (location) {
              note = { text: e.message, location };
              return note;
            }
          } catch {
          }
        };
      }
      function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
        let text = "Internal error";
        let location = null;
        try {
          text = (e && e.message || e) + "";
        } catch {
        }
        try {
          location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
        } catch {
        }
        return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
      }
      function parseStackLinesV8(streamIn, lines, ident) {
        let at = "    at ";
        if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
          for (let i = 1; i < lines.length; i++) {
            let line = lines[i];
            if (!line.startsWith(at))
              continue;
            line = line.slice(at.length);
            while (true) {
              let match3 = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
              if (match3) {
                line = match3[1];
                continue;
              }
              match3 = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
              if (match3) {
                line = match3[1];
                continue;
              }
              match3 = /^(\S+):(\d+):(\d+)$/.exec(line);
              if (match3) {
                let contents;
                try {
                  contents = streamIn.readFileSync(match3[1], "utf8");
                } catch {
                  break;
                }
                let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match3[2] - 1] || "";
                let column = +match3[3] - 1;
                let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
                return {
                  file: match3[1],
                  namespace: "file",
                  line: +match3[2],
                  column: encodeUTF8(lineText.slice(0, column)).length,
                  length: encodeUTF8(lineText.slice(column, column + length)).length,
                  lineText: lineText + "\n" + lines.slice(1).join("\n"),
                  suggestion: ""
                };
              }
              break;
            }
          }
        }
        return null;
      }
      function failureErrorWithLog(text, errors, warnings) {
        let limit = 5;
        text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
          if (i === limit)
            return "\n...";
          if (!e.location)
            return `
error: ${e.text}`;
          let { file, line, column } = e.location;
          let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
          return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
        }).join("");
        let error2 = new Error(text);
        for (const [key, value] of [["errors", errors], ["warnings", warnings]]) {
          Object.defineProperty(error2, key, {
            configurable: true,
            enumerable: true,
            get: () => value,
            set: (value2) => Object.defineProperty(error2, key, {
              configurable: true,
              enumerable: true,
              value: value2
            })
          });
        }
        return error2;
      }
      function replaceDetailsInMessages(messages, stash) {
        for (const message of messages) {
          message.detail = stash.load(message.detail);
        }
        return messages;
      }
      function sanitizeLocation(location, where) {
        if (location == null)
          return null;
        let keys4 = {};
        let file = getFlag(location, keys4, "file", mustBeString);
        let namespace = getFlag(location, keys4, "namespace", mustBeString);
        let line = getFlag(location, keys4, "line", mustBeInteger);
        let column = getFlag(location, keys4, "column", mustBeInteger);
        let length = getFlag(location, keys4, "length", mustBeInteger);
        let lineText = getFlag(location, keys4, "lineText", mustBeString);
        let suggestion = getFlag(location, keys4, "suggestion", mustBeString);
        checkForInvalidFlags(location, keys4, where);
        return {
          file: file || "",
          namespace: namespace || "",
          line: line || 0,
          column: column || 0,
          length: length || 0,
          lineText: lineText || "",
          suggestion: suggestion || ""
        };
      }
      function sanitizeMessages(messages, property, stash, fallbackPluginName) {
        let messagesClone = [];
        let index = 0;
        for (const message of messages) {
          let keys4 = {};
          let id = getFlag(message, keys4, "id", mustBeString);
          let pluginName = getFlag(message, keys4, "pluginName", mustBeString);
          let text = getFlag(message, keys4, "text", mustBeString);
          let location = getFlag(message, keys4, "location", mustBeObjectOrNull);
          let notes = getFlag(message, keys4, "notes", mustBeArray);
          let detail = getFlag(message, keys4, "detail", canBeAnything);
          let where = `in element ${index} of "${property}"`;
          checkForInvalidFlags(message, keys4, where);
          let notesClone = [];
          if (notes) {
            for (const note of notes) {
              let noteKeys = {};
              let noteText = getFlag(note, noteKeys, "text", mustBeString);
              let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
              checkForInvalidFlags(note, noteKeys, where);
              notesClone.push({
                text: noteText || "",
                location: sanitizeLocation(noteLocation, where)
              });
            }
          }
          messagesClone.push({
            id: id || "",
            pluginName: pluginName || fallbackPluginName,
            text: text || "",
            location: sanitizeLocation(location, where),
            notes: notesClone,
            detail: stash ? stash.store(detail) : -1
          });
          index++;
        }
        return messagesClone;
      }
      function sanitizeStringArray(values, property) {
        const result = [];
        for (const value of values) {
          if (typeof value !== "string")
            throw new Error(`${quote(property)} must be an array of strings`);
          result.push(value);
        }
        return result;
      }
      function convertOutputFiles({ path: path32, contents, hash: hash4 }) {
        let text = null;
        return {
          path: path32,
          contents,
          hash: hash4,
          get text() {
            const binary = this.contents;
            if (text === null || binary !== contents) {
              contents = binary;
              text = decodeUTF8(binary);
            }
            return text;
          }
        };
      }
      var fs4 = __require2("fs");
      var os2 = __require2("os");
      var path5 = __require2("path");
      var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
      var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
      var packageDarwin_arm64 = "@esbuild/darwin-arm64";
      var packageDarwin_x64 = "@esbuild/darwin-x64";
      var knownWindowsPackages = {
        "win32 arm64 LE": "@esbuild/win32-arm64",
        "win32 ia32 LE": "@esbuild/win32-ia32",
        "win32 x64 LE": "@esbuild/win32-x64"
      };
      var knownUnixlikePackages = {
        "android arm64 LE": "@esbuild/android-arm64",
        "darwin arm64 LE": "@esbuild/darwin-arm64",
        "darwin x64 LE": "@esbuild/darwin-x64",
        "freebsd arm64 LE": "@esbuild/freebsd-arm64",
        "freebsd x64 LE": "@esbuild/freebsd-x64",
        "linux arm LE": "@esbuild/linux-arm",
        "linux arm64 LE": "@esbuild/linux-arm64",
        "linux ia32 LE": "@esbuild/linux-ia32",
        "linux mips64el LE": "@esbuild/linux-mips64el",
        "linux ppc64 LE": "@esbuild/linux-ppc64",
        "linux riscv64 LE": "@esbuild/linux-riscv64",
        "linux s390x BE": "@esbuild/linux-s390x",
        "linux x64 LE": "@esbuild/linux-x64",
        "linux loong64 LE": "@esbuild/linux-loong64",
        "netbsd x64 LE": "@esbuild/netbsd-x64",
        "openbsd x64 LE": "@esbuild/openbsd-x64",
        "sunos x64 LE": "@esbuild/sunos-x64"
      };
      var knownWebAssemblyFallbackPackages = {
        "android arm LE": "@esbuild/android-arm",
        "android x64 LE": "@esbuild/android-x64"
      };
      function pkgAndSubpathForCurrentPlatform() {
        let pkg;
        let subpath;
        let isWASM = false;
        let platformKey = `${process.platform} ${os2.arch()} ${os2.endianness()}`;
        if (platformKey in knownWindowsPackages) {
          pkg = knownWindowsPackages[platformKey];
          subpath = "esbuild.exe";
        } else if (platformKey in knownUnixlikePackages) {
          pkg = knownUnixlikePackages[platformKey];
          subpath = "bin/esbuild";
        } else if (platformKey in knownWebAssemblyFallbackPackages) {
          pkg = knownWebAssemblyFallbackPackages[platformKey];
          subpath = "bin/esbuild";
          isWASM = true;
        } else {
          throw new Error(`Unsupported platform: ${platformKey}`);
        }
        return { pkg, subpath, isWASM };
      }
      function pkgForSomeOtherPlatform() {
        const libMainJS = __require2.resolve("esbuild");
        const nodeModulesDirectory = path5.dirname(path5.dirname(path5.dirname(libMainJS)));
        if (path5.basename(nodeModulesDirectory) === "node_modules") {
          for (const unixKey in knownUnixlikePackages) {
            try {
              const pkg = knownUnixlikePackages[unixKey];
              if (fs4.existsSync(path5.join(nodeModulesDirectory, pkg)))
                return pkg;
            } catch {
            }
          }
          for (const windowsKey in knownWindowsPackages) {
            try {
              const pkg = knownWindowsPackages[windowsKey];
              if (fs4.existsSync(path5.join(nodeModulesDirectory, pkg)))
                return pkg;
            } catch {
            }
          }
        }
        return null;
      }
      function downloadedBinPath(pkg, subpath) {
        const esbuildLibDir = path5.dirname(__require2.resolve("esbuild"));
        return path5.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path5.basename(subpath)}`);
      }
      function generateBinPath() {
        if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
          if (!fs4.existsSync(ESBUILD_BINARY_PATH)) {
            console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
          } else {
            return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
          }
        }
        const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
        let binPath;
        try {
          binPath = __require2.resolve(`${pkg}/${subpath}`);
        } catch (e) {
          binPath = downloadedBinPath(pkg, subpath);
          if (!fs4.existsSync(binPath)) {
            try {
              __require2.resolve(pkg);
            } catch {
              const otherPkg = pkgForSomeOtherPlatform();
              if (otherPkg) {
                let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                  suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                }
                throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
              }
              throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
            }
            throw e;
          }
        }
        if (/\.zip\//.test(binPath)) {
          let pnpapi;
          try {
            pnpapi = __require2("pnpapi");
          } catch (e) {
          }
          if (pnpapi) {
            const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
            const binTargetPath = path5.join(
              root,
              "node_modules",
              ".cache",
              "esbuild",
              `pnpapi-${pkg.replace("/", "-")}-${"0.19.3"}-${path5.basename(subpath)}`
            );
            if (!fs4.existsSync(binTargetPath)) {
              fs4.mkdirSync(path5.dirname(binTargetPath), { recursive: true });
              fs4.copyFileSync(binPath, binTargetPath);
              fs4.chmodSync(binTargetPath, 493);
            }
            return { binPath: binTargetPath, isWASM };
          }
        }
        return { binPath, isWASM };
      }
      var child_process = __require2("child_process");
      var crypto6 = __require2("crypto");
      var path23 = __require2("path");
      var fs22 = __require2("fs");
      var os22 = __require2("os");
      var tty = __require2("tty");
      var worker_threads;
      if (process.env.ESBUILD_WORKER_THREADS !== "0") {
        try {
          worker_threads = __require2("worker_threads");
        } catch {
        }
        let [major, minor] = process.versions.node.split(".");
        if (
          // <v12.17.0 does not work
          +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
        ) {
          worker_threads = void 0;
        }
      }
      var _a;
      var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.19.3";
      var esbuildCommandAndArgs = () => {
        if ((!ESBUILD_BINARY_PATH || false) && (path23.basename(__filename) !== "main.js" || path23.basename(__dirname) !== "lib")) {
          throw new Error(
            `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
          );
        }
        if (false) {
          return ["node", [path23.join(__dirname, "..", "bin", "esbuild")]];
        } else {
          const { binPath, isWASM } = generateBinPath();
          if (isWASM) {
            return ["node", [binPath]];
          } else {
            return [binPath, []];
          }
        }
      };
      var isTTY = () => tty.isatty(2);
      var fsSync = {
        readFile(tempFile, callback) {
          try {
            let contents = fs22.readFileSync(tempFile, "utf8");
            try {
              fs22.unlinkSync(tempFile);
            } catch {
            }
            callback(null, contents);
          } catch (err) {
            callback(err, null);
          }
        },
        writeFile(contents, callback) {
          try {
            let tempFile = randomFileName();
            fs22.writeFileSync(tempFile, contents);
            callback(tempFile);
          } catch {
            callback(null);
          }
        }
      };
      var fsAsync = {
        readFile(tempFile, callback) {
          try {
            fs22.readFile(tempFile, "utf8", (err, contents) => {
              try {
                fs22.unlink(tempFile, () => callback(err, contents));
              } catch {
                callback(err, contents);
              }
            });
          } catch (err) {
            callback(err, null);
          }
        },
        writeFile(contents, callback) {
          try {
            let tempFile = randomFileName();
            fs22.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
          } catch {
            callback(null);
          }
        }
      };
      var version2 = "0.19.3";
      var build3 = (options) => ensureServiceIsRunning().build(options);
      var context2 = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
      var transform = (input, options) => ensureServiceIsRunning().transform(input, options);
      var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
      var analyzeMetafile = (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options);
      var buildSync = (options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.buildSync(options);
        }
        let result;
        runServiceSync((service) => service.buildOrContext({
          callName: "buildSync",
          refs: null,
          options,
          isTTY: isTTY(),
          defaultWD,
          callback: (err, res) => {
            if (err)
              throw err;
            result = res;
          }
        }));
        return result;
      };
      var transformSync = (input, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.transformSync(input, options);
        }
        let result;
        runServiceSync((service) => service.transform({
          callName: "transformSync",
          refs: null,
          input,
          options: options || {},
          isTTY: isTTY(),
          fs: fsSync,
          callback: (err, res) => {
            if (err)
              throw err;
            result = res;
          }
        }));
        return result;
      };
      var formatMessagesSync = (messages, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.formatMessagesSync(messages, options);
        }
        let result;
        runServiceSync((service) => service.formatMessages({
          callName: "formatMessagesSync",
          refs: null,
          messages,
          options,
          callback: (err, res) => {
            if (err)
              throw err;
            result = res;
          }
        }));
        return result;
      };
      var analyzeMetafileSync = (metafile, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.analyzeMetafileSync(metafile, options);
        }
        let result;
        runServiceSync((service) => service.analyzeMetafile({
          callName: "analyzeMetafileSync",
          refs: null,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options,
          callback: (err, res) => {
            if (err)
              throw err;
            result = res;
          }
        }));
        return result;
      };
      var initializeWasCalled = false;
      var initialize = (options) => {
        options = validateInitializeOptions(options || {});
        if (options.wasmURL)
          throw new Error(`The "wasmURL" option only works in the browser`);
        if (options.wasmModule)
          throw new Error(`The "wasmModule" option only works in the browser`);
        if (options.worker)
          throw new Error(`The "worker" option only works in the browser`);
        if (initializeWasCalled)
          throw new Error('Cannot call "initialize" more than once');
        ensureServiceIsRunning();
        initializeWasCalled = true;
        return Promise.resolve();
      };
      var defaultWD = process.cwd();
      var longLivedService;
      var ensureServiceIsRunning = () => {
        if (longLivedService)
          return longLivedService;
        let [command, args] = esbuildCommandAndArgs();
        let child = child_process.spawn(command, args.concat(`--service=${"0.19.3"}`, "--ping"), {
          windowsHide: true,
          stdio: ["pipe", "pipe", "inherit"],
          cwd: defaultWD
        });
        let { readFromStdout, afterClose, service } = createChannel({
          writeToStdin(bytes3) {
            child.stdin.write(bytes3, (err) => {
              if (err)
                afterClose(err);
            });
          },
          readFileSync: fs22.readFileSync,
          isSync: false,
          hasFS: true,
          esbuild: node_exports
        });
        child.stdin.on("error", afterClose);
        child.on("error", afterClose);
        const stdin = child.stdin;
        const stdout = child.stdout;
        stdout.on("data", readFromStdout);
        stdout.on("end", afterClose);
        let refCount = 0;
        child.unref();
        if (stdin.unref) {
          stdin.unref();
        }
        if (stdout.unref) {
          stdout.unref();
        }
        const refs = {
          ref() {
            if (++refCount === 1)
              child.ref();
          },
          unref() {
            if (--refCount === 0)
              child.unref();
          }
        };
        longLivedService = {
          build: (options) => new Promise((resolve4, reject) => {
            service.buildOrContext({
              callName: "build",
              refs,
              options,
              isTTY: isTTY(),
              defaultWD,
              callback: (err, res) => err ? reject(err) : resolve4(res)
            });
          }),
          context: (options) => new Promise((resolve4, reject) => service.buildOrContext({
            callName: "context",
            refs,
            options,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve4(res)
          })),
          transform: (input, options) => new Promise((resolve4, reject) => service.transform({
            callName: "transform",
            refs,
            input,
            options: options || {},
            isTTY: isTTY(),
            fs: fsAsync,
            callback: (err, res) => err ? reject(err) : resolve4(res)
          })),
          formatMessages: (messages, options) => new Promise((resolve4, reject) => service.formatMessages({
            callName: "formatMessages",
            refs,
            messages,
            options,
            callback: (err, res) => err ? reject(err) : resolve4(res)
          })),
          analyzeMetafile: (metafile, options) => new Promise((resolve4, reject) => service.analyzeMetafile({
            callName: "analyzeMetafile",
            refs,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options,
            callback: (err, res) => err ? reject(err) : resolve4(res)
          }))
        };
        return longLivedService;
      };
      var runServiceSync = (callback) => {
        let [command, args] = esbuildCommandAndArgs();
        let stdin = new Uint8Array();
        let { readFromStdout, afterClose, service } = createChannel({
          writeToStdin(bytes3) {
            if (stdin.length !== 0)
              throw new Error("Must run at most one command");
            stdin = bytes3;
          },
          isSync: true,
          hasFS: true,
          esbuild: node_exports
        });
        callback(service);
        let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.19.3"}`), {
          cwd: defaultWD,
          windowsHide: true,
          input: stdin,
          // We don't know how large the output could be. If it's too large, the
          // command will fail with ENOBUFS. Reserve 16mb for now since that feels
          // like it should be enough. Also allow overriding this with an environment
          // variable.
          maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
        });
        readFromStdout(stdout);
        afterClose(null);
      };
      var randomFileName = () => {
        return path23.join(os22.tmpdir(), `esbuild-${crypto6.randomBytes(32).toString("hex")}`);
      };
      var workerThreadService = null;
      var startWorkerThreadService = (worker_threads2) => {
        let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
        let worker = new worker_threads2.Worker(__filename, {
          workerData: { workerPort, defaultWD, esbuildVersion: "0.19.3" },
          transferList: [workerPort],
          // From node's documentation: https://nodejs.org/api/worker_threads.html
          //
          //   Take care when launching worker threads from preload scripts (scripts loaded
          //   and run using the `-r` command line flag). Unless the `execArgv` option is
          //   explicitly set, new Worker threads automatically inherit the command line flags
          //   from the running process and will preload the same preload scripts as the main
          //   thread. If the preload script unconditionally launches a worker thread, every
          //   thread spawned will spawn another until the application crashes.
          //
          execArgv: []
        });
        let nextID = 0;
        let fakeBuildError = (text) => {
          let error2 = new Error(`Build failed with 1 error:
error: ${text}`);
          let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
          error2.errors = errors;
          error2.warnings = [];
          return error2;
        };
        let validateBuildSyncOptions = (options) => {
          if (!options)
            return;
          let plugins = options.plugins;
          if (plugins && plugins.length > 0)
            throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
        };
        let applyProperties = (object2, properties) => {
          for (let key in properties) {
            object2[key] = properties[key];
          }
        };
        let runCallSync = (command, args) => {
          let id = nextID++;
          let sharedBuffer = new SharedArrayBuffer(8);
          let sharedBufferView = new Int32Array(sharedBuffer);
          let msg = { sharedBuffer, id, command, args };
          worker.postMessage(msg);
          let status = Atomics.wait(sharedBufferView, 0, 0);
          if (status !== "ok" && status !== "not-equal")
            throw new Error("Internal error: Atomics.wait() failed: " + status);
          let { message: { id: id2, resolve: resolve4, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
          if (id !== id2)
            throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
          if (reject) {
            applyProperties(reject, properties);
            throw reject;
          }
          return resolve4;
        };
        worker.unref();
        return {
          buildSync(options) {
            validateBuildSyncOptions(options);
            return runCallSync("build", [options]);
          },
          transformSync(input, options) {
            return runCallSync("transform", [input, options]);
          },
          formatMessagesSync(messages, options) {
            return runCallSync("formatMessages", [messages, options]);
          },
          analyzeMetafileSync(metafile, options) {
            return runCallSync("analyzeMetafile", [metafile, options]);
          }
        };
      };
      var startSyncServiceWorker = () => {
        let workerPort = worker_threads.workerData.workerPort;
        let parentPort = worker_threads.parentPort;
        let extractProperties = (object2) => {
          let properties = {};
          if (object2 && typeof object2 === "object") {
            for (let key in object2) {
              properties[key] = object2[key];
            }
          }
          return properties;
        };
        try {
          let service = ensureServiceIsRunning();
          defaultWD = worker_threads.workerData.defaultWD;
          parentPort.on("message", (msg) => {
            (async () => {
              let { sharedBuffer, id, command, args } = msg;
              let sharedBufferView = new Int32Array(sharedBuffer);
              try {
                switch (command) {
                  case "build":
                    workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                    break;
                  case "transform":
                    workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                    break;
                  case "formatMessages":
                    workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                    break;
                  case "analyzeMetafile":
                    workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                    break;
                  default:
                    throw new Error(`Invalid command: ${command}`);
                }
              } catch (reject) {
                workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
              }
              Atomics.add(sharedBufferView, 0, 1);
              Atomics.notify(sharedBufferView, 0, Infinity);
            })();
          });
        } catch (reject) {
          parentPort.on("message", (msg) => {
            let { sharedBuffer, id } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          });
        }
      };
      if (isInternalWorkerThread) {
        startSyncServiceWorker();
      }
      var node_default3 = node_exports;
    }
  });

  // ../../node_modules/.pnpm/joycon@3.1.1/node_modules/joycon/lib/index.js
  var require_lib4 = __commonJS({
    "../../node_modules/.pnpm/joycon@3.1.1/node_modules/joycon/lib/index.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _fs = _interopRequireDefault(__require2("fs"));
      var _path = _interopRequireDefault(__require2("path"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var readFileSync7 = (fp) => {
        return _fs.default.readFileSync(fp, "utf8");
      };
      var pathExists = (fp) => new Promise((resolve4) => {
        _fs.default.access(fp, (err) => {
          resolve4(!err);
        });
      });
      var pathExistsSync = _fs.default.existsSync;
      var JoyCon2 = class {
        constructor({
          files,
          cwd = process.cwd(),
          stopDir,
          packageKey,
          parseJSON = JSON.parse
        } = {}) {
          this.options = {
            files,
            cwd,
            stopDir,
            packageKey,
            parseJSON
          };
          this.existsCache = /* @__PURE__ */ new Map();
          this.loaders = /* @__PURE__ */ new Set();
          this.packageJsonCache = /* @__PURE__ */ new Map();
          this.loadCache = /* @__PURE__ */ new Map();
        }
        addLoader(loader) {
          this.loaders.add(loader);
          return this;
        }
        removeLoader(name) {
          for (const loader of this.loaders) {
            if (name && loader.name === name) {
              this.loaders.delete(loader);
            }
          }
          return this;
        }
        async recusivelyResolve(options) {
          if (options.cwd === options.stopDir || _path.default.basename(options.cwd) === "node_modules") {
            return null;
          }
          for (const filename of options.files) {
            const file = _path.default.resolve(options.cwd, filename);
            const exists3 = process.env.NODE_ENV !== "test" && this.existsCache.has(file) ? this.existsCache.get(file) : await pathExists(file);
            this.existsCache.set(file, exists3);
            if (exists3) {
              if (!options.packageKey || _path.default.basename(file) !== "package.json") {
                return file;
              }
              const data = __require2(file);
              delete __require2.cache[file];
              const hasPackageKey = Object.prototype.hasOwnProperty.call(data, options.packageKey);
              if (hasPackageKey) {
                this.packageJsonCache.set(file, data);
                return file;
              }
            }
            continue;
          }
          return this.recusivelyResolve(Object.assign({}, options, {
            cwd: _path.default.dirname(options.cwd)
          }));
        }
        recusivelyResolveSync(options) {
          if (options.cwd === options.stopDir || _path.default.basename(options.cwd) === "node_modules") {
            return null;
          }
          for (const filename of options.files) {
            const file = _path.default.resolve(options.cwd, filename);
            const exists3 = process.env.NODE_ENV !== "test" && this.existsCache.has(file) ? this.existsCache.get(file) : pathExistsSync(file);
            this.existsCache.set(file, exists3);
            if (exists3) {
              if (!options.packageKey || _path.default.basename(file) !== "package.json") {
                return file;
              }
              const data = __require2(file);
              delete __require2.cache[file];
              const hasPackageKey = Object.prototype.hasOwnProperty.call(data, options.packageKey);
              if (hasPackageKey) {
                this.packageJsonCache.set(file, data);
                return file;
              }
            }
            continue;
          }
          return this.recusivelyResolveSync(Object.assign({}, options, {
            cwd: _path.default.dirname(options.cwd)
          }));
        }
        async resolve(...args) {
          const options = this.normalizeOptions(args);
          return this.recusivelyResolve(options);
        }
        resolveSync(...args) {
          const options = this.normalizeOptions(args);
          return this.recusivelyResolveSync(options);
        }
        runLoaderSync(loader, filepath) {
          return loader.loadSync(filepath);
        }
        runLoader(loader, filepath) {
          if (!loader.load)
            return loader.loadSync(filepath);
          return loader.load(filepath);
        }
        async load(...args) {
          const options = this.normalizeOptions(args);
          const filepath = await this.recusivelyResolve(options);
          if (filepath) {
            const defaultLoader = {
              test: /\.+/,
              loadSync: (filepath2) => {
                const extname = _path.default.extname(filepath2).slice(1);
                if (extname === "js" || extname === "cjs") {
                  delete __require2.cache[filepath2];
                  return __require2(filepath2);
                }
                if (this.packageJsonCache.has(filepath2)) {
                  return this.packageJsonCache.get(filepath2)[options.packageKey];
                }
                const data2 = this.options.parseJSON(readFileSync7(filepath2));
                return data2;
              }
            };
            const loader = this.findLoader(filepath) || defaultLoader;
            let data;
            if (this.loadCache.has(filepath)) {
              data = this.loadCache.get(filepath);
            } else {
              data = await this.runLoader(loader, filepath);
              this.loadCache.set(filepath, data);
            }
            return {
              path: filepath,
              data
            };
          }
          return {};
        }
        loadSync(...args) {
          const options = this.normalizeOptions(args);
          const filepath = this.recusivelyResolveSync(options);
          if (filepath) {
            const defaultLoader = {
              test: /\.+/,
              loadSync: (filepath2) => {
                const extname = _path.default.extname(filepath2).slice(1);
                if (extname === "js" || extname === "cjs") {
                  delete __require2.cache[filepath2];
                  return __require2(filepath2);
                }
                if (this.packageJsonCache.has(filepath2)) {
                  return this.packageJsonCache.get(filepath2)[options.packageKey];
                }
                const data2 = this.options.parseJSON(readFileSync7(filepath2));
                return data2;
              }
            };
            const loader = this.findLoader(filepath) || defaultLoader;
            let data;
            if (this.loadCache.has(filepath)) {
              data = this.loadCache.get(filepath);
            } else {
              data = this.runLoaderSync(loader, filepath);
              this.loadCache.set(filepath, data);
            }
            return {
              path: filepath,
              data
            };
          }
          return {};
        }
        findLoader(filepath) {
          for (const loader of this.loaders) {
            if (loader.test && loader.test.test(filepath)) {
              return loader;
            }
          }
          return null;
        }
        clearCache() {
          this.existsCache.clear();
          this.packageJsonCache.clear();
          this.loadCache.clear();
          return this;
        }
        normalizeOptions(args) {
          const options = Object.assign({}, this.options);
          if (Object.prototype.toString.call(args[0]) === "[object Object]") {
            Object.assign(options, args[0]);
          } else {
            if (args[0]) {
              options.files = args[0];
            }
            if (args[1]) {
              options.cwd = args[1];
            }
            if (args[2]) {
              options.stopDir = args[2];
            }
          }
          options.cwd = _path.default.resolve(options.cwd);
          options.stopDir = options.stopDir ? _path.default.resolve(options.stopDir) : _path.default.parse(options.cwd).root;
          if (!options.files || options.files.length === 0) {
            throw new Error("[joycon] files must be an non-empty array!");
          }
          options.__normalized__ = true;
          return options;
        }
      };
      exports.default = JoyCon2;
      module.exports = JoyCon2;
      module.exports.default = JoyCon2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js
  var require_baseHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js"(exports, module) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseHas(object2, key) {
        return object2 != null && hasOwnProperty.call(object2, key);
      }
      module.exports = baseHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports, module) {
      var isArray = Array.isArray;
      module.exports = isArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
  var require_root = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports, module) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module.exports = Symbol2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
  var require_isObjectLike2 = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike2 = require_isObjectLike2();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js"(exports, module) {
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray(value)) {
          return false;
        }
        var type3 = typeof value;
        if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      module.exports = isKey;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports, module) {
      function isObject2(value) {
        var type3 = typeof value;
        return value != null && (type3 == "object" || type3 == "function");
      }
      module.exports = isObject2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module.exports = isFunction;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports, module) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module.exports = coreJsData;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports, module) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module.exports = isMasked;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports, module) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module.exports = toSource;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports, module) {
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module.exports = baseIsNative;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports, module) {
      function getValue(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      module.exports = getValue;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports, module) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      module.exports = getNative;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports, module) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module.exports = nativeCreate;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module.exports = hashClear;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports, module) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = hashDelete;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module.exports = hashGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module.exports = hashHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module.exports = hashSet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports, module) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash3(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash3.prototype.clear = hashClear;
      Hash3.prototype["delete"] = hashDelete;
      Hash3.prototype.get = hashGet;
      Hash3.prototype.has = hashHas;
      Hash3.prototype.set = hashSet;
      module.exports = Hash3;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports, module) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module.exports = listCacheClear;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports, module) {
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      module.exports = eq2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports, module) {
      var eq2 = require_eq();
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq2(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module.exports = assocIndexOf;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module.exports = listCacheDelete;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module.exports = listCacheGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module.exports = listCacheHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module.exports = listCacheSet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports, module) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module.exports = Map2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports, module) {
      var Hash3 = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash3(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash3()
        };
      }
      module.exports = mapCacheClear;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports, module) {
      function isKeyable(value) {
        var type3 = typeof value;
        return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
      }
      module.exports = isKeyable;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports, module) {
      var isKeyable = require_isKeyable();
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module.exports = getMapData;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = mapCacheDelete;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module.exports = mapCacheGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module.exports = mapCacheHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module.exports = mapCacheSet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports, module) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js"(exports, module) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized.cache;
          if (cache3.has(key)) {
            return cache3.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache3.set(key, result) || cache3;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module.exports = memoize;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js"(exports, module) {
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache3.size === MAX_MEMOIZE_SIZE) {
            cache3.clear();
          }
          return key;
        });
        var cache3 = result.cache;
        return result;
      }
      module.exports = memoizeCapped;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js"(exports, module) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match3, number4, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match3);
        });
        return result;
      });
      module.exports = stringToPath;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js"(exports, module) {
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      module.exports = arrayMap;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = baseToString;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js"(exports, module) {
      var baseToString = require_baseToString();
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      module.exports = toString3;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js"(exports, module) {
      var isArray = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString3 = require_toString();
      function castPath(value, object2) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath(toString3(value));
      }
      module.exports = castPath;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike2 = require_isObjectLike2();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag(value) == argsTag;
      }
      module.exports = baseIsArguments;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports, module) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike2 = require_isObjectLike2();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module.exports = isArguments;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type3 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module.exports = isIndex;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module.exports = isLength;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js"(exports, module) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = toKey;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js"(exports, module) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object2, path5, hasFunc) {
        path5 = castPath(path5, object2);
        var index = -1, length = path5.length, result = false;
        while (++index < length) {
          var key = toKey(path5[index]);
          if (!(result = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
      }
      module.exports = hasPath;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js
  var require_has = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js"(exports, module) {
      var baseHas = require_baseHas();
      var hasPath = require_hasPath();
      function has4(object2, path5) {
        return object2 != null && hasPath(object2, path5, baseHas);
      }
      module.exports = has4;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports, module) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module.exports = defineProperty;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"(exports, module) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      module.exports = baseAssignValue;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js"(exports, module) {
      function createBaseFor(fromRight) {
        return function(object2, iteratee, keysFunc) {
          var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object2;
        };
      }
      module.exports = createBaseFor;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js"(exports, module) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module.exports = baseFor;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports, module) {
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module.exports = baseTimes;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports, module) {
      function stubFalse() {
        return false;
      }
      module.exports = stubFalse;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports, module) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module.exports = isBuffer;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike2 = require_isObjectLike2();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module.exports = baseIsTypedArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports, module) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module.exports = baseUnary;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module.exports = nodeUtil;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports, module) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = arrayLikeKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports, module) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module.exports = isPrototype;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports, module) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module.exports = overArg;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports, module) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module.exports = nativeKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports, module) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports, module) {
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module.exports = isArrayLike;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys4(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      module.exports = keys4;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"(exports, module) {
      var baseFor = require_baseFor();
      var keys4 = require_keys();
      function baseForOwn(object2, iteratee) {
        return object2 && baseFor(object2, iteratee, keys4);
      }
      module.exports = baseForOwn;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports, module) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module.exports = stackClear;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports, module) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module.exports = stackDelete;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports, module) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module.exports = stackGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports, module) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module.exports = stackHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports, module) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module.exports = stackSet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports, module) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack2(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      module.exports = Stack2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js"(exports, module) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module.exports = setCacheAdd;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js"(exports, module) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module.exports = setCacheHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js"(exports, module) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module.exports = SetCache;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js"(exports, module) {
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      module.exports = arraySome;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js"(exports, module) {
      function cacheHas(cache3, key) {
        return cache3.has(key);
      }
      module.exports = cacheHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js"(exports, module) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      module.exports = equalArrays;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports, module) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module.exports = Uint8Array2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js"(exports, module) {
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module.exports = mapToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js"(exports, module) {
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module.exports = setToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq2 = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq2(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert2 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert2 || (convert2 = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result = equalArrays(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module.exports = equalByTag;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports, module) {
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      module.exports = arrayPush;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      module.exports = baseGetAllKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports, module) {
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports, module) {
      function stubArray() {
        return [];
      }
      module.exports = stubArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      module.exports = getSymbols;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys4 = require_keys();
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys4, getSymbols);
      }
      module.exports = getAllKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js"(exports, module) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result;
      }
      module.exports = equalObjects;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView2 = getNative(root, "DataView");
      module.exports = DataView2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module.exports = Promise2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module.exports = Set2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module.exports = WeakMap2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports, module) {
      var DataView2 = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module.exports = getTag;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
      var Stack2 = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      module.exports = baseIsEqualDeep;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js"(exports, module) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike2 = require_isObjectLike2();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module.exports = baseIsEqual;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js"(exports, module) {
      var Stack2 = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object2, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object2 == null) {
          return !length;
        }
        object2 = Object(object2);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object2[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object2)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object2, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module.exports = baseIsMatch;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js"(exports, module) {
      var isObject2 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      module.exports = isStrictComparable;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js"(exports, module) {
      var isStrictComparable = require_isStrictComparable();
      var keys4 = require_keys();
      function getMatchData(object2) {
        var result = keys4(object2), length = result.length;
        while (length--) {
          var key = result[length], value = object2[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module.exports = getMatchData;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
        };
      }
      module.exports = matchesStrictComparable;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js"(exports, module) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      module.exports = baseMatches;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js"(exports, module) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object2, path5) {
        path5 = castPath(path5, object2);
        var index = 0, length = path5.length;
        while (object2 != null && index < length) {
          object2 = object2[toKey(path5[index++])];
        }
        return index && index == length ? object2 : void 0;
      }
      module.exports = baseGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js
  var require_get = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js"(exports, module) {
      var baseGet = require_baseGet();
      function get(object2, path5, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path5);
        return result === void 0 ? defaultValue : result;
      }
      module.exports = get;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js"(exports, module) {
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      module.exports = baseHasIn;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js"(exports, module) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object2, path5) {
        return object2 != null && hasPath(object2, path5, baseHasIn);
      }
      module.exports = hasIn;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
      var baseIsEqual = require_baseIsEqual();
      var get = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path5, srcValue) {
        if (isKey(path5) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path5), srcValue);
        }
        return function(object2) {
          var objValue = get(object2, path5);
          return objValue === void 0 && objValue === srcValue ? hasIn(object2, path5) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module.exports = baseMatchesProperty;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js"(exports, module) {
      function identity2(value) {
        return value;
      }
      module.exports = identity2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js"(exports, module) {
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      module.exports = baseProperty;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js"(exports, module) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path5) {
        return function(object2) {
          return baseGet(object2, path5);
        };
      }
      module.exports = basePropertyDeep;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js
  var require_property = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js"(exports, module) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path5) {
        return isKey(path5) ? baseProperty(toKey(path5)) : basePropertyDeep(path5);
      }
      module.exports = property;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js"(exports, module) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity2 = require_identity();
      var isArray = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module.exports = baseIteratee;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapValues.js
  var require_mapValues = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapValues.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapValues3(object2, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object2, function(value, key, object3) {
          baseAssignValue(result, key, iteratee(value, key, object3));
        });
        return result;
      }
      module.exports = mapValues3;
    }
  });

  // ../../node_modules/.pnpm/property-expr@2.0.5/node_modules/property-expr/index.js
  var require_property_expr = __commonJS({
    "../../node_modules/.pnpm/property-expr@2.0.5/node_modules/property-expr/index.js"(exports, module) {
      "use strict";
      function Cache(maxSize) {
        this._maxSize = maxSize;
        this.clear();
      }
      Cache.prototype.clear = function() {
        this._size = 0;
        this._values = /* @__PURE__ */ Object.create(null);
      };
      Cache.prototype.get = function(key) {
        return this._values[key];
      };
      Cache.prototype.set = function(key, value) {
        this._size >= this._maxSize && this.clear();
        if (!(key in this._values))
          this._size++;
        return this._values[key] = value;
      };
      var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
      var DIGIT_REGEX = /^\d+$/;
      var LEAD_DIGIT_REGEX = /^\d/;
      var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
      var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
      var MAX_CACHE_SIZE = 512;
      var pathCache = new Cache(MAX_CACHE_SIZE);
      var setCache = new Cache(MAX_CACHE_SIZE);
      var getCache = new Cache(MAX_CACHE_SIZE);
      module.exports = {
        Cache,
        split: split4,
        normalizePath,
        setter: function(path5) {
          var parts = normalizePath(path5);
          return setCache.get(path5) || setCache.set(path5, function setter(obj, value) {
            var index = 0;
            var len = parts.length;
            var data = obj;
            while (index < len - 1) {
              var part = parts[index];
              if (part === "__proto__" || part === "constructor" || part === "prototype") {
                return obj;
              }
              data = data[parts[index++]];
            }
            data[parts[index]] = value;
          });
        },
        getter: function(path5, safe) {
          var parts = normalizePath(path5);
          return getCache.get(path5) || getCache.set(path5, function getter3(data) {
            var index = 0, len = parts.length;
            while (index < len) {
              if (data != null || !safe)
                data = data[parts[index++]];
              else
                return;
            }
            return data;
          });
        },
        join: function(segments) {
          return segments.reduce(function(path5, part) {
            return path5 + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path5 ? "." : "") + part);
          }, "");
        },
        forEach: function(path5, cb, thisArg) {
          forEach2(Array.isArray(path5) ? path5 : split4(path5), cb, thisArg);
        }
      };
      function normalizePath(path5) {
        return pathCache.get(path5) || pathCache.set(
          path5,
          split4(path5).map(function(part) {
            return part.replace(CLEAN_QUOTES_REGEX, "$2");
          })
        );
      }
      function split4(path5) {
        return path5.match(SPLIT_REGEX) || [""];
      }
      function forEach2(parts, iter, thisArg) {
        var len = parts.length, part, idx, isArray, isBracket;
        for (idx = 0; idx < len; idx++) {
          part = parts[idx];
          if (part) {
            if (shouldBeQuoted(part)) {
              part = '"' + part + '"';
            }
            isBracket = isQuoted(part);
            isArray = !isBracket && /^\d+$/.test(part);
            iter.call(thisArg, part, isBracket, isArray, idx, parts);
          }
        }
      }
      function isQuoted(str) {
        return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
      }
      function hasLeadingNumber(part) {
        return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
      }
      function hasSpecialChars(part) {
        return SPEC_CHAR_REGEX.test(part);
      }
      function shouldBeQuoted(part) {
        return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
      }
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js"(exports, module) {
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      module.exports = arrayReduce;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyOf.js
  var require_basePropertyOf = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyOf.js"(exports, module) {
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      module.exports = basePropertyOf;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_deburrLetter.js
  var require_deburrLetter = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_deburrLetter.js"(exports, module) {
      var basePropertyOf = require_basePropertyOf();
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var deburrLetter = basePropertyOf(deburredLetters);
      module.exports = deburrLetter;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/deburr.js
  var require_deburr = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/deburr.js"(exports, module) {
      var deburrLetter = require_deburrLetter();
      var toString3 = require_toString();
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsCombo = "[" + rsComboRange + "]";
      var reComboMark = RegExp(rsCombo, "g");
      function deburr(string2) {
        string2 = toString3(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      module.exports = deburr;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiWords.js
  var require_asciiWords = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiWords.js"(exports, module) {
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      module.exports = asciiWords;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicodeWord.js
  var require_hasUnicodeWord = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicodeWord.js"(exports, module) {
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      module.exports = hasUnicodeWord;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeWords.js
  var require_unicodeWords = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeWords.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsDingbatRange = "\\u2700-\\u27bf";
      var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
      var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
      var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
      var rsPunctuationRange = "\\u2000-\\u206f";
      var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
      var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]";
      var rsBreak = "[" + rsBreakRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsDigits = "\\d+";
      var rsDingbat = "[" + rsDingbatRange + "]";
      var rsLower = "[" + rsLowerRange + "]";
      var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsUpper = "[" + rsUpperRange + "]";
      var rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
      var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
      var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
      var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
      var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      module.exports = unicodeWords;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/words.js
  var require_words = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/words.js"(exports, module) {
      var asciiWords = require_asciiWords();
      var hasUnicodeWord = require_hasUnicodeWord();
      var toString3 = require_toString();
      var unicodeWords = require_unicodeWords();
      function words(string2, pattern, guard) {
        string2 = toString3(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      module.exports = words;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCompounder.js
  var require_createCompounder = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCompounder.js"(exports, module) {
      var arrayReduce = require_arrayReduce();
      var deburr = require_deburr();
      var words = require_words();
      var rsApos = "['\u2019]";
      var reApos = RegExp(rsApos, "g");
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      module.exports = createCompounder;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/snakeCase.js
  var require_snakeCase = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/snakeCase.js"(exports, module) {
      var createCompounder = require_createCompounder();
      var snakeCase2 = createCompounder(function(result, word, index) {
        return result + (index ? "_" : "") + word.toLowerCase();
      });
      module.exports = snakeCase2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js
  var require_baseSlice = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js"(exports, module) {
      function baseSlice(array2, start, end) {
        var index = -1, length = array2.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array2[index + start];
        }
        return result;
      }
      module.exports = baseSlice;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js
  var require_castSlice = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js"(exports, module) {
      var baseSlice = require_baseSlice();
      function castSlice(array2, start, end) {
        var length = array2.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array2 : baseSlice(array2, start, end);
      }
      module.exports = castSlice;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      module.exports = hasUnicode;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js
  var require_asciiToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js"(exports, module) {
      function asciiToArray(string2) {
        return string2.split("");
      }
      module.exports = asciiToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js
  var require_unicodeToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      module.exports = unicodeToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js
  var require_stringToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js"(exports, module) {
      var asciiToArray = require_asciiToArray();
      var hasUnicode = require_hasUnicode();
      var unicodeToArray = require_unicodeToArray();
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      module.exports = stringToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js
  var require_createCaseFirst = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js"(exports, module) {
      var castSlice = require_castSlice();
      var hasUnicode = require_hasUnicode();
      var stringToArray = require_stringToArray();
      var toString3 = require_toString();
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString3(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      module.exports = createCaseFirst;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js
  var require_upperFirst = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js"(exports, module) {
      var createCaseFirst = require_createCaseFirst();
      var upperFirst3 = createCaseFirst("toUpperCase");
      module.exports = upperFirst3;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/capitalize.js
  var require_capitalize = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/capitalize.js"(exports, module) {
      var toString3 = require_toString();
      var upperFirst3 = require_upperFirst();
      function capitalize(string2) {
        return upperFirst3(toString3(string2).toLowerCase());
      }
      module.exports = capitalize;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/camelCase.js
  var require_camelCase = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/camelCase.js"(exports, module) {
      var capitalize = require_capitalize();
      var createCompounder = require_createCompounder();
      var camelCase3 = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      module.exports = camelCase3;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapKeys.js
  var require_mapKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapKeys.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapKeys2(object2, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object2, function(value, key, object3) {
          baseAssignValue(result, iteratee(value, key, object3), value);
        });
        return result;
      }
      module.exports = mapKeys2;
    }
  });

  // ../../node_modules/.pnpm/toposort@2.0.2/node_modules/toposort/index.js
  var require_toposort = __commonJS({
    "../../node_modules/.pnpm/toposort@2.0.2/node_modules/toposort/index.js"(exports, module) {
      module.exports = function(edges) {
        return toposort2(uniqueNodes(edges), edges);
      };
      module.exports.array = toposort2;
      function toposort2(nodes, edges) {
        var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
        edges.forEach(function(edge) {
          if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
            throw new Error("Unknown node. There is an unknown node in the supplied edges.");
          }
        });
        while (i--) {
          if (!visited[i])
            visit2(nodes[i], i, /* @__PURE__ */ new Set());
        }
        return sorted;
        function visit2(node, i2, predecessors) {
          if (predecessors.has(node)) {
            var nodeRep;
            try {
              nodeRep = ", node was:" + JSON.stringify(node);
            } catch (e) {
              nodeRep = "";
            }
            throw new Error("Cyclic dependency" + nodeRep);
          }
          if (!nodesHash.has(node)) {
            throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
          }
          if (visited[i2])
            return;
          visited[i2] = true;
          var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
          outgoing = Array.from(outgoing);
          if (i2 = outgoing.length) {
            predecessors.add(node);
            do {
              var child = outgoing[--i2];
              visit2(child, nodesHash.get(child), predecessors);
            } while (i2);
            predecessors.delete(node);
          }
          sorted[--cursor] = node;
        }
      }
      function uniqueNodes(arr) {
        var res = /* @__PURE__ */ new Set();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          res.add(edge[0]);
          res.add(edge[1]);
        }
        return Array.from(res);
      }
      function makeOutgoingEdges(arr) {
        var edges = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          if (!edges.has(edge[0]))
            edges.set(edge[0], /* @__PURE__ */ new Set());
          if (!edges.has(edge[1]))
            edges.set(edge[1], /* @__PURE__ */ new Set());
          edges.get(edge[0]).add(edge[1]);
        }
        return edges;
      }
      function makeNodesHash(arr) {
        var res = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          res.set(arr[i], i);
        }
        return res;
      }
    }
  });

  // src/cli/utils/logger.ts
  var import_chalk = __toESM(require_source());
  var loggingConfig = {
    isDebugEnabled: false,
    isLoggingEnabled: true
  };
  function configureLogging(params) {
    loggingConfig.isLoggingEnabled = params.isLoggingEnabled;
    loggingConfig.isDebugEnabled = params.isDebugEnabled && loggingConfig.isLoggingEnabled;
  }
  function log(...data) {
    if (loggingConfig.isLoggingEnabled) {
      process.stdout.write(`${data.join(" ")}
`);
    }
  }
  function debug(...data) {
    if (loggingConfig.isDebugEnabled) {
      log(data);
    }
  }
  function error(...data) {
    process.stderr.write(`${import_chalk.default.red(data.join(" "))}
`);
  }

  // ../versions/dist/index.mjs
  function getBuiltinVersions() {
    return {
      FORC: "0.49.3",
      FUEL_CORE: "0.22.1",
      FUELS: "0.79.0"
    };
  }
  function parseVersion(version2) {
    const [major, minor, patch] = version2.split(".").map((v) => parseInt(v, 10));
    return { major, minor, patch };
  }
  function versionDiffs(version1, version2) {
    const semver1 = parseVersion(version1);
    const semver2 = parseVersion(version2);
    const major = semver1.major - semver2.major;
    const minor = semver1.minor - semver2.minor;
    const patch = semver1.patch - semver2.patch;
    return {
      major,
      minor,
      patch,
      fullVersionDiff: major || minor || patch
    };
  }
  function majorEq(version1, version2) {
    const { major } = versionDiffs(version1, version2);
    return major === 0;
  }
  function minorEq(version1, version2) {
    const { minor } = versionDiffs(version1, version2);
    return minor === 0;
  }
  function patchEq(version1, version2) {
    const { patch } = versionDiffs(version1, version2);
    return patch === 0;
  }
  function checkFuelCoreVersionCompatibility(networkVersion) {
    const { FUEL_CORE: supportedVersion } = getBuiltinVersions();
    if (/^\d+\.\d+\.\d+\D+/m.test(networkVersion)) {
      console.warn(`You're running against an unreleased fuel-core version: ${networkVersion}. Things may work as expected, but it's not guaranteed. Please use a released version.      
This unreleased fuel-core build may include features and updates not yet supported by this version of the TS-SDK.`);
    }
    return {
      supportedVersion,
      isMajorSupported: majorEq(networkVersion, supportedVersion),
      isMinorSupported: minorEq(networkVersion, supportedVersion),
      isPatchSupported: patchEq(networkVersion, supportedVersion)
    };
  }
  var versions = getBuiltinVersions();

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/esm.mjs
  var import_index = __toESM(require_commander(), 1);
  var {
    program,
    createCommand,
    createArgument,
    createOption,
    CommanderError,
    InvalidArgumentError,
    InvalidOptionArgumentError,
    // deprecated old name
    Command,
    Argument,
    Option,
    Help
  } = import_index.default;

  // ../errors/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
    ErrorCode2["NO_ABIS_FOUND"] = "no-abis-found";
    ErrorCode2["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
    ErrorCode2["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
    ErrorCode2["INVALID_COMPONENT"] = "invalid-component";
    ErrorCode2["FRAGMENT_NOT_FOUND"] = "fragment-not-found";
    ErrorCode2["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
    ErrorCode2["TYPE_NOT_FOUND"] = "type-not-found";
    ErrorCode2["TYPE_NOT_SUPPORTED"] = "type-not-supported";
    ErrorCode2["INVALID_DECODE_VALUE"] = "invalid-decode-value";
    ErrorCode2["JSON_ABI_ERROR"] = "json-abi-error";
    ErrorCode2["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
    ErrorCode2["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
    ErrorCode2["CODER_NOT_FOUND"] = "coder-not-found";
    ErrorCode2["INVALID_DATA"] = "invalid-data";
    ErrorCode2["FUNCTION_NOT_FOUND"] = "function-not-found";
    ErrorCode2["UNSUPPORTED_ENCODING_VERSION"] = "unsupported-encoding-version";
    ErrorCode2["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
    ErrorCode2["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
    ErrorCode2["INVALID_B256_ADDRESS"] = "invalid-b256-address";
    ErrorCode2["INVALID_URL"] = "invalid-url";
    ErrorCode2["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
    ErrorCode2["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
    ErrorCode2["MISSING_PROVIDER"] = "missing-provider";
    ErrorCode2["INVALID_PROVIDER"] = "invalid-provider";
    ErrorCode2["CONNECTION_REFUSED"] = "connection-refused";
    ErrorCode2["INVALID_PUBLIC_KEY"] = "invalid-public-key";
    ErrorCode2["INSUFFICIENT_BALANCE"] = "insufficient-balance";
    ErrorCode2["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
    ErrorCode2["HD_WALLET_ERROR"] = "hd-wallet-error";
    ErrorCode2["MISSING_CONNECTOR"] = "missing-connector";
    ErrorCode2["PARSE_FAILED"] = "parse-failed";
    ErrorCode2["ENCODE_ERROR"] = "encode-error";
    ErrorCode2["DECODE_ERROR"] = "decode-error";
    ErrorCode2["INVALID_CREDENTIALS"] = "invalid-credentials";
    ErrorCode2["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
    ErrorCode2["INVALID_TTL"] = "invalid-ttl";
    ErrorCode2["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
    ErrorCode2["NOT_IMPLEMENTED"] = "not-implemented";
    ErrorCode2["NOT_SUPPORTED"] = "not-supported";
    ErrorCode2["CONVERTING_FAILED"] = "converting-error";
    ErrorCode2["ELEMENT_NOT_FOUND"] = "element-not-found";
    ErrorCode2["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
    ErrorCode2["INVALID_REQUEST"] = "invalid-request";
    ErrorCode2["UNEXPECTED_HEX_VALUE"] = "unexpected-hex-value";
    ErrorCode2["INVALID_TRANSFER_AMOUNT"] = "invalid-transfer-amount";
    ErrorCode2["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
    ErrorCode2["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
    ErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
    ErrorCode2["TRANSACTION_FAILED"] = "transaction-failed";
    ErrorCode2["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
    ErrorCode2["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
    ErrorCode2["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
    ErrorCode2["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
    ErrorCode2["INVALID_TRANSACTION_TYPE"] = "invalid-transaction-type";
    ErrorCode2["TRANSACTION_ERROR"] = "transaction-error";
    ErrorCode2["INVALID_POLICY_TYPE"] = "invalid-policy-type";
    ErrorCode2["DUPLICATED_POLICY"] = "duplicated-policy";
    ErrorCode2["TRANSACTION_SQUEEZED_OUT"] = "transaction-squeezed-out";
    ErrorCode2["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
    ErrorCode2["INVALID_WORD_LIST"] = "invalid-word-list";
    ErrorCode2["INVALID_MNEMONIC"] = "invalid-mnemonic";
    ErrorCode2["INVALID_ENTROPY"] = "invalid-entropy";
    ErrorCode2["INVALID_SEED"] = "invalid-seed";
    ErrorCode2["INVALID_CHECKSUM"] = "invalid-checksum";
    ErrorCode2["INVALID_PASSWORD"] = "invalid-password";
    ErrorCode2["ACCOUNT_REQUIRED"] = "account-required";
    ErrorCode2["UNLOCKED_WALLET_REQUIRED"] = "unlocked-wallet-required";
    ErrorCode2["LATEST_BLOCK_UNAVAILABLE"] = "latest-block-unavailable";
    ErrorCode2["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
    ErrorCode2["UNSUPPORTED_FUEL_CLIENT_VERSION"] = "unsupported-fuel-client-version";
    ErrorCode2["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
    ErrorCode2["INVALID_MULTICALL"] = "invalid-multicall";
    ErrorCode2["SCRIPT_REVERTED"] = "script-reverted";
    ErrorCode2["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
    ErrorCode2["STREAM_PARSING_ERROR"] = "stream-parsing-error";
    return ErrorCode2;
  })(ErrorCode || {});
  var _FuelError = class extends Error {
    VERSIONS = versions;
    static parse(e) {
      const error2 = e;
      if (error2.code === void 0) {
        throw new _FuelError(
          "parse-failed",
          "Failed to parse the error object. The required 'code' property is missing."
        );
      }
      const enumValues = Object.values(ErrorCode);
      const codeIsKnown = enumValues.includes(error2.code);
      if (!codeIsKnown) {
        throw new _FuelError(
          "parse-failed",
          `Unknown error code: ${error2.code}. Accepted codes: ${enumValues.join(", ")}.`
        );
      }
      return new _FuelError(error2.code, error2.message);
    }
    code;
    constructor(code, message) {
      super(message);
      this.code = code;
      this.name = "FuelError";
    }
    toObject() {
      const { code, name, message, VERSIONS } = this;
      return { code, name, message, VERSIONS };
    }
  };
  var FuelError = _FuelError;
  __publicField2(FuelError, "CODES", ErrorCode);

  // ../abi-typegen/dist/cli.mjs
  var import_fs2 = __require2("fs");

  // ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/index.js
  var import_brace_expansion = __toESM(require_brace_expansion(), 1);

  // ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/assert-valid-pattern.js
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };

  // ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/brace-expressions.js
  var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
    "[:alpha:]": ["\\p{L}\\p{Nl}", true],
    "[:ascii:]": ["\\x00-\\x7f", false],
    "[:blank:]": ["\\p{Zs}\\t", true],
    "[:cntrl:]": ["\\p{Cc}", true],
    "[:digit:]": ["\\p{Nd}", true],
    "[:graph:]": ["\\p{Z}\\p{C}", true, true],
    "[:lower:]": ["\\p{Ll}", true],
    "[:print:]": ["\\p{C}", true],
    "[:punct:]": ["\\p{P}", true],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
    "[:upper:]": ["\\p{Lu}", true],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
    "[:xdigit:]": ["A-Fa-f0-9", false]
  };
  var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
  var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var rangesToString = (ranges) => ranges.join("");
  var parseClass = (glob2, position) => {
    const pos = position;
    if (glob2.charAt(pos) !== "[") {
      throw new Error("not in a brace expression");
    }
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = "";
    WHILE:
      while (i < glob2.length) {
        const c = glob2.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob2.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob2.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob2.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob2.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
    if (endPos < i) {
      return ["", false, 0, false];
    }
    if (!ranges.length && !negs.length) {
      return ["$.", false, glob2.length - pos, true];
    }
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
    const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
    return [comb, uflag, endPos - pos, true];
  };

  // ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/unescape.js
  var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  };

  // ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/ast.js
  var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
  var isExtglobType = (c) => types.has(c);
  var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
  var startNoDot = "(?!\\.)";
  var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
  var justDots = /* @__PURE__ */ new Set(["..", "."]);
  var reSpecials = new Set("().*{}+?[]^$\\!");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var qmark = "[^/]";
  var star = qmark + "*?";
  var starNoEmpty = qmark + "+?";
  var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
  var _AST = class {
    constructor(type3, parent, options = {}) {
      __privateAdd(this, _fillNegs);
      __privateAdd(this, _partsToRegExp);
      __publicField(this, "type");
      __privateAdd(this, _root, void 0);
      __privateAdd(this, _hasMagic, void 0);
      __privateAdd(this, _uflag, false);
      __privateAdd(this, _parts, []);
      __privateAdd(this, _parent, void 0);
      __privateAdd(this, _parentIndex, void 0);
      __privateAdd(this, _negs, void 0);
      __privateAdd(this, _filledNegs, false);
      __privateAdd(this, _options, void 0);
      __privateAdd(this, _toString, void 0);
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      __privateAdd(this, _emptyExt, false);
      this.type = type3;
      if (type3)
        __privateSet(this, _hasMagic, true);
      __privateSet(this, _parent, parent);
      __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
      __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
      __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
      if (type3 === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
        __privateGet(this, _negs).push(this);
      __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
    }
    get hasMagic() {
      if (__privateGet(this, _hasMagic) !== void 0)
        return __privateGet(this, _hasMagic);
      for (const p of __privateGet(this, _parts)) {
        if (typeof p === "string")
          continue;
        if (p.type || p.hasMagic)
          return __privateSet(this, _hasMagic, true);
      }
      return __privateGet(this, _hasMagic);
    }
    // reconstructs the pattern
    toString() {
      if (__privateGet(this, _toString) !== void 0)
        return __privateGet(this, _toString);
      if (!this.type) {
        return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
      } else {
        return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
      }
    }
    push(...parts) {
      for (const p of parts) {
        if (p === "")
          continue;
        if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
          throw new Error("invalid part: " + p);
        }
        __privateGet(this, _parts).push(p);
      }
    }
    toJSON() {
      const ret4 = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
      if (this.isStart() && !this.type)
        ret4.unshift([]);
      if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!")) {
        ret4.push({});
      }
      return ret4;
    }
    isStart() {
      if (__privateGet(this, _root) === this)
        return true;
      if (!__privateGet(this, _parent)?.isStart())
        return false;
      if (__privateGet(this, _parentIndex) === 0)
        return true;
      const p = __privateGet(this, _parent);
      for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
        const pp = __privateGet(p, _parts)[i];
        if (!(pp instanceof _AST && pp.type === "!")) {
          return false;
        }
      }
      return true;
    }
    isEnd() {
      if (__privateGet(this, _root) === this)
        return true;
      if (__privateGet(this, _parent)?.type === "!")
        return true;
      if (!__privateGet(this, _parent)?.isEnd())
        return false;
      if (!this.type)
        return __privateGet(this, _parent)?.isEnd();
      const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
      return __privateGet(this, _parentIndex) === pl - 1;
    }
    copyIn(part) {
      if (typeof part === "string")
        this.push(part);
      else
        this.push(part.clone(this));
    }
    clone(parent) {
      const c = new _AST(this.type, parent);
      for (const p of __privateGet(this, _parts)) {
        c.copyIn(p);
      }
      return c;
    }
    static fromGlob(pattern, options = {}) {
      var _a;
      const ast = new _AST(null, void 0, options);
      __privateMethod(_a = _AST, _parseAST, parseAST_fn).call(_a, pattern, ast, 0, options);
      return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
      if (this !== __privateGet(this, _root))
        return __privateGet(this, _root).toMMPattern();
      const glob2 = this.toString();
      const [re, body, hasMagic2, uflag] = this.toRegExpSource();
      const anyMagic = hasMagic2 || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
      if (!anyMagic) {
        return body;
      }
      const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob2
      });
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
      const dot = allowDot ?? !!__privateGet(this, _options).dot;
      if (__privateGet(this, _root) === this)
        __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
      if (!this.type) {
        const noEmpty = this.isStart() && this.isEnd();
        const src = __privateGet(this, _parts).map((p) => {
          var _a;
          const [re, _, hasMagic2, uflag] = typeof p === "string" ? __privateMethod(_a = _AST, _parseGlob, parseGlob_fn).call(_a, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
          __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic2);
          __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
          return re;
        }).join("");
        let start2 = "";
        if (this.isStart()) {
          if (typeof __privateGet(this, _parts)[0] === "string") {
            const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
            if (!dotTravAllowed) {
              const aps = addPatternStart;
              const needNoTrav = (
                // dots are allowed, and the pattern starts with [ or .
                dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                src.startsWith("\\.\\.") && aps.has(src.charAt(4))
              );
              const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
              start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
            }
          }
        }
        let end = "";
        if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!") {
          end = "(?:$|\\/)";
        }
        const final2 = start2 + src + end;
        return [
          final2,
          unescape(src),
          __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
          __privateGet(this, _uflag)
        ];
      }
      const repeated = this.type === "*" || this.type === "+";
      const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
      let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        const s = this.toString();
        __privateSet(this, _parts, [s]);
        this.type = null;
        __privateSet(this, _hasMagic, void 0);
        return [s, unescape(this.toString()), false, false];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
      if (bodyDotAllowed === body) {
        bodyDotAllowed = "";
      }
      if (bodyDotAllowed) {
        body = `(?:${body})(?:${bodyDotAllowed})*?`;
      }
      let final = "";
      if (this.type === "!" && __privateGet(this, _emptyExt)) {
        final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
      } else {
        const close = this.type === "!" ? (
          // !() must match something,but !(x) can match ''
          "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
        ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
        final = start + body + close;
      }
      return [
        final,
        unescape(body),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
  };
  var AST = _AST;
  _root = new WeakMap();
  _hasMagic = new WeakMap();
  _uflag = new WeakMap();
  _parts = new WeakMap();
  _parent = new WeakMap();
  _parentIndex = new WeakMap();
  _negs = new WeakMap();
  _filledNegs = new WeakMap();
  _options = new WeakMap();
  _toString = new WeakMap();
  _emptyExt = new WeakMap();
  _fillNegs = new WeakSet();
  fillNegs_fn = function() {
    if (this !== __privateGet(this, _root))
      throw new Error("should only call on root");
    if (__privateGet(this, _filledNegs))
      return this;
    this.toString();
    __privateSet(this, _filledNegs, true);
    let n;
    while (n = __privateGet(this, _negs).pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = __privateGet(p, _parent);
      while (pp) {
        for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
          for (const part of __privateGet(n, _parts)) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(__privateGet(pp, _parts)[i]);
          }
        }
        p = pp;
        pp = __privateGet(p, _parent);
      }
    }
    return this;
  };
  _parseAST = new WeakSet();
  parseAST_fn = function(str, ast, pos, opt) {
    var _a, _b;
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str.length) {
        const c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = __privateMethod(_a = _AST, _parseAST, parseAST_fn).call(_a, str, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = __privateMethod(_b = _AST, _parseAST, parseAST_fn).call(_b, str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && __privateGet(ast, _parts).length === 0) {
          __privateSet(ast, _emptyExt, true);
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    __privateSet(ast, _hasMagic, void 0);
    __privateSet(ast, _parts, [str.substring(pos - 1)]);
    return i;
  };
  _partsToRegExp = new WeakSet();
  partsToRegExp_fn = function(dot) {
    return __privateGet(this, _parts).map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
      __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  };
  _parseGlob = new WeakSet();
  parseGlob_fn = function(glob2, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob2.length; i++) {
      const c = glob2.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob2.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob2 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob2), !!hasMagic2, uflag];
  };
  __privateAdd(AST, _parseAST);
  __privateAdd(AST, _parseGlob);

  // ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/escape.js
  var escape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
  };

  // ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/index.js
  var minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
  var starDotExtTest = (ext2) => (f2) => !f2.startsWith(".") && f2.endsWith(ext2);
  var starDotExtTestDot = (ext2) => (f2) => f2.endsWith(ext2);
  var starDotExtTestNocase = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f2) => !f2.startsWith(".") && f2.toLowerCase().endsWith(ext2);
  };
  var starDotExtTestNocaseDot = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f2) => f2.toLowerCase().endsWith(ext2);
  };
  var starDotStarRE = /^\*+\.\*+$/;
  var starDotStarTest = (f2) => !f2.startsWith(".") && f2.includes(".");
  var starDotStarTestDot = (f2) => f2 !== "." && f2 !== ".." && f2.includes(".");
  var dotStarRE = /^\.\*+$/;
  var dotStarTest = (f2) => f2 !== "." && f2 !== ".." && f2.startsWith(".");
  var starRE = /^\*+$/;
  var starTest = (f2) => f2.length !== 0 && !f2.startsWith(".");
  var starTestDot = (f2) => f2.length !== 0 && f2 !== "." && f2 !== "..";
  var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
  var qmarksTestNocase = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
  };
  var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
  };
  var qmarksTestDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
  };
  var qmarksTest = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
  };
  var qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f2) => f2.length === len && !f2.startsWith(".");
  };
  var qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f2) => f2.length === len && f2 !== "." && f2 !== "..";
  };
  var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
  var path = {
    win32: { sep: "\\" },
    posix: { sep: "/" }
  };
  var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
  minimatch.sep = sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var qmark2 = "[^/]";
  var star2 = qmark2 + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
  minimatch.filter = filter;
  var ext = (a, b = {}) => Object.assign({}, a, b);
  var defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
      Minimatch: class Minimatch extends orig.Minimatch {
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class AST extends orig.AST {
        /* c8 ignore start */
        constructor(type3, parent, options = {}) {
          super(type3, parent, ext(def, options));
        }
        /* c8 ignore stop */
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: (options) => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR
    });
  };
  minimatch.defaults = defaults;
  var braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return (0, import_brace_expansion.default)(pattern);
  };
  minimatch.braceExpand = braceExpand;
  var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
  minimatch.makeRe = makeRe;
  var match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f2) => mm.match(f2));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  minimatch.match = match;
  var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
  var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var Minimatch = class {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      assertValidPattern(pattern);
      options = options || {};
      this.options = options;
      this.pattern = pattern;
      this.platform = options.platform || defaultPlatform;
      this.isWindows = this.platform === "win32";
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
      this.regexp = null;
      this.negate = false;
      this.nonegate = !!options.nonegate;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.nocase = !!this.options.nocase;
      this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
      this.globSet = [];
      this.globParts = [];
      this.set = [];
      this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) {
        return true;
      }
      for (const pattern of this.set) {
        for (const part of pattern) {
          if (typeof part !== "string")
            return true;
        }
      }
      return false;
    }
    debug(..._) {
    }
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      this.globSet = [...new Set(this.braceExpand())];
      if (options.debug) {
        this.debug = (...args) => console.error(...args);
      }
      this.debug(this.pattern, this.globSet);
      const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts);
      this.debug(this.pattern, this.globParts);
      let set2 = this.globParts.map((s, _, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
          const isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) {
            return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
          } else if (isDrive) {
            return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
          }
        }
        return s.map((ss) => this.parse(ss));
      });
      this.debug(this.pattern, set2);
      this.set = set2.filter((s) => s.indexOf(false) === -1);
      if (this.isWindows) {
        for (let i = 0; i < this.set.length; i++) {
          const p = this.set[i];
          if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
            p[2] = "?";
          }
        }
      }
      this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
      if (this.options.noglobstar) {
        for (let i = 0; i < globParts.length; i++) {
          for (let j = 0; j < globParts[i].length; j++) {
            if (globParts[i][j] === "**") {
              globParts[i][j] = "*";
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        globParts = this.firstPhasePreProcess(globParts);
        globParts = this.secondPhasePreProcess(globParts);
      } else if (optimizationLevel >= 1) {
        globParts = this.levelOneOptimize(globParts);
      } else {
        globParts = this.adjascentGlobstarOptimize(globParts);
      }
      return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
      return globParts.map((parts) => {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let i = gs;
          while (parts[i + 1] === "**") {
            i++;
          }
          if (i !== gs) {
            parts.splice(gs, i - gs);
          }
        }
        return parts;
      });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
      return globParts.map((parts) => {
        parts = parts.reduce((set2, part) => {
          const prev = set2[set2.length - 1];
          if (part === "**" && prev === "**") {
            return set2;
          }
          if (part === "..") {
            if (prev && prev !== ".." && prev !== "." && prev !== "**") {
              set2.pop();
              return set2;
            }
          }
          set2.push(part);
          return set2;
        }, []);
        return parts.length === 0 ? [""] : parts;
      });
    }
    levelTwoFileOptimize(parts) {
      if (!Array.isArray(parts)) {
        parts = this.slashSplit(parts);
      }
      let didSomething = false;
      do {
        didSomething = false;
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            parts.splice(dd - 1, 2);
            dd -= 2;
          }
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
      let didSomething = false;
      do {
        didSomething = false;
        for (let parts of globParts) {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let gss = gs;
            while (parts[gss + 1] === "**") {
              gss++;
            }
            if (gss > gs) {
              parts.splice(gs + 1, gss - gs);
            }
            let next = parts[gs + 1];
            const p = parts[gs + 2];
            const p2 = parts[gs + 3];
            if (next !== "..")
              continue;
            if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
              continue;
            }
            didSomething = true;
            parts.splice(gs, 1);
            const other = parts.slice(0);
            other[gs] = "**";
            globParts.push(other);
            gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              const needDot = dd === 1 && parts[dd + 1] === "**";
              const splin = needDot ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin);
              if (parts.length === 0)
                parts.push("");
              dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
      for (let i = 0; i < globParts.length - 1; i++) {
        for (let j = i + 1; j < globParts.length; j++) {
          const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
          if (!matched)
            continue;
          globParts[i] = matched;
          globParts[j] = [];
        }
      }
      return globParts.filter((gs) => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
      let ai = 0;
      let bi = 0;
      let result = [];
      let which = "";
      while (ai < a.length && bi < b.length) {
        if (a[ai] === b[bi]) {
          result.push(which === "b" ? b[bi] : a[ai]);
          ai++;
          bi++;
        } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
          result.push(a[ai]);
          ai++;
        } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
          result.push(b[bi]);
          bi++;
        } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
          if (which === "b")
            return false;
          which = "a";
          result.push(a[ai]);
          ai++;
          bi++;
        } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
          if (which === "a")
            return false;
          which = "b";
          result.push(b[bi]);
          ai++;
          bi++;
        } else {
          return false;
        }
      }
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
      const options = this.options;
      if (this.isWindows) {
        const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
        const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
        const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
        const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
        const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
        const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
        if (typeof fdi === "number" && typeof pdi === "number") {
          const [fd, pd] = [file[fdi], pattern[pdi]];
          if (fd.toLowerCase() === pd.toLowerCase()) {
            pattern[pdi] = fd;
            if (pdi > fdi) {
              pattern = pattern.slice(pdi);
            } else if (fdi > pdi) {
              file = file.slice(fdi);
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        file = this.levelTwoFileOptimize(file);
      }
      this.debug("matchOne", this, { file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f2 = file[fi];
        this.debug(pattern, p, f2);
        if (p === false) {
          return false;
        }
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f2]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl) {
              return true;
            }
          }
          return false;
        }
        let hit;
        if (typeof p === "string") {
          hit = f2 === p;
          this.debug("string match", p, f2, hit);
        } else {
          hit = p.test(f2);
          this.debug("pattern match", p, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      } else {
        throw new Error("wtf?");
      }
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      let m;
      let fastTest = null;
      if (m = pattern.match(starRE)) {
        fastTest = options.dot ? starTestDot : starTest;
      } else if (m = pattern.match(starDotExtRE)) {
        fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
      } else if (m = pattern.match(qmarksRE)) {
        fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
      } else if (m = pattern.match(starDotStarRE)) {
        fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
      } else if (m = pattern.match(dotStarRE)) {
        fastTest = dotStarTest;
      }
      const re = AST.fromGlob(pattern, this.options).toMMPattern();
      return fastTest ? Object.assign(re, { test: fastTest }) : re;
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set2 = this.set;
      if (!set2.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
      const flags = new Set(options.nocase ? ["i"] : []);
      let re = set2.map((pattern) => {
        const pp = pattern.map((p) => {
          if (p instanceof RegExp) {
            for (const f2 of p.flags.split(""))
              flags.add(f2);
          }
          return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
        });
        pp.forEach((p, i) => {
          const next = pp[i + 1];
          const prev = pp[i - 1];
          if (p !== GLOBSTAR || prev === GLOBSTAR) {
            return;
          }
          if (prev === void 0) {
            if (next !== void 0 && next !== GLOBSTAR) {
              pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
            } else {
              pp[i] = twoStar;
            }
          } else if (next === void 0) {
            pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
          } else if (next !== GLOBSTAR) {
            pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
            pp[i + 1] = GLOBSTAR;
          }
        });
        return pp.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      const [open, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$";
      if (this.negate)
        re = "^(?!" + re + ").+$";
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    slashSplit(p) {
      if (this.preserveMultipleSlashes) {
        return p.split("/");
      } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
        return ["", ...p.split(/\/+/)];
      } else {
        return p.split(/\/+/);
      }
    }
    match(f2, partial = this.partial) {
      this.debug("match", f2, this.pattern);
      if (this.comment) {
        return false;
      }
      if (this.empty) {
        return f2 === "";
      }
      if (f2 === "/" && partial) {
        return true;
      }
      const options = this.options;
      if (this.isWindows) {
        f2 = f2.split("\\").join("/");
      }
      const ff = this.slashSplit(f2);
      this.debug(this.pattern, "split", ff);
      const set2 = this.set;
      this.debug(this.pattern, "set", set2);
      let filename = ff[ff.length - 1];
      if (!filename) {
        for (let i = ff.length - 2; !filename && i >= 0; i--) {
          filename = ff[i];
        }
      }
      for (let i = 0; i < set2.length; i++) {
        const pattern = set2[i];
        let file = ff;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) {
            return true;
          }
          return !this.negate;
        }
      }
      if (options.flipNegate) {
        return false;
      }
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  };
  minimatch.AST = AST;
  minimatch.Minimatch = Minimatch;
  minimatch.escape = escape;
  minimatch.unescape = unescape;

  // ../../node_modules/.pnpm/lru-cache@10.0.0/node_modules/lru-cache/dist/mjs/index.js
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var warned = /* @__PURE__ */ new Set();
  var PROCESS = typeof process === "object" && !!process ? process : {};
  var emitWarning = (msg, type3, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type3, code, fn) : console.error(`[${code}] ${type3}: ${msg}`);
  };
  var AC = globalThis.AbortController;
  var AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(_, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS();
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  var shouldWarn = (code) => !warned.has(code);
  var TYPE = Symbol("type");
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
  var ZeroArray = class extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  };
  var _constructing;
  var _Stack = class {
    heap;
    length;
    static create(max2) {
      const HeapCls = getUintArray(max2);
      if (!HeapCls)
        return [];
      __privateSet(_Stack, _constructing, true);
      const s = new _Stack(max2, HeapCls);
      __privateSet(_Stack, _constructing, false);
      return s;
    }
    constructor(max2, HeapCls) {
      if (!__privateGet(_Stack, _constructing)) {
        throw new TypeError("instantiate Stack using Stack.create(n)");
      }
      this.heap = new HeapCls(max2);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  var Stack = _Stack;
  _constructing = new WeakMap();
  // private constructor
  __privateAdd(Stack, _constructing, false);
  var LRUCache = class {
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
      return {
        // properties
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        // methods
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context2) => c.#backgroundFetch(k, index, options, context2),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options) => c.#indexes(options),
        rindexes: (options) => c.#rindexes(options),
        isStale: (index) => c.#isStale(index)
      };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
      return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
      return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
      return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
      return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
      return this.#fetchMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
      return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options) {
      const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
      if (max2 !== 0 && !isPosInt(max2)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max2 ? getUintArray(max2) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max2);
      }
      this.#max = max2;
      this.#maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.#maxSize;
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.#fetchMethod = fetchMethod;
      this.#hasFetchMethod = !!fetchMethod;
      this.#keyMap = /* @__PURE__ */ new Map();
      this.#keyList = new Array(max2).fill(void 0);
      this.#valList = new Array(max2).fill(void 0);
      this.#next = new UintArray(max2);
      this.#prev = new UintArray(max2);
      this.#head = 0;
      this.#tail = 0;
      this.#free = Stack.create(max2);
      this.#size = 0;
      this.#calculatedSize = 0;
      if (typeof dispose === "function") {
        this.#dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.#disposeAfter = disposeAfter;
        this.#disposed = [];
      } else {
        this.#disposeAfter = void 0;
        this.#disposed = void 0;
      }
      this.#hasDispose = !!this.#dispose;
      this.#hasDisposeAfter = !!this.#disposeAfter;
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.#initializeSizeTracking();
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
    }
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max);
      const starts = new ZeroArray(this.#max);
      this.#ttls = ttls;
      this.#starts = starts;
      this.#setItemTTL = (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.delete(this.#keyList[index]);
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      };
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.#keyMap.get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (ttl === 0 || start === 0) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      this.#isStale = (index) => {
        return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
      };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => {
    };
    #statusTTL = () => {
    };
    #setItemTTL = () => {
    };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0;
      this.#sizes = sizes;
      this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index];
        sizes[index] = 0;
      };
      this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      };
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size;
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize) {
            this.#evict(true);
          }
        }
        this.#calculatedSize += sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.#calculatedSize;
        }
      };
    }
    #removeItemSize = (_i) => {
    };
    #addItemSize = (_i, _s, _st) => {
    };
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail; true; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#head) {
            break;
          } else {
            i = this.#prev[i];
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head; true; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#tail) {
            break;
          } else {
            i = this.#next[i];
          }
        }
      }
    }
    #isValidIndex(index) {
      return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
      for (const i of this.#indexes()) {
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
      for (const i of this.#rindexes()) {
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
      return this.entries();
    }
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions);
        }
      }
    }
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
      let deleted = false;
      for (const i of this.#rindexes({ allowStale: true })) {
        if (this.#isStale(i)) {
          this.delete(this.#keyList[i]);
          deleted = true;
        }
      }
      return deleted;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump() {
      const arr = [];
      for (const i of this.#indexes({ allowStale: true })) {
        const key = this.#keyList[i];
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0 || key === void 0)
          continue;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          const age = perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k, v, setOptions = {}) {
      if (v === void 0) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.delete(k);
        return this;
      }
      let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
      if (index === void 0) {
        index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
        this.#keyList[index] = k;
        this.#valList[index] = v;
        this.#keyMap.set(k, index);
        this.#next[this.#tail] = index;
        this.#prev[index] = this.#tail;
        this.#tail = index;
        this.#size++;
        this.#addItemSize(index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
      } else {
        this.#moveToTail(index);
        const oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, "set"]);
            }
          }
          this.#removeItemSize(index);
          this.#addItemSize(index, size, status);
          this.#valList[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== void 0)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking();
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start);
        }
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head];
          this.#evict(true);
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== void 0) {
            return val;
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head;
      const k = this.#keyList[head];
      const v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "evict");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "evict"]);
        }
      }
      this.#removeItemSize(head);
      if (free) {
        this.#keyList[head] = void 0;
        this.#valList[head] = void 0;
        this.#free.push(head);
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0;
        this.#free.length = 0;
      } else {
        this.#head = this.#next[head];
      }
      this.#keyMap.delete(k);
      this.#size--;
      return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
          return false;
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index);
          }
          if (status) {
            status.has = "hit";
            this.#statusTTL(status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          this.#statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0 && (allowStale || !this.#isStale(index))) {
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
    }
    #backgroundFetch(k, index, options, context2) {
      const v = index === void 0 ? void 0 : this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context: context2
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (this.#valList[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              this.#valList[index] = bf2.__staleWhileFetching;
            } else {
              this.delete(k);
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (this.#valList[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            this.delete(k);
          } else if (!allowStaleAborted) {
            this.#valList[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = this.#keyMap.get(k);
      } else {
        this.#valList[index] = bf;
      }
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context: context2,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.#keyMap.get(k);
      if (index === void 0) {
        if (status)
          status.fetch = "miss";
        const p = this.#backgroundFetch(k, index, options, context2);
        return p.__returned = p;
      } else {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== void 0;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        const p = this.#backgroundFetch(k, index, options, context2);
        const hasStale = p.__staleWhileFetching !== void 0;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        const value = this.#valList[index];
        const fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.delete(k);
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : void 0;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== void 0) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : void 0;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    #connect(p, n) {
      this.#prev[n] = p;
      this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index];
        } else {
          this.#connect(this.#prev[index], this.#next[index]);
        }
        this.#connect(this.#tail, index);
        this.#tail = index;
      }
    }
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
      let deleted = false;
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          deleted = true;
          if (this.#size === 1) {
            this.clear();
          } else {
            this.#removeItemSize(index);
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, "delete");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, "delete"]);
              }
            }
            this.#keyMap.delete(k);
            this.#keyList[index] = void 0;
            this.#valList[index] = void 0;
            if (index === this.#tail) {
              this.#tail = this.#prev[index];
            } else if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              this.#next[this.#prev[index]] = this.#next[index];
              this.#prev[this.#next[index]] = this.#prev[index];
            }
            this.#size--;
            this.#free.push(index);
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
      for (const index of this.#rindexes({ allowStale: true })) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.#keyList[index];
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "delete");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "delete"]);
          }
        }
      }
      this.#keyMap.clear();
      this.#valList.fill(void 0);
      this.#keyList.fill(void 0);
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0);
        this.#starts.fill(0);
      }
      if (this.#sizes) {
        this.#sizes.fill(0);
      }
      this.#head = 0;
      this.#tail = 0;
      this.#free.length = 0;
      this.#calculatedSize = 0;
      this.#size = 0;
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  };

  // ../../node_modules/.pnpm/path-scurry@1.10.0/node_modules/path-scurry/dist/mjs/index.js
  var import_path = __require2("path");
  var import_url = __require2("url");
  var actualFS = __toESM(__require2("fs"), 1);
  var import_fs = __require2("fs");
  var import_promises = __require2("fs/promises");

  // ../../node_modules/.pnpm/minipass@6.0.2/node_modules/minipass/index.mjs
  var import_events = __toESM(__require2("events"), 1);
  var import_stream = __toESM(__require2("stream"), 1);
  var import_string_decoder = __toESM(__require2("string_decoder"), 1);
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var SD = import_string_decoder.default.StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFER = Symbol("buffer");
  var PIPES = Symbol("pipes");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var ERROR = Symbol("error");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var ABORT = Symbol("abort");
  var ABORTED = Symbol("aborted");
  var SIGNAL = Symbol("signal");
  var defer = (fn) => Promise.resolve().then(fn);
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  var Pipe = class {
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {
    }
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  };
  var PipeProxyErrors = class extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  };
  var Minipass = class extends import_stream.default {
    constructor(options) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this[PIPES] = [];
      this[BUFFER] = [];
      this[OBJECTMODE] = options && options.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options && options.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[ASYNC] = options && !!options.async || false;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this[EMITTED_ERROR] = null;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      this[SIGNAL] = options && options.signal;
      this[ABORTED] = false;
      if (this[SIGNAL]) {
        this[SIGNAL].addEventListener("abort", () => this[ABORT]());
        if (this[SIGNAL].aborted) {
          this[ABORT]();
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this[BUFFER].length)
          this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL].reason);
      this.destroy(this[SIGNAL].reason);
    }
    get aborted() {
      return this[ABORTED];
    }
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit(
          "error",
          Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          )
        );
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : (f2) => f2();
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (this[OBJECTMODE]) {
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (typeof chunk === "string" && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this.flowing)
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this[BUFFER] = [this[BUFFER].join("")];
        else
          this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
      }
      const ret4 = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret4;
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this[BUFFER][0] = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain) {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this.flowing;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(
          !opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts)
        );
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret4 = super.on(ev, fn);
      if (ev === "data" && !this[PIPES].length && !this.flowing)
        this[RESUME]();
      else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
        super.emit("readable");
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        if (this[ASYNC])
          defer(() => fn.call(this, this[EMITTED_ERROR]));
        else
          fn.call(this, this[EMITTED_ERROR]);
      }
      return ret4;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
        const ret5 = super.emit("close");
        this.removeAllListeners("close");
        return ret5;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret5 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret5;
      } else if (ev === "resume") {
        const ret5 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret5;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret5 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret5;
      }
      const ret4 = super.emit(ev, data, ...extra);
      this[MAYBE_EMIT_END]();
      return ret4;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret4 = super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret4;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return;
      this[EMITTED_END] = true;
      this.readable = false;
      if (this[ASYNC])
        defer(() => this[EMITEND2]());
      else
        this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret4 = super.emit("end");
      this.removeAllListeners("end");
      return ret4;
    }
    // const all = await stream.collect()
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    // const data = await stream.concat()
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
        (buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
      );
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
      return new Promise((resolve4, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve4());
      });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
      let stopped = false;
      const stop = () => {
        this.pause();
        stopped = true;
        return Promise.resolve({ done: true });
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve4 = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          this.removeListener(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.removeListener(DESTROYED, ondestroy);
          this.pause();
          resolve4({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          this.removeListener(DESTROYED, ondestroy);
          stop();
          resolve4({ done: true });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve4 = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [ASYNCITERATOR]() {
          return this;
        }
      };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
      let stopped = false;
      const stop = () => {
        this.pause();
        this.removeListener(ERROR, stop);
        this.removeListener(DESTROYED, stop);
        this.removeListener("end", stop);
        stopped = true;
        return { done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [ITERATOR]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof import_stream.default || s instanceof import_events.default && // readable
      (typeof s.pipe === "function" || // writable
      typeof s.write === "function" && typeof s.end === "function"));
    }
  };

  // ../../node_modules/.pnpm/path-scurry@1.10.0/node_modules/path-scurry/dist/mjs/index.js
  var realpathSync = import_fs.realpathSync.native;
  var defaultFS = {
    lstatSync: import_fs.lstatSync,
    readdir: import_fs.readdir,
    readdirSync: import_fs.readdirSync,
    readlinkSync: import_fs.readlinkSync,
    realpathSync,
    promises: {
      lstat: import_promises.lstat,
      readdir: import_promises.readdir,
      readlink: import_promises.readlink,
      realpath: import_promises.realpath
    }
  };
  var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
    ...defaultFS,
    ...fsOption,
    promises: {
      ...defaultFS.promises,
      ...fsOption.promises || {}
    }
  };
  var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
  var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
  var eitherSep = /[\\\/]/;
  var UNKNOWN = 0;
  var IFIFO = 1;
  var IFCHR = 2;
  var IFDIR = 4;
  var IFBLK = 6;
  var IFREG = 8;
  var IFLNK = 10;
  var IFSOCK = 12;
  var IFMT = 15;
  var IFMT_UNKNOWN = ~IFMT;
  var READDIR_CALLED = 16;
  var LSTAT_CALLED = 32;
  var ENOTDIR = 64;
  var ENOENT = 128;
  var ENOREADLINK = 256;
  var ENOREALPATH = 512;
  var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
  var TYPEMASK = 1023;
  var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
  var normalizeCache = /* @__PURE__ */ new Map();
  var normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
      return c;
    const n = s.normalize("NFKD");
    normalizeCache.set(s, n);
    return n;
  };
  var normalizeNocaseCache = /* @__PURE__ */ new Map();
  var normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
      return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
  };
  var ResolveCache = class extends LRUCache {
    constructor() {
      super({ max: 256 });
    }
  };
  var ChildrenCache = class extends LRUCache {
    constructor(maxSize = 16 * 1024) {
      super({
        maxSize,
        // parent + children
        sizeCalculation: (a) => a.length + 1
      });
    }
  };
  var setAsCwd = Symbol("PathScurry setAsCwd");
  var PathBase = class {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
      return this.#dev;
    }
    #mode;
    get mode() {
      return this.#mode;
    }
    #nlink;
    get nlink() {
      return this.#nlink;
    }
    #uid;
    get uid() {
      return this.#uid;
    }
    #gid;
    get gid() {
      return this.#gid;
    }
    #rdev;
    get rdev() {
      return this.#rdev;
    }
    #blksize;
    get blksize() {
      return this.#blksize;
    }
    #ino;
    get ino() {
      return this.#ino;
    }
    #size;
    get size() {
      return this.#size;
    }
    #blocks;
    get blocks() {
      return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
      return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
      return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
      return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
      return this.#birthtimeMs;
    }
    #atime;
    get atime() {
      return this.#atime;
    }
    #mtime;
    get mtime() {
      return this.#mtime;
    }
    #ctime;
    get ctime() {
      return this.#ctime;
    }
    #birthtime;
    get birthtime() {
      return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path() {
      return (this.parent || this).fullpath();
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      this.name = name;
      this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
      this.#type = type3 & TYPEMASK;
      this.nocase = nocase;
      this.roots = roots;
      this.root = root || this;
      this.#children = children;
      this.#fullpath = opts.fullpath;
      this.#relative = opts.relative;
      this.#relativePosix = opts.relativePosix;
      this.parent = opts.parent;
      if (this.parent) {
        this.#fs = this.parent.#fs;
      } else {
        this.#fs = fsFromOption(opts.fs);
      }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
      if (this.#depth !== void 0)
        return this.#depth;
      if (!this.parent)
        return this.#depth = 0;
      return this.#depth = this.parent.depth() + 1;
    }
    /**
     * @internal
     */
    childrenCache() {
      return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path5) {
      if (!path5) {
        return this;
      }
      const rootPath = this.getRootString(path5);
      const dir = path5.substring(rootPath.length);
      const dirParts = dir.split(this.splitSep);
      const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
      return result;
    }
    #resolveParts(dirParts) {
      let p = this;
      for (const part of dirParts) {
        p = p.child(part);
      }
      return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
      const cached = this.#children.get(this);
      if (cached) {
        return cached;
      }
      const children = Object.assign([], { provisional: 0 });
      this.#children.set(this, children);
      this.#type &= ~READDIR_CALLED;
      return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
      if (pathPart === "" || pathPart === ".") {
        return this;
      }
      if (pathPart === "..") {
        return this.parent || this;
      }
      const children = this.children();
      const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
      for (const p of children) {
        if (p.#matchName === name) {
          return p;
        }
      }
      const s = this.parent ? this.sep : "";
      const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
      const pchild = this.newChild(pathPart, UNKNOWN, {
        ...opts,
        parent: this,
        fullpath
      });
      if (!this.canReaddir()) {
        pchild.#type |= ENOENT;
      }
      children.push(pchild);
      return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
      if (this.#relative !== void 0) {
        return this.#relative;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relative = this.name;
      }
      const pv = p.relative();
      return pv + (!pv || !p.parent ? "" : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
      if (this.sep === "/")
        return this.relative();
      if (this.#relativePosix !== void 0)
        return this.#relativePosix;
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relativePosix = this.fullpathPosix();
      }
      const pv = p.relativePosix();
      return pv + (!pv || !p.parent ? "" : "/") + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
      if (this.#fullpath !== void 0) {
        return this.#fullpath;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#fullpath = this.name;
      }
      const pv = p.fullpath();
      const fp = pv + (!p.parent ? "" : this.sep) + name;
      return this.#fullpath = fp;
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
      if (this.#fullpathPosix !== void 0)
        return this.#fullpathPosix;
      if (this.sep === "/")
        return this.#fullpathPosix = this.fullpath();
      if (!this.parent) {
        const p2 = this.fullpath().replace(/\\/g, "/");
        if (/^[a-z]:\//i.test(p2)) {
          return this.#fullpathPosix = `//?/${p2}`;
        } else {
          return this.#fullpathPosix = p2;
        }
      }
      const p = this.parent;
      const pfpp = p.fullpathPosix();
      const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
      return this.#fullpathPosix = fpp;
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
      return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type3) {
      return this[`is${type3}`]();
    }
    getType() {
      return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
        /* c8 ignore start */
        this.isSocket() ? "Socket" : "Unknown"
      );
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
      return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
      return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
      return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
      return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
      return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
      return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
      return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
      return this.#type & LSTAT_CALLED ? this : void 0;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
      return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
      return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
      const children = this.children();
      return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
      if (this.#linkTarget)
        return true;
      if (!this.parent)
        return false;
      const ifmt = this.#type & IFMT;
      return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
      return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
      return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
      return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return void 0;
      }
      if (!this.parent) {
        return void 0;
      }
      try {
        const read = await this.#fs.promises.readlink(this.fullpath());
        const linkTarget = this.parent.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return void 0;
      }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return void 0;
      }
      if (!this.parent) {
        return void 0;
      }
      try {
        const read = this.#fs.readlinkSync(this.fullpath());
        const linkTarget = this.parent.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return void 0;
      }
    }
    #readdirSuccess(children) {
      this.#type |= READDIR_CALLED;
      for (let p = children.provisional; p < children.length; p++) {
        children[p].#markENOENT();
      }
    }
    #markENOENT() {
      if (this.#type & ENOENT)
        return;
      this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
      this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
      const children = this.children();
      children.provisional = 0;
      for (const p of children) {
        p.#markENOENT();
      }
    }
    #markENOREALPATH() {
      this.#type |= ENOREALPATH;
      this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
      if (this.#type & ENOTDIR)
        return;
      let t = this.#type;
      if ((t & IFMT) === IFDIR)
        t &= IFMT_UNKNOWN;
      this.#type = t | ENOTDIR;
      this.#markChildrenENOENT();
    }
    #readdirFail(code = "") {
      if (code === "ENOTDIR" || code === "EPERM") {
        this.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      } else {
        this.children().provisional = 0;
      }
    }
    #lstatFail(code = "") {
      if (code === "ENOTDIR") {
        const p = this.parent;
        p.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      }
    }
    #readlinkFail(code = "") {
      let ter = this.#type;
      ter |= ENOREADLINK;
      if (code === "ENOENT")
        ter |= ENOENT;
      if (code === "EINVAL" || code === "UNKNOWN") {
        ter &= IFMT_UNKNOWN;
      }
      this.#type = ter;
      if (code === "ENOTDIR" && this.parent) {
        this.parent.#markENOTDIR();
      }
    }
    #readdirAddChild(e, c) {
      return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
    }
    #readdirAddNewChild(e, c) {
      const type3 = entToType(e);
      const child = this.newChild(e.name, type3, { parent: this });
      const ifmt = child.#type & IFMT;
      if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
        child.#type |= ENOTDIR;
      }
      c.unshift(child);
      c.provisional++;
      return child;
    }
    #readdirMaybePromoteChild(e, c) {
      for (let p = c.provisional; p < c.length; p++) {
        const pchild = c[p];
        const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
        if (name !== pchild.#matchName) {
          continue;
        }
        return this.#readdirPromoteChild(e, pchild, p, c);
      }
    }
    #readdirPromoteChild(e, p, index, c) {
      const v = p.name;
      p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
      if (v !== e.name)
        p.name = e.name;
      if (index !== c.provisional) {
        if (index === c.length - 1)
          c.pop();
        else
          c.splice(index, 1);
        c.unshift(p);
      }
      c.provisional++;
      return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(this.#fs.lstatSync(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    #applyStat(st) {
      const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev: dev2, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
      this.#atime = atime;
      this.#atimeMs = atimeMs;
      this.#birthtime = birthtime;
      this.#birthtimeMs = birthtimeMs;
      this.#blksize = blksize;
      this.#blocks = blocks;
      this.#ctime = ctime;
      this.#ctimeMs = ctimeMs;
      this.#dev = dev2;
      this.#gid = gid;
      this.#ino = ino;
      this.#mode = mode;
      this.#mtime = mtime;
      this.#mtimeMs = mtimeMs;
      this.#nlink = nlink;
      this.#rdev = rdev;
      this.#size = size;
      this.#uid = uid;
      const ifmt = entToType(st);
      this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
      if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
        this.#type |= ENOTDIR;
      }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
      this.#readdirCBInFlight = false;
      const cbs = this.#onReaddirCB.slice();
      this.#onReaddirCB.length = 0;
      cbs.forEach((cb) => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
      if (!this.canReaddir()) {
        if (allowZalgo)
          cb(null, []);
        else
          queueMicrotask(() => cb(null, []));
        return;
      }
      const children = this.children();
      if (this.calledReaddir()) {
        const c = children.slice(0, children.provisional);
        if (allowZalgo)
          cb(null, c);
        else
          queueMicrotask(() => cb(null, c));
        return;
      }
      this.#onReaddirCB.push(cb);
      if (this.#readdirCBInFlight) {
        return;
      }
      this.#readdirCBInFlight = true;
      const fullpath = this.fullpath();
      this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
        if (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        } else {
          for (const e of entries) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        }
        this.#callOnReaddirCB(children.slice(0, children.provisional));
        return;
      });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      if (this.#asyncReaddirInFlight) {
        await this.#asyncReaddirInFlight;
      } else {
        let resolve4 = () => {
        };
        this.#asyncReaddirInFlight = new Promise((res) => resolve4 = res);
        try {
          for (const e of await this.#fs.promises.readdir(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        this.#asyncReaddirInFlight = void 0;
        resolve4();
      }
      return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      try {
        for (const e of this.#fs.readdirSync(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      return children.slice(0, children.provisional);
    }
    canReaddir() {
      if (this.#type & ENOCHILD)
        return false;
      const ifmt = IFMT & this.#type;
      if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
        return false;
      }
      return true;
    }
    shouldWalk(dirs, walkFilter) {
      return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return void 0;
      try {
        const rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_) {
        this.#markENOREALPATH();
      }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return void 0;
      try {
        const rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_) {
        this.#markENOREALPATH();
      }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
      if (oldCwd === this)
        return;
      const changed = /* @__PURE__ */ new Set([]);
      let rp = [];
      let p = this;
      while (p && p.parent) {
        changed.add(p);
        p.#relative = rp.join(this.sep);
        p.#relativePosix = rp.join("/");
        p = p.parent;
        rp.push("..");
      }
      p = oldCwd;
      while (p && p.parent && !changed.has(p)) {
        p.#relative = void 0;
        p.#relativePosix = void 0;
        p = p.parent;
      }
    }
  };
  var PathWin32 = class extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = "\\";
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type3, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type3 = UNKNOWN, opts = {}) {
      return new PathWin32(name, type3, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path5) {
      return import_path.win32.parse(path5).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
      rootPath = uncToDrive(rootPath.toUpperCase());
      if (rootPath === this.root.name) {
        return this.root;
      }
      for (const [compare, root] of Object.entries(this.roots)) {
        if (this.sameRoot(rootPath, compare)) {
          return this.roots[rootPath] = root;
        }
      }
      return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
      rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
      return rootPath === compare;
    }
  };
  var PathPosix = class extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = "/";
    /**
     * separator for generating path strings
     */
    sep = "/";
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type3, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path5) {
      return path5.startsWith("/") ? "/" : "";
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
      return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type3 = UNKNOWN, opts = {}) {
      return new PathPosix(name, type3, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
  };
  var PathScurryBase = class {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs4 = defaultFS } = {}) {
      this.#fs = fsFromOption(fs4);
      if (cwd instanceof URL || cwd.startsWith("file://")) {
        cwd = (0, import_url.fileURLToPath)(cwd);
      }
      const cwdPath = pathImpl.resolve(cwd);
      this.roots = /* @__PURE__ */ Object.create(null);
      this.rootPath = this.parseRootPath(cwdPath);
      this.#resolveCache = new ResolveCache();
      this.#resolvePosixCache = new ResolveCache();
      this.#children = new ChildrenCache(childrenCacheSize);
      const split4 = cwdPath.substring(this.rootPath.length).split(sep2);
      if (split4.length === 1 && !split4[0]) {
        split4.pop();
      }
      if (nocase === void 0) {
        throw new TypeError("must provide nocase setting to PathScurryBase ctor");
      }
      this.nocase = nocase;
      this.root = this.newRoot(this.#fs);
      this.roots[this.rootPath] = this.root;
      let prev = this.root;
      let len = split4.length - 1;
      const joinSep = pathImpl.sep;
      let abs = this.rootPath;
      let sawFirst = false;
      for (const part of split4) {
        const l = len--;
        prev = prev.child(part, {
          relative: new Array(l).fill("..").join(joinSep),
          relativePosix: new Array(l).fill("..").join("/"),
          fullpath: abs += (sawFirst ? "" : joinSep) + part
        });
        sawFirst = true;
      }
      this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path5 = this.cwd) {
      if (typeof path5 === "string") {
        path5 = this.cwd.resolve(path5);
      }
      return path5.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
      return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
      let r = "";
      for (let i = paths.length - 1; i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolveCache.get(r);
      if (cached !== void 0) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpath();
      this.#resolveCache.set(r, result);
      return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
      let r = "";
      for (let i = paths.length - 1; i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolvePosixCache.get(r);
      if (cached !== void 0) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpathPosix();
      this.#resolvePosixCache.set(r, result);
      return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else {
        const p = await entry.readdir();
        return withFileTypes ? p : p.map((e) => e.name);
      }
    }
    readdirSync(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else if (withFileTypes) {
        return entry.readdirSync();
      } else {
        return entry.readdirSync().map((e) => e.name);
      }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.readlink();
      return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.readlinkSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.realpath();
      return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.realpathSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set();
      const walk = (dir, cb) => {
        dirs.add(dir);
        dir.readdirCB((er, entries) => {
          if (er) {
            return cb(er);
          }
          let len = entries.length;
          if (!len)
            return cb();
          const next = () => {
            if (--len === 0) {
              cb();
            }
          };
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            if (follow && e.isSymbolicLink()) {
              e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
            } else {
              if (e.shouldWalk(dirs, walkFilter)) {
                walk(e, next);
              } else {
                next();
              }
            }
          }
        }, true);
      };
      const start = entry;
      return new Promise((res, rej) => {
        walk(start, (er) => {
          if (er)
            return rej(er);
          res(results);
        });
      });
    }
    walkSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
      return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        options = entry;
        entry = this.cwd;
      }
      return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      if (!filter2 || filter2(entry)) {
        yield withFileTypes ? entry : entry.fullpath();
      }
      const dirs = /* @__PURE__ */ new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            yield withFileTypes ? e : e.fullpath();
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
    }
    stream(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new Minipass({ objectMode: true });
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set();
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const onReaddir = (er, entries, didRealpaths = false) => {
            if (er)
              return results.emit("error", er);
            if (follow && !didRealpaths) {
              const promises = [];
              for (const e of entries) {
                if (e.isSymbolicLink()) {
                  promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                }
              }
              if (promises.length) {
                Promise.all(promises).then(() => onReaddir(null, entries, true));
                return;
              }
            }
            for (const e of entries) {
              if (e && (!filter2 || filter2(e))) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              const r = e.realpathCached() || e;
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
            if (paused && !results.flowing) {
              results.once("drain", process2);
            } else if (!sync2) {
              process2();
            }
          };
          let sync2 = true;
          dir.readdirCB(onReaddir, true);
          sync2 = false;
        }
      };
      process2();
      return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new Minipass({ objectMode: true });
      const dirs = /* @__PURE__ */ new Set();
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
        }
        if (paused && !results.flowing)
          results.once("drain", process2);
      };
      process2();
      return results;
    }
    chdir(path5 = this.cwd) {
      const oldCwd = this.cwd;
      this.cwd = typeof path5 === "string" ? this.cwd.resolve(path5) : path5;
      this.cwd[setAsCwd](oldCwd);
    }
  };
  var PathScurryWin32 = class extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = "\\";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, import_path.win32, "\\", { ...opts, nocase });
      this.nocase = nocase;
      for (let p = this.cwd; p; p = p.parent) {
        p.nocase = this.nocase;
      }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
      return import_path.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs4) {
      return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs4 });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
      return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
    }
  };
  var PathScurryPosix = class extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = "/";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = false } = opts;
      super(cwd, import_path.posix, "/", { ...opts, nocase });
      this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
      return "/";
    }
    /**
     * @internal
     */
    newRoot(fs4) {
      return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs4 });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
      return p.startsWith("/");
    }
  };
  var PathScurryDarwin = class extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, { ...opts, nocase });
    }
  };
  var Path = process.platform === "win32" ? PathWin32 : PathPosix;
  var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/glob.js
  var import_url2 = __require2("url");

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/pattern.js
  var isPatternList = (pl) => pl.length >= 1;
  var isGlobList = (gl) => gl.length >= 1;
  var Pattern = class {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
      if (!isPatternList(patternList)) {
        throw new TypeError("empty pattern list");
      }
      if (!isGlobList(globList)) {
        throw new TypeError("empty glob list");
      }
      if (globList.length !== patternList.length) {
        throw new TypeError("mismatched pattern list and glob list lengths");
      }
      this.length = patternList.length;
      if (index < 0 || index >= this.length) {
        throw new TypeError("index out of range");
      }
      this.#patternList = patternList;
      this.#globList = globList;
      this.#index = index;
      this.#platform = platform;
      if (this.#index === 0) {
        if (this.isUNC()) {
          const [p0, p1, p2, p3, ...prest] = this.#patternList;
          const [g0, g1, g2, g3, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = [p0, p1, p2, p3, ""].join("/");
          const g = [g0, g1, g2, g3, ""].join("/");
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        } else if (this.isDrive() || this.isAbsolute()) {
          const [p1, ...prest] = this.#patternList;
          const [g1, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = p1 + "/";
          const g = g1 + "/";
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        }
      }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
      return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
      return typeof this.#patternList[this.#index] === "string";
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
      return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
      return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
      return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
      return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
      if (this.#rest !== void 0)
        return this.#rest;
      if (!this.hasMore())
        return this.#rest = null;
      this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
      this.#rest.#isAbsolute = this.#isAbsolute;
      this.#rest.#isUNC = this.#isUNC;
      this.#rest.#isDrive = this.#isDrive;
      return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
      const pl = this.#patternList;
      return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
      const pl = this.#patternList;
      return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
      const pl = this.#patternList;
      return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
      const p = this.#patternList[0];
      return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
      return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
      if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
        return false;
      this.#followGlobstar = false;
      return true;
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/ignore.js
  var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
  var Ignore = class {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform2 }) {
      this.relative = [];
      this.absolute = [];
      this.relativeChildren = [];
      this.absoluteChildren = [];
      const mmopts = {
        dot: true,
        nobrace,
        nocase,
        noext,
        noglobstar,
        optimizationLevel: 2,
        platform,
        nocomment: true,
        nonegate: true
      };
      for (const ign of ignored) {
        const mm = new Minimatch(ign, mmopts);
        for (let i = 0; i < mm.set.length; i++) {
          const parsed = mm.set[i];
          const globParts = mm.globParts[i];
          const p = new Pattern(parsed, globParts, 0, platform);
          const m = new Minimatch(p.globString(), mmopts);
          const children = globParts[globParts.length - 1] === "**";
          const absolute = p.isAbsolute();
          if (absolute)
            this.absolute.push(m);
          else
            this.relative.push(m);
          if (children) {
            if (absolute)
              this.absoluteChildren.push(m);
            else
              this.relativeChildren.push(m);
          }
        }
      }
    }
    ignored(p) {
      const fullpath = p.fullpath();
      const fullpaths = `${fullpath}/`;
      const relative2 = p.relative() || ".";
      const relatives = `${relative2}/`;
      for (const m of this.relative) {
        if (m.match(relative2) || m.match(relatives))
          return true;
      }
      for (const m of this.absolute) {
        if (m.match(fullpath) || m.match(fullpaths))
          return true;
      }
      return false;
    }
    childrenIgnored(p) {
      const fullpath = p.fullpath() + "/";
      const relative2 = (p.relative() || ".") + "/";
      for (const m of this.relativeChildren) {
        if (m.match(relative2))
          return true;
      }
      for (const m of this.absoluteChildren) {
        if (m.match(fullpath))
          true;
      }
      return false;
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/processor.js
  var HasWalkedCache = class {
    store;
    constructor(store = /* @__PURE__ */ new Map()) {
      this.store = store;
    }
    copy() {
      return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
      return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
      const fullpath = target.fullpath();
      const cached = this.store.get(fullpath);
      if (cached)
        cached.add(pattern.globString());
      else
        this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
    }
  };
  var MatchRecord = class {
    store = /* @__PURE__ */ new Map();
    add(target, absolute, ifDir) {
      const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
      const current = this.store.get(target);
      this.store.set(target, current === void 0 ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
      return [...this.store.entries()].map(([path5, n]) => [
        path5,
        !!(n & 2),
        !!(n & 1)
      ]);
    }
  };
  var SubWalks = class {
    store = /* @__PURE__ */ new Map();
    add(target, pattern) {
      if (!target.canReaddir()) {
        return;
      }
      const subs = this.store.get(target);
      if (subs) {
        if (!subs.find((p) => p.globString() === pattern.globString())) {
          subs.push(pattern);
        }
      } else
        this.store.set(target, [pattern]);
    }
    get(target) {
      const subs = this.store.get(target);
      if (!subs) {
        throw new Error("attempting to walk unknown path");
      }
      return subs;
    }
    entries() {
      return this.keys().map((k) => [k, this.store.get(k)]);
    }
    keys() {
      return [...this.store.keys()].filter((t) => t.canReaddir());
    }
  };
  var Processor = class {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
      this.opts = opts;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
      this.patterns = patterns;
      const processingSet = patterns.map((p) => [target, p]);
      for (let [t, pattern] of processingSet) {
        this.hasWalkedCache.storeWalked(t, pattern);
        const root = pattern.root();
        const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
        if (root) {
          t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
          const rest2 = pattern.rest();
          if (!rest2) {
            this.matches.add(t, true, false);
            continue;
          } else {
            pattern = rest2;
          }
        }
        if (t.isENOENT())
          continue;
        let p;
        let rest;
        let changed = false;
        while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
          const c = t.resolve(p);
          if (c.isUnknown() && p !== "..")
            break;
          t = c;
          pattern = rest;
          changed = true;
        }
        p = pattern.pattern();
        rest = pattern.rest();
        if (changed) {
          if (this.hasWalkedCache.hasWalked(t, pattern))
            continue;
          this.hasWalkedCache.storeWalked(t, pattern);
        }
        if (typeof p === "string") {
          if (!rest) {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
          } else {
            this.subwalks.add(t, pattern);
          }
          continue;
        } else if (p === GLOBSTAR) {
          if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
            this.subwalks.add(t, pattern);
          }
          const rp = rest?.pattern();
          const rrest = rest?.rest();
          if (!rest || (rp === "" || rp === ".") && !rrest) {
            this.matches.add(t, absolute, rp === "" || rp === ".");
          } else {
            if (rp === "..") {
              const tp = t.parent || t;
              if (!rrest)
                this.matches.add(tp, absolute, true);
              else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                this.subwalks.add(tp, rrest);
              }
            }
          }
        } else if (p instanceof RegExp) {
          this.subwalks.add(t, pattern);
        }
      }
      return this;
    }
    subwalkTargets() {
      return this.subwalks.keys();
    }
    child() {
      return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
      const patterns = this.subwalks.get(parent);
      const results = this.child();
      for (const e of entries) {
        for (const pattern of patterns) {
          const absolute = pattern.isAbsolute();
          const p = pattern.pattern();
          const rest = pattern.rest();
          if (p === GLOBSTAR) {
            results.testGlobstar(e, pattern, rest, absolute);
          } else if (p instanceof RegExp) {
            results.testRegExp(e, p, rest, absolute);
          } else {
            results.testString(e, p, rest, absolute);
          }
        }
      }
      return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
      if (this.dot || !e.name.startsWith(".")) {
        if (!pattern.hasMore()) {
          this.matches.add(e, absolute, false);
        }
        if (e.canReaddir()) {
          if (this.follow || !e.isSymbolicLink()) {
            this.subwalks.add(e, pattern);
          } else if (e.isSymbolicLink()) {
            if (rest && pattern.checkFollowGlobstar()) {
              this.subwalks.add(e, rest);
            } else if (pattern.markFollowGlobstar()) {
              this.subwalks.add(e, pattern);
            }
          }
        }
      }
      if (rest) {
        const rp = rest.pattern();
        if (typeof rp === "string" && // dots and empty were handled already
        rp !== ".." && rp !== "" && rp !== ".") {
          this.testString(e, rp, rest.rest(), absolute);
        } else if (rp === "..") {
          const ep = e.parent || e;
          this.subwalks.add(ep, rest);
        } else if (rp instanceof RegExp) {
          this.testRegExp(e, rp, rest.rest(), absolute);
        }
      }
    }
    testRegExp(e, p, rest, absolute) {
      if (!p.test(e.name))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
    testString(e, p, rest, absolute) {
      if (!e.isNamed(p))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/walker.js
  var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
  var GlobUtil = class {
    path;
    patterns;
    opts;
    seen = /* @__PURE__ */ new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    constructor(patterns, path5, opts) {
      this.patterns = patterns;
      this.path = path5;
      this.opts = opts;
      this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
      if (opts.ignore) {
        this.#ignore = makeIgnore(opts.ignore, opts);
      }
      this.maxDepth = opts.maxDepth || Infinity;
      if (opts.signal) {
        this.signal = opts.signal;
        this.signal.addEventListener("abort", () => {
          this.#onResume.length = 0;
        });
      }
    }
    #ignored(path5) {
      return this.seen.has(path5) || !!this.#ignore?.ignored?.(path5);
    }
    #childrenIgnored(path5) {
      return !!this.#ignore?.childrenIgnored?.(path5);
    }
    // backpressure mechanism
    pause() {
      this.paused = true;
    }
    resume() {
      if (this.signal?.aborted)
        return;
      this.paused = false;
      let fn = void 0;
      while (!this.paused && (fn = this.#onResume.shift())) {
        fn();
      }
    }
    onResume(fn) {
      if (this.signal?.aborted)
        return;
      if (!this.paused) {
        fn();
      } else {
        this.#onResume.push(fn);
      }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return void 0;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || await e.realpath();
        if (!rpc)
          return void 0;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);
    }
    matchCheckTest(e, ifDir) {
      return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !this.#ignored(e) ? e : void 0;
    }
    matchCheckSync(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return void 0;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || e.realpathSync();
        if (!rpc)
          return void 0;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
    }
    matchFinish(e, absolute) {
      if (this.#ignored(e))
        return;
      const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
      this.seen.add(e);
      const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
      if (this.opts.withFileTypes) {
        this.matchEmit(e);
      } else if (abs) {
        const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
        this.matchEmit(abs2 + mark);
      } else {
        const rel = this.opts.posix ? e.relativePosix() : e.relative();
        const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
        this.matchEmit(!rel ? "." + mark : pre + rel + mark);
      }
    }
    async match(e, absolute, ifDir) {
      const p = await this.matchCheck(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
      const p = this.matchCheckSync(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const childrenCached = t.readdirCached();
        if (t.calledReaddir())
          this.walkCB3(t, childrenCached, processor, next);
        else {
          t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
        }
      }
      next();
    }
    walkCB3(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2(target2, patterns, processor.child(), next);
      }
      next();
    }
    walkCBSync(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const children = t.readdirSync();
        this.walkCB3Sync(t, children, processor, next);
      }
      next();
    }
    walkCB3Sync(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2Sync(target2, patterns, processor.child(), next);
      }
      next();
    }
  };
  var GlobWalker = class extends GlobUtil {
    matches;
    constructor(patterns, path5, opts) {
      super(patterns, path5, opts);
      this.matches = /* @__PURE__ */ new Set();
    }
    matchEmit(e) {
      this.matches.add(e);
    }
    async walk() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        await this.path.lstat();
      }
      await new Promise((res, rej) => {
        this.walkCB(this.path, this.patterns, () => {
          if (this.signal?.aborted) {
            rej(this.signal.reason);
          } else {
            res(this.matches);
          }
        });
      });
      return this.matches;
    }
    walkSync() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => {
        if (this.signal?.aborted)
          throw this.signal.reason;
      });
      return this.matches;
    }
  };
  var GlobStream = class extends GlobUtil {
    results;
    constructor(patterns, path5, opts) {
      super(patterns, path5, opts);
      this.results = new Minipass({
        signal: this.signal,
        objectMode: true
      });
      this.results.on("drain", () => this.resume());
      this.results.on("resume", () => this.resume());
    }
    matchEmit(e) {
      this.results.write(e);
      if (!this.results.flowing)
        this.pause();
    }
    stream() {
      const target = this.path;
      if (target.isUnknown()) {
        target.lstat().then(() => {
          this.walkCB(target, this.patterns, () => this.results.end());
        });
      } else {
        this.walkCB(target, this.patterns, () => this.results.end());
      }
      return this.results;
    }
    streamSync() {
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => this.results.end());
      return this.results;
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/glob.js
  var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
  var Glob = class {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
      this.withFileTypes = !!opts.withFileTypes;
      this.signal = opts.signal;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.dotRelative = !!opts.dotRelative;
      this.nodir = !!opts.nodir;
      this.mark = !!opts.mark;
      if (!opts.cwd) {
        this.cwd = "";
      } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
        opts.cwd = (0, import_url2.fileURLToPath)(opts.cwd);
      }
      this.cwd = opts.cwd || "";
      this.root = opts.root;
      this.magicalBraces = !!opts.magicalBraces;
      this.nobrace = !!opts.nobrace;
      this.noext = !!opts.noext;
      this.realpath = !!opts.realpath;
      this.absolute = opts.absolute;
      this.noglobstar = !!opts.noglobstar;
      this.matchBase = !!opts.matchBase;
      this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
      this.stat = !!opts.stat;
      this.ignore = opts.ignore;
      if (this.withFileTypes && this.absolute !== void 0) {
        throw new Error("cannot set absolute and withFileTypes:true");
      }
      if (typeof pattern === "string") {
        pattern = [pattern];
      }
      this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        pattern = pattern.map((p) => p.replace(/\\/g, "/"));
      }
      if (this.matchBase) {
        if (opts.noglobstar) {
          throw new TypeError("base matching requires globstar");
        }
        pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
      }
      this.pattern = pattern;
      this.platform = opts.platform || defaultPlatform3;
      this.opts = { ...opts, platform: this.platform };
      if (opts.scurry) {
        this.scurry = opts.scurry;
        if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
          throw new Error("nocase option contradicts provided scurry option");
        }
      } else {
        const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
        this.scurry = new Scurry(this.cwd, {
          nocase: opts.nocase,
          fs: opts.fs
        });
      }
      this.nocase = this.scurry.nocase;
      const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
      const mmo = {
        // default nocase based on platform
        ...opts,
        dot: this.dot,
        matchBase: this.matchBase,
        nobrace: this.nobrace,
        nocase: this.nocase,
        nocaseMagicOnly,
        nocomment: true,
        noext: this.noext,
        nonegate: true,
        optimizationLevel: 2,
        platform: this.platform,
        windowsPathsNoEscape: this.windowsPathsNoEscape,
        debug: !!this.opts.debug
      };
      const mms = this.pattern.map((p) => new Minimatch(p, mmo));
      const [matchSet, globParts] = mms.reduce((set2, m) => {
        set2[0].push(...m.set);
        set2[1].push(...m.globParts);
        return set2;
      }, [[], []]);
      this.patterns = matchSet.map((set2, i) => {
        return new Pattern(set2, globParts[i], 0, this.platform);
      });
    }
    async walk() {
      return [
        ...await new GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase
        }).walk()
      ];
    }
    walkSync() {
      return [
        ...new GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase
        }).walkSync()
      ];
    }
    stream() {
      return new GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase
      }).stream();
    }
    streamSync() {
      return new GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase
      }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
      return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
      return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/has-magic.js
  var hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
      pattern = [pattern];
    }
    for (const p of pattern) {
      if (new Minimatch(p, options).hasMagic())
        return true;
    }
    return false;
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/index.js
  function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
  }
  function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
  }
  function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
  }
  async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
  }
  function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
  }
  function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
  }
  var streamSync = globStreamSync;
  var stream = Object.assign(globStream, { sync: globStreamSync });
  var iterateSync = globIterateSync;
  var iterate = Object.assign(globIterate, {
    sync: globIterateSync
  });
  var sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync
  });
  var glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob,
    hasMagic,
    escape,
    unescape
  });
  glob.glob = glob;

  // ../abi-typegen/dist/cli.mjs
  var import_mkdirp = __toESM(require_mkdirp(), 1);
  var import_path8 = __require2("path");
  var import_rimraf = __toESM(require_rimraf(), 1);

  // ../utils/dist/index.mjs
  var __defProp3 = Object.defineProperty;
  var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField3 = (obj, key, value) => {
    __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var capitalizeString = (str) => {
    if (!str.length) {
      return str;
    }
    return str[0].toUpperCase() + str.slice(1);
  };
  var chunkAndPadBytes = (bytes3, chunkSize) => {
    const chunks = [];
    for (let offset = 0; offset < bytes3.length; offset += chunkSize) {
      const chunk = new Uint8Array(chunkSize);
      chunk.set(bytes3.slice(offset, offset + chunkSize));
      chunks.push(chunk);
    }
    const lastChunk = chunks[chunks.length - 1];
    const remainingBytes = bytes3.length % chunkSize;
    const paddedChunkLength = remainingBytes + (8 - remainingBytes % 8) % 8;
    const newChunk = lastChunk.slice(0, paddedChunkLength);
    chunks[chunks.length - 1] = newChunk;
    return chunks;
  };
  var arrayify = (value) => {
    if (value instanceof Uint8Array) {
      return new Uint8Array(value);
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    throw new FuelError(ErrorCode.PARSE_FAILED, "invalid BytesLike value");
  };
  var concatBytes = (arrays) => {
    const byteArrays = arrays.map((array2) => {
      if (array2 instanceof Uint8Array) {
        return array2;
      }
      return Uint8Array.from(array2);
    });
    const totalSize = byteArrays.reduce((accum, item) => accum + item.length, 0);
    const concatenated = new Uint8Array(totalSize);
    byteArrays.reduce((offset, object2) => {
      concatenated.set(object2, offset);
      return offset + object2.length;
    }, 0);
    return concatenated;
  };
  var concat = (arrays) => {
    const bytes3 = arrays.map((v) => arrayify(v));
    return concatBytes(bytes3);
  };
  var HexCharacters = "0123456789abcdef";
  function hexlify(data) {
    const bytes3 = arrayify(data);
    let result = "0x";
    for (let i = 0; i < bytes3.length; i++) {
      const v = bytes3[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  var normalizeString = (str) => {
    const transformations = [
      (s) => s.replace(/\s+/g, "-"),
      // spaces to -
      (s) => s.replace(/\./g, "-"),
      // dots to -
      (s) => s.replace(/_/g, "-"),
      // underscore to -
      (s) => s.replace(/-[a-z]/g, (match3) => match3.slice(-1).toUpperCase()),
      // delete '-' and capitalize the letter after them
      (s) => s.replace(/-/g, ""),
      // delete any '-' left
      (s) => s.replace(/^\d+/, ""),
      // removes leading digits
      (s) => s[0].toUpperCase() + s.slice(1)
      // capitalize first letter
    ];
    const output3 = transformations.reduce((s, t) => t(s), str);
    if (output3 === "") {
      const errMsg = `The provided string '${str}' results in an empty output after`.concat(
        ` normalization, therefore, it can't normalize string.`
      );
      throw new FuelError(ErrorCode.PARSE_FAILED, errMsg);
    }
    return output3;
  };
  var TAI64_LEAP_SECONDS = 37;
  var TAI64_UNIX_OFFSET = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);
  var msToSeconds = (ms) => Math.floor(ms / 1e3);
  var secondsToMs = (seconds) => seconds * 1e3;
  var tai64ToUnixSeconds = (tai64) => Number(BigInt(tai64) - TAI64_UNIX_OFFSET);
  var unixSecondsToTai64 = (unixSeconds) => String(BigInt(unixSeconds) + TAI64_UNIX_OFFSET);
  var tai64ToUnixMilliseconds = (tai64) => secondsToMs(tai64ToUnixSeconds(tai64));
  var _DateTime = class extends Date {
    /**
     * Generates a new DateTime instance from a Tai64 timestamp.
     *
     * @param tai64 - Tai64 timestamp
     * @returns a new DateTime instance
     */
    static fromTai64(tai64) {
      return new _DateTime(tai64ToUnixMilliseconds(tai64));
    }
    /**
     * @param unixMilliseconds - unix milliseconds timestamp
     * @returns a new DateTime instance
     */
    static fromUnixMilliseconds(unixMilliseconds) {
      return new _DateTime(unixMilliseconds);
    }
    /**
     * @param unixSeconds - unix seconds timestamp
     * @returns a new DateTime instance
     */
    static fromUnixSeconds(unixSeconds) {
      return new _DateTime(secondsToMs(unixSeconds));
    }
    /**
     * Hide the constructor to prevent direct instantiation.
     */
    constructor(date2) {
      super(date2);
    }
    /**
     * Returns the Tai64 timestamp.
     *
     * @returns the Tai64 timestamp
     */
    toTai64() {
      return unixSecondsToTai64(this.toUnixSeconds());
    }
    /**
     * @returns the unix milliseconds timestamp
     */
    toUnixMilliseconds() {
      return this.getTime();
    }
    /**
     * @returns the unix seconds timestamp
     */
    toUnixSeconds() {
      return msToSeconds(this.getTime());
    }
  };
  var DateTime = _DateTime;
  __publicField3(DateTime, "TAI64_NULL", "");
  var chainConfig_default = {
    chain_name: "local_testnet",
    block_gas_limit: 5e9,
    initial_state: {
      coins: [
        {
          owner: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x5d99ee966b42cd8fc7bdd1364b389153a9e78b42b7d4a691470674e817888d4e",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x5d99ee966b42cd8fc7bdd1364b389153a9e78b42b7d4a691470674e817888d4e",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x5d99ee966b42cd8fc7bdd1364b389153a9e78b42b7d4a691470674e817888d4e",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0xbdaad6a89e073e177895b3e5a9ccd15806749eda134a6438dae32fc5b6601f3f",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0xbdaad6a89e073e177895b3e5a9ccd15806749eda134a6438dae32fc5b6601f3f",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0xbdaad6a89e073e177895b3e5a9ccd15806749eda134a6438dae32fc5b6601f3f",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x95a7aa6cc32743f8706c40ef49a7423b47da763bb4bbc055b1f07254dc729036",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x95a7aa6cc32743f8706c40ef49a7423b47da763bb4bbc055b1f07254dc729036",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x95a7aa6cc32743f8706c40ef49a7423b47da763bb4bbc055b1f07254dc729036",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0xcee104acd38b940c8f1c62c6d7ea00a0ad2241d6dee0509a4bf27297508870d3",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0xcee104acd38b940c8f1c62c6d7ea00a0ad2241d6dee0509a4bf27297508870d3",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0xcee104acd38b940c8f1c62c6d7ea00a0ad2241d6dee0509a4bf27297508870d3",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x7e3626e306588eba79cafab73f0709e55ab8f4bdfe8c8b75034a430fc56ece89",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x7e3626e306588eba79cafab73f0709e55ab8f4bdfe8c8b75034a430fc56ece89",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x7e3626e306588eba79cafab73f0709e55ab8f4bdfe8c8b75034a430fc56ece89",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x1c31df52b6df56407dd95f83082e8beb9cfc9532ac111d5bd8491651d95ba775",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x1c31df52b6df56407dd95f83082e8beb9cfc9532ac111d5bd8491651d95ba775",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x1c31df52b6df56407dd95f83082e8beb9cfc9532ac111d5bd8491651d95ba775",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x09dd7a49174d6fcc9f4c6f7942c18060a935ddd03ee69b594189b8c3581276ea",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x09dd7a49174d6fcc9f4c6f7942c18060a935ddd03ee69b594189b8c3581276ea",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x09dd7a49174d6fcc9f4c6f7942c18060a935ddd03ee69b594189b8c3581276ea",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x86604282dc604481b809845be49667607c470644f6822fc01eb0d22f167e08cf",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x86604282dc604481b809845be49667607c470644f6822fc01eb0d22f167e08cf",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x86604282dc604481b809845be49667607c470644f6822fc01eb0d22f167e08cf",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0xbca334a06d19db5041c78fe2f465b07be5bec828f38b7796b2877e7d1542c950",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0xbca334a06d19db5041c78fe2f465b07be5bec828f38b7796b2877e7d1542c950",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0xbca334a06d19db5041c78fe2f465b07be5bec828f38b7796b2877e7d1542c950",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0xbd9a1dc8d3ec3521c43f6c2c01611b4d0204c7610204ff0178488c8738a30bd2",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0xbd9a1dc8d3ec3521c43f6c2c01611b4d0204c7610204ff0178488c8738a30bd2",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0xbd9a1dc8d3ec3521c43f6c2c01611b4d0204c7610204ff0178488c8738a30bd2",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0xb32197cf75efe05bf453c26178139f09b391582065549c1422bc92555ecffb64",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0xb32197cf75efe05bf453c26178139f09b391582065549c1422bc92555ecffb64",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0xb32197cf75efe05bf453c26178139f09b391582065549c1422bc92555ecffb64",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x3b24509ed4ab3c7959f5c9391c1445c59290cdb5f13d6f780922f376b7029f30",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x3b24509ed4ab3c7959f5c9391c1445c59290cdb5f13d6f780922f376b7029f30",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x3b24509ed4ab3c7959f5c9391c1445c59290cdb5f13d6f780922f376b7029f30",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x77c6f40b7da70d885f68efaad7c661327482a63ea10dcb4271de819438254ae1",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x77c6f40b7da70d885f68efaad7c661327482a63ea10dcb4271de819438254ae1",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x77c6f40b7da70d885f68efaad7c661327482a63ea10dcb4271de819438254ae1",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x6a2c4691c547c43924650dbd30620b184b5fe3fb6dbe5c4446110b08f6f405bf",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x6a2c4691c547c43924650dbd30620b184b5fe3fb6dbe5c4446110b08f6f405bf",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x6a2c4691c547c43924650dbd30620b184b5fe3fb6dbe5c4446110b08f6f405bf",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        },
        {
          owner: "0x49075a7538e2c88ebe1926ce4d898198a2a4e790d14512943a9864bc536b3c82",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x49075a7538e2c88ebe1926ce4d898198a2a4e790d14512943a9864bc536b3c82",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0101010101010101010101010101010101010101010101010101010101010101"
        },
        {
          owner: "0x49075a7538e2c88ebe1926ce4d898198a2a4e790d14512943a9864bc536b3c82",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0202020202020202020202020202020202020202020202020202020202020202"
        }
      ],
      messages: [
        {
          sender: "0xc43454aa38dd91f88109a4b7aef5efb96ce34e3f24992fe0f81d233ca686f80f",
          recipient: "0x69a2b736b60159b43bb8a4f98c0589f6da5fa3a3d101e8e269c499eb942753ba",
          nonce: "0101010101010101010101010101010101010101010101010101010101010101",
          amount: "0x000000000000FFFF",
          data: "",
          da_height: "0x00"
        },
        {
          sender: "0x69a2b736b60159b43bb8a4f98c0589f6da5fa3a3d101e8e269c499eb942753ba",
          recipient: "0xc43454aa38dd91f88109a4b7aef5efb96ce34e3f24992fe0f81d233ca686f80f",
          nonce: "0e1ef2963832068b0e1ef2963832068b0e1ef2963832068b0e1ef2963832068b",
          amount: "0xb04f3c08f59b309e",
          data: "",
          da_height: "0x00"
        }
      ]
    },
    consensus_parameters: {
      tx_params: {
        max_inputs: 255,
        max_outputs: 255,
        max_witnesses: 255,
        max_gas_per_tx: 1e7,
        max_size: 17825792
      },
      predicate_params: {
        max_predicate_length: 1048576,
        max_predicate_data_length: 1048576,
        max_gas_per_predicate: 1e7,
        max_message_data_length: 1048576
      },
      script_params: {
        max_script_length: 1048576,
        max_script_data_length: 1048576
      },
      contract_params: {
        contract_max_size: 16777216,
        max_storage_slots: 255
      },
      fee_params: {
        gas_price_factor: 92,
        gas_per_byte: 4
      }
    },
    gas_costs: {
      add: 1,
      addi: 1,
      aloc: 1,
      and: 1,
      andi: 1,
      bal: 13,
      bhei: 1,
      bhsh: 1,
      burn: 132,
      cb: 1,
      cfei: 1,
      cfsi: 1,
      croo: 16,
      div: 1,
      divi: 1,
      ecr1: 3e3,
      eck1: 951,
      ed19: 3e3,
      eq: 1,
      exp: 1,
      expi: 1,
      flag: 1,
      gm: 1,
      gt: 1,
      gtf: 1,
      ji: 1,
      jmp: 1,
      jne: 1,
      jnei: 1,
      jnzi: 1,
      jmpf: 1,
      jmpb: 1,
      jnzf: 1,
      jnzb: 1,
      jnef: 1,
      jneb: 1,
      lb: 1,
      log: 9,
      lt: 1,
      lw: 1,
      mint: 135,
      mlog: 1,
      modOp: 1,
      modi: 1,
      moveOp: 1,
      movi: 1,
      mroo: 2,
      mul: 1,
      muli: 1,
      mldv: 1,
      noop: 1,
      not: 1,
      or: 1,
      ori: 1,
      poph: 2,
      popl: 2,
      pshh: 2,
      pshl: 2,
      ret: 13,
      rvrt: 13,
      sb: 1,
      sll: 1,
      slli: 1,
      srl: 1,
      srli: 1,
      srw: 12,
      sub: 1,
      subi: 1,
      sw: 1,
      sww: 67,
      time: 1,
      tr: 105,
      tro: 60,
      wdcm: 1,
      wqcm: 1,
      wdop: 1,
      wqop: 1,
      wdml: 1,
      wqml: 1,
      wddv: 1,
      wqdv: 2,
      wdmd: 3,
      wqmd: 4,
      wdam: 2,
      wqam: 3,
      wdmm: 3,
      wqmm: 3,
      xor: 1,
      xori: 1,
      call: {
        LightOperation: {
          base: 144,
          units_per_gas: 214
        }
      },
      ccp: {
        LightOperation: {
          base: 15,
          units_per_gas: 103
        }
      },
      csiz: {
        LightOperation: {
          base: 17,
          units_per_gas: 790
        }
      },
      k256: {
        LightOperation: {
          base: 11,
          units_per_gas: 214
        }
      },
      ldc: {
        LightOperation: {
          base: 15,
          units_per_gas: 272
        }
      },
      logd: {
        LightOperation: {
          base: 26,
          units_per_gas: 64
        }
      },
      mcl: {
        LightOperation: {
          base: 1,
          units_per_gas: 3333
        }
      },
      mcli: {
        LightOperation: {
          base: 1,
          units_per_gas: 3333
        }
      },
      mcp: {
        LightOperation: {
          base: 1,
          units_per_gas: 2e3
        }
      },
      mcpi: {
        LightOperation: {
          base: 3,
          units_per_gas: 2e3
        }
      },
      meq: {
        LightOperation: {
          base: 1,
          units_per_gas: 2500
        }
      },
      retd: {
        LightOperation: {
          base: 29,
          units_per_gas: 62
        }
      },
      s256: {
        LightOperation: {
          base: 2,
          units_per_gas: 214
        }
      },
      scwq: {
        LightOperation: {
          base: 13,
          units_per_gas: 5
        }
      },
      smo: {
        LightOperation: {
          base: 209,
          units_per_gas: 55
        }
      },
      srwq: {
        LightOperation: {
          base: 47,
          units_per_gas: 5
        }
      },
      swwq: {
        LightOperation: {
          base: 44,
          units_per_gas: 5
        }
      },
      contract_root: {
        LightOperation: {
          base: 75,
          units_per_gas: 1
        }
      },
      state_root: {
        LightOperation: {
          base: 412,
          units_per_gas: 1
        }
      },
      vm_initialization: {
        HeavyOperation: {
          base: 2e3,
          gas_per_unit: 0
        }
      },
      new_storage_per_byte: 1
    },
    consensus: {
      PoA: {
        signing_key: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d"
      }
    }
  };
  var defaultChainConfig = chainConfig_default;
  var defaultConsensusKey = "0xa449b1ffee0e2205fa924c6740cc48b3b473aa28587df6dab12abc245d1f5298";

  // ../abi-typegen/dist/cli.mjs
  var import_path9 = __require2("path");
  var import_handlebars = __toESM(require_lib(), 1);

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isPlaceholder.js
  function _isPlaceholder(a) {
    return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_curry1.js
  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_curry2.js
  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
            return fn(a, _b);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function(_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isArray.js
  var isArray_default = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
  };

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isTransformer.js
  function _isTransformer(obj) {
    return obj != null && typeof obj["@@transducer/step"] === "function";
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_dispatchable.js
  function _dispatchable(methodNames, transducerCreator, fn) {
    return function() {
      if (arguments.length === 0) {
        return fn();
      }
      var obj = arguments[arguments.length - 1];
      if (!isArray_default(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === "function") {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_xfBase.js
  var xfBase_default = {
    init: function() {
      return this.xf["@@transducer/init"]();
    },
    result: function(result) {
      return this.xf["@@transducer/result"](result);
    }
  };

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_arrayFromIterator.js
  function _arrayFromIterator(iter) {
    var list = [];
    var next;
    while (!(next = iter.next()).done) {
      list.push(next.value);
    }
    return list;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_includesWith.js
  function _includesWith(pred, x, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_functionName.js
  function _functionName(f2) {
    var match3 = String(f2).match(/^function (\w*)/);
    return match3 == null ? "" : match3[1];
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_has.js
  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_objectIs.js
  function _objectIs(a, b) {
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    } else {
      return a !== a && b !== b;
    }
  }
  var objectIs_default = typeof Object.is === "function" ? Object.is : _objectIs;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isArguments.js
  var toString = Object.prototype.toString;
  var _isArguments = /* @__PURE__ */ function() {
    return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
      return toString.call(x) === "[object Arguments]";
    } : function _isArguments2(x) {
      return _has("callee", x);
    };
  }();
  var isArguments_default = _isArguments;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/keys.js
  var hasEnumBug = !/* @__PURE__ */ {
    toString: null
  }.propertyIsEnumerable("toString");
  var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
  var hasArgsEnumBug = /* @__PURE__ */ function() {
    "use strict";
    return arguments.propertyIsEnumerable("length");
  }();
  var contains = function contains2(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };
  var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : /* @__PURE__ */ _curry1(function keys3(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== "length")) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });
  var keys_default = keys;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/type.js
  var type = /* @__PURE__ */ _curry1(function type2(val) {
    return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
  });
  var type_default = type;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_equals.js
  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);
    var b = _arrayFromIterator(bIterator);
    function eq2(_a, _b) {
      return _equals(_a, _b, stackA.slice(), stackB.slice());
    }
    return !_includesWith(function(b2, aItem) {
      return !_includesWith(eq2, aItem, b2);
    }, b, a);
  }
  function _equals(a, b, stackA, stackB) {
    if (objectIs_default(a, b)) {
      return true;
    }
    var typeA = type_default(a);
    if (typeA !== type_default(b)) {
      return false;
    }
    if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
      return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
    }
    if (typeof a.equals === "function" || typeof b.equals === "function") {
      return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
    }
    switch (typeA) {
      case "Arguments":
      case "Array":
      case "Object":
        if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
          return a === b;
        }
        break;
      case "Boolean":
      case "Number":
      case "String":
        if (!(typeof a === typeof b && objectIs_default(a.valueOf(), b.valueOf()))) {
          return false;
        }
        break;
      case "Date":
        if (!objectIs_default(a.valueOf(), b.valueOf())) {
          return false;
        }
        break;
      case "Error":
        return a.name === b.name && a.message === b.message;
      case "RegExp":
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }
        break;
    }
    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }
    switch (typeA) {
      case "Map":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
      case "Set":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
      case "Arguments":
      case "Array":
      case "Object":
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "Error":
      case "RegExp":
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "ArrayBuffer":
        break;
      default:
        return false;
    }
    var keysA = keys_default(a);
    if (keysA.length !== keys_default(b).length) {
      return false;
    }
    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }
      idx -= 1;
    }
    return true;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/equals.js
  var equals = /* @__PURE__ */ _curry2(function equals2(a, b) {
    return _equals(a, b, [], []);
  });
  var equals_default = equals;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_indexOf.js
  function _indexOf(list, a, idx) {
    var inf, item;
    if (typeof list.indexOf === "function") {
      switch (typeof a) {
        case "number":
          if (a === 0) {
            inf = 1 / a;
            while (idx < list.length) {
              item = list[idx];
              if (item === 0 && 1 / item === inf) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          } else if (a !== a) {
            while (idx < list.length) {
              item = list[idx];
              if (typeof item === "number" && item !== item) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          }
          return list.indexOf(a, idx);
        case "string":
        case "boolean":
        case "function":
        case "undefined":
          return list.indexOf(a, idx);
        case "object":
          if (a === null) {
            return list.indexOf(a, idx);
          }
      }
    }
    while (idx < list.length) {
      if (equals_default(list[idx], a)) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_includes.js
  function _includes(a, list) {
    return _indexOf(list, a, 0) >= 0;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_toISOString.js
  var pad = function pad2(n) {
    return (n < 10 ? "0" : "") + n;
  };
  var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
    return d.toISOString();
  } : function _toISOString3(d) {
    return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
  };

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isInteger.js
  var isInteger_default = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
  };

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_cloneRegExp.js
  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : "") + (pattern.dotAll ? "s" : ""));
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_clone.js
  function _clone(value, deep, map2) {
    map2 || (map2 = new _ObjectMap());
    if (_isPrimitive(value)) {
      return value;
    }
    var copy = function copy2(copiedValue) {
      var cachedCopy = map2.get(value);
      if (cachedCopy) {
        return cachedCopy;
      }
      map2.set(value, copiedValue);
      for (var key in value) {
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          copiedValue[key] = deep ? _clone(value[key], true, map2) : value[key];
        }
      }
      return copiedValue;
    };
    switch (type_default(value)) {
      case "Object":
        return copy(Object.create(Object.getPrototypeOf(value)));
      case "Array":
        return copy([]);
      case "Date":
        return new Date(value.valueOf());
      case "RegExp":
        return _cloneRegExp(value);
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array":
        return value.slice();
      default:
        return value;
    }
  }
  function _isPrimitive(param) {
    var type3 = typeof param;
    return param == null || type3 != "object" && type3 != "function";
  }
  var _ObjectMap = /* @__PURE__ */ function() {
    function _ObjectMap2() {
      this.map = {};
      this.length = 0;
    }
    _ObjectMap2.prototype.set = function(key, value) {
      const hashedKey = this.hash(key);
      let bucket = this.map[hashedKey];
      if (!bucket) {
        this.map[hashedKey] = bucket = [];
      }
      bucket.push([key, value]);
      this.length += 1;
    };
    _ObjectMap2.prototype.hash = function(key) {
      let hashedKey = [];
      for (var value in key) {
        hashedKey.push(Object.prototype.toString.call(key[value]));
      }
      return hashedKey.join();
    };
    _ObjectMap2.prototype.get = function(key) {
      if (this.length <= 180) {
        for (const p in this.map) {
          const bucket2 = this.map[p];
          for (let i = 0; i < bucket2.length; i += 1) {
            const element = bucket2[i];
            if (element[0] === key) {
              return element[1];
            }
          }
        }
        return;
      }
      const hashedKey = this.hash(key);
      const bucket = this.map[hashedKey];
      if (!bucket) {
        return;
      }
      for (let i = 0; i < bucket.length; i += 1) {
        const element = bucket[i];
        if (element[0] === key) {
          return element[1];
        }
      }
    };
    return _ObjectMap2;
  }();

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/clone.js
  var clone = /* @__PURE__ */ _curry1(function clone2(value) {
    return value != null && typeof value.clone === "function" ? value.clone() : _clone(value, true);
  });
  var clone_default = clone;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_identity.js
  function _identity(x) {
    return x;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/identity.js
  var identity = /* @__PURE__ */ _curry1(_identity);
  var identity_default = identity;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_Set.js
  var _Set = /* @__PURE__ */ function() {
    function _Set2() {
      this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
      this._items = {};
    }
    _Set2.prototype.add = function(item) {
      return !hasOrAdd(item, true, this);
    };
    _Set2.prototype.has = function(item) {
      return hasOrAdd(item, false, this);
    };
    return _Set2;
  }();
  function hasOrAdd(item, shouldAdd, set2) {
    var type3 = typeof item;
    var prevSize, newSize;
    switch (type3) {
      case "string":
      case "number":
        if (item === 0 && 1 / item === -Infinity) {
          if (set2._items["-0"]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items["-0"] = true;
            }
            return false;
          }
        }
        if (set2._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set2._nativeSet.size;
            set2._nativeSet.add(item);
            newSize = set2._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set2._nativeSet.has(item);
          }
        } else {
          if (!(type3 in set2._items)) {
            if (shouldAdd) {
              set2._items[type3] = {};
              set2._items[type3][item] = true;
            }
            return false;
          } else if (item in set2._items[type3]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items[type3][item] = true;
            }
            return false;
          }
        }
      case "boolean":
        if (type3 in set2._items) {
          var bIdx = item ? 1 : 0;
          if (set2._items[type3][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items[type3][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set2._items[type3] = item ? [false, true] : [true, false];
          }
          return false;
        }
      case "function":
        if (set2._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set2._nativeSet.size;
            set2._nativeSet.add(item);
            newSize = set2._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set2._nativeSet.has(item);
          }
        } else {
          if (!(type3 in set2._items)) {
            if (shouldAdd) {
              set2._items[type3] = [item];
            }
            return false;
          }
          if (!_includes(item, set2._items[type3])) {
            if (shouldAdd) {
              set2._items[type3].push(item);
            }
            return false;
          }
          return true;
        }
      case "undefined":
        if (set2._items[type3]) {
          return true;
        } else {
          if (shouldAdd) {
            set2._items[type3] = true;
          }
          return false;
        }
      case "object":
        if (item === null) {
          if (!set2._items["null"]) {
            if (shouldAdd) {
              set2._items["null"] = true;
            }
            return false;
          }
          return true;
        }
      default:
        type3 = Object.prototype.toString.call(item);
        if (!(type3 in set2._items)) {
          if (shouldAdd) {
            set2._items[type3] = [item];
          }
          return false;
        }
        if (!_includes(item, set2._items[type3])) {
          if (shouldAdd) {
            set2._items[type3].push(item);
          }
          return false;
        }
        return true;
    }
  }
  var Set_default = _Set;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_xuniqBy.js
  var XUniqBy = /* @__PURE__ */ function() {
    function XUniqBy2(f2, xf) {
      this.xf = xf;
      this.f = f2;
      this.set = new Set_default();
    }
    XUniqBy2.prototype["@@transducer/init"] = xfBase_default.init;
    XUniqBy2.prototype["@@transducer/result"] = xfBase_default.result;
    XUniqBy2.prototype["@@transducer/step"] = function(result, input) {
      return this.set.add(this.f(input)) ? this.xf["@@transducer/step"](result, input) : result;
    };
    return XUniqBy2;
  }();
  function _xuniqBy(f2) {
    return function(xf) {
      return new XUniqBy(f2, xf);
    };
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/uniqBy.js
  var uniqBy = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable([], _xuniqBy, function(fn, list) {
      var set2 = new Set_default();
      var result = [];
      var idx = 0;
      var appliedItem, item;
      while (idx < list.length) {
        item = list[idx];
        appliedItem = fn(item);
        if (set2.add(appliedItem)) {
          result.push(item);
        }
        idx += 1;
      }
      return result;
    })
  );
  var uniqBy_default = uniqBy;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/uniq.js
  var uniq = /* @__PURE__ */ uniqBy_default(identity_default);
  var uniq_default = uniq;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/trim.js
  var hasProtoTrim = typeof String.prototype.trim === "function";

  // ../abi-typegen/dist/cli.mjs
  var import_path10 = __require2("path");
  var import_path11 = __require2("path");
  var import_fs3 = __require2("fs");
  var import_fs4 = __require2("fs");
  var __defProp4 = Object.defineProperty;
  var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField4 = (obj, key, value) => {
    __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function findType(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  var Configurable = class {
    name;
    type;
    rawAbiConfigurable;
    constructor(params) {
      const { types: types2, rawAbiConfigurable } = params;
      this.name = rawAbiConfigurable.name;
      this.rawAbiConfigurable = rawAbiConfigurable;
      this.type = findType({ types: types2, typeId: rawAbiConfigurable.configurableType.type });
    }
  };
  function makeConfigurable(params) {
    const { types: types2, rawAbiConfigurable } = params;
    return new Configurable({ types: types2, rawAbiConfigurable });
  }
  function parseConfigurables(params) {
    const { types: types2, rawAbiConfigurables } = params;
    const configurables = rawAbiConfigurables.map(
      (rawAbiConfigurable) => makeConfigurable({ types: types2, rawAbiConfigurable })
    );
    return configurables;
  }
  function parseTypeArguments(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      let currentLabel;
      const currentTypeId = typeArgument.type;
      try {
        const currentType = findType({ types: types2, typeId: currentTypeId });
        currentLabel = currentType.attributes[attributeKey];
      } catch (_err) {
        currentLabel = "void";
      }
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output3 = buffer.join(", ");
    if (parentLabel) {
      output3 = `${parentLabel}<${output3}>`;
    }
    return output3;
  }
  var Function2 = class {
    name;
    types;
    rawAbiFunction;
    attributes;
    constructor(params) {
      this.rawAbiFunction = params.rawAbiFunction;
      this.types = params.types;
      this.name = params.rawAbiFunction.name;
      this.attributes = {
        inputs: this.bundleInputTypes(),
        output: this.bundleOutputTypes(),
        prefixedInputs: this.bundleInputTypes(true)
      };
    }
    bundleInputTypes(shouldPrefixParams = false) {
      const { types: types2 } = this;
      const inputs = this.rawAbiFunction.inputs.map((input) => {
        const { name, type: typeId, typeArguments } = input;
        const type3 = findType({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments({
            types: types2,
            target: "input",
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          typeDecl = type3.attributes.inputLabel;
        }
        if (shouldPrefixParams) {
          return `${name}: ${typeDecl}`;
        }
        return typeDecl;
      });
      return inputs.join(", ");
    }
    bundleOutputTypes() {
      return parseTypeArguments({
        types: this.types,
        target: "output",
        typeArguments: [this.rawAbiFunction.output]
      });
    }
    getDeclaration() {
      const { name } = this;
      const { prefixedInputs, output: output3 } = this.attributes;
      const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output3}>`;
      return decl;
    }
  };
  function makeFunction(params) {
    const { types: types2, rawAbiFunction } = params;
    return new Function2({ types: types2, rawAbiFunction });
  }
  function parseFunctions(params) {
    const { types: types2, rawAbiFunctions } = params;
    const functions = rawAbiFunctions.map(
      (rawAbiFunction) => makeFunction({ types: types2, rawAbiFunction })
    );
    return functions;
  }
  var AType = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _ArrayType = class extends AType {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType = _ArrayType;
  __publicField4(ArrayType, "swayType", "[_; 2]");
  __publicField4(ArrayType, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType = class extends AType {
    name = "str";
    static isSuitableFor(params) {
      return _StrType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType = _StrType;
  __publicField4(StrType, "swayType", "str[3]");
  __publicField4(StrType, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type = class extends StrType {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type = _B256Type;
  __publicField4(B256Type, "swayType", "b256");
  __publicField4(B256Type, "MATCH_REGEX", /^b256$/m);
  var _B512Type = class extends B256Type {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type = _B512Type;
  __publicField4(B512Type, "swayType", "struct B512");
  __publicField4(B512Type, "MATCH_REGEX", /^struct B512$/m);
  var _BoolType = class extends AType {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType = _BoolType;
  __publicField4(BoolType, "swayType", "bool");
  __publicField4(BoolType, "MATCH_REGEX", /^bool$/m);
  var _BytesType = class extends ArrayType {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType = _BytesType;
  __publicField4(BytesType, "swayType", "struct Bytes");
  __publicField4(BytesType, "MATCH_REGEX", /^struct Bytes/m);
  function extractStructName(params) {
    const { rawAbiType, regex } = params;
    const match3 = rawAbiType.type.match(params.regex)?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _EnumType = class extends AType {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _EnumType.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash4, row) => ({
          ...hash4,
          [row.rawAbiType.typeId]: row
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => !typeHash[type3])) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const { attributes } = findType({ types: types2, typeId });
        return `${name}: ${attributes[attributeKey]}`;
      });
      return contents.join(", ");
    }
  };
  var EnumType = _EnumType;
  __publicField4(EnumType, "swayType", "enum MyEnumName");
  __publicField4(EnumType, "MATCH_REGEX", /^enum (.+)$/m);
  __publicField4(EnumType, "IGNORE_REGEX", /^enum Option$/m);
  var _EvmAddressType = class extends AType {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType = _EvmAddressType;
  __publicField4(EvmAddressType, "swayType", "struct EvmAddress");
  __publicField4(EvmAddressType, "MATCH_REGEX", /^struct EvmAddress$/m);
  var _GenericType = class extends AType {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _GenericType.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType = _GenericType;
  __publicField4(GenericType, "swayType", "generic T");
  __publicField4(GenericType, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _OptionType = class extends AType {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType = _OptionType;
  __publicField4(OptionType, "swayType", "enum Option");
  __publicField4(OptionType, "MATCH_REGEX", /^enum Option$/m);
  var _U8Type = class extends AType {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type = _U8Type;
  __publicField4(U8Type, "swayType", "u8");
  __publicField4(U8Type, "MATCH_REGEX", /^u8$/m);
  var _U64Type = class extends U8Type {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type = _U64Type;
  __publicField4(U64Type, "swayType", "u64");
  __publicField4(U64Type, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr = class extends U64Type {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr = _RawUntypedPtr;
  __publicField4(RawUntypedPtr, "swayType", "raw untyped ptr");
  __publicField4(RawUntypedPtr, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice = class extends ArrayType {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice = _RawUntypedSlice;
  __publicField4(RawUntypedSlice, "swayType", "raw untyped slice");
  __publicField4(RawUntypedSlice, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType = class extends AType {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType = _StdStringType;
  __publicField4(StdStringType, "swayType", "struct String");
  __publicField4(StdStringType, "MATCH_REGEX", /^struct String/m);
  var _StrSliceType = class extends AType {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "StrSlice",
        outputLabel: "StrSlice"
      };
      return this.attributes;
    }
  };
  var StrSliceType = _StrSliceType;
  __publicField4(StrSliceType, "swayType", "str");
  __publicField4(StrSliceType, "MATCH_REGEX", /^str$/m);
  var _StructType = class extends AType {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _StructType.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType = _StructType;
  __publicField4(StructType, "swayType", "struct MyStruct");
  __publicField4(StructType, "MATCH_REGEX", /^struct (.+)$/m);
  __publicField4(StructType, "IGNORE_REGEX", /^struct (Vec|RawVec|EvmAddress|Bytes|String)$/m);
  var _TupleType = class extends AType {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType = _TupleType;
  __publicField4(TupleType, "swayType", "(_, _, _)");
  __publicField4(TupleType, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type = class extends U8Type {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type = _U16Type;
  __publicField4(U16Type, "swayType", "u16");
  __publicField4(U16Type, "MATCH_REGEX", /^u16$/m);
  var _U256Type = class extends U64Type {
    name = "u256";
    static isSuitableFor(params) {
      return _U256Type.MATCH_REGEX.test(params.type);
    }
  };
  var U256Type = _U256Type;
  __publicField4(U256Type, "swayType", "u256");
  __publicField4(U256Type, "MATCH_REGEX", /^u256$/m);
  var _U32Type = class extends U8Type {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type = _U32Type;
  __publicField4(U32Type, "swayType", "u32");
  __publicField4(U32Type, "MATCH_REGEX", /^u32$/m);
  var _VectorType = class extends ArrayType {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType = _VectorType;
  __publicField4(VectorType, "swayType", "struct Vec");
  __publicField4(VectorType, "MATCH_REGEX", /^struct Vec/m);
  __publicField4(VectorType, "IGNORE_REGEX", /^struct RawVec$/m);
  var supportedTypes = [
    ArrayType,
    B256Type,
    B512Type,
    BoolType,
    BytesType,
    EnumType,
    GenericType,
    OptionType,
    RawUntypedPtr,
    RawUntypedSlice,
    StdStringType,
    StrType,
    StrSliceType,
    StructType,
    TupleType,
    U16Type,
    U32Type,
    U64Type,
    U256Type,
    U8Type,
    VectorType,
    EvmAddressType
  ];
  function makeType(params) {
    const { rawAbiType } = params;
    const { type: type3 } = rawAbiType;
    const TypeClass = supportedTypes.find((tc) => tc.isSuitableFor({ type: type3 }));
    if (!TypeClass) {
      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Type not supported: ${type3}`);
    }
    return new TypeClass(params);
  }
  function shouldSkipAbiType(params) {
    const ignoreList = ["()", "struct RawVec"];
    const shouldSkip = ignoreList.indexOf(params.type) >= 0;
    return shouldSkip;
  }
  function parseTypes(params) {
    const types2 = [];
    params.rawAbiTypes.forEach((rawAbiType) => {
      const { type: type3 } = rawAbiType;
      const skip = shouldSkipAbiType({ type: type3 });
      if (!skip) {
        const parsedType = makeType({ rawAbiType });
        types2.push(parsedType);
      }
    });
    types2.forEach((type3) => {
      type3.parseComponentsAttributes({ types: types2 });
    });
    return types2;
  }
  var Abi = class {
    name;
    programType;
    filepath;
    outputDir;
    commonTypesInUse = [];
    rawContents;
    hexlifiedBinContents;
    storageSlotsContents;
    types;
    functions;
    configurables;
    constructor(params) {
      const {
        filepath,
        outputDir,
        rawContents,
        hexlifiedBinContents,
        programType,
        storageSlotsContents
      } = params;
      const abiNameRegex = /([^/]+)-abi\.json$/m;
      const abiName = filepath.match(abiNameRegex);
      const couldNotParseName = !abiName || abiName.length === 0;
      if (couldNotParseName) {
        throw new FuelError(
          ErrorCode.PARSE_FAILED,
          `Could not parse name from ABI file: ${filepath}.`
        );
      }
      const name = `${normalizeString(abiName[1])}Abi`;
      this.name = name;
      this.programType = programType;
      this.filepath = filepath;
      this.rawContents = rawContents;
      this.hexlifiedBinContents = hexlifiedBinContents;
      this.storageSlotsContents = storageSlotsContents;
      this.outputDir = outputDir;
      const { types: types2, functions, configurables } = this.parse();
      this.types = types2;
      this.functions = functions;
      this.configurables = configurables;
      this.computeCommonTypesInUse();
    }
    parse() {
      const {
        types: rawAbiTypes,
        functions: rawAbiFunctions,
        configurables: rawAbiConfigurables
      } = this.rawContents;
      const types2 = parseTypes({ rawAbiTypes });
      const functions = parseFunctions({ rawAbiFunctions, types: types2 });
      const configurables = parseConfigurables({ rawAbiConfigurables, types: types2 });
      return {
        types: types2,
        functions,
        configurables
      };
    }
    computeCommonTypesInUse() {
      const customTypesTable = {
        option: "Option",
        enum: "Enum",
        vector: "Vec"
      };
      this.commonTypesInUse = [];
      Object.keys(customTypesTable).forEach((typeName) => {
        const isInUse = !!this.types.find((t) => t.name === typeName);
        if (isInUse) {
          const commonTypeLabel = customTypesTable[typeName];
          this.commonTypesInUse.push(commonTypeLabel);
        }
      });
    }
  };
  var ProgramTypeEnum = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum || {});
  var header_default = "/* Autogenerated file. Do not edit manually. */\n\n/* tslint:disable */\n/* eslint-disable */\n\n/*\n  Fuels version: {{FUELS}}\n  Forc version: {{FORC}}\n  Fuel-Core version: {{FUEL_CORE}}\n*/\n";
  function renderHbsTemplate(params) {
    const { data, template } = params;
    const options = {
      strict: true,
      noEscape: true
    };
    const renderTemplate = (0, import_handlebars.compile)(template, options);
    const renderHeaderTemplate = (0, import_handlebars.compile)(header_default, options);
    const text = renderTemplate({
      ...data,
      header: renderHeaderTemplate(versions)
    });
    return text.replace(/[\n]{3,}/gm, "\n\n");
  }
  var common_default = "{{header}}\n\n/*\n  Mimics Sway Enum, requires at least one Key-Value but\n  does not raise error on multiple pairs.\n  This is done in the abi-coder\n*/\nexport type Enum<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n  U[keyof U];\n\n/*\n  Mimics Sway Option and Vectors.\n  Vectors are treated like arrays in Typescript.\n*/\nexport type Option<T> = T | undefined;\n\nexport type Vec<T> = T[];\n";
  function renderCommonTemplate() {
    const text = renderHbsTemplate({ template: common_default });
    return text;
  }
  var common_default2 = "{{header}}\n\n{{#if isGeneratingContracts}}\n{{#each abis}}\nexport type { {{name}} } from './{{name}}';\n{{/each}}\n{{/if}}\n\n{{#if isGeneratingPredicates}}\n{{#each abis}}\nexport type { {{name}}Inputs } from './factories/{{name}}__factory';\n{{/each}}\n{{/if}}\n\n{{#each abis}}\nexport { {{name}}__factory } from './factories/{{name}}__factory';\n{{/each}}\n";
  function renderIndexTemplate(params) {
    const { abis } = params;
    const isGeneratingContracts = abis[0].programType === "contract";
    const isGeneratingPredicates = abis[0].programType === "predicate";
    const text = renderHbsTemplate({
      template: common_default2,
      data: { abis, isGeneratingContracts, isGeneratingPredicates }
    });
    return text;
  }
  var bytecode_default = "{{header}}\n\nexport default '{{hexlifiedBytecode}}'";
  function renderBytecodeTemplate(params) {
    const text = renderHbsTemplate({
      template: bytecode_default,
      data: {
        hexlifiedBytecode: params.hexlifiedBytecode
      }
    });
    return text;
  }
  function formatConfigurables(params) {
    const { configurables } = params;
    const formattedConfigurables = configurables.map((c) => {
      const {
        name,
        type: {
          attributes: { inputLabel }
        }
      } = c;
      return {
        configurableName: name,
        configurableType: inputLabel
      };
    });
    return { formattedConfigurables };
  }
  function formatEnums(params) {
    const { types: types2 } = params;
    const enums = types2.filter((t) => t.name === "enum").map((t) => {
      const et = t;
      const structName = et.getStructName();
      const inputValues = et.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = et.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const inputNativeValues = et.getNativeEnum({ types: types2 });
      const outputNativeValues = et.getNativeEnum({ types: types2 });
      return {
        structName,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues,
        // reduces duplication
        inputNativeValues,
        outputNativeValues
      };
    });
    return { enums };
  }
  var caseInsensitiveSort = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
  function formatImports(params) {
    const { types: types2, baseMembers = [] } = params;
    const members = types2.flatMap((t) => t.requiredFuelsMembersImports);
    const imports = uniq_default(baseMembers.concat(members).sort(caseInsensitiveSort));
    return {
      imports: imports.length ? imports : void 0
    };
  }
  function formatStructs(params) {
    const { types: types2 } = params;
    const structs = types2.filter((t) => t.name === "struct").map((t) => {
      const st = t;
      const structName = st.getStructName();
      const inputValues = st.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = st.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const typeAnnotations = st.getStructDeclaration({ types: types2 });
      return {
        structName,
        typeAnnotations,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues
        // reduces duplication
      };
    });
    return { structs };
  }
  var dts_default = `{{header}}

{{#if imports}}
import type {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if formattedConfigurables}}
export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};
{{/if}}

interface {{capitalizedName}}Interface extends Interface {
  functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };

  {{#each encoders}}
  encodeFunctionData(functionFragment: '{{functionName}}', values: [{{input}}]): Uint8Array;
  {{/each}}

  {{#each decoders}}
  decodeFunctionData(functionFragment: '{{functionName}}', data: BytesLike): DecodedValue;
  {{/each}}
}


export class {{capitalizedName}} extends Contract {
  interface: {{capitalizedName}}Interface;
  functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };
}
`;
  function renderDtsTemplate(params) {
    const { name: capitalizedName, types: types2, functions, commonTypesInUse, configurables } = params.abi;
    const functionsTypedefs = functions.map((f2) => f2.getDeclaration());
    const functionsFragments = functions.map((f2) => f2.name);
    const encoders = functions.map((f2) => ({
      functionName: f2.name,
      input: f2.attributes.inputs
    }));
    const decoders = functions.map((f2) => ({
      functionName: f2.name
    }));
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: [
        "Interface",
        "FunctionFragment",
        "DecodedValue",
        "Contract",
        "BytesLike",
        "InvokeFunction"
      ]
    });
    const { formattedConfigurables } = formatConfigurables({ configurables });
    const text = renderHbsTemplate({
      template: dts_default,
      data: {
        capitalizedName,
        commonTypesInUse: commonTypesInUse.join(", "),
        functionsTypedefs,
        functionsFragments,
        encoders,
        decoders,
        structs,
        enums,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  var factory_default = '{{header}}\n\nimport { Interface, Contract, ContractFactory } from "fuels";\nimport type { Provider, Account, AbstractAddress, BytesLike, DeployContractOptions, StorageSlot } from "fuels";\nimport type { {{capitalizedName}}, {{capitalizedName}}Interface } from "../{{capitalizedName}}";\n\nconst _abi = {{abiJsonString}};\n\nconst _storageSlots: StorageSlot[] = {{storageSlotsJsonString}};\n\nexport class {{capitalizedName}}__factory {\n  static readonly abi = _abi;\n\n  static readonly storageSlots = _storageSlots;\n\n  static createInterface(): {{capitalizedName}}Interface {\n    return new Interface(_abi) as unknown as {{capitalizedName}}Interface\n  }\n\n  static connect(\n    id: string | AbstractAddress,\n    accountOrProvider: Account | Provider\n  ): {{capitalizedName}} {\n    return new Contract(id, _abi, accountOrProvider) as unknown as {{capitalizedName}}\n  }\n\n  static async deployContract(\n    bytecode: BytesLike,\n    wallet: Account,\n    options: DeployContractOptions = {}\n  ): Promise<{{capitalizedName}}> {\n    const factory = new ContractFactory(bytecode, _abi, wallet);\n\n    const { storageSlots } = {{capitalizedName}}__factory;\n\n    const contract = await factory.deployContract({\n      storageSlots,\n      ...options,\n    });\n\n    return contract as unknown as {{capitalizedName}};\n  }\n}\n';
  function renderFactoryTemplate(params) {
    const { name: capitalizedName, rawContents, storageSlotsContents } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate({
      template: factory_default,
      data: { capitalizedName, abiJsonString, storageSlotsJsonString }
    });
    return text;
  }
  function assembleContracts(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const dtsFilepath = `${outputDir}/${name}.d.ts`;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const hexBinFilePath = `${outputDir}/${name}.hex.ts`;
      const dts = {
        path: dtsFilepath,
        contents: renderDtsTemplate({ abi })
      };
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate({ abi })
      };
      const hexBinFile = {
        path: hexBinFilePath,
        contents: renderBytecodeTemplate({
          hexlifiedBytecode: abi.hexlifiedBinContents
        })
      };
      files.push(dts);
      files.push(factory);
      files.push(hexBinFile);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path9.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate()
      };
      files.push(file);
    }
    return files;
  }
  var factory_default2 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};

export type {{capitalizedName}}Inputs = [{{inputs}}];

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin;

  static createInstance(provider: Provider, predicateData?: {{capitalizedName}}Inputs, configurables?: {{capitalizedName}}Configurables) {

    const { abi, bin } = {{capitalizedName}}__factory

    const predicate = new Predicate<{{capitalizedName}}Inputs>({
      bytecode: bin,
      abi,
      provider,
      inputData: predicateData,
      configurableConstants: configurables,
    })

    return predicate;

  }

}
`;
  function renderFactoryTemplate2(params) {
    const { abi } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      name: capitalizedName,
      hexlifiedBinContents: hexlifiedBinString
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: ["Predicate", "Provider", "InputValue"]
    });
    const { formattedConfigurables } = formatConfigurables({ configurables });
    const { prefixedInputs: inputs, output: output3 } = func.attributes;
    const text = renderHbsTemplate({
      template: factory_default2,
      data: {
        inputs,
        output: output3,
        structs,
        enums,
        abiJsonString,
        hexlifiedBinString,
        capitalizedName,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  function assemblePredicates(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate2({ abi })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path10.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate()
      };
      files.push(file);
    }
    return files;
  }
  var factory_default3 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

type {{capitalizedName}}Inputs = [{{inputs}}];
type {{capitalizedName}}Output = {{output}};

{{#if formattedConfigurables}}
export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};
{{/if}}

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin

  static createInstance(wallet: Account) {

    const { abi, bin } = {{capitalizedName}}__factory

    const script = new Script<
      {{capitalizedName}}Inputs,
      {{capitalizedName}}Output
    >(bin, abi, wallet);

    return script;

  }

}
`;
  function renderFactoryTemplate3(params) {
    const { abi } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      name: capitalizedName,
      hexlifiedBinContents: hexlifiedBinString
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({ types: types2, baseMembers: ["Script", "Account"] });
    const { formattedConfigurables } = formatConfigurables({ configurables });
    const { prefixedInputs: inputs, output: output3 } = func.attributes;
    const text = renderHbsTemplate({
      template: factory_default3,
      data: {
        inputs,
        output: output3,
        structs,
        enums,
        abiJsonString,
        hexlifiedBinString,
        capitalizedName,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  function assembleScripts(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate3({ abi })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path11.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate()
      };
      files.push(file);
    }
    return files;
  }
  var upperFirst = (s) => s[0].toUpperCase() + s.slice(1);
  function validateBinFile(params) {
    const { abiFilepath, binFilepath, binExists, programType } = params;
    const isScript = programType === "script";
    if (!binExists && isScript) {
      throw new FuelError(
        ErrorCode.BIN_FILE_NOT_FOUND,
        [
          `Could not find BIN file for counterpart ${upperFirst(programType)} ABI.`,
          `  - ABI: ${abiFilepath}`,
          `  - BIN: ${binFilepath}`,
          programType
        ].join("\n")
      );
    }
  }
  var AbiTypeGen = class {
    abis;
    abiFiles;
    binFiles;
    storageSlotsFiles;
    outputDir;
    files;
    constructor(params) {
      const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles } = params;
      this.outputDir = outputDir;
      this.abiFiles = abiFiles;
      this.binFiles = binFiles;
      this.storageSlotsFiles = storageSlotsFiles;
      this.abis = this.abiFiles.map((abiFile) => {
        const binFilepath = abiFile.path.replace("-abi.json", ".bin");
        const relatedBinFile = this.binFiles.find(({ path: path5 }) => path5 === binFilepath);
        const storageSlotFilepath = abiFile.path.replace("-abi.json", "-storage_slots.json");
        const relatedStorageSlotsFile = this.storageSlotsFiles.find(
          ({ path: path5 }) => path5 === storageSlotFilepath
        );
        if (!relatedBinFile) {
          validateBinFile({
            abiFilepath: abiFile.path,
            binExists: !!relatedBinFile,
            binFilepath,
            programType
          });
        }
        const abi = new Abi({
          filepath: abiFile.path,
          rawContents: JSON.parse(abiFile.contents),
          hexlifiedBinContents: relatedBinFile?.contents,
          storageSlotsContents: relatedStorageSlotsFile?.contents,
          outputDir,
          programType
        });
        return abi;
      });
      this.files = this.getAssembledFiles({ programType });
    }
    getAssembledFiles(params) {
      const { abis, outputDir } = this;
      const { programType } = params;
      switch (programType) {
        case "contract":
          return assembleContracts({ abis, outputDir });
        case "script":
          return assembleScripts({ abis, outputDir });
        case "predicate":
          return assemblePredicates({ abis, outputDir });
        default:
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(
              ProgramTypeEnum
            )}`
          );
      }
    }
  };
  var collectBinFilepaths = (params) => {
    const { filepaths, programType } = params;
    const binFiles = filepaths.map((abiFilepath) => {
      const binFilepath = abiFilepath.replace("-abi.json", ".bin");
      const binExists = (0, import_fs3.existsSync)(binFilepath);
      validateBinFile({ abiFilepath, binFilepath, binExists, programType });
      const bin = {
        path: binFilepath,
        contents: hexlify((0, import_fs3.readFileSync)(binFilepath))
      };
      return bin;
    });
    return binFiles;
  };
  var collectStorageSlotsFilepaths = (params) => {
    const { filepaths, programType } = params;
    const storageSlotsFiles = [];
    if (programType !== "contract") {
      return storageSlotsFiles;
    }
    filepaths.forEach((abiFilepath) => {
      const storageSlotsFilepath = abiFilepath.replace("-abi.json", "-storage_slots.json");
      const storageSlotsExists = (0, import_fs4.existsSync)(storageSlotsFilepath);
      if (storageSlotsExists) {
        const storageSlots = {
          path: storageSlotsFilepath,
          contents: (0, import_fs4.readFileSync)(storageSlotsFilepath, "utf-8")
        };
        storageSlotsFiles.push(storageSlots);
      }
    });
    return storageSlotsFiles;
  };
  function runTypegen(params) {
    const { cwd, inputs, output: output3, silent, programType, filepaths: inputFilepaths } = params;
    const cwdBasename = (0, import_path8.basename)(cwd);
    function log2(...args) {
      if (!silent) {
        process.stdout.write(`${args.join(" ")}
`);
      }
    }
    let filepaths = [];
    if (!inputFilepaths?.length && inputs?.length) {
      filepaths = inputs.flatMap((i) => globSync(i, { cwd }));
    } else if (inputFilepaths?.length) {
      filepaths = inputFilepaths;
    } else {
      throw new FuelError(
        ErrorCode.MISSING_REQUIRED_PARAMETER,
        `At least one parameter should be supplied: 'input' or 'filepaths'.`
      );
    }
    const abiFiles = filepaths.map((filepath) => {
      const abi = {
        path: filepath,
        contents: (0, import_fs2.readFileSync)(filepath, "utf-8")
      };
      return abi;
    });
    if (!abiFiles.length) {
      throw new FuelError(ErrorCode.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);
    }
    const binFiles = collectBinFilepaths({ filepaths, programType });
    const storageSlotsFiles = collectStorageSlotsFilepaths({ filepaths, programType });
    const abiTypeGen = new AbiTypeGen({
      outputDir: output3,
      abiFiles,
      binFiles,
      storageSlotsFiles,
      programType
    });
    log2("Generating files..\n");
    import_mkdirp.default.sync(`${output3}/factories`);
    abiTypeGen.files.forEach((file) => {
      import_rimraf.default.sync(file.path);
      (0, import_fs2.writeFileSync)(file.path, file.contents);
      const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, "m");
      log2(` - ${file.path.replace(trimPathRegex, "")}`);
    });
    log2("\nDone.\u26A1");
  }
  function resolveProgramType(params) {
    const { contract, script, predicate } = params;
    const noneSpecified = !contract && !script && !predicate;
    if (contract || noneSpecified) {
      return "contract";
    }
    if (predicate) {
      return "predicate";
    }
    return "script";
  }
  function runCliAction(options) {
    const { inputs, output: output3, silent, contract, script, predicate } = options;
    const cwd = process.cwd();
    const programType = resolveProgramType({ contract, script, predicate });
    try {
      runTypegen({
        cwd,
        inputs,
        output: output3,
        programType,
        silent: !!silent
      });
    } catch (err) {
      process.stderr.write(`error: ${err.message}
`);
      process.exit(1);
    }
  }
  function configureCliOptions(program2) {
    return program2.requiredOption("-i, --inputs <path|glob...>", "Input paths/globals to your ABI JSON files").requiredOption("-o, --output <dir>", "Directory path for generated files").addOption(
      new Option("-c, --contract", "Generate types for Contracts [default]").conflicts(["script", "predicate"]).implies({ script: void 0, predicate: void 0 })
    ).addOption(
      new Option("-s, --script", "Generate types for Scripts").conflicts(["contract", "predicate"]).implies({ contract: void 0, predicate: void 0 })
    ).addOption(
      new Option("-p, --predicate", "Generate types for Predicates").conflicts(["contract", "script"]).implies({ contract: void 0, script: void 0 })
    ).option("-S, --silent", "Omit output messages").action(runCliAction);
  }

  // ../utils/dist/cli-utils.mjs
  var import_fs5 = __require2("fs");
  var import_path12 = __require2("path");
  var findBinPath = (binCommandName, startingDir) => {
    const cmdPath = (0, import_path12.join)(startingDir, "node_modules", ".bin", binCommandName);
    const parentDir = (0, import_path12.join)(startingDir, "..");
    if ((0, import_fs5.existsSync)(cmdPath)) {
      return cmdPath;
    }
    if (parentDir === startingDir) {
      throw new Error(`Command not found: ${binCommandName}`);
    }
    return findBinPath(binCommandName, parentDir);
  };

  // ../versions/dist/cli.mjs
  var import_chalk2 = __toESM(require_source(), 1);
  var import_cli_table = __toESM(require_lib2(), 1);
  var import_chalk3 = __toESM(require_source(), 1);
  var import_child_process = __require2("child_process");
  var colorizeUserVersion = (params) => {
    const { version: version2, isGt, isOk } = params;
    if (isGt) {
      return (0, import_chalk3.cyan)(version2);
    }
    if (isOk) {
      return (0, import_chalk3.green)(version2);
    }
    return (0, import_chalk3.red)(version2);
  };
  function getBuiltinVersions2() {
    return {
      FORC: "0.49.3",
      FUEL_CORE: "0.22.1",
      FUELS: "0.79.0"
    };
  }
  function parseVersion2(version2) {
    const [major, minor, patch] = version2.split(".").map((v) => parseInt(v, 10));
    return { major, minor, patch };
  }
  function versionDiffs2(version1, version2) {
    const semver1 = parseVersion2(version1);
    const semver2 = parseVersion2(version2);
    const major = semver1.major - semver2.major;
    const minor = semver1.minor - semver2.minor;
    const patch = semver1.patch - semver2.patch;
    return {
      major,
      minor,
      patch,
      fullVersionDiff: major || minor || patch
    };
  }
  function gt(version1, version2) {
    const { fullVersionDiff } = versionDiffs2(version1, version2);
    return fullVersionDiff > 0;
  }
  function eq(version1, version2) {
    const { fullVersionDiff } = versionDiffs2(version1, version2);
    return fullVersionDiff === 0;
  }
  function compareSystemVersions(params) {
    const { systemForcVersion, systemFuelCoreVersion } = params;
    const versions2 = getBuiltinVersions2();
    const systemForcIsGt = gt(systemForcVersion, versions2.FORC);
    const systemFuelCoreIsGt = gt(systemFuelCoreVersion, versions2.FUEL_CORE);
    const systemForcIsEq = eq(systemForcVersion, versions2.FORC);
    const systemFuelCoreIsEq = eq(systemFuelCoreVersion, versions2.FUEL_CORE);
    return {
      systemForcIsGt,
      systemFuelCoreIsGt,
      systemForcIsEq,
      systemFuelCoreIsEq
    };
  }
  var fuelUpLink = "https://github.com/fuellabs/fuelup";
  var versionReg = /[0-9]+\.[0-9]+\.[0-9]/;
  var getSystemVersion = (command) => {
    let version2 = null;
    let error2 = null;
    try {
      const contents = (0, import_child_process.execSync)(command).toString();
      if (versionReg.test(contents)) {
        version2 = contents.match(versionReg)?.[0];
      } else {
        throw new Error(contents);
      }
    } catch (err) {
      error2 = err;
    }
    return {
      error: error2,
      version: version2
    };
  };
  function getSystemForc() {
    const { error: error2, version: v } = getSystemVersion("forc --version");
    return { error: error2, systemForcVersion: v };
  }
  function getSystemFuelCore() {
    const { error: error2, version: v } = getSystemVersion("fuel-core --version");
    return { error: error2, systemFuelCoreVersion: v };
  }
  function getSystemVersions() {
    const { error: errorForc, systemForcVersion } = getSystemForc();
    const { error: errorCore, systemFuelCoreVersion } = getSystemFuelCore();
    const error2 = errorForc ?? errorCore;
    return {
      error: error2,
      systemForcVersion,
      systemFuelCoreVersion
    };
  }
  var eitherOr = (val1, val2) => val1 ?? val2;
  function runVersions() {
    const { error: error2, info } = console;
    const supportedVersions = getBuiltinVersions2();
    const cliTable = new import_cli_table.default({
      head: ["", (0, import_chalk2.bold)("Supported"), (0, import_chalk2.bold)(`Yours / System`)]
    });
    const { error: systemError, systemForcVersion, systemFuelCoreVersion } = getSystemVersions();
    const comparisons = compareSystemVersions({
      systemForcVersion: eitherOr(systemForcVersion, "0"),
      systemFuelCoreVersion: eitherOr(systemFuelCoreVersion, "0")
    });
    const userForcColorized = colorizeUserVersion({
      version: eitherOr(systemForcVersion, "\u2014"),
      isGt: comparisons.systemForcIsGt,
      isOk: comparisons.systemForcIsEq
    });
    const userFuelCoreColorized = colorizeUserVersion({
      version: eitherOr(systemFuelCoreVersion, "\u2014"),
      isGt: comparisons.systemFuelCoreIsGt,
      isOk: comparisons.systemFuelCoreIsEq
    });
    cliTable.push(["Forc", supportedVersions.FORC, userForcColorized]);
    cliTable.push(["Fuel-Core", supportedVersions.FUEL_CORE, userFuelCoreColorized]);
    const someIsGt = comparisons.systemForcIsGt || comparisons.systemFuelCoreIsGt;
    const bothAreExact = comparisons.systemForcIsEq && comparisons.systemFuelCoreIsEq;
    let exitCode;
    if (someIsGt) {
      exitCode = 0;
      info(cliTable.toString());
      info(`
Your system's components are newer than the ones supported!`);
    } else if (bothAreExact) {
      exitCode = 0;
      info(cliTable.toString());
      info(`
You have all the right versions! \u26A1`);
    } else if (systemError) {
      exitCode = 1;
      error2(cliTable.toString());
      error2("\n - Make sure you have Forc and Fuel-Core installed");
      error2("   >> Error: ", systemError.message);
    } else {
      exitCode = 1;
      error2(cliTable.toString());
      error2(`
 - You're using outdated versions`);
    }
    if (exitCode === 1) {
      error2(`  ${(0, import_chalk2.green)(fuelUpLink)}`);
    }
    process.exit(exitCode);
  }

  // src/cli/config/forcUtils.ts
  var import_fs6 = __require2("fs");
  var import_lodash = __toESM(require_lodash());
  var import_path13 = __require2("path");
  var import_toml = __toESM(require_toml());
  var forcFiles = /* @__PURE__ */ new Map();
  var swayFiles = /* @__PURE__ */ new Map();
  function readForcToml(path5) {
    const forcPath = (0, import_path13.join)(path5, "./Forc.toml");
    if (!(0, import_fs6.existsSync)(forcPath)) {
      throw new Error(`Toml file not found:
  ${forcPath}`);
    }
    if (!forcFiles.has(forcPath)) {
      const forcFile = (0, import_fs6.readFileSync)(forcPath, "utf8");
      const tomlParsed = import_toml.default.parse(forcFile);
      forcFiles.set(forcPath, tomlParsed);
    }
    const tomlContents = forcFiles.get(forcPath);
    return tomlContents;
  }
  function readSwayType(path5) {
    const forcToml = readForcToml(path5);
    const entryFile = forcToml.project.entry || "main.sw";
    const swayEntryPath = (0, import_path13.join)(path5, "src", entryFile);
    if (!swayFiles.has(swayEntryPath)) {
      const swayFile = (0, import_fs6.readFileSync)(swayEntryPath, "utf8");
      const [swayType] = swayFile.split(";\n");
      swayFiles.set(swayEntryPath, swayType);
    }
    return swayFiles.get(swayEntryPath);
  }
  function getContractName(contractPath) {
    const { project } = readForcToml(contractPath);
    return project.name;
  }
  function getContractCamelCase(contractPath) {
    const projectName = getContractName(contractPath);
    return (0, import_lodash.default)(projectName);
  }
  function getBinaryPath(contractPath, { buildMode }) {
    const projectName = getContractName(contractPath);
    return (0, import_path13.join)(contractPath, `/out/${buildMode}/${projectName}.bin`);
  }
  function getABIPath(contractPath, { buildMode }) {
    const projectName = getContractName(contractPath);
    return (0, import_path13.join)(contractPath, `/out/${buildMode}/${projectName}-abi.json`);
  }
  function getABIPaths(paths, config) {
    return Promise.all(paths.map((path5) => getABIPath(path5, config)));
  }
  var getStorageSlotsPath = (contractPath, { buildMode }) => {
    const projectName = getContractName(contractPath);
    return (0, import_path13.join)(contractPath, `/out/${buildMode}/${projectName}-storage_slots.json`);
  };

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  function bytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash(hash4) {
    if (typeof hash4 !== "function" || typeof hash4.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash4.outputLen);
    number(hash4.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/cryptoNode.js
  var nc = __toESM(__require2("crypto"), 1);
  var crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/utils.js
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  function isBytes2(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!isBytes2(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes2(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      if (!isBytes2(a))
        throw new Error("Uint8Array expected");
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad3 = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad3);
      pad3 += a.length;
    }
    return res;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var toStr = {}.toString;
  function checkOpts(defaults2, opts) {
    if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults2, opts);
    return merged;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto && typeof crypto.getRandomValues === "function") {
      return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  var SHA2 = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE3);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha256.js
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash {
    constructor(hash4, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash(hash4);
      const key = toBytes(_key);
      this.iHash = hash4.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad3 = new Uint8Array(blockLen);
      pad3.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
      for (let i = 0; i < pad3.length; i++)
        pad3[i] ^= 54;
      this.iHash.update(pad3);
      this.oHash = hash4.create();
      for (let i = 0; i < pad3.length; i++)
        pad3[i] ^= 54 ^ 92;
      this.oHash.update(pad3);
      pad3.fill(0);
    }
    update(buf) {
      exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists(this);
      bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash4, key, message) => new HMAC(hash4, key).update(message).digest();
  hmac.create = (hash4, key) => new HMAC(hash4, key);

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/pbkdf2.js
  function pbkdf2Init(hash4, _password, _salt, _opts) {
    hash(hash4);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    number(c);
    number(dkLen);
    number(asyncTick);
    if (c < 1)
      throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = toBytes(_password);
    const salt = toBytes(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash4, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    u.fill(0);
    return DK;
  }
  function pbkdf2(hash4, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash4, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/scrypt.js
  var rotl = (a, b) => a << b | a >>> 32 - b;
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i = 0; i < 8; i += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
      out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
      XorAndSalsa(out, tail, input, ii, out, head);
      if (i > 0)
        tail += 16;
      XorAndSalsa(out, head, input, ii += 16, out, tail);
    }
  }
  function scryptInit(password, salt, _opts) {
    const opts = checkOpts({
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    number(N);
    number(r);
    number(p);
    number(dkLen);
    number(asyncTick);
    number(maxmem);
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error("progressCb should be function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
      throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
    }
    if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
      throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    }
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
      throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    }
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
      throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    }
    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    const V = u32(new Uint8Array(blockSize * N));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => {
    };
    if (onProgress) {
      const totalBlockMix = 2 * N * p;
      const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
      let blockMixCnt = 0;
      blockMixCb = () => {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
          onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
  }
  function scrypt(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
      const Pi2 = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi2 + i];
      for (let i = 0, pos = 0; i < N - 1; i++) {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      }
      BlockMix(V, (N - 1) * blockSize32, B32, Pi2, r);
      blockMixCb();
      for (let i = 0; i < N; i++) {
        const j = B32[Pi2 + blockSize32 - 16] % N;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi2, r);
        blockMixCb();
      }
    }
    return scryptOutput(password, dkLen, B, V, tmp);
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha3.js
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _256n = /* @__PURE__ */ BigInt(256);
  var _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var Keccak = class extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists(this);
      const { blockLen, state } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes3) {
      number(bytes3);
      return this.xofInto(new Uint8Array(bytes3));
    }
    digestInto(out) {
      output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
  var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

  // ../crypto/dist/index.mjs
  var import_crypto8 = __toESM(__require2("crypto"), 1);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/_version.js
  var version = "6.7.1";

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/properties.js
  function checkType(value, type3, name) {
    const types2 = type3.split("|").map((t) => t.trim());
    for (let i = 0; i < types2.length; i++) {
      switch (type3) {
        case "any":
          return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          if (typeof value === type3) {
            return;
          }
      }
    }
    const error2 = new Error(`invalid value for type ${type3}`);
    error2.code = "INVALID_ARGUMENT";
    error2.argument = `value.${name}`;
    error2.value = value;
    throw error2;
  }
  function defineProperties(target, values, types2) {
    for (let key in values) {
      let value = values[key];
      const type3 = types2 ? types2[key] : null;
      if (type3) {
        checkType(value, type3, key);
      }
      Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/errors.js
  function stringify(value) {
    if (value == null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return "[ " + value.map(stringify).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
      const HEX = "0123456789abcdef";
      let result = "0x";
      for (let i = 0; i < value.length; i++) {
        result += HEX[value[i] >> 4];
        result += HEX[value[i] & 15];
      }
      return result;
    }
    if (typeof value === "object" && typeof value.toJSON === "function") {
      return stringify(value.toJSON());
    }
    switch (typeof value) {
      case "boolean":
      case "symbol":
        return value.toString();
      case "bigint":
        return BigInt(value).toString();
      case "number":
        return value.toString();
      case "string":
        return JSON.stringify(value);
      case "object": {
        const keys4 = Object.keys(value);
        keys4.sort();
        return "{ " + keys4.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
      }
    }
    return `[ COULD NOT SERIALIZE ]`;
  }
  function makeError(message, code, info) {
    {
      const details = [];
      if (info) {
        if ("message" in info || "code" in info || "name" in info) {
          throw new Error(`value will overwrite populated values: ${stringify(info)}`);
        }
        for (const key in info) {
          const value = info[key];
          details.push(key + "=" + stringify(value));
        }
      }
      details.push(`code=${code}`);
      details.push(`version=${version}`);
      if (details.length) {
        message += " (" + details.join(", ") + ")";
      }
    }
    let error2;
    switch (code) {
      case "INVALID_ARGUMENT":
        error2 = new TypeError(message);
        break;
      case "NUMERIC_FAULT":
      case "BUFFER_OVERRUN":
        error2 = new RangeError(message);
        break;
      default:
        error2 = new Error(message);
    }
    defineProperties(error2, { code });
    if (info) {
      Object.assign(error2, info);
    }
    return error2;
  }
  function assert(check, message, code, info) {
    if (!check) {
      throw makeError(message, code, info);
    }
  }
  function assertArgument(check, message, name, value) {
    assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
  }
  var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
    try {
      if ("test".normalize(form) !== "test") {
        throw new Error("bad");
      }
      ;
      if (form === "NFD") {
        const check = String.fromCharCode(233).normalize("NFD");
        const expected = String.fromCharCode(101, 769);
        if (check !== expected) {
          throw new Error("broken");
        }
      }
      accum.push(form);
    } catch (error2) {
    }
    return accum;
  }, []);
  function assertNormalize(form) {
    assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
      operation: "String.prototype.normalize",
      info: { form }
    });
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/data.js
  function _getBytes(value, name, copy) {
    if (value instanceof Uint8Array) {
      if (copy) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    assertArgument(false, "invalid BytesLike value", name || "value", value);
  }
  function getBytes(value, name) {
    return _getBytes(value, name, false);
  }
  function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (typeof length === "number" && value.length !== 2 + 2 * length) {
      return false;
    }
    if (length === true && value.length % 2 !== 0) {
      return false;
    }
    return true;
  }
  var HexCharacters2 = "0123456789abcdef";
  function hexlify2(data) {
    const bytes3 = getBytes(data);
    let result = "0x";
    for (let i = 0; i < bytes3.length; i++) {
      const v = bytes3[i];
      result += HexCharacters2[(v & 240) >> 4] + HexCharacters2[v & 15];
    }
    return result;
  }
  function dataSlice(data, start, end) {
    const bytes3 = getBytes(data);
    if (end != null && end > bytes3.length) {
      assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: bytes3,
        length: bytes3.length,
        offset: end
      });
    }
    return hexlify2(bytes3.slice(start == null ? 0 : start, end == null ? bytes3.length : end));
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/maths.js
  var BN_0 = BigInt(0);
  var BN_1 = BigInt(1);
  var maxValue = 9007199254740991;
  function getBigInt(value, name) {
    switch (typeof value) {
      case "bigint":
        return value;
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return BigInt(value);
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          if (value[0] === "-" && value[1] !== "-") {
            return -BigInt(value.substring(1));
          }
          return BigInt(value);
        } catch (e) {
          assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
        }
    }
    assertArgument(false, "invalid BigNumberish value", name || "value", value);
  }
  function getUint(value, name) {
    const result = getBigInt(value, name);
    assert(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value
    });
    return result;
  }
  var Nibbles = "0123456789abcdef";
  function toBigInt(value) {
    if (value instanceof Uint8Array) {
      let result = "0x0";
      for (const v of value) {
        result += Nibbles[v >> 4];
        result += Nibbles[v & 15];
      }
      return BigInt(result);
    }
    return getBigInt(value);
  }
  function getNumber(value, name) {
    switch (typeof value) {
      case "bigint":
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return Number(value);
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return value;
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          return getNumber(BigInt(value), name);
        } catch (e) {
          assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
        }
    }
    assertArgument(false, "invalid numeric value", name || "value", value);
  }
  function toBeHex(_value, _width) {
    const value = getUint(_value, "value");
    let result = value.toString(16);
    if (_width == null) {
      if (result.length % 2) {
        result = "0" + result;
      }
    } else {
      const width = getNumber(_width, "width");
      assert(width * 2 >= result.length, `value exceeds width (${width} bits)`, "NUMERIC_FAULT", {
        operation: "toBeHex",
        fault: "overflow",
        value: _value
      });
      while (result.length < width * 2) {
        result = "0" + result;
      }
    }
    return "0x" + result;
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/base58.js
  var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var Lookup = null;
  function getAlpha(letter) {
    if (Lookup == null) {
      Lookup = {};
      for (let i = 0; i < Alphabet.length; i++) {
        Lookup[Alphabet[i]] = BigInt(i);
      }
    }
    const result = Lookup[letter];
    assertArgument(result != null, `invalid base58 value`, "letter", letter);
    return result;
  }
  var BN_02 = BigInt(0);
  var BN_58 = BigInt(58);
  function encodeBase58(_value) {
    let value = toBigInt(getBytes(_value));
    let result = "";
    while (value) {
      result = Alphabet[Number(value % BN_58)] + result;
      value /= BN_58;
    }
    return result;
  }
  function decodeBase58(value) {
    let result = BN_02;
    for (let i = 0; i < value.length; i++) {
      result *= BN_58;
      result += getAlpha(value[i]);
    }
    return result;
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/utf8.js
  function errorFunc(reason, offset, bytes3, output3, badCodepoint) {
    assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
  }
  function ignoreFunc(reason, offset, bytes3, output3, badCodepoint) {
    if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
      let i = 0;
      for (let o = offset + 1; o < bytes3.length; o++) {
        if (bytes3[o] >> 6 !== 2) {
          break;
        }
        i++;
      }
      return i;
    }
    if (reason === "OVERRUN") {
      return bytes3.length - offset - 1;
    }
    return 0;
  }
  function replaceFunc(reason, offset, bytes3, output3, badCodepoint) {
    if (reason === "OVERLONG") {
      assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
      output3.push(badCodepoint);
      return 0;
    }
    output3.push(65533);
    return ignoreFunc(reason, offset, bytes3, output3, badCodepoint);
  }
  var Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
  });
  function getUtf8CodePoints(_bytes, onError) {
    if (onError == null) {
      onError = Utf8ErrorFuncs.error;
    }
    const bytes3 = getBytes(_bytes, "bytes");
    const result = [];
    let i = 0;
    while (i < bytes3.length) {
      const c = bytes3[i++];
      if (c >> 7 === 0) {
        result.push(c);
        continue;
      }
      let extraLength = null;
      let overlongMask = null;
      if ((c & 224) === 192) {
        extraLength = 1;
        overlongMask = 127;
      } else if ((c & 240) === 224) {
        extraLength = 2;
        overlongMask = 2047;
      } else if ((c & 248) === 240) {
        extraLength = 3;
        overlongMask = 65535;
      } else {
        if ((c & 192) === 128) {
          i += onError("UNEXPECTED_CONTINUE", i - 1, bytes3, result);
        } else {
          i += onError("BAD_PREFIX", i - 1, bytes3, result);
        }
        continue;
      }
      if (i - 1 + extraLength >= bytes3.length) {
        i += onError("OVERRUN", i - 1, bytes3, result);
        continue;
      }
      let res = c & (1 << 8 - extraLength - 1) - 1;
      for (let j = 0; j < extraLength; j++) {
        let nextChar = bytes3[i];
        if ((nextChar & 192) != 128) {
          i += onError("MISSING_CONTINUE", i, bytes3, result);
          res = null;
          break;
        }
        ;
        res = res << 6 | nextChar & 63;
        i++;
      }
      if (res === null) {
        continue;
      }
      if (res > 1114111) {
        i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes3, result, res);
        continue;
      }
      if (res >= 55296 && res <= 57343) {
        i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes3, result, res);
        continue;
      }
      if (res <= overlongMask) {
        i += onError("OVERLONG", i - 1 - extraLength, bytes3, result, res);
        continue;
      }
      result.push(res);
    }
    return result;
  }
  function toUtf8Bytes(str, form) {
    if (form != null) {
      assertNormalize(form);
      str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
      const c = str.charCodeAt(i);
      if (c < 128) {
        result.push(c);
      } else if (c < 2048) {
        result.push(c >> 6 | 192);
        result.push(c & 63 | 128);
      } else if ((c & 64512) == 55296) {
        i++;
        const c2 = str.charCodeAt(i);
        assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
        const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c >> 12 | 224);
        result.push(c >> 6 & 63 | 128);
        result.push(c & 63 | 128);
      }
    }
    return new Uint8Array(result);
  }
  function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
      if (codePoint <= 65535) {
        return String.fromCharCode(codePoint);
      }
      codePoint -= 65536;
      return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
    }).join("");
  }
  function toUtf8String(bytes3, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes3, onError));
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/crypto.js
  var import_crypto2 = __require2("crypto");

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/hmac.js
  var locked = false;
  var _computeHmac = function(algorithm, key, data) {
    return (0, import_crypto2.createHmac)(algorithm, key).update(data).digest();
  };
  var __computeHmac = _computeHmac;
  function computeHmac(algorithm, _key, _data) {
    const key = getBytes(_key, "key");
    const data = getBytes(_data, "data");
    return hexlify2(__computeHmac(algorithm, key, data));
  }
  computeHmac._ = _computeHmac;
  computeHmac.lock = function() {
    locked = true;
  };
  computeHmac.register = function(func) {
    if (locked) {
      throw new Error("computeHmac is locked");
    }
    __computeHmac = func;
  };
  Object.freeze(computeHmac);

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/_assert.js
  function number2(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bool(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  }
  function bytes2(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash2(hash4) {
    if (typeof hash4 !== "function" || typeof hash4.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number2(hash4.outputLen);
    number2(hash4.blockLen);
  }
  function exists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output2(out, instance) {
    bytes2(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert2 = {
    number: number2,
    bool,
    bytes: bytes2,
    hash: hash2,
    exists: exists2,
    output: output2
  };
  var assert_default = assert2;

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK642 = BigInt(2 ** 32 - 1);
  var _32n2 = BigInt(32);
  function fromBig2(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
    return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
  }
  function split2(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig2(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
  var shrSH = (h, l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H = (h, l) => l;
  var rotr32L = (h, l) => h;
  var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig: fromBig2,
    split: split2,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH: rotlSH2,
    rotlSL: rotlSL2,
    rotlBH: rotlBH2,
    rotlBL: rotlBL2,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var u64_default = u64;

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/utils.js
  var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE2)
    throw new Error("Non little-endian hardware is not supported");
  var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  function utf8ToBytes2(str) {
    if (typeof str !== "string") {
      throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
  }
  function toBytes2(data) {
    if (typeof data === "string")
      data = utf8ToBytes2(data);
    if (!(data instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
  }
  var Hash2 = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor2(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes2(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/sha3.js
  var [SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2] = [[], [], []];
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n2 = BigInt(2);
  var _7n2 = BigInt(7);
  var _256n2 = BigInt(256);
  var _0x71n2 = BigInt(113);
  for (let round = 0, R = _1n2, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI2.push(2 * (5 * y + x));
    SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n2;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n2 ^ (R >> _7n2) * _0x71n2) % _256n2;
      if (R & _2n2)
        t ^= _1n2 << (_1n2 << BigInt(j)) - _1n2;
    }
    _SHA3_IOTA2.push(t);
  }
  var [SHA3_IOTA_H2, SHA3_IOTA_L2] = u64_default.split(_SHA3_IOTA2, true);
  var rotlH2 = (h, l, s) => s > 32 ? u64_default.rotlBH(h, l, s) : u64_default.rotlSH(h, l, s);
  var rotlL2 = (h, l, s) => s > 32 ? u64_default.rotlBL(h, l, s) : u64_default.rotlSL(h, l, s);
  function keccakP2(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH2(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL2[t];
        const Th = rotlH2(curH, curL, shift);
        const Tl = rotlL2(curH, curL, shift);
        const PI = SHA3_PI2[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H2[round];
      s[1] ^= SHA3_IOTA_L2[round];
    }
    B.fill(0);
  }
  var Keccak2 = class extends Hash2 {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      assert_default.number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u322(this.state);
    }
    keccak() {
      keccakP2(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      assert_default.exists(this);
      const { blockLen, state } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      assert_default.exists(this, false);
      assert_default.bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes3) {
      assert_default.number(bytes3);
      return this.xofInto(new Uint8Array(bytes3));
    }
    digestInto(out) {
      assert_default.output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen2 = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak2(blockLen, suffix, outputLen));
  var sha3_2242 = gen2(6, 144, 224 / 8);
  var sha3_2562 = gen2(6, 136, 256 / 8);
  var sha3_3842 = gen2(6, 104, 384 / 8);
  var sha3_5122 = gen2(6, 72, 512 / 8);
  var keccak_2242 = gen2(1, 144, 224 / 8);
  var keccak_2562 = gen2(1, 136, 256 / 8);
  var keccak_3842 = gen2(1, 104, 384 / 8);
  var keccak_5122 = gen2(1, 72, 512 / 8);
  var genShake2 = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake1282 = genShake2(31, 168, 128 / 8);
  var shake2562 = genShake2(31, 136, 256 / 8);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/keccak.js
  var locked2 = false;
  var _keccak256 = function(data) {
    return keccak_2562(data);
  };
  var __keccak256 = _keccak256;
  function keccak256(_data) {
    const data = getBytes(_data, "data");
    return hexlify2(__keccak256(data));
  }
  keccak256._ = _keccak256;
  keccak256.lock = function() {
    locked2 = true;
  };
  keccak256.register = function(func) {
    if (locked2) {
      throw new TypeError("keccak256 is locked");
    }
    __keccak256 = func;
  };
  Object.freeze(keccak256);

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint642(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  var SHA22 = class extends Hash2 {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView2(this.buffer);
    }
    update(data) {
      assert_default.exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView2(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      assert_default.exists(this);
      assert_default.output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView2(out);
      this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE3));
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/ripemd160.js
  var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
  var Pi = Id.map((i) => (9 * i + 5) % 16);
  var idxL = [Id];
  var idxR = [Pi];
  for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
      j.push(j[i].map((k) => Rho[k]));
  var shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i) => new Uint8Array(i));
  var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
  var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
  var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
  var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
  var rotl2 = (word, shift) => word << shift | word >>> 32 - shift;
  function f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    else if (group === 1)
      return x & y | ~x & z;
    else if (group === 2)
      return (x | ~y) ^ z;
    else if (group === 3)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  var BUF = new Uint32Array(16);
  var RIPEMD160 = class extends SHA22 {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        BUF[i] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl[group], hbr = Kr[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL[group], sr = shiftsR[group];
        for (let i = 0; i < 16; i++) {
          const tl = rotl2(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
          al = el, el = dl, dl = rotl2(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i = 0; i < 16; i++) {
          const tr3 = rotl2(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
          ar = er, er = dr, dr = rotl2(cr, 10) | 0, cr = br, br = tr3;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = wrapConstructor2(() => new RIPEMD160());

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/ripemd160.js
  var locked3 = false;
  var _ripemd160 = function(data) {
    return ripemd160(data);
  };
  var __ripemd160 = _ripemd160;
  function ripemd1602(_data) {
    const data = getBytes(_data, "data");
    return hexlify2(__ripemd160(data));
  }
  ripemd1602._ = _ripemd160;
  ripemd1602.lock = function() {
    locked3 = true;
  };
  ripemd1602.register = function(func) {
    if (locked3) {
      throw new TypeError("ripemd160 is locked");
    }
    __ripemd160 = func;
  };
  Object.freeze(ripemd1602);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/pbkdf2.js
  var locked4 = false;
  var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
    return (0, import_crypto2.pbkdf2Sync)(password, salt, iterations, keylen, algo);
  };
  var __pbkdf2 = _pbkdf2;
  function pbkdf22(_password, _salt, iterations, keylen, algo) {
    const password = getBytes(_password, "password");
    const salt = getBytes(_salt, "salt");
    return hexlify2(__pbkdf2(password, salt, iterations, keylen, algo));
  }
  pbkdf22._ = _pbkdf2;
  pbkdf22.lock = function() {
    locked4 = true;
  };
  pbkdf22.register = function(func) {
    if (locked4) {
      throw new Error("pbkdf2 is locked");
    }
    __pbkdf2 = func;
  };
  Object.freeze(pbkdf22);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/address/address.js
  var BN_03 = BigInt(0);
  var BN_36 = BigInt(36);
  function getChecksumAddress(address) {
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
      expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = getBytes(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
      if (hashed[i >> 1] >> 4 >= 8) {
        chars[i] = chars[i].toUpperCase();
      }
      if ((hashed[i >> 1] & 15) >= 8) {
        chars[i + 1] = chars[i + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  }
  var ibanLookup = {};
  for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
  }
  for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
  }
  var safeDigits = 15;
  function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => {
      return ibanLookup[c];
    }).join("");
    while (expanded.length >= safeDigits) {
      let block2 = expanded.substring(0, safeDigits);
      expanded = parseInt(block2, 10) % 97 + expanded.substring(block2.length);
    }
    let checksum = String(98 - parseInt(expanded, 10) % 97);
    while (checksum.length < 2) {
      checksum = "0" + checksum;
    }
    return checksum;
  }
  var Base36 = function() {
    ;
    const result = {};
    for (let i = 0; i < 36; i++) {
      const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
      result[key] = BigInt(i);
    }
    return result;
  }();
  function fromBase36(value) {
    value = value.toLowerCase();
    let result = BN_03;
    for (let i = 0; i < value.length; i++) {
      result = result * BN_36 + Base36[value[i]];
    }
    return result;
  }
  function getAddress(address) {
    assertArgument(typeof address === "string", "invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      if (!address.startsWith("0x")) {
        address = "0x" + address;
      }
      const result = getChecksumAddress(address);
      assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
      return result;
    }
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
      let result = fromBase36(address.substring(4)).toString(16);
      while (result.length < 40) {
        result = "0" + result;
      }
      return getChecksumAddress("0x" + result);
    }
    assertArgument(false, "invalid address", "address", address);
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/transaction/accesslist.js
  function accessSetify(addr, storageKeys) {
    return {
      address: getAddress(addr),
      storageKeys: storageKeys.map((storageKey, index) => {
        assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
        return storageKey.toLowerCase();
      })
    };
  }
  function accessListify(value) {
    if (Array.isArray(value)) {
      return value.map((set2, index) => {
        if (Array.isArray(set2)) {
          assertArgument(set2.length === 2, "invalid slot set", `value[${index}]`, set2);
          return accessSetify(set2[0], set2[1]);
        }
        assertArgument(set2 != null && typeof set2 === "object", "invalid address-slot set", "value", value);
        return accessSetify(set2.address, set2.storageKeys);
      });
    }
    assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
    const result = Object.keys(value).map((addr) => {
      const storageKeys = value[addr].reduce((accum, storageKey) => {
        accum[storageKey] = true;
        return accum;
      }, {});
      return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => a.address.localeCompare(b.address));
    return result;
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/providers/plugins-network.js
  var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
  var NetworkPlugin = class {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    name;
    /**
     *  Creates a new **NetworkPlugin**.
     */
    constructor(name) {
      defineProperties(this, { name });
    }
    /**
     *  Creates a copy of this plugin.
     */
    clone() {
      return new NetworkPlugin(this.name);
    }
  };
  var GasCostPlugin = class extends NetworkPlugin {
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    effectiveBlock;
    /**
     *  The transactions base fee.
     */
    txBase;
    /**
     *  The fee for creating a new account.
     */
    txCreate;
    /**
     *  The fee per zero-byte in the data.
     */
    txDataZero;
    /**
     *  The fee per non-zero-byte in the data.
     */
    txDataNonzero;
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    txAccessListStorageKey;
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    txAccessListAddress;
    /**
     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
     *  latest block or another GasCostPlugin supercedes that block number,
     *  with the associated %%costs%%.
     */
    constructor(effectiveBlock, costs) {
      if (effectiveBlock == null) {
        effectiveBlock = 0;
      }
      super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
      const props = { effectiveBlock };
      function set2(name, nullish) {
        let value = (costs || {})[name];
        if (value == null) {
          value = nullish;
        }
        assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
        props[name] = value;
      }
      set2("txBase", 21e3);
      set2("txCreate", 32e3);
      set2("txDataZero", 4);
      set2("txDataNonzero", 16);
      set2("txAccessListStorageKey", 1900);
      set2("txAccessListAddress", 2400);
      defineProperties(this, props);
    }
    clone() {
      return new GasCostPlugin(this.effectiveBlock, this);
    }
  };
  var EnsPlugin = class extends NetworkPlugin {
    /**
     *  The ENS Registrty Contract address.
     */
    address;
    /**
     *  The chain ID that the ENS contract lives on.
     */
    targetNetwork;
    /**
     *  Creates a new **EnsPlugin** connected to %%address%% on the
     *  %%targetNetwork%%. The default ENS address and mainnet is used
     *  if unspecified.
     */
    constructor(address, targetNetwork) {
      super("org.ethers.plugins.network.Ens");
      defineProperties(this, {
        address: address || EnsAddress,
        targetNetwork: targetNetwork == null ? 1 : targetNetwork
      });
    }
    clone() {
      return new EnsPlugin(this.address, this.targetNetwork);
    }
  };
  var FetchUrlFeeDataNetworkPlugin = class extends NetworkPlugin {
    #url;
    #processFunc;
    /**
     *  The URL to initialize the FetchRequest with in %%processFunc%%.
     */
    get url() {
      return this.#url;
    }
    /**
     *  The callback to use when computing the FeeData.
     */
    get processFunc() {
      return this.#processFunc;
    }
    /**
     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
     *  be used when computing the fee data for the network.
     */
    constructor(url, processFunc) {
      super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
      this.#url = url;
      this.#processFunc = processFunc;
    }
    // We are immutable, so we can serve as our own clone
    clone() {
      return this;
    }
  };

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/providers/network.js
  var Networks = /* @__PURE__ */ new Map();
  var Network = class {
    #name;
    #chainId;
    #plugins;
    /**
     *  Creates a new **Network** for %%name%% and %%chainId%%.
     */
    constructor(name, chainId) {
      this.#name = name;
      this.#chainId = getBigInt(chainId);
      this.#plugins = /* @__PURE__ */ new Map();
    }
    /**
     *  Returns a JSON-compatible representation of a Network.
     */
    toJSON() {
      return { name: this.name, chainId: String(this.chainId) };
    }
    /**
     *  The network common name.
     *
     *  This is the canonical name, as networks migh have multiple
     *  names.
     */
    get name() {
      return this.#name;
    }
    set name(value) {
      this.#name = value;
    }
    /**
     *  The network chain ID.
     */
    get chainId() {
      return this.#chainId;
    }
    set chainId(value) {
      this.#chainId = getBigInt(value, "chainId");
    }
    /**
     *  Returns true if %%other%% matches this network. Any chain ID
     *  must match, and if no chain ID is present, the name must match.
     *
     *  This method does not currently check for additional properties,
     *  such as ENS address or plug-in compatibility.
     */
    matches(other) {
      if (other == null) {
        return false;
      }
      if (typeof other === "string") {
        try {
          return this.chainId === getBigInt(other);
        } catch (error2) {
        }
        return this.name === other;
      }
      if (typeof other === "number" || typeof other === "bigint") {
        try {
          return this.chainId === getBigInt(other);
        } catch (error2) {
        }
        return false;
      }
      if (typeof other === "object") {
        if (other.chainId != null) {
          try {
            return this.chainId === getBigInt(other.chainId);
          } catch (error2) {
          }
          return false;
        }
        if (other.name != null) {
          return this.name === other.name;
        }
        return false;
      }
      return false;
    }
    /**
     *  Returns the list of plugins currently attached to this Network.
     */
    get plugins() {
      return Array.from(this.#plugins.values());
    }
    /**
     *  Attach a new %%plugin%% to this Network. The network name
     *  must be unique, excluding any fragment.
     */
    attachPlugin(plugin) {
      if (this.#plugins.get(plugin.name)) {
        throw new Error(`cannot replace existing plugin: ${plugin.name} `);
      }
      this.#plugins.set(plugin.name, plugin.clone());
      return this;
    }
    /**
     *  Return the plugin, if any, matching %%name%% exactly. Plugins
     *  with fragments will not be returned unless %%name%% includes
     *  a fragment.
     */
    getPlugin(name) {
      return this.#plugins.get(name) || null;
    }
    /**
     *  Gets a list of all plugins that match %%name%%, with otr without
     *  a fragment.
     */
    getPlugins(basename3) {
      return this.plugins.filter((p) => p.name.split("#")[0] === basename3);
    }
    /**
     *  Create a copy of this Network.
     */
    clone() {
      const clone5 = new Network(this.name, this.chainId);
      this.plugins.forEach((plugin) => {
        clone5.attachPlugin(plugin.clone());
      });
      return clone5;
    }
    /**
     *  Compute the intrinsic gas required for a transaction.
     *
     *  A GasCostPlugin can be attached to override the default
     *  values.
     */
    computeIntrinsicGas(tx) {
      const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
      let gas = costs.txBase;
      if (tx.to == null) {
        gas += costs.txCreate;
      }
      if (tx.data) {
        for (let i = 2; i < tx.data.length; i += 2) {
          if (tx.data.substring(i, i + 2) === "00") {
            gas += costs.txDataZero;
          } else {
            gas += costs.txDataNonzero;
          }
        }
      }
      if (tx.accessList) {
        const accessList = accessListify(tx.accessList);
        for (const addr in accessList) {
          gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
        }
      }
      return gas;
    }
    /**
     *  Returns a new Network for the %%network%% name or chainId.
     */
    static from(network) {
      injectCommonNetworks();
      if (network == null) {
        return Network.from("mainnet");
      }
      if (typeof network === "number") {
        network = BigInt(network);
      }
      if (typeof network === "string" || typeof network === "bigint") {
        const networkFunc = Networks.get(network);
        if (networkFunc) {
          return networkFunc();
        }
        if (typeof network === "bigint") {
          return new Network("unknown", network);
        }
        assertArgument(false, "unknown network", "network", network);
      }
      if (typeof network.clone === "function") {
        const clone5 = network.clone();
        return clone5;
      }
      if (typeof network === "object") {
        assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
        const custom = new Network(network.name, network.chainId);
        if (network.ensAddress || network.ensNetwork != null) {
          custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
        }
        return custom;
      }
      assertArgument(false, "invalid network", "network", network);
    }
    /**
     *  Register %%nameOrChainId%% with a function which returns
     *  an instance of a Network representing that chain.
     */
    static register(nameOrChainId, networkFunc) {
      if (typeof nameOrChainId === "number") {
        nameOrChainId = BigInt(nameOrChainId);
      }
      const existing = Networks.get(nameOrChainId);
      if (existing) {
        assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
      }
      Networks.set(nameOrChainId, networkFunc);
    }
  };
  function parseUnits(_value, decimals) {
    const value = String(_value);
    if (!value.match(/^[0-9.]+$/)) {
      throw new Error(`invalid gwei value: ${_value}`);
    }
    const comps = value.split(".");
    if (comps.length === 1) {
      comps.push("");
    }
    if (comps.length !== 2) {
      throw new Error(`invalid gwei value: ${_value}`);
    }
    while (comps[1].length < decimals) {
      comps[1] += "0";
    }
    if (comps[1].length > 9) {
      let frac = BigInt(comps[1].substring(0, 9));
      if (!comps[1].substring(9).match(/^0+$/)) {
        frac++;
      }
      comps[1] = frac.toString();
    }
    return BigInt(comps[0] + comps[1]);
  }
  function getGasStationPlugin(url) {
    return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
      request.setHeader("User-Agent", "ethers");
      let response;
      try {
        const [_response, _feeData] = await Promise.all([
          request.send(),
          fetchFeeData()
        ]);
        response = _response;
        const payload = response.bodyJson.standard;
        const feeData = {
          gasPrice: _feeData.gasPrice,
          maxFeePerGas: parseUnits(payload.maxFee, 9),
          maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
        };
        return feeData;
      } catch (error2) {
        assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error: error2 });
      }
    });
  }
  function getPriorityFeePlugin(maxPriorityFeePerGas) {
    return new FetchUrlFeeDataNetworkPlugin("data:", async (fetchFeeData, provider, request) => {
      const feeData = await fetchFeeData();
      if (feeData.maxFeePerGas == null || feeData.maxPriorityFeePerGas == null) {
        return feeData;
      }
      const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;
      return {
        gasPrice: feeData.gasPrice,
        maxFeePerGas: baseFee + maxPriorityFeePerGas,
        maxPriorityFeePerGas
      };
    });
  }
  var injected = false;
  function injectCommonNetworks() {
    if (injected) {
      return;
    }
    injected = true;
    function registerEth(name, chainId, options) {
      const func = function() {
        const network = new Network(name, chainId);
        if (options.ensNetwork != null) {
          network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
        }
        network.attachPlugin(new GasCostPlugin());
        (options.plugins || []).forEach((plugin) => {
          network.attachPlugin(plugin);
        });
        return network;
      };
      Network.register(name, func);
      Network.register(chainId, func);
      if (options.altNames) {
        options.altNames.forEach((name2) => {
          Network.register(name2, func);
        });
      }
    }
    registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
    registerEth("ropsten", 3, { ensNetwork: 3 });
    registerEth("rinkeby", 4, { ensNetwork: 4 });
    registerEth("goerli", 5, { ensNetwork: 5 });
    registerEth("kovan", 42, { ensNetwork: 42 });
    registerEth("sepolia", 11155111, {});
    registerEth("classic", 61, {});
    registerEth("classicKotti", 6, {});
    registerEth("arbitrum", 42161, {
      ensNetwork: 1
    });
    registerEth("arbitrum-goerli", 421613, {});
    registerEth("bnb", 56, { ensNetwork: 1 });
    registerEth("bnbt", 97, {});
    registerEth("linea", 59144, { ensNetwork: 1 });
    registerEth("linea-goerli", 59140, {});
    registerEth("matic", 137, {
      ensNetwork: 1,
      plugins: [
        getGasStationPlugin("https://gasstation.polygon.technology/v2")
      ]
    });
    registerEth("matic-mumbai", 80001, {
      altNames: ["maticMumbai", "maticmum"],
      plugins: [
        getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
      ]
    });
    registerEth("optimism", 10, {
      ensNetwork: 1,
      plugins: [
        getPriorityFeePlugin(BigInt("1000000"))
      ]
    });
    registerEth("optimism-goerli", 420, {});
    registerEth("xdai", 100, { ensNetwork: 1 });
  }

  // ../crypto/dist/index.mjs
  var import_crypto9 = __toESM(__require2("crypto"), 1);
  var import_crypto10 = __toESM(__require2("crypto"), 1);
  var scrypt3 = (params) => {
    const { password, salt, n, p, r, dklen } = params;
    const derivedKey = scrypt(password, salt, { N: n, r, p, dkLen: dklen });
    return derivedKey;
  };
  var keccak2562 = (data) => keccak_256(data);
  var bufferFromString = (string2, encoding = "base64") => Uint8Array.from(Buffer.from(string2, encoding));
  var randomBytes4 = (length) => {
    const randomValues = Uint8Array.from(import_crypto9.default.randomBytes(length));
    return randomValues;
  };
  var stringFromBuffer = (buffer, encoding = "base64") => Buffer.from(buffer).toString(encoding);
  var ALGORITHM = "aes-256-ctr";
  var keyFromPassword = (password, saltBuffer) => {
    const passBuffer = bufferFromString(String(password).normalize("NFKC"), "utf-8");
    const key = pbkdf22(passBuffer, saltBuffer, 1e5, 32, "sha256");
    return arrayify(key);
  };
  var encrypt = async (password, data) => {
    const iv = randomBytes4(16);
    const salt = randomBytes4(32);
    const secret = keyFromPassword(password, salt);
    const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), "utf-8"));
    const cipher = await import_crypto8.default.createCipheriv(ALGORITHM, secret, iv);
    let cipherData = cipher.update(dataBuffer);
    cipherData = Buffer.concat([cipherData, cipher.final()]);
    return {
      data: stringFromBuffer(cipherData),
      iv: stringFromBuffer(iv),
      salt: stringFromBuffer(salt)
    };
  };
  var decrypt = async (password, keystore) => {
    const iv = bufferFromString(keystore.iv);
    const salt = bufferFromString(keystore.salt);
    const secret = keyFromPassword(password, salt);
    const encryptedText = bufferFromString(keystore.data);
    const decipher = await import_crypto8.default.createDecipheriv(ALGORITHM, secret, iv);
    const decrypted = decipher.update(encryptedText);
    const deBuff = Buffer.concat([decrypted, decipher.final()]);
    const decryptedData = Buffer.from(deBuff).toString("utf-8");
    try {
      return JSON.parse(decryptedData);
    } catch {
      throw new FuelError(ErrorCode.INVALID_CREDENTIALS, "Invalid credentials.");
    }
  };
  async function encryptJsonWalletData(data, key, iv) {
    const cipher = await import_crypto10.default.createCipheriv("aes-128-ctr", key.subarray(0, 16), iv);
    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
    return new Uint8Array(encrypted);
  }
  async function decryptJsonWalletData(data, key, iv) {
    const decipher = import_crypto10.default.createDecipheriv("aes-128-ctr", key.subarray(0, 16), iv);
    const decrypted = await Buffer.concat([decipher.update(data), decipher.final()]);
    return new Uint8Array(decrypted);
  }
  var api = {
    bufferFromString,
    stringFromBuffer,
    decrypt,
    encrypt,
    keyFromPassword,
    randomBytes: randomBytes4,
    scrypt: scrypt3,
    keccak256: keccak2562,
    decryptJsonWalletData,
    encryptJsonWalletData
  };
  var node_default = api;
  var {
    bufferFromString: bufferFromString2,
    decrypt: decrypt2,
    encrypt: encrypt2,
    keyFromPassword: keyFromPassword2,
    randomBytes: randomBytes22,
    stringFromBuffer: stringFromBuffer2,
    scrypt: scrypt22,
    keccak256: keccak25622,
    decryptJsonWalletData: decryptJsonWalletData2,
    encryptJsonWalletData: encryptJsonWalletData2
  } = node_default;

  // ../interfaces/dist/index.mjs
  var AbstractAddress = class {
  };
  var AbstractAccount = class {
  };
  var AbstractProgram = class {
  };
  var AbstractContract = class extends AbstractProgram {
  };

  // ../address/dist/index.mjs
  var import_bech32 = __toESM(require_dist(), 1);
  var FUEL_BECH32_HRP_PREFIX = "fuel";
  function fromBech32(address) {
    return import_bech32.bech32m.decode(address);
  }
  function toBech32(address) {
    return import_bech32.bech32m.encode(
      FUEL_BECH32_HRP_PREFIX,
      import_bech32.bech32m.toWords(arrayify(hexlify(address)))
    );
  }
  function isBech32(address) {
    return typeof address === "string" && address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 && fromBech32(address).prefix === FUEL_BECH32_HRP_PREFIX;
  }
  function isB256(address) {
    return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);
  }
  function isPublicKey(address) {
    return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);
  }
  function isEvmAddress(address) {
    return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);
  }
  function getBytesFromBech32(address) {
    return new Uint8Array(import_bech32.bech32m.fromWords(fromBech32(address).words));
  }
  function toB256(address) {
    if (!isBech32(address)) {
      throw new FuelError(
        FuelError.CODES.INVALID_BECH32_ADDRESS,
        `Invalid Bech32 Address: ${address}.`
      );
    }
    return hexlify(getBytesFromBech32(address));
  }
  function normalizeBech32(address) {
    const { words } = fromBech32(address);
    return import_bech32.bech32m.encode(FUEL_BECH32_HRP_PREFIX, words);
  }
  var addressify = (addressLike) => {
    if (addressLike instanceof AbstractAccount) {
      return addressLike.address;
    }
    if (addressLike instanceof AbstractContract) {
      return addressLike.id;
    }
    return addressLike;
  };
  var getRandomB256 = () => hexlify(randomBytes22(32));
  var clearFirst12BytesFromB256 = (b256) => {
    let bytes3;
    try {
      if (!isB256(b256)) {
        throw new FuelError(
          FuelError.CODES.INVALID_BECH32_ADDRESS,
          `Invalid Bech32 Address: ${b256}.`
        );
      }
      bytes3 = getBytesFromBech32(toBech32(b256));
      bytes3 = hexlify(bytes3.fill(0, 0, 12));
    } catch (error2) {
      throw new FuelError(
        FuelError.CODES.PARSE_FAILED,
        `Cannot generate EVM Address B256 from: ${b256}.`
      );
    }
    return bytes3;
  };
  var padFirst12BytesOfEvmAddress = (address) => {
    if (!isEvmAddress(address)) {
      throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
    }
    return address.replace("0x", "0x000000000000000000000000");
  };
  var Address = class extends AbstractAddress {
    // #region address-2
    bech32Address;
    // #endregion address-2
    /**
     * @param address - A Bech32 address
     */
    constructor(address) {
      super();
      this.bech32Address = normalizeBech32(address);
      if (!isBech32(this.bech32Address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_BECH32_ADDRESS,
          `Invalid Bech32 Address: ${address}.`
        );
      }
    }
    /**
     * Returns the `bech32Address` property
     *
     * @returns The `bech32Address` property
     */
    toAddress() {
      return this.bech32Address;
    }
    /**
     * Converts and returns the `bech32Address` property to a 256 bit hash string
     *
     * @returns The `bech32Address` property as a 256 bit hash string
     */
    toB256() {
      return toB256(this.bech32Address);
    }
    /**
     * Converts and returns the `bech32Address` property to a byte array
     *
     * @returns The `bech32Address` property as a byte array
     */
    toBytes() {
      return getBytesFromBech32(this.bech32Address);
    }
    /**
     * Converts
     *
     * @returns The `bech32Address` property as a 256 bit hash string
     */
    toHexString() {
      return this.toB256();
    }
    /**
     * Converts and returns the `bech32Address` property as a string
     *
     * @returns The `bech32Address` property as a string
     */
    toString() {
      return this.bech32Address;
    }
    /**
     * Converts and returns the `bech32Address` property as a string
     *
     * @returns The `bech32Address` property as a string
     */
    toJSON() {
      return this.bech32Address;
    }
    /**
     * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`
     *
     * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}
     */
    toEvmAddress() {
      const b256Address = toB256(this.bech32Address);
      return {
        value: clearFirst12BytesFromB256(b256Address)
      };
    }
    /**
     * Wraps the `bech32Address` property and returns as an `AssetId`.
     *
     * @returns The `bech32Address` property as an {@link AssetId | `AssetId`}
     */
    toAssetId() {
      return {
        value: this.toB256()
      };
    }
    /**
     * Returns the value of the `bech32Address` property
     *
     * @returns The value of `bech32Address` property
     */
    valueOf() {
      return this.bech32Address;
    }
    /**
     * Compares this the `bech32Address` property to another for direct equality
     *
     * @param other - Another address to compare against
     * @returns The equality of the comparison
     */
    equals(other) {
      return this.bech32Address === other.bech32Address;
    }
    /**
     * Takes a Public Key, hashes it, and creates an `Address`
     *
     * @param publicKey - A wallets public key
     * @returns A new `Address` instance
     */
    static fromPublicKey(publicKey) {
      if (!isPublicKey(publicKey)) {
        throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);
      }
      const b256Address = hexlify(sha256(arrayify(publicKey)));
      return new Address(toBech32(b256Address));
    }
    /**
     * Takes a B256 Address and creates an `Address`
     *
     * @param b256Address - A b256 hash
     * @returns A new `Address` instance
     */
    static fromB256(b256Address) {
      if (!isB256(b256Address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_B256_ADDRESS,
          `Invalid B256 Address: ${b256Address}.`
        );
      }
      return new Address(toBech32(b256Address));
    }
    /**
     * Creates an `Address` with a randomized `bech32Address` property
     *
     * @returns A new `Address` instance
     */
    static fromRandom() {
      return this.fromB256(getRandomB256());
    }
    /**
     * Takes an ambiguous string and attempts to create an `Address`
     *
     * @param address - An ambiguous string
     * @returns A new `Address` instance
     */
    static fromString(address) {
      return isBech32(address) ? new Address(address) : this.fromB256(address);
    }
    /**
     * Takes an ambiguous string or address and creates an `Address`
     *
     * @returns a new `Address` instance
     */
    static fromAddressOrString(address) {
      return typeof address === "string" ? this.fromString(address) : address;
    }
    /**
     * Takes a dynamic string or `AbstractAddress` and creates an `Address`
     *
     * @param addressId - A string containing Bech32, B256, or Public Key
     * @throws Error - Unknown address if the format is not recognised
     * @returns A new `Address` instance
     */
    static fromDynamicInput(address) {
      if (typeof address !== "string" && "toB256" in address) {
        return Address.fromB256(address.toB256());
      }
      if (isPublicKey(address)) {
        return Address.fromPublicKey(address);
      }
      if (isBech32(address)) {
        return new Address(address);
      }
      if (isB256(address)) {
        return Address.fromB256(address);
      }
      if (isEvmAddress(address)) {
        return Address.fromEvmAddress(address);
      }
      throw new FuelError(
        FuelError.CODES.PARSE_FAILED,
        `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`
      );
    }
    /**
     * Takes an Evm Address and returns back an `Address`
     *
     * @returns A new `Address` instance
     */
    static fromEvmAddress(evmAddress) {
      if (!isEvmAddress(evmAddress)) {
        throw new FuelError(
          FuelError.CODES.INVALID_EVM_ADDRESS,
          `Invalid Evm Address: ${evmAddress}.`
        );
      }
      const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);
      return new Address(toBech32(paddedAddress));
    }
  };

  // ../address/dist/configs.mjs
  var ZeroBytes32 = "0x0000000000000000000000000000000000000000000000000000000000000000";
  var BaseAssetId = ZeroBytes32;

  // ../math/dist/index.mjs
  var import_bn = __toESM(require_bn(), 1);
  var DEFAULT_PRECISION = 9;
  var DEFAULT_MIN_PRECISION = 3;
  var DECIMAL_UNITS = 9;
  function toFixed(value, options) {
    const { precision = DEFAULT_PRECISION, minPrecision = DEFAULT_MIN_PRECISION } = options || {};
    const [valueUnits = "0", valueDecimals = "0"] = String(value || "0.0").split(".");
    const groupRegex = /(\d)(?=(\d{3})+\b)/g;
    const units = valueUnits.replace(groupRegex, "$1,");
    let decimals = valueDecimals.slice(0, precision);
    if (minPrecision < precision) {
      const trimmedDecimal = decimals.match(/.*[1-9]{1}/);
      const lastNonZeroIndex = trimmedDecimal?.[0].length || 0;
      const keepChars = Math.max(minPrecision, lastNonZeroIndex);
      decimals = decimals.slice(0, keepChars);
    }
    const decimalPortion = decimals ? `.${decimals}` : "";
    return `${units}${decimalPortion}`;
  }
  var BN = class extends import_bn.default {
    MAX_U64 = "0xFFFFFFFFFFFFFFFF";
    constructor(value, base, endian) {
      let bnValue = value;
      let bnBase = base;
      if (BN.isBN(value)) {
        bnValue = value.toArray();
      } else if (typeof value === "string" && value.slice(0, 2) === "0x") {
        bnValue = value.substring(2);
        bnBase = base || "hex";
      }
      super(bnValue == null ? 0 : bnValue, bnBase, endian);
    }
    // ANCHOR: HELPERS
    // make sure we always include `0x` in hex strings
    toString(base, length) {
      const output3 = super.toString(base, length);
      if (base === 16 || base === "hex") {
        return `0x${output3}`;
      }
      return output3;
    }
    toHex(bytesPadding) {
      const bytes3 = bytesPadding || 0;
      const bytesLength = bytes3 * 2;
      if (this.isNeg()) {
        throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to hex.");
      }
      if (bytesPadding && this.byteLength() > bytesPadding) {
        throw new FuelError(
          ErrorCode.CONVERTING_FAILED,
          `Provided value ${this} is too large. It should fit within ${bytesPadding} bytes.`
        );
      }
      return this.toString(16, bytesLength);
    }
    toBytes(bytesPadding) {
      if (this.isNeg()) {
        throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to bytes.");
      }
      return Uint8Array.from(this.toArray(void 0, bytesPadding));
    }
    toJSON() {
      return this.toString(16);
    }
    valueOf() {
      return this.toString();
    }
    format(options) {
      const {
        units = DECIMAL_UNITS,
        precision = DEFAULT_PRECISION,
        minPrecision = DEFAULT_MIN_PRECISION
      } = options || {};
      const formattedUnits = this.formatUnits(units);
      const formattedFixed = toFixed(formattedUnits, { precision, minPrecision });
      if (!parseFloat(formattedFixed)) {
        const [, originalDecimals = "0"] = formattedUnits.split(".");
        const firstNonZero = originalDecimals.match(/[1-9]/);
        if (firstNonZero && firstNonZero.index && firstNonZero.index + 1 > precision) {
          const [valueUnits = "0"] = formattedFixed.split(".");
          return `${valueUnits}.${originalDecimals.slice(0, firstNonZero.index + 1)}`;
        }
      }
      return formattedFixed;
    }
    formatUnits(units = DECIMAL_UNITS) {
      const valueUnits = this.toString().slice(0, units * -1);
      const valueDecimals = this.toString().slice(units * -1);
      const length = valueDecimals.length;
      const defaultDecimals = Array.from({ length: units - length }).fill("0").join("");
      const integerPortion = valueUnits ? `${valueUnits}.` : "0.";
      return `${integerPortion}${defaultDecimals}${valueDecimals}`;
    }
    // END ANCHOR: HELPERS
    // ANCHOR: OVERRIDES to accept better inputs
    add(v) {
      return this.caller(v, "add");
    }
    pow(v) {
      return this.caller(v, "pow");
    }
    sub(v) {
      return this.caller(v, "sub");
    }
    div(v) {
      return this.caller(v, "div");
    }
    mul(v) {
      return this.caller(v, "mul");
    }
    mod(v) {
      return this.caller(v, "mod");
    }
    divRound(v) {
      return this.caller(v, "divRound");
    }
    lt(v) {
      return this.caller(v, "lt");
    }
    lte(v) {
      return this.caller(v, "lte");
    }
    gt(v) {
      return this.caller(v, "gt");
    }
    gte(v) {
      return this.caller(v, "gte");
    }
    eq(v) {
      return this.caller(v, "eq");
    }
    cmp(v) {
      return this.caller(v, "cmp");
    }
    // END ANCHOR: OVERRIDES to accept better inputs
    // ANCHOR: OVERRIDES to output our BN type
    sqr() {
      return new BN(super.sqr().toArray());
    }
    neg() {
      return new BN(super.neg().toArray());
    }
    abs() {
      return new BN(super.abs().toArray());
    }
    toTwos(width) {
      return new BN(super.toTwos(width).toArray());
    }
    fromTwos(width) {
      return new BN(super.fromTwos(width).toArray());
    }
    // END ANCHOR: OVERRIDES to output our BN type
    // ANCHOR: OVERRIDES to avoid losing references
    caller(v, methodName) {
      const output3 = super[methodName](new BN(v));
      if (BN.isBN(output3)) {
        return new BN(output3.toArray());
      }
      if (typeof output3 === "boolean") {
        return output3;
      }
      return output3;
    }
    clone() {
      return new BN(this.toArray());
    }
    mulTo(num, out) {
      const output3 = new import_bn.default(this.toArray()).mulTo(num, out);
      return new BN(output3.toArray());
    }
    egcd(p) {
      const { a, b, gcd } = new import_bn.default(this.toArray()).egcd(p);
      return {
        a: new BN(a.toArray()),
        b: new BN(b.toArray()),
        gcd: new BN(gcd.toArray())
      };
    }
    divmod(num, mode, positive) {
      const { div, mod: mod2 } = new import_bn.default(this.toArray()).divmod(new BN(num), mode, positive);
      return {
        div: new BN(div?.toArray()),
        mod: new BN(mod2?.toArray())
      };
    }
    maxU64() {
      return this.gte(this.MAX_U64) ? new BN(this.MAX_U64) : this;
    }
    normalizeZeroToOne() {
      return this.isZero() ? new BN(1) : this;
    }
    // END ANCHOR: OVERRIDES to avoid losing references
  };
  var bn = (value, base, endian) => new BN(value, base, endian);
  bn.parseUnits = (value, units = DECIMAL_UNITS) => {
    const valueToParse = value === "." ? "0." : value;
    const [valueUnits = "0", valueDecimals = "0"] = valueToParse.split(".");
    const length = valueDecimals.length;
    if (length > units) {
      throw new FuelError(
        ErrorCode.CONVERTING_FAILED,
        `Decimal can't have more than ${units} digits.`
      );
    }
    const decimals = Array.from({ length: units }).fill("0");
    decimals.splice(0, length, valueDecimals);
    const amount = `${valueUnits.replaceAll(",", "")}${decimals.join("")}`;
    return bn(amount);
  };
  function toNumber2(value) {
    return bn(value).toNumber();
  }
  function toHex(value, bytesPadding) {
    return bn(value).toHex(bytesPadding);
  }
  function toBytes3(value, bytesPadding) {
    return bn(value).toBytes(bytesPadding);
  }
  function max(...numbers) {
    return numbers.reduce((prev, cur) => bn(cur).gt(prev) ? bn(cur) : prev, bn(0));
  }

  // ../hasher/dist/index.mjs
  function sha2563(data) {
    return hexlify(sha256(arrayify(data)));
  }
  function hash3(data) {
    return sha2563(data);
  }
  function uint64ToBytesBE(value) {
    const bigIntValue = BigInt(value);
    const buffer = new ArrayBuffer(8);
    const dataView = new DataView(buffer);
    dataView.setBigUint64(0, bigIntValue, false);
    return new Uint8Array(dataView.buffer);
  }
  function hashMessage(msg) {
    return hash3(bufferFromString2(msg, "utf-8"));
  }

  // ../abi-coder/dist/index.mjs
  var __defProp5 = Object.defineProperty;
  var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField5 = (obj, key, value) => {
    __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck2 = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateAdd2 = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateMethod2 = (obj, member, method) => {
    __accessCheck2(obj, member, "access private method");
    return method;
  };
  var Coder = class {
    name;
    type;
    encodedLength;
    constructor(name, type3, encodedLength) {
      this.name = name;
      this.type = type3;
      this.encodedLength = encodedLength;
    }
  };
  var U8_CODER_TYPE = "u8";
  var U16_CODER_TYPE = "u16";
  var U32_CODER_TYPE = "u32";
  var U64_CODER_TYPE = "u64";
  var U256_CODER_TYPE = "u256";
  var RAW_PTR_CODER_TYPE = "raw untyped ptr";
  var RAW_SLICE_CODER_TYPE = "raw untyped slice";
  var BOOL_CODER_TYPE = "bool";
  var B256_CODER_TYPE = "b256";
  var B512_CODER_TYPE = "struct B512";
  var OPTION_CODER_TYPE = "enum Option";
  var VEC_CODER_TYPE = "struct Vec";
  var BYTES_CODER_TYPE = "struct Bytes";
  var STD_STRING_CODER_TYPE = "struct String";
  var STR_SLICE_CODER_TYPE = "str";
  var stringRegEx = /str\[(?<length>[0-9]+)\]/;
  var arrayRegEx = /\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/;
  var structRegEx = /^struct (?<name>\w+)$/;
  var enumRegEx = /^enum (?<name>\w+)$/;
  var tupleRegEx = /^\((?<items>.*)\)$/;
  var genericRegEx = /^generic (?<name>\w+)$/;
  var ENCODING_V0 = "0";
  var ENCODING_V1 = "1";
  var WORD_SIZE = 8;
  var BYTES_32 = 32;
  var ASSET_ID_LEN = BYTES_32;
  var CONTRACT_ID_LEN = BYTES_32;
  var ADDRESS_LEN = BYTES_32;
  var NONCE_LEN = BYTES_32;
  var TX_LEN = WORD_SIZE * 4;
  var TX_POINTER_LEN = WORD_SIZE * 2;
  var MAX_BYTES = 2 ** 32 - 1;
  var calculateVmTxMemory = ({ maxInputs }) => BYTES_32 + // Tx ID
  WORD_SIZE + // Tx size
  // Asset ID/Balance coin input pairs
  maxInputs * (ASSET_ID_LEN + WORD_SIZE);
  var SCRIPT_FIXED_SIZE = WORD_SIZE + // Identifier
  WORD_SIZE + // Gas limit
  WORD_SIZE + // Script size
  WORD_SIZE + // Script data size
  WORD_SIZE + // Policies
  WORD_SIZE + // Inputs size
  WORD_SIZE + // Outputs size
  WORD_SIZE + // Witnesses size
  BYTES_32;
  var INPUT_COIN_FIXED_SIZE = WORD_SIZE + // Identifier
  TX_LEN + // Utxo Length
  WORD_SIZE + // Output Index
  ADDRESS_LEN + // Owner
  WORD_SIZE + // Amount
  ASSET_ID_LEN + // Asset id
  TX_POINTER_LEN + // TxPointer
  WORD_SIZE + // Witnesses index
  WORD_SIZE + // Maturity
  WORD_SIZE + // Predicate size
  WORD_SIZE + // Predicate data size
  WORD_SIZE;
  var INPUT_MESSAGE_FIXED_SIZE = WORD_SIZE + // Identifier
  ADDRESS_LEN + // Sender
  ADDRESS_LEN + // Recipient
  WORD_SIZE + // Amount
  NONCE_LEN + // Nonce
  WORD_SIZE + // witness_index
  WORD_SIZE + // Data size
  WORD_SIZE + // Predicate size
  WORD_SIZE + // Predicate data size
  WORD_SIZE;
  var encodedLengths = {
    u64: WORD_SIZE,
    u256: WORD_SIZE * 4
  };
  var BigNumberCoder = class extends Coder {
    constructor(baseType) {
      super("bigNumber", baseType, encodedLengths[baseType]);
    }
    encode(value) {
      let bytes3;
      try {
        bytes3 = toBytes3(value, this.encodedLength);
      } catch (error2) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return bytes3;
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} data size.`);
      }
      let bytes3 = data.slice(offset, offset + this.encodedLength);
      bytes3 = bytes3.slice(0, this.encodedLength);
      if (bytes3.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} byte data size.`);
      }
      return [bn(bytes3), offset + this.encodedLength];
    }
  };
  var VEC_PROPERTY_SPACE = 3;
  var BASE_VECTOR_OFFSET = VEC_PROPERTY_SPACE * WORD_SIZE;
  var RAW_SLICE_PROPERTY_SPACE = 2;
  var BASE_RAW_SLICE_OFFSET = RAW_SLICE_PROPERTY_SPACE * WORD_SIZE;
  function concatWithDynamicData(items) {
    const topLevelData = {};
    let totalIndex = 0;
    const objects = items.map((item) => {
      const dynamicData = item.dynamicData;
      if (dynamicData) {
        Object.entries(dynamicData).forEach(([pointerIndex, vData]) => {
          topLevelData[parseInt(pointerIndex, 10) + totalIndex] = vData;
        });
      }
      const byteArray = arrayify(item);
      totalIndex += byteArray.byteLength / WORD_SIZE;
      return byteArray;
    });
    const length = objects.reduce((accum, item) => accum + item.length, 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object2) => {
      result.set(object2, offset);
      return offset + object2.length;
    }, 0);
    if (Object.keys(topLevelData).length) {
      result.dynamicData = topLevelData;
    }
    return result;
  }
  function unpackDynamicData(results, baseOffset, dataOffset) {
    if (!results.dynamicData) {
      return concat([results]);
    }
    let cumulativeDynamicByteLength = 0;
    let updatedResults = results;
    Object.entries(results.dynamicData).forEach(([pointerIndex, vData]) => {
      const pointerOffset = parseInt(pointerIndex, 10) * WORD_SIZE;
      const adjustedValue = new BigNumberCoder("u64").encode(
        dataOffset + baseOffset + cumulativeDynamicByteLength
      );
      updatedResults.set(adjustedValue, pointerOffset);
      const dataToAppend = vData.dynamicData ? (
        // unpack child dynamic data
        unpackDynamicData(
          vData,
          baseOffset,
          dataOffset + vData.byteLength + cumulativeDynamicByteLength
        )
      ) : vData;
      updatedResults = concat([updatedResults, dataToAppend]);
      cumulativeDynamicByteLength += dataToAppend.byteLength;
    });
    return updatedResults;
  }
  var chunkByLength = (data, length = WORD_SIZE) => {
    const chunks = [];
    let offset = 0;
    let chunk = data.slice(offset, offset + length);
    while (chunk.length) {
      chunks.push(chunk);
      offset += length;
      chunk = data.slice(offset, offset + length);
    }
    return chunks;
  };
  var isPointerType = (type3) => {
    switch (type3) {
      case "u8":
      case "u16":
      case "u32":
      case "u64":
      case "bool": {
        return false;
      }
      default: {
        return true;
      }
    }
  };
  var isHeapType = (type3) => type3 === VEC_CODER_TYPE || type3 === BYTES_CODER_TYPE || type3 === STD_STRING_CODER_TYPE;
  function findOrThrow(arr, predicate, throwFn = () => {
    throw new FuelError(ErrorCode.ELEMENT_NOT_FOUND, "Element not found in the array.");
  }) {
    const found = arr.find(predicate);
    if (found === void 0) {
      throwFn();
    }
    return found;
  }
  var isMultipleOfWordSize = (length) => length % WORD_SIZE === 0;
  var getWordSizePadding = (length) => WORD_SIZE - length % WORD_SIZE;
  var rightPadToWordSize = (encoded) => {
    if (isMultipleOfWordSize(encoded.length)) {
      return encoded;
    }
    const padding = new Uint8Array(WORD_SIZE - encoded.length % WORD_SIZE);
    return concatBytes([encoded, padding]);
  };
  var ArrayCoder = class extends Coder {
    coder;
    length;
    constructor(coder, length) {
      super("array", `[${coder.type}; ${length}]`, length * coder.encodedLength);
      this.coder = coder;
      this.length = length;
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      if (this.length !== value.length) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
      }
      return concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v)));
    }
    decode(data, offset) {
      if (data.length < this.encodedLength || data.length > MAX_BYTES) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid array data size.`);
      }
      let newOffset = offset;
      const decodedValue = Array(this.length).fill(0).map(() => {
        let decoded;
        [decoded, newOffset] = this.coder.decode(data, newOffset);
        return decoded;
      });
      return [decodedValue, newOffset];
    }
  };
  var B256Coder = class extends Coder {
    constructor() {
      super("b256", "b256", WORD_SIZE * 4);
    }
    encode(value) {
      let encodedValue;
      try {
        encodedValue = arrayify(value);
      } catch (error2) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      if (encodedValue.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return encodedValue;
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 data size.`);
      }
      let bytes3 = data.slice(offset, offset + this.encodedLength);
      const decoded = bn(bytes3);
      if (decoded.isZero()) {
        bytes3 = new Uint8Array(32);
      }
      if (bytes3.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 byte data size.`);
      }
      return [toHex(bytes3, 32), offset + 32];
    }
  };
  var B512Coder = class extends Coder {
    constructor() {
      super("b512", "struct B512", WORD_SIZE * 8);
    }
    encode(value) {
      let encodedValue;
      try {
        encodedValue = arrayify(value);
      } catch (error2) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      if (encodedValue.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return encodedValue;
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 data size.`);
      }
      let bytes3 = data.slice(offset, offset + this.encodedLength);
      const decoded = bn(bytes3);
      if (decoded.isZero()) {
        bytes3 = new Uint8Array(64);
      }
      if (bytes3.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 byte data size.`);
      }
      return [toHex(bytes3, this.encodedLength), offset + this.encodedLength];
    }
  };
  var BooleanCoder = class extends Coder {
    paddingLength;
    options;
    constructor(options = {
      isSmallBytes: false,
      isRightPadded: false
    }) {
      const paddingLength = options.isSmallBytes ? 1 : 8;
      super("boolean", "boolean", paddingLength);
      this.paddingLength = paddingLength;
      this.options = options;
    }
    encode(value) {
      const isTrueBool = value === true || value === false;
      if (!isTrueBool) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);
      }
      const output3 = toBytes3(value ? 1 : 0, this.paddingLength);
      if (this.options.isRightPadded) {
        return output3.reverse();
      }
      return output3;
    }
    decode(data, offset) {
      if (data.length < this.paddingLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);
      }
      let bytes3;
      if (this.options.isRightPadded) {
        bytes3 = data.slice(offset, offset + 1);
      } else {
        bytes3 = data.slice(offset, offset + this.paddingLength);
      }
      const decodedValue = bn(bytes3);
      if (decodedValue.isZero()) {
        return [false, offset + this.paddingLength];
      }
      if (!decodedValue.eq(bn(1))) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);
      }
      return [true, offset + this.paddingLength];
    }
  };
  var _getPaddedData;
  var getPaddedData_fn;
  var ByteCoder = class extends Coder {
    constructor() {
      super("struct", "struct Bytes", BASE_VECTOR_OFFSET);
      __privateAdd2(this, _getPaddedData);
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const parts = [];
      const pointer = new BigNumberCoder("u64").encode(BASE_VECTOR_OFFSET);
      const data = __privateMethod2(this, _getPaddedData, getPaddedData_fn).call(this, value);
      pointer.dynamicData = {
        0: concatWithDynamicData([data])
      };
      parts.push(pointer);
      parts.push(new BigNumberCoder("u64").encode(data.byteLength));
      parts.push(new BigNumberCoder("u64").encode(value.length));
      return concatWithDynamicData(parts);
    }
    decode(data, offset) {
      if (data.length < BASE_VECTOR_OFFSET) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);
      }
      const len = data.slice(16, 24);
      const encodedLength = bn(new BigNumberCoder("u64").decode(len, 0)[0]).toNumber();
      const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + encodedLength);
      if (byteData.length !== encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);
      }
      return [byteData, offset + BASE_VECTOR_OFFSET];
    }
  };
  _getPaddedData = /* @__PURE__ */ new WeakSet();
  getPaddedData_fn = function(value) {
    const data = [Uint8Array.from(value)];
    const paddingLength = (WORD_SIZE - value.length % WORD_SIZE) % WORD_SIZE;
    if (paddingLength) {
      data.push(new Uint8Array(paddingLength));
    }
    return concat(data);
  };
  __publicField5(ByteCoder, "memorySize", 1);
  var isFullyNativeEnum = (enumCoders) => Object.values(enumCoders).every(
    // @ts-expect-error complicated types
    ({ type: type3, coders }) => type3 === "()" && JSON.stringify(coders) === JSON.stringify([])
  );
  var EnumCoder = class extends Coder {
    name;
    coders;
    #caseIndexCoder;
    #encodedValueSize;
    constructor(name, coders) {
      const caseIndexCoder = new BigNumberCoder("u64");
      const encodedValueSize = Object.values(coders).reduce(
        (max2, coder) => Math.max(max2, coder.encodedLength),
        0
      );
      super("enum", `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);
      this.name = name;
      this.coders = coders;
      this.#caseIndexCoder = caseIndexCoder;
      this.#encodedValueSize = encodedValueSize;
    }
    #encodeNativeEnum(value) {
      const valueCoder = this.coders[value];
      const encodedValue = valueCoder.encode([]);
      const caseIndex = Object.keys(this.coders).indexOf(value);
      const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);
      return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);
    }
    encode(value) {
      if (typeof value === "string" && this.coders[value]) {
        return this.#encodeNativeEnum(value);
      }
      const [caseKey, ...empty] = Object.keys(value);
      if (!caseKey) {
        throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "A field for the case must be provided.");
      }
      if (empty.length !== 0) {
        throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "Only one field must be provided.");
      }
      const valueCoder = this.coders[caseKey];
      const caseIndex = Object.keys(this.coders).indexOf(caseKey);
      const encodedValue = valueCoder.encode(value[caseKey]);
      const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);
      return concatWithDynamicData([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);
    }
    #decodeNativeEnum(caseKey, newOffset) {
      return [caseKey, newOffset];
    }
    decode(data, offset) {
      if (data.length < this.#encodedValueSize) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);
      }
      let newOffset = offset;
      let decoded;
      [decoded, newOffset] = new BigNumberCoder("u64").decode(data, newOffset);
      const caseIndex = toNumber2(decoded);
      const caseKey = Object.keys(this.coders)[caseIndex];
      if (!caseKey) {
        throw new FuelError(
          ErrorCode.INVALID_DECODE_VALUE,
          `Invalid caseIndex "${caseIndex}". Valid cases: ${Object.keys(this.coders)}.`
        );
      }
      const valueCoder = this.coders[caseKey];
      const padding = this.#encodedValueSize - valueCoder.encodedLength;
      newOffset += padding;
      [decoded, newOffset] = valueCoder.decode(data, newOffset);
      if (isFullyNativeEnum(this.coders)) {
        return this.#decodeNativeEnum(caseKey, newOffset);
      }
      return [{ [caseKey]: decoded }, newOffset];
    }
  };
  var OptionCoder = class extends EnumCoder {
    encode(value) {
      const result = super.encode(this.toSwayOption(value));
      return result;
    }
    toSwayOption(input) {
      if (input !== void 0) {
        return { Some: input };
      }
      return { None: [] };
    }
    decode(data, offset) {
      if (data.length < this.encodedLength - 1) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid option data size.`);
      }
      const [decoded, newOffset] = super.decode(data, offset);
      return [this.toOption(decoded), newOffset];
    }
    toOption(output3) {
      if (output3 && "Some" in output3) {
        return output3.Some;
      }
      return void 0;
    }
  };
  var NumberCoder = class extends Coder {
    // This is to align the bits to the total bytes
    // See https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#unsigned-integers
    length;
    paddingLength;
    baseType;
    options;
    constructor(baseType, options = {
      isSmallBytes: false,
      isRightPadded: false
    }) {
      const paddingLength = options.isSmallBytes && baseType === "u8" ? 1 : 8;
      super("number", baseType, paddingLength);
      this.baseType = baseType;
      switch (baseType) {
        case "u8":
          this.length = 1;
          break;
        case "u16":
          this.length = 2;
          break;
        case "u32":
        default:
          this.length = 4;
          break;
      }
      this.paddingLength = paddingLength;
      this.options = options;
    }
    encode(value) {
      let bytes3;
      try {
        bytes3 = toBytes3(value);
      } catch (error2) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);
      }
      if (bytes3.length > this.length) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);
      }
      const output3 = toBytes3(bytes3, this.paddingLength);
      if (this.baseType !== "u8") {
        return output3;
      }
      return this.options.isRightPadded ? output3.reverse() : output3;
    }
    decodeU8(data, offset) {
      let bytes3;
      if (this.options.isRightPadded) {
        bytes3 = data.slice(offset, offset + 1);
      } else {
        bytes3 = data.slice(offset, offset + this.paddingLength);
        bytes3 = bytes3.slice(this.paddingLength - this.length, this.paddingLength);
      }
      return [toNumber2(bytes3), offset + this.paddingLength];
    }
    decode(data, offset) {
      if (data.length < this.paddingLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);
      }
      if (this.baseType === "u8") {
        return this.decodeU8(data, offset);
      }
      let bytes3 = data.slice(offset, offset + this.paddingLength);
      bytes3 = bytes3.slice(8 - this.length, 8);
      if (bytes3.length !== this.paddingLength - (this.paddingLength - this.length)) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);
      }
      return [toNumber2(bytes3), offset + 8];
    }
  };
  var RawSliceCoder = class extends Coder {
    constructor() {
      super("raw untyped slice", "raw untyped slice", BASE_RAW_SLICE_OFFSET);
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const parts = [];
      const coder = new NumberCoder("u8", { isSmallBytes: true });
      const pointer = new BigNumberCoder("u64").encode(
        BASE_RAW_SLICE_OFFSET
      );
      pointer.dynamicData = {
        0: concatWithDynamicData(value.map((v) => coder.encode(v)))
      };
      parts.push(pointer);
      parts.push(new BigNumberCoder("u64").encode(value.length));
      return concatWithDynamicData(parts);
    }
    decode(data, offset) {
      const dataBytes = data.slice(offset);
      const internalCoder = new ArrayCoder(
        new NumberCoder("u8", { isSmallBytes: true }),
        dataBytes.length
      );
      const [decodedValue] = internalCoder.decode(dataBytes, 0);
      return [decodedValue, offset + dataBytes.length];
    }
  };
  var _getPaddedData2;
  var getPaddedData_fn2;
  var StdStringCoder = class extends Coder {
    constructor() {
      super("struct", "struct String", 1);
      __privateAdd2(this, _getPaddedData2);
    }
    encode(value) {
      const parts = [];
      const pointer = new BigNumberCoder("u64").encode(BASE_VECTOR_OFFSET);
      const data = __privateMethod2(this, _getPaddedData2, getPaddedData_fn2).call(this, value);
      pointer.dynamicData = {
        0: concatWithDynamicData([data])
      };
      parts.push(pointer);
      parts.push(new BigNumberCoder("u64").encode(data.byteLength));
      parts.push(new BigNumberCoder("u64").encode(value.length));
      return concatWithDynamicData(parts);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);
      }
      const len = data.slice(16, 24);
      const encodedLength = bn(new BigNumberCoder("u64").decode(len, 0)[0]).toNumber();
      const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + encodedLength);
      if (byteData.length !== encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);
      }
      const value = toUtf8String(byteData);
      return [value, offset + BASE_VECTOR_OFFSET];
    }
  };
  _getPaddedData2 = /* @__PURE__ */ new WeakSet();
  getPaddedData_fn2 = function(value) {
    const data = [toUtf8Bytes(value)];
    const paddingLength = (WORD_SIZE - value.length % WORD_SIZE) % WORD_SIZE;
    if (paddingLength) {
      data.push(new Uint8Array(paddingLength));
    }
    return concat(data);
  };
  __publicField5(StdStringCoder, "memorySize", 1);
  var StringCoder = class extends Coder {
    length;
    #paddingLength;
    constructor(length) {
      let paddingLength = (8 - length) % 8;
      paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;
      super("string", `str[${length}]`, length + paddingLength);
      this.length = length;
      this.#paddingLength = paddingLength;
    }
    encode(value) {
      if (this.length !== value.length) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);
      }
      const encoded = toUtf8Bytes(value);
      const padding = new Uint8Array(this.#paddingLength);
      return concat([encoded, padding]);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);
      }
      const bytes3 = data.slice(offset, offset + this.length);
      if (bytes3.length !== this.length) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);
      }
      const value = toUtf8String(bytes3);
      const padding = this.#paddingLength;
      return [value, offset + this.length + padding];
    }
  };
  var StructCoder = class extends Coder {
    name;
    coders;
    constructor(name, coders) {
      const encodedLength = Object.values(coders).reduce(
        (acc, coder) => acc + coder.encodedLength,
        0
      );
      super("struct", `struct ${name}`, encodedLength);
      this.name = name;
      this.coders = coders;
    }
    encode(value) {
      const encodedFields = Object.keys(this.coders).map((fieldName) => {
        const fieldCoder = this.coders[fieldName];
        const fieldValue = value[fieldName];
        if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {
          throw new FuelError(
            ErrorCode.ENCODE_ERROR,
            `Invalid ${this.type}. Field "${fieldName}" not present.`
          );
        }
        const encoded = fieldCoder.encode(fieldValue);
        if (!isMultipleOfWordSize(encoded.length)) {
          return rightPadToWordSize(encoded);
        }
        return encoded;
      });
      return concatWithDynamicData([concatWithDynamicData(encodedFields)]);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);
      }
      let newOffset = offset;
      const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {
        const fieldCoder = this.coders[fieldName];
        let decoded;
        [decoded, newOffset] = fieldCoder.decode(data, newOffset);
        if (!isMultipleOfWordSize(newOffset)) {
          newOffset += getWordSizePadding(newOffset);
        }
        obj[fieldName] = decoded;
        return obj;
      }, {});
      return [decodedValue, newOffset];
    }
  };
  var TupleCoder = class extends Coder {
    coders;
    constructor(coders) {
      const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);
      super("tuple", `(${coders.map((coder) => coder.type).join(", ")})`, encodedLength);
      this.coders = coders;
    }
    encode(value) {
      if (this.coders.length !== value.length) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
      }
      return concatWithDynamicData(
        this.coders.map((coder, i) => {
          const encoded = coder.encode(value[i]);
          if (!isMultipleOfWordSize(encoded.length)) {
            return rightPadToWordSize(encoded);
          }
          return encoded;
        })
      );
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);
      }
      let newOffset = offset;
      const decodedValue = this.coders.map((coder) => {
        let decoded;
        [decoded, newOffset] = coder.decode(data, newOffset);
        if (!isMultipleOfWordSize(newOffset)) {
          newOffset += getWordSizePadding(newOffset);
        }
        return decoded;
      });
      return [decodedValue, newOffset];
    }
  };
  var VecCoder = class extends Coder {
    coder;
    constructor(coder) {
      super("struct", `struct Vec`, coder.encodedLength + BASE_VECTOR_OFFSET);
      this.coder = coder;
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const parts = [];
      const pointer = new BigNumberCoder("u64").encode(BASE_VECTOR_OFFSET);
      pointer.dynamicData = {
        0: concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v)))
      };
      parts.push(pointer);
      parts.push(new BigNumberCoder("u64").encode(value.length));
      parts.push(new BigNumberCoder("u64").encode(value.length));
      return concatWithDynamicData(parts);
    }
    decode(data, offset) {
      if (data.length < BASE_VECTOR_OFFSET || data.length > MAX_BYTES) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);
      }
      const len = data.slice(16, 24);
      const encodedLength = bn(new BigNumberCoder("u64").decode(len, 0)[0]).toNumber();
      const vectorRawDataLength = encodedLength * this.coder.encodedLength;
      const vectorRawData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + vectorRawDataLength);
      if (vectorRawData.length !== vectorRawDataLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);
      }
      return [
        chunkByLength(vectorRawData, this.coder.encodedLength).map(
          (chunk) => this.coder.decode(chunk, 0)[0]
        ),
        offset + BASE_VECTOR_OFFSET
      ];
    }
  };
  var ResolvedAbiType = class {
    abi;
    name;
    type;
    originalTypeArguments;
    components;
    constructor(abi, argument) {
      this.abi = abi;
      const type3 = findOrThrow(
        abi.types,
        (t) => t.typeId === argument.type,
        () => {
          throw new FuelError(
            ErrorCode.TYPE_NOT_FOUND,
            `Type does not exist in the provided abi: ${JSON.stringify({
              argument,
              abi: this.abi
            })}`
          );
        }
      );
      this.name = argument.name;
      this.type = type3.type;
      this.originalTypeArguments = argument.typeArguments;
      this.components = ResolvedAbiType.getResolvedGenericComponents(
        abi,
        argument,
        type3.components,
        type3.typeParameters ?? ResolvedAbiType.getImplicitGenericTypeParameters(abi, type3.components)
      );
    }
    static getResolvedGenericComponents(abi, arg, components, typeParameters) {
      if (components === null) {
        return null;
      }
      if (typeParameters === null || typeParameters.length === 0) {
        return components.map((c) => new ResolvedAbiType(abi, c));
      }
      const typeParametersAndArgsMap = typeParameters.reduce(
        (obj, typeParameter, typeParameterIndex) => {
          const o = { ...obj };
          o[typeParameter] = structuredClone(
            arg.typeArguments?.[typeParameterIndex]
          );
          return o;
        },
        {}
      );
      const resolvedComponents = this.resolveGenericArgTypes(
        abi,
        components,
        typeParametersAndArgsMap
      );
      return resolvedComponents.map((c) => new ResolvedAbiType(abi, c));
    }
    static resolveGenericArgTypes(abi, args, typeParametersAndArgsMap) {
      return args.map((arg) => {
        if (typeParametersAndArgsMap[arg.type] !== void 0) {
          return {
            ...typeParametersAndArgsMap[arg.type],
            name: arg.name
          };
        }
        if (arg.typeArguments) {
          return {
            ...structuredClone(arg),
            typeArguments: this.resolveGenericArgTypes(
              abi,
              arg.typeArguments,
              typeParametersAndArgsMap
            )
          };
        }
        const argType = findOrThrow(abi.types, (t) => t.typeId === arg.type);
        const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);
        if (implicitTypeParameters && implicitTypeParameters.length > 0) {
          return {
            ...structuredClone(arg),
            typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp])
          };
        }
        return arg;
      });
    }
    static getImplicitGenericTypeParameters(abi, args, implicitGenericParametersParam) {
      if (!Array.isArray(args)) {
        return null;
      }
      const implicitGenericParameters = implicitGenericParametersParam ?? [];
      args.forEach((a) => {
        const argType = findOrThrow(abi.types, (t) => t.typeId === a.type);
        if (genericRegEx.test(argType.type)) {
          implicitGenericParameters.push(argType.typeId);
          return;
        }
        if (!Array.isArray(a.typeArguments)) {
          return;
        }
        this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);
      });
      return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;
    }
    getSignature() {
      const prefix = this.getArgSignaturePrefix();
      const content = this.getArgSignatureContent();
      return `${prefix}${content}`;
    }
    getArgSignaturePrefix() {
      const structMatch = structRegEx.test(this.type);
      if (structMatch) {
        return "s";
      }
      const arrayMatch = arrayRegEx.test(this.type);
      if (arrayMatch) {
        return "a";
      }
      const enumMatch = enumRegEx.test(this.type);
      if (enumMatch) {
        return "e";
      }
      return "";
    }
    getArgSignatureContent() {
      if (this.type === "raw untyped ptr") {
        return "rawptr";
      }
      if (this.type === "raw untyped slice") {
        return "rawslice";
      }
      const strMatch = stringRegEx.exec(this.type)?.groups;
      if (strMatch) {
        return `str[${strMatch.length}]`;
      }
      if (this.components === null) {
        return this.type;
      }
      const arrayMatch = arrayRegEx.exec(this.type)?.groups;
      if (arrayMatch) {
        return `[${this.components[0].getSignature()};${arrayMatch.length}]`;
      }
      const typeArgumentsSignature = this.originalTypeArguments !== null ? `<${this.originalTypeArguments.map((a) => new ResolvedAbiType(this.abi, a).getSignature()).join(",")}>` : "";
      const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(",")})`;
      return `${typeArgumentsSignature}${componentsSignature}`;
    }
  };
  function getCoders(components, options) {
    const { getCoder: getCoder3 } = options;
    return components.reduce((obj, component) => {
      const o = obj;
      o[component.name] = getCoder3(component, options);
      return o;
    }, {});
  }
  var getCoder = (resolvedAbiType, options) => {
    switch (resolvedAbiType.type) {
      case U8_CODER_TYPE:
      case U16_CODER_TYPE:
      case U32_CODER_TYPE:
        return new NumberCoder(resolvedAbiType.type, options);
      case U64_CODER_TYPE:
      case RAW_PTR_CODER_TYPE:
        return new BigNumberCoder("u64");
      case U256_CODER_TYPE:
        return new BigNumberCoder("u256");
      case RAW_SLICE_CODER_TYPE:
        return new RawSliceCoder();
      case BOOL_CODER_TYPE:
        return new BooleanCoder(options);
      case B256_CODER_TYPE:
        return new B256Coder();
      case B512_CODER_TYPE:
        return new B512Coder();
      case BYTES_CODER_TYPE:
        return new ByteCoder();
      case STD_STRING_CODER_TYPE:
        return new StdStringCoder();
      default:
        break;
    }
    const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;
    if (stringMatch) {
      const length = parseInt(stringMatch.length, 10);
      return new StringCoder(length);
    }
    const components = resolvedAbiType.components;
    const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;
    if (arrayMatch) {
      const length = parseInt(arrayMatch.length, 10);
      const arg = components[0];
      if (!arg) {
        throw new FuelError(
          ErrorCode.INVALID_COMPONENT,
          `The provided Array type is missing an item of 'component'.`
        );
      }
      const arrayElementCoder = getCoder(arg, { isSmallBytes: true });
      return new ArrayCoder(arrayElementCoder, length);
    }
    if (resolvedAbiType.type === VEC_CODER_TYPE) {
      const arg = findOrThrow(components, (c) => c.name === "buf").originalTypeArguments?.[0];
      if (!arg) {
        throw new FuelError(
          ErrorCode.INVALID_COMPONENT,
          `The provided Vec type is missing the 'type argument'.`
        );
      }
      const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);
      const itemCoder = getCoder(argType, { isSmallBytes: true, encoding: ENCODING_V0 });
      return new VecCoder(itemCoder);
    }
    const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;
    if (structMatch) {
      const coders = getCoders(components, { isRightPadded: true, getCoder });
      return new StructCoder(structMatch.name, coders);
    }
    const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;
    if (enumMatch) {
      const coders = getCoders(components, { getCoder });
      const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;
      if (isOptionEnum) {
        return new OptionCoder(enumMatch.name, coders);
      }
      return new EnumCoder(enumMatch.name, coders);
    }
    const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;
    if (tupleMatch) {
      const coders = components.map(
        (component) => getCoder(component, { isRightPadded: true, encoding: ENCODING_V0 })
      );
      return new TupleCoder(coders);
    }
    if (resolvedAbiType.type === STR_SLICE_CODER_TYPE) {
      throw new FuelError(
        ErrorCode.INVALID_DATA,
        "String slices can not be decoded from logs. Convert the slice to `str[N]` with `__to_str_array`"
      );
    }
    throw new FuelError(
      ErrorCode.CODER_NOT_FOUND,
      `Coder not found: ${JSON.stringify(resolvedAbiType)}.`
    );
  };
  var BooleanCoder2 = class extends Coder {
    constructor() {
      super("boolean", "boolean", 1);
    }
    encode(value) {
      const isTrueBool = value === true || value === false;
      if (!isTrueBool) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);
      }
      return toBytes3(value ? 1 : 0, this.encodedLength);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);
      }
      const bytes3 = bn(data.slice(offset, offset + this.encodedLength));
      if (bytes3.isZero()) {
        return [false, offset + this.encodedLength];
      }
      if (!bytes3.eq(bn(1))) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);
      }
      return [true, offset + this.encodedLength];
    }
  };
  var ByteCoder2 = class extends Coder {
    constructor() {
      super("struct", "struct Bytes", WORD_SIZE);
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const bytes3 = new Uint8Array(value);
      const lengthBytes = new BigNumberCoder("u64").encode(value.length);
      return new Uint8Array([...lengthBytes, ...bytes3]);
    }
    decode(data, offset) {
      if (data.length < WORD_SIZE) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);
      if (dataBytes.length !== length) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);
      }
      return [dataBytes, offsetAndLength + length];
    }
  };
  __publicField5(ByteCoder2, "memorySize", 1);
  var isFullyNativeEnum2 = (enumCoders) => Object.values(enumCoders).every(
    // @ts-expect-error complicated types
    ({ type: type3, coders }) => type3 === "()" && JSON.stringify(coders) === JSON.stringify([])
  );
  var EnumCoder2 = class extends Coder {
    name;
    coders;
    #caseIndexCoder;
    #encodedValueSize;
    constructor(name, coders) {
      const caseIndexCoder = new BigNumberCoder("u64");
      const encodedValueSize = Object.values(coders).reduce(
        (max2, coder) => Math.max(max2, coder.encodedLength),
        0
      );
      super("enum", `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);
      this.name = name;
      this.coders = coders;
      this.#caseIndexCoder = caseIndexCoder;
      this.#encodedValueSize = encodedValueSize;
    }
    #encodeNativeEnum(value) {
      const valueCoder = this.coders[value];
      const encodedValue = valueCoder.encode([]);
      const caseIndex = Object.keys(this.coders).indexOf(value);
      const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);
      return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);
    }
    encode(value) {
      if (typeof value === "string" && this.coders[value]) {
        return this.#encodeNativeEnum(value);
      }
      const [caseKey, ...empty] = Object.keys(value);
      if (!caseKey) {
        throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "A field for the case must be provided.");
      }
      if (empty.length !== 0) {
        throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "Only one field must be provided.");
      }
      const valueCoder = this.coders[caseKey];
      const caseIndex = Object.keys(this.coders).indexOf(caseKey);
      const encodedValue = valueCoder.encode(value[caseKey]);
      return new Uint8Array([...this.#caseIndexCoder.encode(caseIndex), ...encodedValue]);
    }
    #decodeNativeEnum(caseKey, newOffset) {
      return [caseKey, newOffset];
    }
    decode(data, offset) {
      if (data.length < this.#encodedValueSize) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);
      }
      const caseBytes = new BigNumberCoder("u64").decode(data, offset)[0];
      const caseIndex = toNumber2(caseBytes);
      const caseKey = Object.keys(this.coders)[caseIndex];
      if (!caseKey) {
        throw new FuelError(
          ErrorCode.INVALID_DECODE_VALUE,
          `Invalid caseIndex "${caseIndex}". Valid cases: ${Object.keys(this.coders)}.`
        );
      }
      const valueCoder = this.coders[caseKey];
      const offsetAndCase = offset + WORD_SIZE;
      const [decoded, newOffset] = valueCoder.decode(data, offsetAndCase);
      if (isFullyNativeEnum2(this.coders)) {
        return this.#decodeNativeEnum(caseKey, newOffset);
      }
      return [{ [caseKey]: decoded }, newOffset];
    }
  };
  var getLength = (baseType) => {
    switch (baseType) {
      case "u8":
        return 1;
      case "u16":
        return 2;
      case "u32":
        return 4;
      default:
        throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Invalid number type: ${baseType}`);
    }
  };
  var NumberCoder2 = class extends Coder {
    length;
    baseType;
    constructor(baseType) {
      const length = getLength(baseType);
      super("number", baseType, length);
      this.baseType = baseType;
      this.length = length;
    }
    encode(value) {
      let bytes3;
      try {
        bytes3 = toBytes3(value);
      } catch (error2) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);
      }
      if (bytes3.length > this.length) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);
      }
      return toBytes3(bytes3, this.length);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);
      }
      const bytes3 = data.slice(offset, offset + this.length);
      if (bytes3.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);
      }
      return [toNumber2(bytes3), offset + this.length];
    }
  };
  var RawSliceCoder2 = class extends Coder {
    constructor() {
      super("raw untyped slice", "raw untyped slice", WORD_SIZE);
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const internalCoder = new ArrayCoder(new NumberCoder2("u8"), value.length);
      const bytes3 = internalCoder.encode(value);
      const lengthBytes = new BigNumberCoder("u64").encode(bytes3.length);
      return new Uint8Array([...lengthBytes, ...bytes3]);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);
      if (dataBytes.length !== length) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice byte data size.`);
      }
      const internalCoder = new ArrayCoder(new NumberCoder2("u8"), length);
      const [decodedValue] = internalCoder.decode(dataBytes, 0);
      return [decodedValue, offsetAndLength + length];
    }
  };
  var StdStringCoder2 = class extends Coder {
    constructor() {
      super("struct", "struct String", WORD_SIZE);
    }
    encode(value) {
      const bytes3 = toUtf8Bytes(value);
      const lengthBytes = new BigNumberCoder("u64").encode(value.length);
      return new Uint8Array([...lengthBytes, ...bytes3]);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);
      if (dataBytes.length !== length) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);
      }
      return [toUtf8String(dataBytes), offsetAndLength + length];
    }
  };
  __publicField5(StdStringCoder2, "memorySize", 1);
  var StringCoder2 = class extends Coder {
    constructor(length) {
      super("string", `str[${length}]`, length);
    }
    encode(value) {
      if (value.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);
      }
      return toUtf8Bytes(value);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);
      }
      const bytes3 = data.slice(offset, offset + this.encodedLength);
      if (bytes3.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);
      }
      return [toUtf8String(bytes3), offset + this.encodedLength];
    }
  };
  var StructCoder2 = class extends Coder {
    name;
    coders;
    constructor(name, coders) {
      const encodedLength = Object.values(coders).reduce(
        (acc, coder) => acc + coder.encodedLength,
        0
      );
      super("struct", `struct ${name}`, encodedLength);
      this.name = name;
      this.coders = coders;
    }
    encode(value) {
      return concatBytes(
        Object.keys(this.coders).map((fieldName) => {
          const fieldCoder = this.coders[fieldName];
          const fieldValue = value[fieldName];
          if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {
            throw new FuelError(
              ErrorCode.ENCODE_ERROR,
              `Invalid ${this.type}. Field "${fieldName}" not present.`
            );
          }
          return fieldCoder.encode(fieldValue);
        })
      );
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);
      }
      let newOffset = offset;
      const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {
        const fieldCoder = this.coders[fieldName];
        let decoded;
        [decoded, newOffset] = fieldCoder.decode(data, newOffset);
        obj[fieldName] = decoded;
        return obj;
      }, {});
      return [decodedValue, newOffset];
    }
  };
  var TupleCoder2 = class extends Coder {
    coders;
    constructor(coders) {
      const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);
      super("tuple", `(${coders.map((coder) => coder.type).join(", ")})`, encodedLength);
      this.coders = coders;
    }
    encode(value) {
      if (this.coders.length !== value.length) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
      }
      return concatBytes(this.coders.map((coder, i) => coder.encode(value[i])));
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);
      }
      let newOffset = offset;
      const decodedValue = this.coders.map((coder) => {
        let decoded;
        [decoded, newOffset] = coder.decode(data, newOffset);
        return decoded;
      });
      return [decodedValue, newOffset];
    }
  };
  var VecCoder2 = class extends Coder {
    coder;
    constructor(coder) {
      super("struct", `struct Vec`, coder.encodedLength + WORD_SIZE);
      this.coder = coder;
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const bytes3 = value.map((v) => this.coder.encode(v));
      const lengthBytes = new BigNumberCoder("u64").encode(value.length);
      return new Uint8Array([...lengthBytes, ...concatBytes(bytes3)]);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength || data.length > MAX_BYTES) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const dataLength2 = length * this.coder.encodedLength;
      const dataBytes = data.slice(offsetAndLength, offsetAndLength + dataLength2);
      if (dataBytes.length !== dataLength2) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);
      }
      return [
        chunkByLength(dataBytes, this.coder.encodedLength).map(
          (chunk) => this.coder.decode(chunk, 0)[0]
        ),
        offsetAndLength + dataLength2
      ];
    }
  };
  var getCoder2 = (resolvedAbiType, _options2) => {
    switch (resolvedAbiType.type) {
      case U8_CODER_TYPE:
      case U16_CODER_TYPE:
      case U32_CODER_TYPE:
        return new NumberCoder2(resolvedAbiType.type);
      case U64_CODER_TYPE:
      case RAW_PTR_CODER_TYPE:
        return new BigNumberCoder("u64");
      case U256_CODER_TYPE:
        return new BigNumberCoder("u256");
      case RAW_SLICE_CODER_TYPE:
        return new RawSliceCoder2();
      case BOOL_CODER_TYPE:
        return new BooleanCoder2();
      case B256_CODER_TYPE:
        return new B256Coder();
      case B512_CODER_TYPE:
        return new B512Coder();
      case BYTES_CODER_TYPE:
        return new ByteCoder2();
      case STD_STRING_CODER_TYPE:
        return new StdStringCoder2();
      default:
        break;
    }
    const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;
    if (stringMatch) {
      const length = parseInt(stringMatch.length, 10);
      return new StringCoder2(length);
    }
    const components = resolvedAbiType.components;
    const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;
    if (arrayMatch) {
      const length = parseInt(arrayMatch.length, 10);
      const arg = components[0];
      if (!arg) {
        throw new FuelError(
          ErrorCode.INVALID_COMPONENT,
          `The provided Array type is missing an item of 'component'.`
        );
      }
      const arrayElementCoder = getCoder2(arg, { isSmallBytes: true });
      return new ArrayCoder(arrayElementCoder, length);
    }
    if (resolvedAbiType.type === VEC_CODER_TYPE) {
      const arg = findOrThrow(components, (c) => c.name === "buf").originalTypeArguments?.[0];
      if (!arg) {
        throw new FuelError(
          ErrorCode.INVALID_COMPONENT,
          `The provided Vec type is missing the 'type argument'.`
        );
      }
      const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);
      const itemCoder = getCoder2(argType, { isSmallBytes: true, encoding: ENCODING_V0 });
      return new VecCoder2(itemCoder);
    }
    const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;
    if (structMatch) {
      const coders = getCoders(components, { isRightPadded: true, getCoder: getCoder2 });
      return new StructCoder2(structMatch.name, coders);
    }
    const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;
    if (enumMatch) {
      const coders = getCoders(components, { getCoder: getCoder2 });
      const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;
      if (isOptionEnum) {
        return new OptionCoder(enumMatch.name, coders);
      }
      return new EnumCoder2(enumMatch.name, coders);
    }
    const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;
    if (tupleMatch) {
      const coders = components.map(
        (component) => getCoder2(component, { isRightPadded: true, encoding: ENCODING_V0 })
      );
      return new TupleCoder2(coders);
    }
    if (resolvedAbiType.type === STR_SLICE_CODER_TYPE) {
      throw new FuelError(
        ErrorCode.INVALID_DATA,
        "String slices can not be decoded from logs. Convert the slice to `str[N]` with `__to_str_array`"
      );
    }
    throw new FuelError(
      ErrorCode.CODER_NOT_FOUND,
      `Coder not found: ${JSON.stringify(resolvedAbiType)}.`
    );
  };
  function getCoderForEncoding(encoding = ENCODING_V0) {
    switch (encoding) {
      case ENCODING_V1:
        return getCoder2;
      case ENCODING_V0:
        return getCoder;
      default:
        throw new FuelError(
          ErrorCode.UNSUPPORTED_ENCODING_VERSION,
          `Encoding version ${encoding} is unsupported.`
        );
    }
  }
  var AbiCoder = class {
    static getCoder(abi, argument, options = {
      isSmallBytes: false
    }) {
      const resolvedAbiType = new ResolvedAbiType(abi, argument);
      return getCoderForEncoding(options.encoding)(resolvedAbiType, options);
    }
    static encode(abi, argument, value, options) {
      return this.getCoder(abi, argument, options).encode(value);
    }
    static decode(abi, argument, data, offset, options) {
      return this.getCoder(abi, argument, options).decode(data, offset);
    }
  };
  var FunctionFragment = class {
    signature;
    selector;
    name;
    jsonFn;
    attributes;
    isInputDataPointer;
    outputMetadata;
    jsonAbi;
    constructor(jsonAbi, name) {
      this.jsonAbi = jsonAbi;
      this.jsonFn = findOrThrow(this.jsonAbi.functions, (f2) => f2.name === name);
      this.name = name;
      this.signature = FunctionFragment.getSignature(this.jsonAbi, this.jsonFn);
      this.selector = FunctionFragment.getFunctionSelector(this.signature);
      this.isInputDataPointer = this.#isInputDataPointer();
      this.outputMetadata = {
        isHeapType: this.#isOutputDataHeap(),
        encodedLength: this.#getOutputEncodedLength()
      };
      this.attributes = this.jsonFn.attributes ?? [];
    }
    static getSignature(abi, fn) {
      const inputsSignatures = fn.inputs.map(
        (input) => new ResolvedAbiType(abi, input).getSignature()
      );
      return `${fn.name}(${inputsSignatures.join(",")})`;
    }
    static getFunctionSelector(functionSignature) {
      const hashedFunctionSignature = sha2563(bufferFromString2(functionSignature, "utf-8"));
      return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);
    }
    #isInputDataPointer() {
      const inputTypes = this.jsonFn.inputs.map(
        (i) => this.jsonAbi.types.find((t) => t.typeId === i.type)
      );
      return this.jsonFn.inputs.length > 1 || isPointerType(inputTypes[0]?.type || "");
    }
    #isOutputDataHeap() {
      const outputType = findOrThrow(this.jsonAbi.types, (t) => t.typeId === this.jsonFn.output.type);
      return isHeapType(outputType?.type || "");
    }
    #getOutputEncodedLength() {
      try {
        const heapCoder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);
        if (heapCoder instanceof VecCoder) {
          return heapCoder.coder.encodedLength;
        }
        if (heapCoder instanceof ByteCoder) {
          return ByteCoder.memorySize;
        }
        return heapCoder.encodedLength;
      } catch (e) {
        return 0;
      }
    }
    encodeArguments(values, offset = 0) {
      FunctionFragment.verifyArgsAndInputsAlign(values, this.jsonFn.inputs, this.jsonAbi);
      const shallowCopyValues = values.slice();
      const nonEmptyInputs = this.jsonFn.inputs.filter(
        (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== "()"
      );
      if (Array.isArray(values) && nonEmptyInputs.length !== values.length) {
        shallowCopyValues.length = this.jsonFn.inputs.length;
        shallowCopyValues.fill(void 0, values.length);
      }
      const coders = nonEmptyInputs.map(
        (t) => AbiCoder.getCoder(this.jsonAbi, t, {
          isRightPadded: nonEmptyInputs.length > 1
        })
      );
      const coder = new TupleCoder(coders);
      const results = coder.encode(shallowCopyValues);
      return unpackDynamicData(results, offset, results.byteLength);
    }
    static verifyArgsAndInputsAlign(args, inputs, abi) {
      if (args.length === inputs.length) {
        return;
      }
      const inputTypes = inputs.map((i) => findOrThrow(abi.types, (t) => t.typeId === i.type));
      const optionalInputs = inputTypes.filter(
        (x) => x.type === OPTION_CODER_TYPE || x.type === "()"
      );
      if (optionalInputs.length === inputTypes.length) {
        return;
      }
      if (inputTypes.length - optionalInputs.length === args.length) {
        return;
      }
      const errorMsg = `Mismatch between provided arguments and expected ABI inputs. Provided ${args.length} arguments, but expected ${inputs.length - optionalInputs.length} (excluding ${optionalInputs.length} optional inputs).`;
      throw new FuelError(ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH, errorMsg);
    }
    decodeArguments(data) {
      const bytes3 = arrayify(data);
      const nonEmptyInputs = this.jsonFn.inputs.filter(
        (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== "()"
      );
      if (nonEmptyInputs.length === 0) {
        if (bytes3.length === 0) {
          return void 0;
        }
        throw new FuelError(
          ErrorCode.DECODE_ERROR,
          `Types/values length mismatch during decode. ${JSON.stringify({
            count: {
              types: this.jsonFn.inputs.length,
              nonEmptyInputs: nonEmptyInputs.length,
              values: bytes3.length
            },
            value: {
              args: this.jsonFn.inputs,
              nonEmptyInputs,
              values: bytes3
            }
          })}`
        );
      }
      const result = nonEmptyInputs.reduce(
        (obj, input) => {
          const coder = AbiCoder.getCoder(this.jsonAbi, input);
          const [decodedValue, decodedValueByteSize] = coder.decode(bytes3, obj.offset);
          return {
            decoded: [...obj.decoded, decodedValue],
            offset: obj.offset + decodedValueByteSize
          };
        },
        { decoded: [], offset: 0 }
      );
      return result.decoded;
    }
    decodeOutput(data) {
      const outputAbiType = findOrThrow(
        this.jsonAbi.types,
        (t) => t.typeId === this.jsonFn.output.type
      );
      if (outputAbiType.type === "()") {
        return [void 0, 0];
      }
      const bytes3 = arrayify(data);
      const coder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);
      return coder.decode(bytes3, 0);
    }
  };
  var Interface = class {
    functions;
    configurables;
    jsonAbi;
    constructor(jsonAbi) {
      this.jsonAbi = jsonAbi;
      this.functions = Object.fromEntries(
        this.jsonAbi.functions.map((x) => [x.name, new FunctionFragment(this.jsonAbi, x.name)])
      );
      this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));
    }
    /**
     * Returns function fragment for a dynamic input.
     * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment
     */
    getFunction(nameOrSignatureOrSelector) {
      const fn = Object.values(this.functions).find(
        (f2) => f2.name === nameOrSignatureOrSelector || f2.signature === nameOrSignatureOrSelector || f2.selector === nameOrSignatureOrSelector
      );
      if (fn !== void 0) {
        return fn;
      }
      throw new FuelError(
        ErrorCode.FUNCTION_NOT_FOUND,
        `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`
      );
    }
    decodeFunctionData(functionFragment, data) {
      const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
      if (!fragment) {
        throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, "Fragment not found.");
      }
      return fragment.decodeArguments(data);
    }
    encodeFunctionData(functionFragment, values, offset = 0) {
      const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
      if (!fragment) {
        throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, "Fragment not found.");
      }
      return fragment.encodeArguments(values, offset);
    }
    // Decode the result of a function call
    decodeFunctionResult(functionFragment, data) {
      const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
      return fragment.decodeOutput(data);
    }
    decodeLog(data, logId) {
      const { loggedType } = findOrThrow(this.jsonAbi.loggedTypes, (type3) => type3.logId === logId);
      return AbiCoder.decode(this.jsonAbi, loggedType, arrayify(data), 0, {
        encoding: this.jsonAbi.encoding
      });
    }
    encodeConfigurable(name, value) {
      const configurable = findOrThrow(
        this.jsonAbi.configurables,
        (c) => c.name === name,
        () => {
          throw new FuelError(
            ErrorCode.CONFIGURABLE_NOT_FOUND,
            `A configurable with the '${name}' was not found in the ABI.`
          );
        }
      );
      return AbiCoder.encode(this.jsonAbi, configurable.configurableType, value, {
        isRightPadded: true
      });
    }
    getTypeById(typeId) {
      return findOrThrow(
        this.jsonAbi.types,
        (t) => t.typeId === typeId,
        () => {
          throw new FuelError(
            ErrorCode.TYPE_NOT_FOUND,
            `Type with typeId '${typeId}' doesn't exist in the ABI.`
          );
        }
      );
    }
  };

  // ../transactions/dist/index.mjs
  var ByteArrayCoder = class extends Coder {
    length;
    #paddingLength;
    constructor(length) {
      const paddingLength = (8 - length % 8) % 8;
      const encodedLength = length + paddingLength;
      super(
        "ByteArray",
        // While this might sound like a [u8; N] coder it's actually not.
        // A [u8; N] coder would pad every u8 to 8 bytes which would
        // make every u8 have the same size as a u64.
        // We are packing four u8s into u64s here, avoiding this padding.
        `[u64; ${encodedLength / 4}]`,
        encodedLength
      );
      this.length = length;
      this.#paddingLength = paddingLength;
    }
    encode(value) {
      const parts = [];
      const data = arrayify(value);
      parts.push(data);
      if (this.#paddingLength) {
        parts.push(new Uint8Array(this.#paddingLength));
      }
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = [hexlify(data.slice(o, o + this.length)), o + this.length];
      const value = decoded;
      if (this.#paddingLength) {
        [decoded, o] = [null, o + this.#paddingLength];
      }
      return [value, o];
    }
  };
  var TxPointerCoder = class extends StructCoder {
    constructor() {
      super("TxPointer", {
        blockHeight: new NumberCoder("u32"),
        txIndex: new NumberCoder("u16")
      });
    }
  };
  var InputType = /* @__PURE__ */ ((InputType2) => {
    InputType2[InputType2["Coin"] = 0] = "Coin";
    InputType2[InputType2["Contract"] = 1] = "Contract";
    InputType2[InputType2["Message"] = 2] = "Message";
    return InputType2;
  })(InputType || {});
  var InputCoinCoder = class extends Coder {
    constructor() {
      super("InputCoin", "struct InputCoin", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.txID));
      parts.push(new NumberCoder("u8").encode(value.outputIndex));
      parts.push(new B256Coder().encode(value.owner));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new NumberCoder("u8").encode(value.witnessIndex));
      parts.push(new NumberCoder("u32").encode(value.maturity));
      parts.push(new BigNumberCoder("u64").encode(value.predicateGasUsed));
      parts.push(new NumberCoder("u32").encode(value.predicateLength));
      parts.push(new NumberCoder("u32").encode(value.predicateDataLength));
      parts.push(new ByteArrayCoder(value.predicateLength).encode(value.predicate));
      parts.push(new ByteArrayCoder(value.predicateDataLength).encode(value.predicateData));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const txID = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const outputIndex = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const owner = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const witnessIndex = Number(decoded);
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const maturity = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const predicateGasUsed = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const predicateLength = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const predicateDataLength = decoded;
      [decoded, o] = new ByteArrayCoder(predicateLength).decode(data, o);
      const predicate = decoded;
      [decoded, o] = new ByteArrayCoder(predicateDataLength).decode(data, o);
      const predicateData = decoded;
      return [
        {
          type: 0,
          txID,
          outputIndex,
          owner,
          amount,
          assetId,
          txPointer,
          witnessIndex,
          maturity,
          predicateGasUsed,
          predicateLength,
          predicateDataLength,
          predicate,
          predicateData
        },
        o
      ];
    }
  };
  var InputContractCoder = class extends Coder {
    constructor() {
      super("InputContract", "struct InputContract", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.txID));
      parts.push(new NumberCoder("u8").encode(value.outputIndex));
      parts.push(new B256Coder().encode(value.balanceRoot));
      parts.push(new B256Coder().encode(value.stateRoot));
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new B256Coder().encode(value.contractID));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const txID = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const outputIndex = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const balanceRoot = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractID = decoded;
      return [
        {
          type: 1,
          txID,
          outputIndex,
          balanceRoot,
          stateRoot,
          txPointer,
          contractID
        },
        o
      ];
    }
  };
  var InputMessageCoder = class extends Coder {
    constructor() {
      super("InputMessage", "struct InputMessage", 0);
    }
    static getMessageId(value) {
      const parts = [];
      parts.push(new ByteArrayCoder(32).encode(value.sender));
      parts.push(new ByteArrayCoder(32).encode(value.recipient));
      parts.push(new ByteArrayCoder(32).encode(value.nonce));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(arrayify(value.data || "0x"));
      return sha2563(concat(parts));
    }
    static encodeData(messageData) {
      const bytes3 = arrayify(messageData || "0x");
      const dataLength2 = bytes3.length;
      return new ByteArrayCoder(dataLength2).encode(bytes3);
    }
    encode(value) {
      const parts = [];
      const data = InputMessageCoder.encodeData(value.data);
      parts.push(new ByteArrayCoder(32).encode(value.sender));
      parts.push(new ByteArrayCoder(32).encode(value.recipient));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new ByteArrayCoder(32).encode(value.nonce));
      parts.push(new NumberCoder("u8").encode(value.witnessIndex));
      parts.push(new BigNumberCoder("u64").encode(value.predicateGasUsed));
      parts.push(new NumberCoder("u32").encode(data.length));
      parts.push(new NumberCoder("u32").encode(value.predicateLength));
      parts.push(new NumberCoder("u32").encode(value.predicateDataLength));
      parts.push(new ByteArrayCoder(data.length).encode(data));
      parts.push(new ByteArrayCoder(value.predicateLength).encode(value.predicate));
      parts.push(new ByteArrayCoder(value.predicateDataLength).encode(value.predicateData));
      return concat(parts);
    }
    static decodeData(messageData) {
      const bytes3 = arrayify(messageData);
      const dataLength2 = bytes3.length;
      const [data] = new ByteArrayCoder(dataLength2).decode(bytes3, 0);
      return arrayify(data);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const sender = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const recipient = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const nonce = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const witnessIndex = Number(decoded);
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const predicateGasUsed = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const dataLength2 = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const predicateLength = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const predicateDataLength = decoded;
      [decoded, o] = new ByteArrayCoder(dataLength2).decode(data, o);
      const messageData = decoded;
      [decoded, o] = new ByteArrayCoder(predicateLength).decode(data, o);
      const predicate = decoded;
      [decoded, o] = new ByteArrayCoder(predicateDataLength).decode(data, o);
      const predicateData = decoded;
      return [
        {
          type: 2,
          sender,
          recipient,
          amount,
          witnessIndex,
          nonce,
          predicateGasUsed,
          dataLength: dataLength2,
          predicateLength,
          predicateDataLength,
          data: messageData,
          predicate,
          predicateData
        },
        o
      ];
    }
  };
  var InputCoder = class extends Coder {
    constructor() {
      super("Input", "struct Input", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8").encode(value.type));
      const { type: type3 } = value;
      switch (type3) {
        case 0: {
          parts.push(new InputCoinCoder().encode(value));
          break;
        }
        case 1: {
          parts.push(new InputContractCoder().encode(value));
          break;
        }
        case 2: {
          parts.push(new InputMessageCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_INPUT,
            `Invalid transaction input type: ${type3}.`
          );
        }
      }
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new InputCoinCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new InputContractCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new InputMessageCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_INPUT,
            `Invalid transaction input type: ${type3}.`
          );
        }
      }
    }
  };
  var OutputType = /* @__PURE__ */ ((OutputType2) => {
    OutputType2[OutputType2["Coin"] = 0] = "Coin";
    OutputType2[OutputType2["Contract"] = 1] = "Contract";
    OutputType2[OutputType2["Change"] = 2] = "Change";
    OutputType2[OutputType2["Variable"] = 3] = "Variable";
    OutputType2[OutputType2["ContractCreated"] = 4] = "ContractCreated";
    return OutputType2;
  })(OutputType || {});
  var OutputCoinCoder = class extends Coder {
    constructor() {
      super("OutputCoin", "struct OutputCoin", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 0,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputContractCoder = class extends Coder {
    constructor() {
      super("OutputContract", "struct OutputContract", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8").encode(value.inputIndex));
      parts.push(new B256Coder().encode(value.balanceRoot));
      parts.push(new B256Coder().encode(value.stateRoot));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const inputIndex = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const balanceRoot = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      return [
        {
          type: 1,
          inputIndex,
          balanceRoot,
          stateRoot
        },
        o
      ];
    }
  };
  var OutputChangeCoder = class extends Coder {
    constructor() {
      super("OutputChange", "struct OutputChange", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 2,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputVariableCoder = class extends Coder {
    constructor() {
      super("OutputVariable", "struct OutputVariable", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 3,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputContractCreatedCoder = class extends Coder {
    constructor() {
      super("OutputContractCreated", "struct OutputContractCreated", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.contractId));
      parts.push(new B256Coder().encode(value.stateRoot));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractId = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      return [
        {
          type: 4,
          contractId,
          stateRoot
        },
        o
      ];
    }
  };
  var OutputCoder = class extends Coder {
    constructor() {
      super("Output", " struct Output", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8").encode(value.type));
      const { type: type3 } = value;
      switch (type3) {
        case 0: {
          parts.push(new OutputCoinCoder().encode(value));
          break;
        }
        case 1: {
          parts.push(new OutputContractCoder().encode(value));
          break;
        }
        case 2: {
          parts.push(new OutputChangeCoder().encode(value));
          break;
        }
        case 3: {
          parts.push(new OutputVariableCoder().encode(value));
          break;
        }
        case 4: {
          parts.push(new OutputContractCreatedCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_OUTPUT,
            `Invalid transaction output type: ${type3}.`
          );
        }
      }
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new OutputCoinCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new OutputContractCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new OutputChangeCoder().decode(data, o);
          return [decoded, o];
        }
        case 3: {
          [decoded, o] = new OutputVariableCoder().decode(data, o);
          return [decoded, o];
        }
        case 4: {
          [decoded, o] = new OutputContractCreatedCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_OUTPUT,
            `Invalid transaction output type: ${type3}.`
          );
        }
      }
    }
  };
  var PolicyType = /* @__PURE__ */ ((PolicyType2) => {
    PolicyType2[PolicyType2["GasPrice"] = 1] = "GasPrice";
    PolicyType2[PolicyType2["WitnessLimit"] = 2] = "WitnessLimit";
    PolicyType2[PolicyType2["Maturity"] = 4] = "Maturity";
    PolicyType2[PolicyType2["MaxFee"] = 8] = "MaxFee";
    return PolicyType2;
  })(PolicyType || {});
  var sortPolicies = (policies) => policies.sort((a, b) => a.type - b.type);
  function validateDuplicatedPolicies(policies) {
    const seenTypes = /* @__PURE__ */ new Set();
    policies.forEach((policy) => {
      if (seenTypes.has(policy.type)) {
        throw new FuelError(
          ErrorCode.DUPLICATED_POLICY,
          `Duplicate policy type found: ${8}`
        );
      }
      seenTypes.add(policy.type);
    });
  }
  var PoliciesCoder = class extends Coder {
    constructor() {
      super("Policies", "array Policy", 0);
    }
    encode(policies) {
      validateDuplicatedPolicies(policies);
      const sortedPolicies = sortPolicies(policies);
      const parts = [];
      sortedPolicies.forEach(({ data, type: type3 }) => {
        switch (type3) {
          case 8:
          case 1:
          case 2:
            parts.push(new BigNumberCoder("u64").encode(data));
            break;
          case 4:
            parts.push(new NumberCoder("u32").encode(data));
            break;
          default: {
            throw new FuelError(ErrorCode.INVALID_POLICY_TYPE, `Invalid policy type: ${type3}`);
          }
        }
      });
      return concat(parts);
    }
    decode(data, offset, policyTypes) {
      let o = offset;
      const policies = [];
      if (policyTypes & 1) {
        const [gasPrice, nextOffset] = new BigNumberCoder("u64").decode(data, o);
        o = nextOffset;
        policies.push({ type: 1, data: gasPrice });
      }
      if (policyTypes & 2) {
        const [witnessLimit, nextOffset] = new BigNumberCoder("u64").decode(data, o);
        o = nextOffset;
        policies.push({ type: 2, data: witnessLimit });
      }
      if (policyTypes & 4) {
        const [maturity, nextOffset] = new NumberCoder("u32").decode(data, o);
        o = nextOffset;
        policies.push({ type: 4, data: maturity });
      }
      if (policyTypes & 8) {
        const [maxFee, nextOffset] = new BigNumberCoder("u64").decode(data, o);
        o = nextOffset;
        policies.push({ type: 8, data: maxFee });
      }
      return [policies, o];
    }
  };
  var ReceiptType = /* @__PURE__ */ ((ReceiptType2) => {
    ReceiptType2[ReceiptType2["Call"] = 0] = "Call";
    ReceiptType2[ReceiptType2["Return"] = 1] = "Return";
    ReceiptType2[ReceiptType2["ReturnData"] = 2] = "ReturnData";
    ReceiptType2[ReceiptType2["Panic"] = 3] = "Panic";
    ReceiptType2[ReceiptType2["Revert"] = 4] = "Revert";
    ReceiptType2[ReceiptType2["Log"] = 5] = "Log";
    ReceiptType2[ReceiptType2["LogData"] = 6] = "LogData";
    ReceiptType2[ReceiptType2["Transfer"] = 7] = "Transfer";
    ReceiptType2[ReceiptType2["TransferOut"] = 8] = "TransferOut";
    ReceiptType2[ReceiptType2["ScriptResult"] = 9] = "ScriptResult";
    ReceiptType2[ReceiptType2["MessageOut"] = 10] = "MessageOut";
    ReceiptType2[ReceiptType2["Mint"] = 11] = "Mint";
    ReceiptType2[ReceiptType2["Burn"] = 12] = "Burn";
    return ReceiptType2;
  })(ReceiptType || {});
  var ReceiptMessageOutCoder = class extends Coder {
    constructor() {
      super("ReceiptMessageOut", "struct ReceiptMessageOut", 0);
    }
    static getMessageId(value) {
      const parts = [];
      parts.push(new ByteArrayCoder(32).encode(value.sender));
      parts.push(new ByteArrayCoder(32).encode(value.recipient));
      parts.push(new ByteArrayCoder(32).encode(value.nonce));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(arrayify(value.data || "0x"));
      return sha2563(concat(parts));
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.sender));
      parts.push(new B256Coder().encode(value.recipient));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.nonce));
      parts.push(new NumberCoder("u16").encode(value.data.length));
      parts.push(new B256Coder().encode(value.digest));
      parts.push(new ByteArrayCoder(value.data.length).encode(value.data));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const sender = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const recipient = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const nonce = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const len = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const digest = decoded;
      [decoded, o] = new ByteArrayCoder(len).decode(data, o);
      const messageData = arrayify(decoded);
      const receiptMessageOut = {
        type: 10,
        messageId: "",
        sender,
        recipient,
        amount,
        nonce,
        digest,
        data: messageData
      };
      receiptMessageOut.messageId = ReceiptMessageOutCoder.getMessageId(receiptMessageOut);
      return [receiptMessageOut, o];
    }
  };
  var getAssetId = (contractId, subId) => {
    const contractIdBytes = arrayify(contractId);
    const subIdBytes = arrayify(subId);
    return sha2563(concat([contractIdBytes, subIdBytes]));
  };
  var ReceiptMintCoder = class extends Coder {
    constructor() {
      super("ReceiptMint", "struct ReceiptMint", 0);
    }
    static getAssetId(contractId, subId) {
      return getAssetId(contractId, subId);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.subId));
      parts.push(new B256Coder().encode(value.contractId));
      parts.push(new BigNumberCoder("u64").encode(value.val));
      parts.push(new BigNumberCoder("u64").encode(value.pc));
      parts.push(new BigNumberCoder("u64").encode(value.is));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const subId = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractId = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const val = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const pc = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const is = decoded;
      const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
      const receiptMint = {
        type: 11,
        subId,
        contractId,
        val,
        pc,
        is,
        assetId
      };
      return [receiptMint, o];
    }
  };
  var ReceiptBurnCoder = class extends Coder {
    constructor() {
      super("ReceiptBurn", "struct ReceiptBurn", 0);
    }
    static getAssetId(contractId, subId) {
      return getAssetId(contractId, subId);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.subId));
      parts.push(new B256Coder().encode(value.contractId));
      parts.push(new BigNumberCoder("u64").encode(value.val));
      parts.push(new BigNumberCoder("u64").encode(value.pc));
      parts.push(new BigNumberCoder("u64").encode(value.is));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const subId = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractId = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const val = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const pc = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const is = decoded;
      const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
      const receiptBurn = {
        type: 12,
        subId,
        contractId,
        val,
        pc,
        is,
        assetId
      };
      return [receiptBurn, o];
    }
  };
  var StorageSlotCoder = class extends StructCoder {
    constructor() {
      super("StorageSlot", {
        key: new B256Coder(),
        value: new B256Coder()
      });
    }
  };
  var WitnessCoder = class extends Coder {
    constructor() {
      super(
        "Witness",
        // Types of dynamic length are not supported in the ABI
        "unknown",
        0
      );
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u32").encode(value.dataLength));
      parts.push(new ByteArrayCoder(value.dataLength).encode(value.data));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const dataLength2 = decoded;
      [decoded, o] = new ByteArrayCoder(dataLength2).decode(data, o);
      const witnessData = decoded;
      return [
        {
          dataLength: dataLength2,
          data: witnessData
        },
        o
      ];
    }
  };
  var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
    TransactionType2[TransactionType2["Script"] = 0] = "Script";
    TransactionType2[TransactionType2["Create"] = 1] = "Create";
    TransactionType2[TransactionType2["Mint"] = 2] = "Mint";
    return TransactionType2;
  })(TransactionType || {});
  var TransactionScriptCoder = class extends Coder {
    constructor() {
      super("TransactionScript", "struct TransactionScript", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new BigNumberCoder("u64").encode(value.scriptGasLimit));
      parts.push(new NumberCoder("u32").encode(value.scriptLength));
      parts.push(new NumberCoder("u32").encode(value.scriptDataLength));
      parts.push(new NumberCoder("u32").encode(value.policyTypes));
      parts.push(new NumberCoder("u8").encode(value.inputsCount));
      parts.push(new NumberCoder("u8").encode(value.outputsCount));
      parts.push(new NumberCoder("u8").encode(value.witnessesCount));
      parts.push(new B256Coder().encode(value.receiptsRoot));
      parts.push(new ByteArrayCoder(value.scriptLength).encode(value.script));
      parts.push(new ByteArrayCoder(value.scriptDataLength).encode(value.scriptData));
      parts.push(new PoliciesCoder().encode(value.policies));
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const scriptGasLimit = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const scriptLength = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const scriptDataLength = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const policyTypes = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const receiptsRoot = decoded;
      [decoded, o] = new ByteArrayCoder(scriptLength).decode(data, o);
      const script = decoded;
      [decoded, o] = new ByteArrayCoder(scriptDataLength).decode(data, o);
      const scriptData = decoded;
      [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);
      const policies = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 0,
          scriptGasLimit,
          scriptLength,
          scriptDataLength,
          policyTypes,
          inputsCount,
          outputsCount,
          witnessesCount,
          receiptsRoot,
          script,
          scriptData,
          policies,
          inputs,
          outputs,
          witnesses
        },
        o
      ];
    }
  };
  var TransactionCreateCoder = class extends Coder {
    constructor() {
      super("TransactionCreate", "struct TransactionCreate", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u32").encode(value.bytecodeLength));
      parts.push(new NumberCoder("u8").encode(value.bytecodeWitnessIndex));
      parts.push(new NumberCoder("u32").encode(value.policyTypes));
      parts.push(new NumberCoder("u16").encode(value.storageSlotsCount));
      parts.push(new NumberCoder("u8").encode(value.inputsCount));
      parts.push(new NumberCoder("u8").encode(value.outputsCount));
      parts.push(new NumberCoder("u8").encode(value.witnessesCount));
      parts.push(new B256Coder().encode(value.salt));
      parts.push(new PoliciesCoder().encode(value.policies));
      parts.push(
        new ArrayCoder(new StorageSlotCoder(), value.storageSlotsCount).encode(value.storageSlots)
      );
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const bytecodeLength = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const bytecodeWitnessIndex = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const policyTypes = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const storageSlotsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const salt = decoded;
      [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);
      const policies = decoded;
      [decoded, o] = new ArrayCoder(new StorageSlotCoder(), storageSlotsCount).decode(data, o);
      const storageSlots = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 1,
          bytecodeLength,
          bytecodeWitnessIndex,
          policyTypes,
          storageSlotsCount,
          inputsCount,
          outputsCount,
          witnessesCount,
          salt,
          policies,
          storageSlots,
          inputs,
          outputs,
          witnesses
        },
        o
      ];
    }
  };
  var TransactionMintCoder = class extends Coder {
    constructor() {
      super("TransactionMint", "struct TransactionMint", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new InputContractCoder().encode(value.inputContract));
      parts.push(new OutputContractCoder().encode(value.outputContract));
      parts.push(new BigNumberCoder("u64").encode(value.mintAmount));
      parts.push(new B256Coder().encode(value.mintAssetId));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new InputContractCoder().decode(data, o);
      const inputContract = decoded;
      [decoded, o] = new OutputContractCoder().decode(data, o);
      const outputContract = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const mintAmount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const mintAssetId = decoded;
      return [
        {
          type: 2,
          txPointer,
          inputContract,
          outputContract,
          mintAmount,
          mintAssetId
        },
        o
      ];
    }
  };
  var TransactionCoder = class extends Coder {
    constructor() {
      super("Transaction", "struct Transaction", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8").encode(value.type));
      const { type: type3 } = value;
      switch (value.type) {
        case 0: {
          parts.push(
            new TransactionScriptCoder().encode(value)
          );
          break;
        }
        case 1: {
          parts.push(
            new TransactionCreateCoder().encode(value)
          );
          break;
        }
        case 2: {
          parts.push(new TransactionMintCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_TYPE,
            `Invalid transaction type: ${type3}`
          );
        }
      }
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new TransactionScriptCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new TransactionCreateCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new TransactionMintCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_TYPE,
            `Invalid transaction type: ${type3}`
          );
        }
      }
    }
  };

  // ../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    bitGet: () => bitGet,
    bitLen: () => bitLen,
    bitMask: () => bitMask,
    bitSet: () => bitSet,
    bytesToHex: () => bytesToHex,
    bytesToNumberBE: () => bytesToNumberBE,
    bytesToNumberLE: () => bytesToNumberLE,
    concatBytes: () => concatBytes3,
    createHmacDrbg: () => createHmacDrbg,
    ensureBytes: () => ensureBytes,
    equalBytes: () => equalBytes,
    hexToBytes: () => hexToBytes,
    hexToNumber: () => hexToNumber,
    isBytes: () => isBytes3,
    numberToBytesBE: () => numberToBytesBE,
    numberToBytesLE: () => numberToBytesLE,
    numberToHexUnpadded: () => numberToHexUnpadded,
    numberToVarBytesBE: () => numberToVarBytesBE,
    utf8ToBytes: () => utf8ToBytes3,
    validateObject: () => validateObject
  });
  var _0n3 = BigInt(0);
  var _1n3 = BigInt(1);
  var _2n3 = BigInt(2);
  function isBytes3(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes3) {
    if (!isBytes3(bytes3))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0; i < bytes3.length; i++) {
      hex += hexes2[bytes3[i]];
    }
    return hex;
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
      return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
      return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
      return char - (asciis._a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array2 = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array2[ai] = n1 * 16 + n2;
    }
    return array2;
  }
  function bytesToNumberBE(bytes3) {
    return hexToNumber(bytesToHex(bytes3));
  }
  function bytesToNumberLE(bytes3) {
    if (!isBytes3(bytes3))
      throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (isBytes3(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes3(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      if (!isBytes3(a))
        throw new Error("Uint8Array expected");
      sum += a.length;
    }
    let res = new Uint8Array(sum);
    let pad3 = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad3);
      pad3 += a.length;
    }
    return res;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  function utf8ToBytes3(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n3; n >>= _1n3, len += 1)
      ;
    return len;
  }
  function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n3;
  }
  var bitSet = (n, pos, value) => {
    return n | (value ? _1n3 : _0n3) << BigInt(pos);
  };
  var bitMask = (n) => (_2n3 << BigInt(n - 1)) - _1n3;
  var u8n = (data) => new Uint8Array(data);
  var u8fr = (arr) => Uint8Array.from(arr);
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n()) => {
      k = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8fr([1]), seed);
      v = h();
    };
    const gen3 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes3(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen3())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object2) => object2.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object2, validators, optValidators = {}) {
    const checkField = (fieldName, type3, isOptional) => {
      const checkVal = validatorFns[type3];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type3}", expected function`);
      const val = object2[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object2)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type3}`);
      }
    };
    for (const [fieldName, type3] of Object.entries(validators))
      checkField(fieldName, type3, false);
    for (const [fieldName, type3] of Object.entries(optValidators))
      checkField(fieldName, type3, true);
    return object2;
  }

  // ../account/dist/index.mjs
  var import_graphql_request = __toESM(require_dist2(), 1);

  // ../../node_modules/.pnpm/tslib@2.6.0/node_modules/tslib/tslib.es6.mjs
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/devAssert.mjs
  function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message);
    }
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isObjectLike.mjs
  function isObjectLike(value) {
    return typeof value == "object" && value !== null;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/invariant.mjs
  function invariant(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(
        message != null ? message : "Unexpected invariant triggered."
      );
    }
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/location.mjs
  var LineRegExp = /\r\n|[\n\r]/g;
  function getLocation(source, position) {
    let lastLineStart = 0;
    let line = 1;
    for (const match3 of source.body.matchAll(LineRegExp)) {
      typeof match3.index === "number" || invariant(false);
      if (match3.index >= position) {
        break;
      }
      lastLineStart = match3.index + match3[0].length;
      line += 1;
    }
    return {
      line,
      column: position + 1 - lastLineStart
    };
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printLocation.mjs
  function printLocation(location) {
    return printSourceLocation(
      location.source,
      getLocation(location.source, location.start)
    );
  }
  function printSourceLocation(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i = 0; i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      // Lines specified like this: ["prefix", "string"],
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_, line]) => line !== void 0);
    const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
    return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/GraphQLError.mjs
  function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  }
  var GraphQLError = class extends Error {
    /**
     * An array of `{ line, column }` locations within the source GraphQL document
     * which correspond to this error.
     *
     * Errors during validation often contain multiple locations, for example to
     * point out two things with the same name. Errors during execution include a
     * single location, the field which produced the error.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     */
    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     */
    /**
     * An array of character offsets within the source GraphQL document
     * which correspond to this error.
     */
    /**
     * The original error thrown from a field resolver during execution.
     */
    /**
     * Extension fields to add to the formatted error.
     */
    /**
     * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
     */
    constructor(message, ...rawArgs) {
      var _this$nodes, _nodeLocations$, _ref;
      const { nodes, source, positions, path: path5, originalError, extensions } = toNormalizedOptions(rawArgs);
      super(message);
      this.name = "GraphQLError";
      this.path = path5 !== null && path5 !== void 0 ? path5 : void 0;
      this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
      this.nodes = undefinedIfEmpty(
        Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
      );
      const nodeLocations = undefinedIfEmpty(
        (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
      );
      this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
      this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
      this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
      const originalExtensions = isObjectLike(
        originalError === null || originalError === void 0 ? void 0 : originalError.extensions
      ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
      this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
      Object.defineProperties(this, {
        message: {
          writable: true,
          enumerable: true
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== void 0 && originalError.stack) {
        Object.defineProperty(this, "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, GraphQLError);
      } else {
        Object.defineProperty(this, "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let output3 = this.message;
      if (this.nodes) {
        for (const node of this.nodes) {
          if (node.loc) {
            output3 += "\n\n" + printLocation(node.loc);
          }
        }
      } else if (this.source && this.locations) {
        for (const location of this.locations) {
          output3 += "\n\n" + printSourceLocation(this.source, location);
        }
      }
      return output3;
    }
    toJSON() {
      const formattedError = {
        message: this.message
      };
      if (this.locations != null) {
        formattedError.locations = this.locations;
      }
      if (this.path != null) {
        formattedError.path = this.path;
      }
      if (this.extensions != null && Object.keys(this.extensions).length > 0) {
        formattedError.extensions = this.extensions;
      }
      return formattedError;
    }
  };
  function undefinedIfEmpty(array2) {
    return array2 === void 0 || array2.length === 0 ? void 0 : array2;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/syntaxError.mjs
  function syntaxError(source, position, description) {
    return new GraphQLError(`Syntax Error: ${description}`, {
      source,
      positions: [position]
    });
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/ast.mjs
  var Location = class {
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The Token at which this Node begins.
     */
    /**
     * The Token at which this Node ends.
     */
    /**
     * The Source document the AST represents.
     */
    constructor(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  };
  var Token = class {
    /**
     * The kind of Token.
     */
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The 1-indexed line number on which this Token appears.
     */
    /**
     * The 1-indexed column number at which this Token begins.
     */
    /**
     * For non-punctuation tokens, represents the interpreted value of the token.
     *
     * Note: is undefined for punctuation tokens, but typed as string for
     * convenience in the parser.
     */
    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     */
    constructor(kind, start, end, line, column, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = null;
      this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  };
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  var kindValues = new Set(Object.keys(QueryDocumentKeys));
  function isNode(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
  }
  var OperationTypeNode;
  (function(OperationTypeNode2) {
    OperationTypeNode2["QUERY"] = "query";
    OperationTypeNode2["MUTATION"] = "mutation";
    OperationTypeNode2["SUBSCRIPTION"] = "subscription";
  })(OperationTypeNode || (OperationTypeNode = {}));

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/directiveLocation.mjs
  var DirectiveLocation;
  (function(DirectiveLocation2) {
    DirectiveLocation2["QUERY"] = "QUERY";
    DirectiveLocation2["MUTATION"] = "MUTATION";
    DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation2["FIELD"] = "FIELD";
    DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation2["SCHEMA"] = "SCHEMA";
    DirectiveLocation2["SCALAR"] = "SCALAR";
    DirectiveLocation2["OBJECT"] = "OBJECT";
    DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation2["INTERFACE"] = "INTERFACE";
    DirectiveLocation2["UNION"] = "UNION";
    DirectiveLocation2["ENUM"] = "ENUM";
    DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
  })(DirectiveLocation || (DirectiveLocation = {}));

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/kinds.mjs
  var Kind;
  (function(Kind2) {
    Kind2["NAME"] = "Name";
    Kind2["DOCUMENT"] = "Document";
    Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind2["SELECTION_SET"] = "SelectionSet";
    Kind2["FIELD"] = "Field";
    Kind2["ARGUMENT"] = "Argument";
    Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind2["INLINE_FRAGMENT"] = "InlineFragment";
    Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind2["VARIABLE"] = "Variable";
    Kind2["INT"] = "IntValue";
    Kind2["FLOAT"] = "FloatValue";
    Kind2["STRING"] = "StringValue";
    Kind2["BOOLEAN"] = "BooleanValue";
    Kind2["NULL"] = "NullValue";
    Kind2["ENUM"] = "EnumValue";
    Kind2["LIST"] = "ListValue";
    Kind2["OBJECT"] = "ObjectValue";
    Kind2["OBJECT_FIELD"] = "ObjectField";
    Kind2["DIRECTIVE"] = "Directive";
    Kind2["NAMED_TYPE"] = "NamedType";
    Kind2["LIST_TYPE"] = "ListType";
    Kind2["NON_NULL_TYPE"] = "NonNullType";
    Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind2["FIELD_DEFINITION"] = "FieldDefinition";
    Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
  })(Kind || (Kind = {}));

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/characterClasses.mjs
  function isWhiteSpace(code) {
    return code === 9 || code === 32;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isLetter(code) {
    return code >= 97 && code <= 122 || // A-Z
    code >= 65 && code <= 90;
  }
  function isNameStart(code) {
    return isLetter(code) || code === 95;
  }
  function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/blockString.mjs
  function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i = 0; i < lines.length; ++i) {
      var _firstNonEmptyLine;
      const line = lines[i];
      const indent2 = leadingWhitespace(line);
      if (indent2 === line.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
      lastNonEmptyLine = i;
      if (i !== 0 && indent2 < commonIndent) {
        commonIndent = indent2;
      }
    }
    return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
      (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
      lastNonEmptyLine + 1
    );
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
      ++i;
    }
    return i;
  }
  function printBlockString(value, options) {
    const escapedValue = value.replace(/"""/g, '\\"""');
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1;
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
    (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result = "";
    const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
      result += "\n";
    }
    result += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
      result += "\n";
    }
    return '"""' + result + '"""';
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/tokenKind.mjs
  var TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind || (TokenKind = {}));

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/lexer.mjs
  var Lexer = class {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     */
    /**
     * The character offset at which the current line begins.
     */
    constructor(source) {
      const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
      this.source = source;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      this.lastToken = this.token;
      const token = this.token = this.lookahead();
      return token;
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the state of Lexer.
     */
    lookahead() {
      let token = this.token;
      if (token.kind !== TokenKind.EOF) {
        do {
          if (token.next) {
            token = token.next;
          } else {
            const nextToken = readNextToken(this, token.end);
            token.next = nextToken;
            nextToken.prev = token;
            token = nextToken;
          }
        } while (token.kind === TokenKind.COMMENT);
      }
      return token;
    }
  };
  function isPunctuatorTokenKind(kind) {
    return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
  }
  function isUnicodeScalarValue(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  }
  function isSupplementaryCodePoint(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
  }
  function isLeadingSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailingSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function printCodePointAt(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === void 0) {
      return TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char = String.fromCodePoint(code);
      return char === '"' ? `'"'` : `"${char}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  }
  function createToken(lexer, kind, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new Token(kind, start, end, line, col, value);
  }
  function readNextToken(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      switch (code) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++position;
          continue;
        case 10:
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 13:
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 35:
          return readComment(lexer, position);
        case 33:
          return createToken(lexer, TokenKind.BANG, position, position + 1);
        case 36:
          return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
        case 38:
          return createToken(lexer, TokenKind.AMP, position, position + 1);
        case 40:
          return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
        case 41:
          return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
        case 46:
          if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
            return createToken(lexer, TokenKind.SPREAD, position, position + 3);
          }
          break;
        case 58:
          return createToken(lexer, TokenKind.COLON, position, position + 1);
        case 61:
          return createToken(lexer, TokenKind.EQUALS, position, position + 1);
        case 64:
          return createToken(lexer, TokenKind.AT, position, position + 1);
        case 91:
          return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
        case 93:
          return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
        case 123:
          return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
        case 124:
          return createToken(lexer, TokenKind.PIPE, position, position + 1);
        case 125:
          return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
        case 34:
          if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            return readBlockString(lexer, position);
          }
          return readString(lexer, position);
      }
      if (isDigit(code) || code === 45) {
        return readNumber(lexer, position, code);
      }
      if (isNameStart(code)) {
        return readName(lexer, position);
      }
      throw syntaxError(
        lexer.source,
        position,
        code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
      );
    }
    return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
  }
  function readComment(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.COMMENT,
      start,
      position,
      body.slice(start + 1, position)
    );
  }
  function readNumber(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position = start;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position);
    }
    if (code === 48) {
      code = body.charCodeAt(++position);
      if (isDigit(code)) {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid number, unexpected digit after 0: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    } else {
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position);
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position);
      }
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46 || isNameStart(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
    return createToken(
      lexer,
      isFloat ? TokenKind.FLOAT : TokenKind.INT,
      start,
      position,
      body.slice(start, position)
    );
  }
  function readDigits(lexer, start, firstCode) {
    if (!isDigit(firstCode)) {
      throw syntaxError(
        lexer.source,
        start,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          start
        )}.`
      );
    }
    const body = lexer.source.body;
    let position = start + 1;
    while (isDigit(body.charCodeAt(position))) {
      ++position;
    }
    return position;
  }
  function readString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    let chunkStart = position;
    let value = "";
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34) {
        value += body.slice(chunkStart, position);
        return createToken(lexer, TokenKind.STRING, start, position + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position);
        const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
        value += escape2.value;
        position += escape2.size;
        chunkStart = position;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readEscapedUnicodeVariableWidth(lexer, position) {
    const body = lexer.source.body;
    let point = 0;
    let size = 3;
    while (size < 12) {
      const code = body.charCodeAt(position + size++);
      if (code === 125) {
        if (size < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(
        position,
        position + size
      )}".`
    );
  }
  function readEscapedUnicodeFixedWidth(lexer, position) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
    );
  }
  function read16BitHexCode(body, position) {
    return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
  }
  function readHexDigit(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  }
  function readEscapedCharacter(lexer, position) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: "\n",
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid character escape sequence: "${body.slice(
        position,
        position + 2
      )}".`
    );
  }
  function readBlockString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position = start + 3;
    let chunkStart = position;
    let currentLine = "";
    const blockLines = [];
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        const token = createToken(
          lexer,
          TokenKind.BLOCK_STRING,
          start,
          position + 3,
          // Return a string of the lines joined with U+000A.
          dedentBlockStringLines(blockLines).join("\n")
        );
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token;
      }
      if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
        currentLine += body.slice(chunkStart, position);
        chunkStart = position + 1;
        position += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        currentLine = "";
        chunkStart = position;
        lineStart = position;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readName(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (isNameContinue(code)) {
        ++position;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.NAME,
      start,
      position,
      body.slice(start, position)
    );
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/inspect.mjs
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object2, seenValues) {
    const entries = Object.entries(object2);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object2) + "]";
    }
    const properties = entries.map(
      ([key, value]) => key + ": " + formatValue(value, seenValues)
    );
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array2, seenValues) {
    if (array2.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
    const remaining = array2.length - len;
    const items = [];
    for (let i = 0; i < len; ++i) {
      items.push(formatValue(array2[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object2) {
    const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object2.constructor === "function") {
      const name = object2.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/instanceOf.mjs
  var instanceOf = (
    /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    // eslint-disable-next-line no-undef
    process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    }
  );

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/source.mjs
  var Source = class {
    constructor(body, name = "GraphQL request", locationOffset = {
      line: 1,
      column: 1
    }) {
      typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
      this.body = body;
      this.name = name;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || devAssert(
        false,
        "line in locationOffset is 1-indexed and must be positive."
      );
      this.locationOffset.column > 0 || devAssert(
        false,
        "column in locationOffset is 1-indexed and must be positive."
      );
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  };
  function isSource(source) {
    return instanceOf(source, Source);
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/parser.mjs
  function parse(source, options) {
    const parser = new Parser(source, options);
    return parser.parseDocument();
  }
  var Parser = class {
    constructor(source, options = {}) {
      const sourceObj = isSource(source) ? source : new Source(source);
      this._lexer = new Lexer(sourceObj);
      this._options = options;
      this._tokenCounter = 0;
    }
    /**
     * Converts a name lex token into a name parse node.
     */
    parseName() {
      const token = this.expectToken(TokenKind.NAME);
      return this.node(token, {
        kind: Kind.NAME,
        value: token.value
      });
    }
    // Implements the parsing rules in the Document section.
    /**
     * Document : Definition+
     */
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: Kind.DOCUMENT,
        definitions: this.many(
          TokenKind.SOF,
          this.parseDefinition,
          TokenKind.EOF
        )
      });
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     *
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     *
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */
    parseDefinition() {
      if (this.peek(TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      }
      const hasDescription = this.peekDescription();
      const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (hasDescription) {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            "Unexpected description, descriptions are supported only on type definitions."
          );
        }
        switch (keywordToken.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    // Implements the parsing rules in the Operations section.
    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */
    parseOperationDefinition() {
      const start = this._lexer.token;
      if (this.peek(TokenKind.BRACE_L)) {
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation: OperationTypeNode.QUERY,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      }
      const operation = this.parseOperationType();
      let name;
      if (this.peek(TokenKind.NAME)) {
        name = this.parseName();
      }
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * OperationType : one of query mutation subscription
     */
    parseOperationType() {
      const operationToken = this.expectToken(TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return OperationTypeNode.QUERY;
        case "mutation":
          return OperationTypeNode.MUTATION;
        case "subscription":
          return OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(operationToken);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */
    parseVariableDefinitions() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseVariableDefinition,
        TokenKind.PAREN_R
      );
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    /**
     * Variable : $ Name
     */
    parseVariable() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.DOLLAR);
      return this.node(start, {
        kind: Kind.VARIABLE,
        name: this.parseName()
      });
    }
    /**
     * ```
     * SelectionSet : { Selection+ }
     * ```
     */
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: Kind.SELECTION_SET,
        selections: this.many(
          TokenKind.BRACE_L,
          this.parseSelection,
          TokenKind.BRACE_R
        )
      });
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    parseSelection() {
      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */
    parseField() {
      const start = this._lexer.token;
      const nameOrAlias = this.parseName();
      let alias;
      let name;
      if (this.expectOptionalToken(TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return this.node(start, {
        kind: Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */
    parseArguments(isConst) {
      const item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */
    parseArgument(isConst = false) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseConstArgument() {
      return this.parseArgument(true);
    }
    // Implements the parsing rules in the Fragments section.
    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */
    parseFragment() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.SPREAD);
      const hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
        return this.node(start, {
          kind: Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false)
        });
      }
      return this.node(start, {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */
    parseFragmentDefinition() {
      const start = this._lexer.token;
      this.expectKeyword("fragment");
      if (this._options.allowLegacyFragmentVariables === true) {
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentName : Name but not `on`
     */
    parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    }
    // Implements the parsing rules in the Values section.
    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseValueLiteral(isConst) {
      const token = this._lexer.token;
      switch (token.kind) {
        case TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case TokenKind.INT:
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.INT,
            value: token.value
          });
        case TokenKind.FLOAT:
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.FLOAT,
            value: token.value
          });
        case TokenKind.STRING:
        case TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case TokenKind.NAME:
          this.advanceLexer();
          switch (token.value) {
            case "true":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: true
              });
            case "false":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: false
              });
            case "null":
              return this.node(token, {
                kind: Kind.NULL
              });
            default:
              return this.node(token, {
                kind: Kind.ENUM,
                value: token.value
              });
          }
        case TokenKind.DOLLAR:
          if (isConst) {
            this.expectToken(TokenKind.DOLLAR);
            if (this._lexer.token.kind === TokenKind.NAME) {
              const varName = this._lexer.token.value;
              throw syntaxError(
                this._lexer.source,
                token.start,
                `Unexpected variable "$${varName}" in constant value.`
              );
            } else {
              throw this.unexpected(token);
            }
          }
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
      const token = this._lexer.token;
      this.advanceLexer();
      return this.node(token, {
        kind: Kind.STRING,
        value: token.value,
        block: token.kind === TokenKind.BLOCK_STRING
      });
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */
    parseList(isConst) {
      const item = () => this.parseValueLiteral(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.LIST,
        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
      });
    }
    /**
     * ```
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     * ```
     */
    parseObject(isConst) {
      const item = () => this.parseObjectField(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.OBJECT,
        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
      });
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */
    parseObjectField(isConst) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    // Implements the parsing rules in the Directives section.
    /**
     * Directives[Const] : Directive[?Const]+
     */
    parseDirectives(isConst) {
      const directives = [];
      while (this.peek(TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    }
    parseConstDirectives() {
      return this.parseDirectives(true);
    }
    /**
     * ```
     * Directive[Const] : @ Name Arguments[?Const]?
     * ```
     */
    parseDirective(isConst) {
      const start = this._lexer.token;
      this.expectToken(TokenKind.AT);
      return this.node(start, {
        kind: Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst)
      });
    }
    // Implements the parsing rules in the Types section.
    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */
    parseTypeReference() {
      const start = this._lexer.token;
      let type3;
      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
        const innerType = this.parseTypeReference();
        this.expectToken(TokenKind.BRACKET_R);
        type3 = this.node(start, {
          kind: Kind.LIST_TYPE,
          type: innerType
        });
      } else {
        type3 = this.parseNamedType();
      }
      if (this.expectOptionalToken(TokenKind.BANG)) {
        return this.node(start, {
          kind: Kind.NON_NULL_TYPE,
          type: type3
        });
      }
      return type3;
    }
    /**
     * NamedType : Name
     */
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    // Implements the parsing rules in the Type Definition section.
    peekDescription() {
      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */
    parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    }
    /**
     * ```
     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
     * ```
     */
    parseSchemaDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.many(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      return this.node(start, {
        kind: Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes
      });
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */
    parseOperationTypeDefinition() {
      const start = this._lexer.token;
      const operation = this.parseOperationType();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseNamedType();
      return this.node(start, {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type: type3
      });
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */
    parseScalarTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives
      });
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */
    parseObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
     * ```
     * FieldsDefinition : { FieldDefinition+ }
     * ```
     */
    parseFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseFieldDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */
    parseFieldDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseTypeReference();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args,
        type: type3,
        directives
      });
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */
    parseArgumentDefs() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseInputValueDef,
        TokenKind.PAREN_R
      );
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */
    parseInputValueDef() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseTypeReference();
      let defaultValue;
      if (this.expectOptionalToken(TokenKind.EQUALS)) {
        defaultValue = this.parseConstValueLiteral();
      }
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type: type3,
        defaultValue,
        directives
      });
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */
    parseInterfaceTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */
    parseUnionTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types2 = this.parseUnionMemberTypes();
      return this.node(start, {
        kind: Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types: types2
      });
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    parseUnionMemberTypes() {
      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */
    parseEnumTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      return this.node(start, {
        kind: Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values
      });
    }
    /**
     * ```
     * EnumValuesDefinition : { EnumValueDefinition+ }
     * ```
     */
    parseEnumValuesDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseEnumValueDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     */
    parseEnumValueDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseEnumValueName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives
      });
    }
    /**
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          `${getTokenDesc(
            this._lexer.token
          )} is reserved and cannot be used for an enum value.`
        );
      }
      return this.parseName();
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */
    parseInputObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields
      });
    }
    /**
     * ```
     * InputFieldsDefinition : { InputValueDefinition+ }
     * ```
     */
    parseInputFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseInputValueDef,
        TokenKind.BRACE_R
      );
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */
    parseTypeSystemExtension() {
      const keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    /**
     * ```
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     * ```
     */
    parseSchemaExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.optionalMany(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes
      });
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */
    parseScalarTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives
      });
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */
    parseObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * InterfaceTypeExtension :
     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend interface Name ImplementsInterfaces? Directives[Const]
     *  - extend interface Name ImplementsInterfaces
     */
    parseInterfaceTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */
    parseUnionTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types2 = this.parseUnionMemberTypes();
      if (directives.length === 0 && types2.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types: types2
      });
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */
    parseEnumTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values
      });
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */
    parseInputObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields
      });
    }
    /**
     * ```
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     * ```
     */
    parseDirectiveDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(TokenKind.AT);
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      const repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const locations = this.parseDirectiveLocations();
      return this.node(start, {
        kind: Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args,
        repeatable,
        locations
      });
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */
    parseDirectiveLocations() {
      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */
    parseDirectiveLocation() {
      const start = this._lexer.token;
      const name = this.parseName();
      if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
        return name;
      }
      throw this.unexpected(start);
    }
    // Core parsing utility functions
    /**
     * Returns a node that, if configured to do so, sets a "loc" field as a
     * location object, used to identify the place in the source that created a
     * given parsed object.
     */
    node(startToken, node) {
      if (this._options.noLocation !== true) {
        node.loc = new Location(
          startToken,
          this._lexer.lastToken,
          this._lexer.source
        );
      }
      return node;
    }
    /**
     * Determines if the next token is of a given kind
     */
    peek(kind) {
      return this._lexer.token.kind === kind;
    }
    /**
     * If the next token is of the given kind, return that token after advancing the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return token;
      }
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
      );
    }
    /**
     * If the next token is of the given kind, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this.advanceLexer();
      } else {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected "${value}", found ${getTokenDesc(token)}.`
        );
      }
    }
    /**
     * If the next token is a given keyword, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token is encountered.
     */
    unexpected(atToken) {
      const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
      return syntaxError(
        this._lexer.source,
        token.start,
        `Unexpected ${getTokenDesc(token)}.`
      );
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    }
    /**
     * Returns a list of parse nodes, determined by the parseFn.
     * It can be empty only if open token is missing otherwise it will always return non-empty list
     * that begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
     * Advances the parser to the next lex token after last item in the list.
     */
    delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    }
    advanceLexer() {
      const { maxTokens } = this._options;
      const token = this._lexer.advance();
      if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
        ++this._tokenCounter;
        if (this._tokenCounter > maxTokens) {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Document contains more that ${maxTokens} tokens. Parsing aborted.`
          );
        }
      }
    }
  };
  function getTokenDesc(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
  }
  function getTokenKindDesc(kind) {
    return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printString.mjs
  function printString(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
  }
  var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function escapedReplacer(str) {
    return escapeSequences[str.charCodeAt(0)];
  }
  var escapeSequences = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 2F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 3F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 4F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    // 5F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 6F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/visitor.mjs
  var BREAK = Object.freeze({});
  function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
    const enterLeaveMap = /* @__PURE__ */ new Map();
    for (const kind of Object.values(Kind)) {
      enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
    }
    let stack = void 0;
    let inArray = Array.isArray(root);
    let keys4 = [root];
    let index = -1;
    let edits = [];
    let node = root;
    let key = void 0;
    let parent = void 0;
    const path5 = [];
    const ancestors = [];
    do {
      index++;
      const isLeaving = index === keys4.length;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? void 0 : path5[path5.length - 1];
        node = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === null) {
                node.splice(arrayKey, 1);
                editOffset++;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            node = Object.defineProperties(
              {},
              Object.getOwnPropertyDescriptors(node)
            );
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index = stack.index;
        keys4 = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent) {
        key = inArray ? index : keys4[index];
        node = parent[key];
        if (node === null || node === void 0) {
          continue;
        }
        path5.push(key);
      }
      let result;
      if (!Array.isArray(node)) {
        var _enterLeaveMap$get, _enterLeaveMap$get2;
        isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
        const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
        result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path5, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path5.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path5.pop();
              continue;
            }
          }
        }
      }
      if (result === void 0 && isEdited) {
        edits.push([key, node]);
      }
      if (isLeaving) {
        path5.pop();
      } else {
        var _node$kind;
        stack = {
          inArray,
          index,
          keys: keys4,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        keys4 = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
        index = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node;
      }
    } while (stack !== void 0);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1];
    }
    return root;
  }
  function getEnterLeaveForKind(visitor, kind) {
    const kindVisitor = visitor[kind];
    if (typeof kindVisitor === "object") {
      return kindVisitor;
    } else if (typeof kindVisitor === "function") {
      return {
        enter: kindVisitor,
        leave: void 0
      };
    }
    return {
      enter: visitor.enter,
      leave: visitor.leave
    };
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printer.mjs
  function print(ast) {
    return visit(ast, printDocASTReducer);
  }
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: {
      leave: (node) => node.value
    },
    Variable: {
      leave: (node) => "$" + node.name
    },
    // Document
    Document: {
      leave: (node) => join6(node.definitions, "\n\n")
    },
    OperationDefinition: {
      leave(node) {
        const varDefs = wrap("(", join6(node.variableDefinitions, ", "), ")");
        const prefix = join6(
          [
            node.operation,
            join6([node.name, varDefs]),
            join6(node.directives, " ")
          ],
          " "
        );
        return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type: type3, defaultValue, directives }) => variable + ": " + type3 + wrap(" = ", defaultValue) + wrap(" ", join6(directives, " "))
    },
    SelectionSet: {
      leave: ({ selections }) => block(selections)
    },
    Field: {
      leave({ alias, name, arguments: args, directives, selectionSet }) {
        const prefix = wrap("", alias, ": ") + name;
        let argsLine = prefix + wrap("(", join6(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap("(\n", indent(join6(args, "\n")), "\n)");
        }
        return join6([argsLine, join6(directives, " "), selectionSet], " ");
      }
    },
    Argument: {
      leave: ({ name, value }) => name + ": " + value
    },
    // Fragments
    FragmentSpread: {
      leave: ({ name, directives }) => "..." + name + wrap(" ", join6(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join6(
        [
          "...",
          wrap("on ", typeCondition),
          join6(directives, " "),
          selectionSet
        ],
        " "
      )
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
        // or removed in the future.
        `fragment ${name}${wrap("(", join6(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join6(directives, " "), " ")}` + selectionSet
      )
    },
    // Value
    IntValue: {
      leave: ({ value }) => value
    },
    FloatValue: {
      leave: ({ value }) => value
    },
    StringValue: {
      leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
    },
    BooleanValue: {
      leave: ({ value }) => value ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value }) => value
    },
    ListValue: {
      leave: ({ values }) => "[" + join6(values, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields }) => "{" + join6(fields, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name, value }) => name + ": " + value
    },
    // Directive
    Directive: {
      leave: ({ name, arguments: args }) => "@" + name + wrap("(", join6(args, ", "), ")")
    },
    // Type
    NamedType: {
      leave: ({ name }) => name
    },
    ListType: {
      leave: ({ type: type3 }) => "[" + type3 + "]"
    },
    NonNullType: {
      leave: ({ type: type3 }) => type3 + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
      leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join6(["schema", join6(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type: type3 }) => operation + ": " + type3
    },
    ScalarTypeDefinition: {
      leave: ({ description, name, directives }) => wrap("", description, "\n") + join6(["scalar", name, join6(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join6(
        [
          "type",
          name,
          wrap("implements ", join6(interfaces, " & ")),
          join6(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    FieldDefinition: {
      leave: ({ description, name, arguments: args, type: type3, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join6(args, "\n")), "\n)") : wrap("(", join6(args, ", "), ")")) + ": " + type3 + wrap(" ", join6(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ description, name, type: type3, defaultValue, directives }) => wrap("", description, "\n") + join6(
        [name + ": " + type3, wrap("= ", defaultValue), join6(directives, " ")],
        " "
      )
    },
    InterfaceTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join6(
        [
          "interface",
          name,
          wrap("implements ", join6(interfaces, " & ")),
          join6(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    UnionTypeDefinition: {
      leave: ({ description, name, directives, types: types2 }) => wrap("", description, "\n") + join6(
        ["union", name, join6(directives, " "), wrap("= ", join6(types2, " | "))],
        " "
      )
    },
    EnumTypeDefinition: {
      leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join6(["enum", name, join6(directives, " "), block(values)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description, name, directives }) => wrap("", description, "\n") + join6([name, join6(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join6(["input", name, join6(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join6(args, "\n")), "\n)") : wrap("(", join6(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join6(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join6(
        ["extend schema", join6(directives, " "), block(operationTypes)],
        " "
      )
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join6(["extend scalar", name, join6(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join6(
        [
          "extend type",
          name,
          wrap("implements ", join6(interfaces, " & ")),
          join6(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join6(
        [
          "extend interface",
          name,
          wrap("implements ", join6(interfaces, " & ")),
          join6(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types: types2 }) => join6(
        [
          "extend union",
          name,
          join6(directives, " "),
          wrap("= ", join6(types2, " | "))
        ],
        " "
      )
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values }) => join6(["extend enum", name, join6(directives, " "), block(values)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) => join6(["extend input", name, join6(directives, " "), block(fields)], " ")
    }
  };
  function join6(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
  }
  function block(array2) {
    return wrap("{\n", indent(join6(array2, "\n")), "\n}");
  }
  function wrap(start, maybeString, end = "") {
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  }
  function indent(str) {
    return wrap("  ", str.replace(/\n/g, "\n  "));
  }
  function hasMultilineItems(maybeArray) {
    var _maybeArray$some;
    return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
  }

  // ../../node_modules/.pnpm/graphql-tag@2.12.6_graphql@16.6.0/node_modules/graphql-tag/lib/index.js
  var docCache = /* @__PURE__ */ new Map();
  var fragmentSourceMap = /* @__PURE__ */ new Map();
  var printFragmentWarnings = true;
  var experimentalFragmentVariables = false;
  function normalize2(string2) {
    return string2.replace(/[\s,]+/g, " ").trim();
  }
  function cacheKeyFromLoc(loc) {
    return normalize2(loc.source.body.substring(loc.start, loc.end));
  }
  function processFragments(ast) {
    var seenKeys = /* @__PURE__ */ new Set();
    var definitions = [];
    ast.definitions.forEach(function(fragmentDefinition) {
      if (fragmentDefinition.kind === "FragmentDefinition") {
        var fragmentName = fragmentDefinition.name.value;
        var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
        var sourceKeySet = fragmentSourceMap.get(fragmentName);
        if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
          if (printFragmentWarnings) {
            console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
          }
        } else if (!sourceKeySet) {
          fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
        }
        sourceKeySet.add(sourceKey);
        if (!seenKeys.has(sourceKey)) {
          seenKeys.add(sourceKey);
          definitions.push(fragmentDefinition);
        }
      } else {
        definitions.push(fragmentDefinition);
      }
    });
    return __assign(__assign({}, ast), { definitions });
  }
  function stripLoc(doc) {
    var workSet = new Set(doc.definitions);
    workSet.forEach(function(node) {
      if (node.loc)
        delete node.loc;
      Object.keys(node).forEach(function(key) {
        var value = node[key];
        if (value && typeof value === "object") {
          workSet.add(value);
        }
      });
    });
    var loc = doc.loc;
    if (loc) {
      delete loc.startToken;
      delete loc.endToken;
    }
    return doc;
  }
  function parseDocument(source) {
    var cacheKey = normalize2(source);
    if (!docCache.has(cacheKey)) {
      var parsed = parse(source, {
        experimentalFragmentVariables,
        allowLegacyFragmentVariables: experimentalFragmentVariables
      });
      if (!parsed || parsed.kind !== "Document") {
        throw new Error("Not a valid GraphQL document.");
      }
      docCache.set(cacheKey, stripLoc(processFragments(parsed)));
    }
    return docCache.get(cacheKey);
  }
  function gql(literals) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof literals === "string") {
      literals = [literals];
    }
    var result = literals[0];
    args.forEach(function(arg, i) {
      if (arg && arg.kind === "Document") {
        result += arg.loc.source.body;
      } else {
        result += arg;
      }
      result += literals[i + 1];
    });
    return parseDocument(result);
  }
  function resetCaches() {
    docCache.clear();
    fragmentSourceMap.clear();
  }
  function disableFragmentWarnings() {
    printFragmentWarnings = false;
  }
  function enableExperimentalFragmentVariables() {
    experimentalFragmentVariables = true;
  }
  function disableExperimentalFragmentVariables() {
    experimentalFragmentVariables = false;
  }
  var extras = {
    gql,
    resetCaches,
    disableFragmentWarnings,
    enableExperimentalFragmentVariables,
    disableExperimentalFragmentVariables
  };
  (function(gql_1) {
    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
  })(gql || (gql = {}));
  gql["default"] = gql;
  var lib_default2 = gql;

  // ../transactions/dist/configs.mjs
  var CONTRACT_MAX_SIZE = 16 * 1024;
  var MAX_SCRIPT_LENGTH = 1024 * 1024 * 1024;
  var MAX_SCRIPT_DATA_LENGTH = 1024 * 1024 * 1024;
  var MAX_PREDICATE_LENGTH = 1024 * 1024;
  var MAX_PREDICATE_DATA_LENGTH = 1024 * 1024;
  var FAILED_REQUIRE_SIGNAL = "0xffffffffffff0000";
  var FAILED_TRANSFER_TO_ADDRESS_SIGNAL = "0xffffffffffff0001";
  var FAILED_SEND_MESSAGE_SIGNAL = "0xffffffffffff0002";
  var FAILED_ASSERT_EQ_SIGNAL = "0xffffffffffff0003";
  var FAILED_ASSERT_SIGNAL = "0xffffffffffff0004";
  var FAILED_UNKNOWN_SIGNAL = "0x0";

  // ../account/dist/index.mjs
  var asm = __toESM(require_node(), 1);

  // ../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/modular.js
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var _2n4 = BigInt(2);
  var _3n = BigInt(3);
  var _4n = BigInt(4);
  var _5n = BigInt(5);
  var _8n = BigInt(8);
  var _9n = BigInt(9);
  var _16n = BigInt(16);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n4 ? result : b + result;
  }
  function pow(num, power, modulo) {
    if (modulo <= _0n4 || power < _0n4)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n4)
      return _0n4;
    let res = _1n4;
    while (power > _0n4) {
      if (power & _1n4)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n4;
    }
    return res;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n4) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number4, modulo) {
    if (number4 === _0n4 || modulo <= _0n4) {
      throw new Error(`invert: expected positive integers, got n=${number4} mod=${modulo}`);
    }
    let a = mod(number4, modulo);
    let b = modulo;
    let x = _0n4, y = _1n4, u = _1n4, v = _0n4;
    while (a !== _0n4) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n4)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function tonelliShanks(P) {
    const legendreC = (P - _1n4) / _2n4;
    let Q, S, Z;
    for (Q = P - _1n4, S = 0; Q % _2n4 === _0n4; Q /= _2n4, S++)
      ;
    for (Z = _2n4; Z < P && pow(Z, legendreC, P) !== P - _1n4; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n4) / _4n;
      return function tonelliFast(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n4) / _2n4;
    return function tonelliSlow(Fp2, n) {
      if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
      let x = Fp2.pow(n, Q1div2);
      let b = Fp2.pow(n, Q);
      while (!Fp2.eql(b, Fp2.ONE)) {
        if (Fp2.eql(b, Fp2.ZERO))
          return Fp2.ZERO;
        let m = 1;
        for (let t2 = Fp2.sqr(b); m < r; m++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge = Fp2.pow(g, _1n4 << BigInt(r - m - 1));
        g = Fp2.sqr(ge);
        x = Fp2.mul(x, ge);
        b = Fp2.mul(b, g);
        r = m;
      }
      return x;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n) {
      const p1div4 = (P + _1n4) / _4n;
      return function sqrt3mod4(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n === _5n) {
      const c1 = (P - _5n) / _8n;
      return function sqrt5mod8(Fp2, n) {
        const n2 = Fp2.mul(n, _2n4);
        const v = Fp2.pow(n2, c1);
        const nv = Fp2.mul(n, v);
        const i = Fp2.mul(Fp2.mul(nv, _2n4), v);
        const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n === _9n) {
    }
    return tonelliShanks(P);
  }
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map2, val) => {
      map2[val] = "function";
      return map2;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f2, num, power) {
    if (power < _0n4)
      throw new Error("Expected power > 0");
    if (power === _0n4)
      return f2.ONE;
    if (power === _1n4)
      return num;
    let p = f2.ONE;
    let d = num;
    while (power > _0n4) {
      if (power & _1n4)
        p = f2.mul(p, d);
      d = f2.sqr(d);
      power >>= _1n4;
    }
    return p;
  }
  function FpInvertBatch(f2, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f2.is0(num))
        return acc;
      tmp[i] = acc;
      return f2.mul(acc, num);
    }, f2.ONE);
    const inverted = f2.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f2.is0(num))
        return acc;
      tmp[i] = f2.mul(acc, tmp[i]);
      return f2.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
    if (ORDER <= _0n4)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f2 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n4,
      ONE: _1n4,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n4 <= num && num < ORDER;
      },
      is0: (num) => num === _0n4,
      isOdd: (num) => (num & _1n4) === _1n4,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f2, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f2, n)),
      invertBatch: (lst) => FpInvertBatch(f2, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes3) => {
        if (bytes3.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
        return isLE3 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
      }
    });
    return Object.freeze(f2);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE3 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE3 ? bytesToNumberBE(key) : bytesToNumberLE(key);
    const reduced = mod(num, fieldOrder - _1n4) + _1n4;
    return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }

  // ../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/curve.js
  var _0n5 = BigInt(0);
  var _1n5 = BigInt(1);
  function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W) => {
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      // non-const time multiplication ladder
      unsafeLadder(elm, n) {
        let p = c.ZERO;
        let d = elm;
        while (n > _0n5) {
          if (n & _1n5)
            p = p.add(d);
          d = d.double();
          n >>= _1n5;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        const { windows, windowSize } = opts(W);
        let p = c.ZERO;
        let f2 = c.BASE;
        const mask2 = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask2);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n5;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f: f2 };
      },
      wNAFCached(P, precomputesMap, n, transform) {
        const W = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n);
      }
    };
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }

  // ../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a } = opts;
    if (endo) {
      if (!Fp2.eql(a, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
  var DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(data) {
      const { Err: E } = DER;
      if (data.length < 2 || data[0] !== 2)
        throw new E("Invalid signature integer tag");
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data.subarray(len + 2) };
    },
    toSig(hex) {
      const { Err: E } = DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      if (!isBytes3(data))
        throw new Error("ui8a expected");
      let l = data.length;
      if (l < 2 || data[0] != 48)
        throw new E("Invalid signature tag");
      if (data[1] !== l - 2)
        throw new E("Invalid signature: incorrect length");
      const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
      const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r, s };
    },
    hexFromSig(sig) {
      const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
      const h = (num) => {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      };
      const s = slice(h(sig.s));
      const r = slice(h(sig.r));
      const shl = s.length / 2;
      const rhl = r.length / 2;
      const sl = h(shl);
      const rl = h(rhl);
      return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    }
  };
  var _0n6 = BigInt(0);
  var _1n6 = BigInt(1);
  var _2n5 = BigInt(2);
  var _3n2 = BigInt(3);
  var _4n2 = BigInt(4);
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const toBytes4 = CURVE.toBytes || ((_c, point, _isCompressed) => {
      const a = point.toAffine();
      return concatBytes3(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes3) => {
      const tail = bytes3.subarray(1);
      const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n6 < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (isBytes3(key))
          key = bytesToHex(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error2) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod(num, n);
      assertGE(num);
      return num;
    }
    const pointPrecomputes = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    class Point2 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
        if (is0(x) && is0(y))
          return Point2.ZERO;
        return new Point2(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex) {
        const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = this.toAffine();
        if (!Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp2.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp2.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point2(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n2);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
          const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
          return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(n) {
        const I = Point2.ZERO;
        if (n === _0n6)
          return I;
        assertGE(n);
        if (n === _1n6)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n6 || k2 > _0n6) {
          if (k1 & _1n6)
            k1p = k1p.add(d);
          if (k2 & _1n6)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n6;
          k2 >>= _1n6;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        assertGE(scalar);
        let n = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f: f2 } = this.wNAF(n);
          point = p;
          fake = f2;
        }
        return Point2.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point2.BASE;
        const mul = (P, a2) => a2 === _0n6 || a2 === _1n6 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z) ∋ (x=x/z, y=y/z)
      toAffine(iz) {
        const { px: x, py: y, pz: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp2.ONE : Fp2.inv(z);
        const ax = Fp2.mul(x, iz);
        const ay = Fp2.mul(y, iz);
        const zz = Fp2.mul(z, iz);
        if (is0)
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        if (!Fp2.eql(zz, Fp2.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n6)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n6)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes4(Point2, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex(this.toRawBytes(isCompressed));
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n6 < num && num < Fp2.ORDER;
    }
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp2.toBytes(a.x);
        const cat = concatBytes3;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
        }
      },
      fromBytes(bytes3) {
        const len = bytes3.length;
        const head = bytes3[0];
        const tail = bytes3.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = bytesToNumberBE(tail);
          if (!isValidFieldElement(x))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y = Fp2.sqrt(y2);
          const isYOdd = (y & _1n6) === _1n6;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp2.neg(y);
          return { x, y };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number4) {
      const HALF = CURVE_ORDER >> _1n6;
      return number4 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
    class Signature2 {
      constructor(r, s, recovery) {
        this.r = r;
        this.s = s;
        this.recovery = recovery;
        this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = ensureBytes("compactSignature", hex, l * 2);
        return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s } = DER.toSig(ensureBytes("DER", hex));
        return new Signature2(r, s);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point2.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h * ir);
        const u2 = modN(s * ir);
        const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error2) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const length = getMinHashLength(CURVE.n);
        return mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = isBytes3(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point2)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point2.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes3) {
      const num = bytesToNumberBE(bytes3);
      const delta = bytes3.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
      return modN(bits2int(bytes3));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n6 <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash4, randomBytes: randomBytes5 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash4(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null) {
        const e = ent === true ? randomBytes5(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes3(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = modN(q.x);
        if (r === _0n6)
          return;
        const s = modN(ik * modN(m + r * d));
        if (s === _0n6)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n6);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point2.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P;
      try {
        if (typeof sg === "string" || isBytes3(sg)) {
          try {
            _sig = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature2.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s2 } = sg;
          _sig = new Signature2(r2, s2);
        } else {
          throw new Error("PARSE");
        }
        P = Point2.fromHex(publicKey);
      } catch (error2) {
        if (error2.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = invN(s);
      const u1 = modN(h * is);
      const u2 = modN(r * is);
      const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
      if (!R)
        return false;
      const v = modN(R.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point2,
      Signature: Signature2,
      utils
    };
  }

  // ../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash4) {
    return {
      hash: hash4,
      hmac: (key, ...msgs) => hmac(hash4, key, concatBytes2(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create10 = (hash4) => weierstrass({ ...curveDef, ...getHash(hash4) });
    return Object.freeze({ ...create10(defHash), create: create10 });
  }

  // ../../node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n7 = BigInt(1);
  var _2n6 = BigInt(2);
  var divNearest = (a, b) => (a + b / _2n6) / b;
  function sqrtMod(y) {
    const P = secp256k1P;
    const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n3, P) * b3 % P;
    const b9 = pow2(b6, _3n3, P) * b3 % P;
    const b11 = pow2(b9, _2n6, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n3, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n6, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
  var secp256k1 = createCurve({
    a: BigInt(0),
    // equation params: a, b
    b: BigInt(7),
    // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp,
    // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: secp256k1N,
    // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    // Cofactor
    lowS: true,
    // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256);
  var _0n7 = BigInt(0);
  var Point = secp256k1.ProjectivePoint;

  // ../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-node/rng.js
  var import_crypto14 = __toESM(__require2("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      import_crypto14.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }

  // ../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-node/stringify.js
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }

  // ../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-node/native.js
  var import_crypto15 = __toESM(__require2("crypto"));
  var native_default = {
    randomUUID: import_crypto15.default.randomUUID
  };

  // ../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-node/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // ../account/dist/index.mjs
  var import_events2 = __require2("events");

  // ../merkle/dist/index.mjs
  var EMPTY = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  var Node = class {
    left;
    right;
    parent;
    hash;
    data;
    index;
    constructor(left, right, parent, hash5, data, index = 0) {
      this.left = left;
      this.right = right;
      this.parent = parent;
      this.hash = hash5;
      this.data = data;
      this.index = index;
    }
  };
  var node_default2 = Node;
  function hashLeaf(data) {
    return hash3("0x00".concat(data.slice(2)));
  }
  function hashNode(left, right) {
    return hash3("0x01".concat(left.slice(2)).concat(right.slice(2)));
  }
  function calcRoot(data) {
    if (!data.length) {
      return EMPTY;
    }
    const nodes = [];
    for (let i = 0; i < data.length; i += 1) {
      const hashed = hashLeaf(data[i]);
      nodes.push(new node_default2(-1, -1, -1, hashed, data[i]));
    }
    let pNodes = nodes;
    let size = nodes.length + 1 >> 1;
    let odd = nodes.length & 1;
    while (true) {
      let i = 0;
      for (; i < size - odd; i += 1) {
        const j = i << 1;
        const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);
        nodes[i] = new node_default2(pNodes[j].index, pNodes[j + 1].index, -1, hashed, "");
      }
      if (odd === 1) {
        nodes[i] = pNodes[i << 1];
      }
      if (size === 1) {
        break;
      }
      odd = size & 1;
      size = size + 1 >> 1;
      pNodes = nodes;
    }
    return nodes[0].hash;
  }
  var leafPrefix = "0x00";
  var nodePrefix = "0x01";
  function hashLeaf2(key, data) {
    const value = "0x00".concat(key.slice(2)).concat(hash3(data).slice(2));
    return [hash3(value), value];
  }
  function hashNode2(left, right) {
    const value = "0x01".concat(left.slice(2)).concat(right.slice(2));
    return [hash3(value), value];
  }
  function parseLeaf(data) {
    const len = nodePrefix.length;
    return ["0x".concat(data.slice(len, len + 64)), "0x".concat(data.slice(len + 64))];
  }
  function parseNode(data) {
    const len = nodePrefix.length;
    return ["0x".concat(data.slice(len, len + 64)), "0x".concat(data.slice(len + 64))];
  }
  function isLeaf(data) {
    return data.slice(0, 4) === leafPrefix;
  }
  var SparseCompactMerkleProof = class {
    SideNodes;
    NonMembershipLeafData;
    BitMask;
    NumSideNodes;
    SiblingData;
    constructor(SideNodes, NonMembershipLeafData, Bitmask, NumSideNodes, SiblingData) {
      this.SideNodes = SideNodes;
      this.NonMembershipLeafData = NonMembershipLeafData;
      this.BitMask = Bitmask;
      this.NumSideNodes = NumSideNodes;
      this.SiblingData = SiblingData;
    }
  };
  var sparseCompactMerkleProof_default = SparseCompactMerkleProof;
  var SparseMerkleProof = class {
    SideNodes;
    NonMembershipLeafData;
    SiblingData;
    constructor(sideNodes, NonMembershipLeafData, SiblingData) {
      this.SideNodes = sideNodes;
      this.NonMembershipLeafData = NonMembershipLeafData;
      this.SiblingData = SiblingData;
    }
  };
  var sparseMerkleProof_default = SparseMerkleProof;
  var ZERO = "0x0000000000000000000000000000000000000000000000000000000000000000";
  var MAX_HEIGHT = 256;
  function getBitAtFromMSB(data, position) {
    const slicedData = data.slice(2);
    const byte = "0x".concat(
      slicedData.slice(Math.floor(position / 8) * 2, Math.floor(position / 8) * 2 + 2)
    );
    const bits = Number(byte) & 1 << 8 - 1 - position % 8;
    if (bits > 0) {
      return 1;
    }
    return 0;
  }
  function reverseSideNodes(sideNodes) {
    let left = 0;
    let right = sideNodes.length - 1;
    const reversedSideNodes = sideNodes;
    while (left < right) {
      [reversedSideNodes[left], reversedSideNodes[right]] = [
        reversedSideNodes[right],
        reversedSideNodes[left]
      ];
      left += 1;
      right -= 1;
    }
    return reversedSideNodes;
  }
  function countCommonPrefix(data1, data2) {
    let count = 0;
    for (let i = 0; i < MAX_HEIGHT; i += 1) {
      if (getBitAtFromMSB(data1, i) === getBitAtFromMSB(data2, i)) {
        count += 1;
      } else {
        break;
      }
    }
    return count;
  }
  function compactProof(proof) {
    const bitMask2 = [];
    const compactedSideNodes = [];
    let node;
    for (let i = 0; i < proof.SideNodes.length; i += 1) {
      node = proof.SideNodes[i];
      if (node === ZERO) {
        bitMask2.push(0);
      } else {
        compactedSideNodes.push(node);
        bitMask2.push(1);
      }
    }
    const compactedProof = new sparseCompactMerkleProof_default(
      compactedSideNodes,
      proof.NonMembershipLeafData,
      bitMask2,
      proof.SideNodes.length,
      proof.SiblingData
    );
    return compactedProof;
  }
  var SparseMerkleTree = class {
    ms;
    root;
    constructor() {
      const ms = {};
      this.ms = ms;
      this.root = ZERO;
      this.ms[this.root] = ZERO;
    }
    get(key) {
      return this.ms[key];
    }
    set(key, value) {
      this.ms[key] = value;
    }
    setRoot(root) {
      this.root = root;
    }
    sideNodesForRoot(key, root) {
      const sideNodes = [];
      if (root === ZERO) {
        return [sideNodes, ZERO, "", ""];
      }
      let currentData = this.get(root);
      if (isLeaf(currentData)) {
        return [sideNodes, root, currentData, ""];
      }
      let leftNode;
      let rightNode;
      let nodeHash = "";
      let sideNode = "";
      for (let i = 0; i < MAX_HEIGHT; i += 1) {
        [leftNode, rightNode] = parseNode(currentData);
        if (getBitAtFromMSB(key, i) === 1) {
          sideNode = leftNode;
          nodeHash = rightNode;
        } else {
          sideNode = rightNode;
          nodeHash = leftNode;
        }
        sideNodes.push(sideNode);
        if (nodeHash === ZERO) {
          currentData = "";
          break;
        }
        currentData = this.get(nodeHash);
        if (isLeaf(currentData)) {
          break;
        }
      }
      const siblingData = this.get(sideNode);
      return [reverseSideNodes(sideNodes), nodeHash, currentData, siblingData];
    }
    deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData) {
      if (oldLeafHash === ZERO) {
        return this.root;
      }
      const [actualPath] = parseLeaf(oldLeafData);
      if (actualPath !== key) {
        return this.root;
      }
      let currentHash = "";
      let currentData = "";
      let sideNode = "";
      let sideNodeValue = "";
      let nonPlaceholderReached = false;
      for (let i = 0; i < sideNodes.length; i += 1) {
        if (sideNodes[i] === "") {
          continue;
        }
        sideNode = sideNodes[i];
        if (currentData === "") {
          sideNodeValue = this.get(sideNode);
          if (isLeaf(sideNodeValue)) {
            currentHash = sideNode;
            currentData = sideNode;
            continue;
          } else {
            currentData = ZERO;
            nonPlaceholderReached = true;
          }
        }
        if (!nonPlaceholderReached && sideNode === ZERO) {
          continue;
        } else if (!nonPlaceholderReached) {
          nonPlaceholderReached = true;
        }
        if (getBitAtFromMSB(key, sideNodes.length - 1 - i) === 1) {
          [currentHash, currentData] = hashNode2(sideNode, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, sideNode);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      if (currentHash === "") {
        currentHash = ZERO;
      }
      return currentHash;
    }
    updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData) {
      let currentHash;
      let currentData;
      this.set(hash3(value), value);
      [currentHash, currentData] = hashLeaf2(key, value);
      this.set(currentHash, currentData);
      currentData = currentHash;
      let commonPrefixCount;
      if (oldLeafHash === ZERO) {
        commonPrefixCount = MAX_HEIGHT;
      } else {
        const [actualPath] = parseLeaf(oldLeafData);
        commonPrefixCount = countCommonPrefix(key, actualPath);
      }
      if (commonPrefixCount !== MAX_HEIGHT) {
        if (getBitAtFromMSB(key, commonPrefixCount) === 1) {
          [currentHash, currentData] = hashNode2(oldLeafHash, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, oldLeafHash);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      for (let i = 0; i < MAX_HEIGHT; i += 1) {
        let sideNode;
        const offsetOfSideNodes = MAX_HEIGHT - sideNodes.length;
        if (i - offsetOfSideNodes < 0 || sideNodes[i - offsetOfSideNodes] === "") {
          if (commonPrefixCount !== MAX_HEIGHT && commonPrefixCount > MAX_HEIGHT - 1 - i) {
            sideNode = ZERO;
          } else {
            continue;
          }
        } else {
          sideNode = sideNodes[i - offsetOfSideNodes];
        }
        if (getBitAtFromMSB(key, MAX_HEIGHT - 1 - i) === 1) {
          [currentHash, currentData] = hashNode2(sideNode, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, sideNode);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      return currentHash;
    }
    update(key, value) {
      const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
      const newRoot = this.updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData);
      this.setRoot(newRoot);
    }
    delete(key) {
      const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
      const newRoot = this.deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData);
      this.setRoot(newRoot);
    }
    prove(key) {
      const [sideNodes, leafHash, leafData, siblingData] = this.sideNodesForRoot(key, this.root);
      const nonEmptySideNodes = [];
      for (let i = 0; i < sideNodes.length; i += 1) {
        if (sideNodes[i] !== "") {
          nonEmptySideNodes.push(sideNodes[i]);
        }
      }
      let nonMembershipLeafData = "";
      if (leafHash !== ZERO) {
        const [actualPath] = parseLeaf(leafData);
        if (actualPath !== key) {
          nonMembershipLeafData = leafData;
        }
      }
      const proof = new sparseMerkleProof_default(nonEmptySideNodes, nonMembershipLeafData, siblingData);
      return proof;
    }
    proveCompacted(key) {
      const proof = this.prove(key);
      const compactedProof = compactProof(proof);
      return compactedProof;
    }
  };

  // ../account/dist/index.mjs
  var import_events3 = __require2("events");
  var __defProp6 = Object.defineProperty;
  var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField6 = (obj, key, value) => {
    __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck3 = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet2 = (obj, member, getter3) => {
    __accessCheck3(obj, member, "read from private field");
    return getter3 ? getter3.call(obj) : member.get(obj);
  };
  var __privateAdd3 = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet2 = (obj, member, value, setter) => {
    __accessCheck3(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod3 = (obj, member, method) => {
    __accessCheck3(obj, member, "access private method");
    return method;
  };
  var coinQuantityfy = (coinQuantityLike) => {
    let assetId;
    let amount;
    let max2;
    if (Array.isArray(coinQuantityLike)) {
      amount = coinQuantityLike[0];
      assetId = coinQuantityLike[1] ?? BaseAssetId;
      max2 = coinQuantityLike[2] ?? void 0;
    } else {
      amount = coinQuantityLike.amount;
      assetId = coinQuantityLike.assetId ?? BaseAssetId;
      max2 = coinQuantityLike.max ?? void 0;
    }
    const bnAmount = bn(amount);
    return {
      assetId: hexlify(assetId),
      amount: bnAmount.lt(1) ? bn(1) : bnAmount,
      max: max2 ? bn(max2) : void 0
    };
  };
  var addAmountToAsset = (params) => {
    const { amount, assetId } = params;
    const coinQuantities = [...params.coinQuantities];
    const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
    if (assetIdx !== -1) {
      coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
    } else {
      coinQuantities.push({ assetId, amount });
    }
    return coinQuantities;
  };
  var ReceiptFragmentFragmentDoc = lib_default2`
    fragment receiptFragment on Receipt {
  contract {
    id
  }
  pc
  is
  to {
    id
  }
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
  var TransactionStatusFragmentFragmentDoc = lib_default2`
    fragment transactionStatusFragment on TransactionStatus {
  type: __typename
  ... on SubmittedStatus {
    time
  }
  ... on SuccessStatus {
    block {
      id
    }
    time
    programState {
      returnType
      data
    }
  }
  ... on FailureStatus {
    block {
      id
    }
    time
    reason
  }
  ... on SqueezedOutStatus {
    reason
  }
}
    `;
  var TransactionFragmentFragmentDoc = lib_default2`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  gasPrice
  receipts {
    ...receiptFragment
  }
  status {
    ...transactionStatusFragment
  }
}
    ${ReceiptFragmentFragmentDoc}
${TransactionStatusFragmentFragmentDoc}`;
  var InputEstimatePredicatesFragmentFragmentDoc = lib_default2`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
  var TransactionEstimatePredicatesFragmentFragmentDoc = lib_default2`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentFragmentDoc}`;
  var CoinFragmentFragmentDoc = lib_default2`
    fragment coinFragment on Coin {
  __typename
  utxoId
  owner
  amount
  assetId
  maturity
  blockCreated
  txCreatedIdx
}
    `;
  var MessageCoinFragmentFragmentDoc = lib_default2`
    fragment messageCoinFragment on MessageCoin {
  __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
  var MessageFragmentFragmentDoc = lib_default2`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  nonce
  daHeight
}
    `;
  var MessageProofFragmentFragmentDoc = lib_default2`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  commitBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  sender
  recipient
  nonce
  amount
  data
}
    `;
  var BalanceFragmentFragmentDoc = lib_default2`
    fragment balanceFragment on Balance {
  owner
  amount
  assetId
}
    `;
  var BlockFragmentFragmentDoc = lib_default2`
    fragment blockFragment on Block {
  id
  header {
    height
    time
  }
  transactions {
    id
  }
}
    `;
  var TxParametersFragmentFragmentDoc = lib_default2`
    fragment TxParametersFragment on TxParameters {
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
}
    `;
  var PredicateParametersFragmentFragmentDoc = lib_default2`
    fragment PredicateParametersFragment on PredicateParameters {
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
  var ScriptParametersFragmentFragmentDoc = lib_default2`
    fragment ScriptParametersFragment on ScriptParameters {
  maxScriptLength
  maxScriptDataLength
}
    `;
  var ContractParametersFragmentFragmentDoc = lib_default2`
    fragment ContractParametersFragment on ContractParameters {
  contractMaxSize
  maxStorageSlots
}
    `;
  var FeeParametersFragmentFragmentDoc = lib_default2`
    fragment FeeParametersFragment on FeeParameters {
  gasPriceFactor
  gasPerByte
}
    `;
  var DependentCostFragmentFragmentDoc = lib_default2`
    fragment DependentCostFragment on DependentCost {
  __typename
  ... on LightOperation {
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    base
    gasPerUnit
  }
}
    `;
  var GasCostsFragmentFragmentDoc = lib_default2`
    fragment GasCostsFragment on GasCosts {
  add
  addi
  aloc
  and
  andi
  bal
  bhei
  bhsh
  burn
  cb
  cfei
  cfsi
  croo
  div
  divi
  ecr1
  eck1
  ed19
  eq
  exp
  expi
  flag
  gm
  gt
  gtf
  ji
  jmp
  jne
  jnei
  jnzi
  jmpf
  jmpb
  jnzf
  jnzb
  jnef
  jneb
  lb
  log
  lt
  lw
  mint
  mlog
  modOp
  modi
  moveOp
  movi
  mroo
  mul
  muli
  mldv
  noop
  not
  or
  ori
  poph
  popl
  pshh
  pshl
  ret
  rvrt
  sb
  sll
  slli
  srl
  srli
  srw
  sub
  subi
  sw
  sww
  time
  tr
  tro
  wdcm
  wqcm
  wdop
  wqop
  wdml
  wqml
  wddv
  wqdv
  wdmd
  wqmd
  wdam
  wqam
  wdmm
  wqmm
  xor
  xori
  call {
    ...DependentCostFragment
  }
  ccp {
    ...DependentCostFragment
  }
  csiz {
    ...DependentCostFragment
  }
  k256 {
    ...DependentCostFragment
  }
  ldc {
    ...DependentCostFragment
  }
  logd {
    ...DependentCostFragment
  }
  mcl {
    ...DependentCostFragment
  }
  mcli {
    ...DependentCostFragment
  }
  mcp {
    ...DependentCostFragment
  }
  mcpi {
    ...DependentCostFragment
  }
  meq {
    ...DependentCostFragment
  }
  retd {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  scwq {
    ...DependentCostFragment
  }
  smo {
    ...DependentCostFragment
  }
  srwq {
    ...DependentCostFragment
  }
  swwq {
    ...DependentCostFragment
  }
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  newStoragePerByte
}
    ${DependentCostFragmentFragmentDoc}`;
  var ConsensusParametersFragmentFragmentDoc = lib_default2`
    fragment consensusParametersFragment on ConsensusParameters {
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentFragmentDoc}
${PredicateParametersFragmentFragmentDoc}
${ScriptParametersFragmentFragmentDoc}
${ContractParametersFragmentFragmentDoc}
${FeeParametersFragmentFragmentDoc}
${GasCostsFragmentFragmentDoc}`;
  var ChainInfoFragmentFragmentDoc = lib_default2`
    fragment chainInfoFragment on ChainInfo {
  name
  latestBlock {
    ...blockFragment
  }
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${BlockFragmentFragmentDoc}
${ConsensusParametersFragmentFragmentDoc}`;
  var ContractBalanceFragmentFragmentDoc = lib_default2`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
  var PageInfoFragmentFragmentDoc = lib_default2`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
  var NodeInfoFragmentFragmentDoc = lib_default2`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  minGasPrice
  maxTx
  maxDepth
  nodeVersion
  peers {
    id
    addresses
    clientVersion
    blockHeight
    lastHeartbeatMs
    appScore
  }
}
    `;
  var GetVersionDocument = lib_default2`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
  var GetNodeInfoDocument = lib_default2`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentFragmentDoc}`;
  var GetChainDocument = lib_default2`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentFragmentDoc}`;
  var GetTransactionDocument = lib_default2`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc}`;
  var GetTransactionWithReceiptsDocument = lib_default2`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
    receipts {
      ...receiptFragment
    }
  }
}
    ${TransactionFragmentFragmentDoc}
${ReceiptFragmentFragmentDoc}`;
  var GetTransactionsDocument = lib_default2`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${TransactionFragmentFragmentDoc}`;
  var GetTransactionsByOwnerDocument = lib_default2`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
  var EstimatePredicatesDocument = lib_default2`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentFragmentDoc}`;
  var GetBlockDocument = lib_default2`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentFragmentDoc}`;
  var GetBlockWithTransactionsDocument = lib_default2`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionFragment
    }
  }
}
    ${BlockFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
  var GetBlocksDocument = lib_default2`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${BlockFragmentFragmentDoc}`;
  var GetCoinDocument = lib_default2`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
  }
}
    ${CoinFragmentFragmentDoc}`;
  var GetCoinsDocument = lib_default2`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${CoinFragmentFragmentDoc}`;
  var GetCoinsToSpendDocument = lib_default2`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentFragmentDoc}
${MessageCoinFragmentFragmentDoc}`;
  var GetContractDocument = lib_default2`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
  var GetContractBalanceDocument = lib_default2`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentFragmentDoc}`;
  var GetBalanceDocument = lib_default2`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    ...balanceFragment
  }
}
    ${BalanceFragmentFragmentDoc}`;
  var GetBalancesDocument = lib_default2`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...balanceFragment
      }
    }
  }
}
    ${BalanceFragmentFragmentDoc}`;
  var GetMessagesDocument = lib_default2`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...messageFragment
      }
    }
  }
}
    ${MessageFragmentFragmentDoc}`;
  var GetMessageProofDocument = lib_default2`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentFragmentDoc}`;
  var GetMessageStatusDocument = lib_default2`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
  var DryRunDocument = lib_default2`
    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {
  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {
    ...receiptFragment
  }
}
    ${ReceiptFragmentFragmentDoc}`;
  var SubmitDocument = lib_default2`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
  var ProduceBlocksDocument = lib_default2`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
  var SubmitAndAwaitDocument = lib_default2`
    subscription submitAndAwait($encodedTransaction: HexString!) {
  submitAndAwait(tx: $encodedTransaction) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc}`;
  var StatusChangeDocument = lib_default2`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc}`;
  function getSdk(requester) {
    return {
      getVersion(variables, options) {
        return requester(GetVersionDocument, variables, options);
      },
      getNodeInfo(variables, options) {
        return requester(GetNodeInfoDocument, variables, options);
      },
      getChain(variables, options) {
        return requester(GetChainDocument, variables, options);
      },
      getTransaction(variables, options) {
        return requester(GetTransactionDocument, variables, options);
      },
      getTransactionWithReceipts(variables, options) {
        return requester(GetTransactionWithReceiptsDocument, variables, options);
      },
      getTransactions(variables, options) {
        return requester(GetTransactionsDocument, variables, options);
      },
      getTransactionsByOwner(variables, options) {
        return requester(GetTransactionsByOwnerDocument, variables, options);
      },
      estimatePredicates(variables, options) {
        return requester(EstimatePredicatesDocument, variables, options);
      },
      getBlock(variables, options) {
        return requester(GetBlockDocument, variables, options);
      },
      getBlockWithTransactions(variables, options) {
        return requester(GetBlockWithTransactionsDocument, variables, options);
      },
      getBlocks(variables, options) {
        return requester(GetBlocksDocument, variables, options);
      },
      getCoin(variables, options) {
        return requester(GetCoinDocument, variables, options);
      },
      getCoins(variables, options) {
        return requester(GetCoinsDocument, variables, options);
      },
      getCoinsToSpend(variables, options) {
        return requester(GetCoinsToSpendDocument, variables, options);
      },
      getContract(variables, options) {
        return requester(GetContractDocument, variables, options);
      },
      getContractBalance(variables, options) {
        return requester(GetContractBalanceDocument, variables, options);
      },
      getBalance(variables, options) {
        return requester(GetBalanceDocument, variables, options);
      },
      getBalances(variables, options) {
        return requester(GetBalancesDocument, variables, options);
      },
      getMessages(variables, options) {
        return requester(GetMessagesDocument, variables, options);
      },
      getMessageProof(variables, options) {
        return requester(GetMessageProofDocument, variables, options);
      },
      getMessageStatus(variables, options) {
        return requester(GetMessageStatusDocument, variables, options);
      },
      dryRun(variables, options) {
        return requester(DryRunDocument, variables, options);
      },
      submit(variables, options) {
        return requester(SubmitDocument, variables, options);
      },
      produceBlocks(variables, options) {
        return requester(ProduceBlocksDocument, variables, options);
      },
      submitAndAwait(variables, options) {
        return requester(SubmitAndAwaitDocument, variables, options);
      },
      statusChange(variables, options) {
        return requester(StatusChangeDocument, variables, options);
      }
    };
  }
  var _FuelGraphqlSubscriber = class {
    constructor(options) {
      this.options = options;
    }
    stream;
    async setStream() {
      const { url, query, variables, fetchFn } = this.options;
      const response = await fetchFn(`${url}-sub`, {
        method: "POST",
        body: JSON.stringify({
          query: print(query),
          variables
        }),
        headers: {
          "Content-Type": "application/json",
          Accept: "text/event-stream"
        }
      });
      this.stream = response.body.getReader();
    }
    async next() {
      if (!this.stream) {
        await this.setStream();
      }
      while (true) {
        const { value, done } = await this.stream.read();
        if (done) {
          return { value, done };
        }
        const text = _FuelGraphqlSubscriber.textDecoder.decode(value);
        if (!text.startsWith("data:")) {
          continue;
        }
        let data;
        let errors;
        try {
          ({ data, errors } = JSON.parse(text.replace(/^data:/, "")));
        } catch (e) {
          throw new FuelError(
            ErrorCode.STREAM_PARSING_ERROR,
            `Error while parsing stream data response: ${text}`
          );
        }
        if (Array.isArray(errors)) {
          throw new FuelError(
            FuelError.CODES.INVALID_REQUEST,
            errors.map((err) => err.message).join("\n\n")
          );
        }
        return { value: data, done: false };
      }
    }
    /**
     * Gets called when `break` is called in a `for-await-of` loop.
     */
    async return() {
      await this.stream.cancel();
      this.stream.releaseLock();
      return { done: true, value: void 0 };
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  var FuelGraphqlSubscriber = _FuelGraphqlSubscriber;
  __publicField6(FuelGraphqlSubscriber, "textDecoder", new TextDecoder());
  var cache = {};
  var DEFAULT_TTL_IN_MS = 30 * 1e3;
  var MemoryCache = class {
    ttl;
    constructor(ttlInMs = DEFAULT_TTL_IN_MS) {
      this.ttl = ttlInMs;
      if (typeof ttlInMs !== "number" || this.ttl <= 0) {
        throw new FuelError(
          ErrorCode.INVALID_TTL,
          `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
        );
      }
    }
    get(value, isAutoExpiring = true) {
      const key = hexlify(value);
      if (cache[key]) {
        if (!isAutoExpiring || cache[key].expires > Date.now()) {
          return cache[key].value;
        }
        this.del(value);
      }
      return void 0;
    }
    set(value) {
      const expiresAt = Date.now() + this.ttl;
      const key = hexlify(value);
      cache[key] = {
        expires: expiresAt,
        value
      };
      return expiresAt;
    }
    getAllData() {
      return Object.keys(cache).reduce((list, key) => {
        const data = this.get(key, false);
        if (data) {
          list.push(data);
        }
        return list;
      }, []);
    }
    getActiveData() {
      return Object.keys(cache).reduce((list, key) => {
        const data = this.get(key);
        if (data) {
          list.push(data);
        }
        return list;
      }, []);
    }
    del(value) {
      const key = hexlify(value);
      delete cache[key];
    }
  };
  var inputify = (value) => {
    const { type: type3 } = value;
    switch (value.type) {
      case InputType.Coin: {
        const predicate = arrayify(value.predicate ?? "0x");
        const predicateData = arrayify(value.predicateData ?? "0x");
        return {
          type: InputType.Coin,
          txID: hexlify(arrayify(value.id).slice(0, 32)),
          outputIndex: arrayify(value.id)[32],
          owner: hexlify(value.owner),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId),
          txPointer: {
            blockHeight: toNumber2(arrayify(value.txPointer).slice(0, 8)),
            txIndex: toNumber2(arrayify(value.txPointer).slice(8, 16))
          },
          witnessIndex: value.witnessIndex,
          maturity: value.maturity ?? 0,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: predicate.length,
          predicateDataLength: predicateData.length,
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData)
        };
      }
      case InputType.Contract: {
        return {
          type: InputType.Contract,
          txID: ZeroBytes32,
          outputIndex: 0,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32,
          txPointer: {
            blockHeight: toNumber2(arrayify(value.txPointer).slice(0, 8)),
            txIndex: toNumber2(arrayify(value.txPointer).slice(8, 16))
          },
          contractID: hexlify(value.contractId)
        };
      }
      case InputType.Message: {
        const predicate = arrayify(value.predicate ?? "0x");
        const predicateData = arrayify(value.predicateData ?? "0x");
        const data = arrayify(value.data ?? "0x");
        return {
          type: InputType.Message,
          sender: hexlify(value.sender),
          recipient: hexlify(value.recipient),
          amount: bn(value.amount),
          nonce: hexlify(value.nonce),
          witnessIndex: value.witnessIndex,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: predicate.length,
          predicateDataLength: predicateData.length,
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData),
          data: hexlify(data),
          dataLength: data.length
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${type3}.`
        );
      }
    }
  };
  var outputify = (value) => {
    const { type: type3 } = value;
    switch (type3) {
      case OutputType.Coin: {
        return {
          type: OutputType.Coin,
          to: hexlify(value.to),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Contract: {
        return {
          type: OutputType.Contract,
          inputIndex: value.inputIndex,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32
        };
      }
      case OutputType.Change: {
        return {
          type: OutputType.Change,
          to: hexlify(value.to),
          amount: bn(0),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Variable: {
        return {
          type: OutputType.Variable,
          to: ZeroBytes32,
          amount: bn(0),
          assetId: ZeroBytes32
        };
      }
      case OutputType.ContractCreated: {
        return {
          type: OutputType.ContractCreated,
          contractId: hexlify(value.contractId),
          stateRoot: hexlify(value.stateRoot)
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction output type: ${type3}.`
        );
      }
    }
  };
  var isCoin = (resource) => "id" in resource;
  var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === ReceiptType.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
  var doesReceiptHaveMissingContractId = (receipt) => receipt.type === ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
  var getReceiptsWithMissingData = (receipts) => receipts.reduce(
    (memo, receipt) => {
      if (doesReceiptHaveMissingOutputVariables(receipt)) {
        memo.missingOutputVariables.push(receipt);
      }
      if (doesReceiptHaveMissingContractId(receipt)) {
        memo.missingOutputContractIds.push(receipt);
      }
      return memo;
    },
    {
      missingOutputVariables: [],
      missingOutputContractIds: []
    }
  );
  var hexOrZero = (hex) => hex || ZeroBytes32;
  function assembleReceiptByType(receipt) {
    const { receiptType } = receipt;
    switch (receiptType) {
      case "CALL": {
        const callReceipt = {
          type: ReceiptType.Call,
          from: hexOrZero(receipt.contract?.id),
          to: hexOrZero(receipt?.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          gas: bn(receipt.gas),
          param1: bn(receipt.param1),
          param2: bn(receipt.param2),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return callReceipt;
      }
      case "RETURN": {
        const returnReceipt = {
          type: ReceiptType.Return,
          id: hexOrZero(receipt.contract?.id),
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return returnReceipt;
      }
      case "RETURN_DATA": {
        const returnDataReceipt = {
          type: ReceiptType.ReturnData,
          id: hexOrZero(receipt.contract?.id),
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero(receipt.digest),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return returnDataReceipt;
      }
      case "PANIC": {
        const panicReceipt = {
          type: ReceiptType.Panic,
          id: hexOrZero(receipt.contract?.id),
          reason: bn(receipt.reason),
          pc: bn(receipt.pc),
          is: bn(receipt.is),
          contractId: hexOrZero(receipt.contractId)
        };
        return panicReceipt;
      }
      case "REVERT": {
        const revertReceipt = {
          type: ReceiptType.Revert,
          id: hexOrZero(receipt.contract?.id),
          val: bn(receipt.ra),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return revertReceipt;
      }
      case "LOG": {
        const logReceipt = {
          type: ReceiptType.Log,
          id: hexOrZero(receipt.contract?.id),
          val0: bn(receipt.ra),
          val1: bn(receipt.rb),
          val2: bn(receipt.rc),
          val3: bn(receipt.rd),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return logReceipt;
      }
      case "LOG_DATA": {
        const logDataReceipt = {
          type: ReceiptType.LogData,
          id: hexOrZero(receipt.contract?.id),
          val0: bn(receipt.ra),
          val1: bn(receipt.rb),
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero(receipt.digest),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return logDataReceipt;
      }
      case "TRANSFER": {
        const transferReceipt = {
          type: ReceiptType.Transfer,
          from: hexOrZero(receipt.contract?.id),
          to: hexOrZero(receipt.toAddress || receipt?.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferReceipt;
      }
      case "TRANSFER_OUT": {
        const transferOutReceipt = {
          type: ReceiptType.TransferOut,
          from: hexOrZero(receipt.contract?.id),
          to: hexOrZero(receipt.toAddress || receipt.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferOutReceipt;
      }
      case "SCRIPT_RESULT": {
        const scriptResultReceipt = {
          type: ReceiptType.ScriptResult,
          result: bn(receipt.result),
          gasUsed: bn(receipt.gasUsed)
        };
        return scriptResultReceipt;
      }
      case "MESSAGE_OUT": {
        const sender = hexOrZero(receipt.sender);
        const recipient = hexOrZero(receipt.recipient);
        const nonce = hexOrZero(receipt.nonce);
        const amount = bn(receipt.amount);
        const data = receipt.data ? arrayify(receipt.data) : Uint8Array.from([]);
        const digest = hexOrZero(receipt.digest);
        const messageId = ReceiptMessageOutCoder.getMessageId({
          sender,
          recipient,
          nonce,
          amount,
          data
        });
        const receiptMessageOut = {
          type: ReceiptType.MessageOut,
          sender,
          recipient,
          amount,
          nonce,
          data,
          digest,
          messageId
        };
        return receiptMessageOut;
      }
      case "MINT": {
        const contractId = hexOrZero(receipt.contract?.id);
        const subId = hexOrZero(receipt.subId);
        const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
        const mintReceipt = {
          type: ReceiptType.Mint,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return mintReceipt;
      }
      case "BURN": {
        const contractId = hexOrZero(receipt.contract?.id);
        const subId = hexOrZero(receipt.subId);
        const assetId = ReceiptBurnCoder.getAssetId(contractId, subId);
        const burnReceipt = {
          type: ReceiptType.Burn,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return burnReceipt;
      }
      default:
        throw new FuelError(ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
    }
  }
  var calculatePriceWithFactor = (gas, gasPrice, priceFactor) => bn(Math.ceil(gas.mul(gasPrice).toNumber() / priceFactor.toNumber()));
  var getGasUsedFromReceipts = (receipts) => {
    const scriptResult = receipts.filter(
      (receipt) => receipt.type === ReceiptType.ScriptResult
    );
    const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn(0));
    return gasUsed;
  };
  function resolveGasDependentCosts(byteSize, gasDependentCost) {
    const base = bn(gasDependentCost.base);
    let dependentValue = bn(0);
    if (gasDependentCost.__typename === "LightOperation") {
      dependentValue = bn(byteSize).div(bn(gasDependentCost.unitsPerGas));
    }
    if (gasDependentCost.__typename === "HeavyOperation") {
      dependentValue = bn(byteSize).mul(bn(gasDependentCost.gasPerUnit));
    }
    return base.add(dependentValue);
  }
  function gasUsedByInputs(inputs, txBytesSize, gasCosts) {
    const witnessCache = [];
    const totalGas = inputs.reduce((total, input) => {
      if ("predicate" in input && input.predicate && input.predicate !== "0x") {
        return total.add(
          resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization).add(resolveGasDependentCosts(arrayify(input.predicate).length, gasCosts.contractRoot)).add(bn(input.predicateGasUsed))
        );
      }
      if ("witnessIndex" in input && !witnessCache.includes(input.witnessIndex)) {
        witnessCache.push(input.witnessIndex);
        return total.add(gasCosts.ecr1);
      }
      return total;
    }, bn());
    return totalGas;
  }
  function getMinGas(params) {
    const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
    const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
    const bytesGas = bn(txBytesSize).mul(gasPerByte);
    const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);
    const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
    return minGas;
  }
  function getMaxGas(params) {
    const { gasPerByte, witnessesLength, witnessLimit, minGas, gasLimit = bn(0) } = params;
    let remainingAllowedWitnessGas = bn(0);
    if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
      remainingAllowedWitnessGas = bn(witnessLimit).sub(witnessesLength).mul(gasPerByte);
    }
    return remainingAllowedWitnessGas.add(minGas).add(gasLimit);
  }
  function calculateMetadataGasForTxCreate({
    gasCosts,
    stateRootSize,
    txBytesSize,
    contractBytesSize
  }) {
    const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);
    const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);
    const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
    const contractIdInputSize = bn(4 + 32 + 32 + 32);
    const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);
    const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
    return metadataGas.maxU64();
  }
  function calculateMetadataGasForTxScript({
    gasCosts,
    txBytesSize
  }) {
    return resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  }
  function normalize3(object2) {
    Object.keys(object2).forEach((key) => {
      switch (object2[key]?.constructor.name) {
        case "Uint8Array":
          object2[key] = hexlify(object2[key]);
          break;
        case "Array":
          object2[key] = normalize3(object2[key]);
          break;
        case "BN":
          object2[key] = object2[key].toHex();
          break;
        case "Address":
          object2[key] = object2[key].toB256();
          break;
        case "Object":
          object2[key] = normalize3(object2[key]);
          break;
        default:
          break;
      }
    });
    return object2;
  }
  function normalizeJSON(root) {
    return normalize3(clone_default(root));
  }
  function sleep(time) {
    return new Promise((resolve4) => {
      setTimeout(() => {
        resolve4(true);
      }, time);
    });
  }
  var NoWitnessAtIndexError = class extends Error {
    constructor(index) {
      super();
      this.index = index;
      this.message = `Witness at index "${index}" was not found`;
    }
    name = "NoWitnessAtIndexError";
  };
  var witnessify = (value) => {
    const data = arrayify(value);
    return {
      data: hexlify(data),
      dataLength: data.length
    };
  };
  var BaseTransactionRequest = class {
    /** Gas price for transaction */
    gasPrice;
    /** Block until which tx cannot be included */
    maturity;
    /** The maximum fee payable by this transaction using BASE_ASSET. */
    maxFee;
    /** The maximum amount of witness data allowed for the transaction */
    witnessLimit;
    /** List of inputs */
    inputs = [];
    /** List of outputs */
    outputs = [];
    /** List of witnesses */
    witnesses = [];
    /**
     * Constructor for initializing a base transaction request.
     *
     * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
     */
    constructor({
      gasPrice,
      maturity,
      maxFee,
      witnessLimit,
      inputs,
      outputs,
      witnesses
    } = {}) {
      this.gasPrice = bn(gasPrice);
      this.maturity = maturity ?? 0;
      this.witnessLimit = witnessLimit ? bn(witnessLimit) : void 0;
      this.maxFee = maxFee ? bn(maxFee) : void 0;
      this.inputs = inputs ?? [];
      this.outputs = outputs ?? [];
      this.witnesses = witnesses ?? [];
    }
    static getPolicyMeta(req2) {
      let policyTypes = 0;
      const policies = [];
      if (req2.gasPrice) {
        policyTypes += PolicyType.GasPrice;
        policies.push({ data: req2.gasPrice, type: PolicyType.GasPrice });
      }
      if (req2.witnessLimit) {
        policyTypes += PolicyType.WitnessLimit;
        policies.push({ data: req2.witnessLimit, type: PolicyType.WitnessLimit });
      }
      if (req2.maturity > 0) {
        policyTypes += PolicyType.Maturity;
        policies.push({ data: req2.maturity, type: PolicyType.Maturity });
      }
      if (req2.maxFee) {
        policyTypes += PolicyType.MaxFee;
        policies.push({ data: req2.maxFee, type: PolicyType.MaxFee });
      }
      return {
        policyTypes,
        policies
      };
    }
    /**
     * Method to obtain the base transaction details.
     *
     * @returns The base transaction details.
     */
    getBaseTransaction() {
      const inputs = this.inputs?.map(inputify) ?? [];
      const outputs = this.outputs?.map(outputify) ?? [];
      const witnesses = this.witnesses?.map(witnessify) ?? [];
      const { policyTypes, policies } = BaseTransactionRequest.getPolicyMeta(this);
      return {
        policyTypes,
        inputs,
        outputs,
        policies,
        witnesses,
        inputsCount: inputs.length,
        outputsCount: outputs.length,
        witnessesCount: witnesses.length
      };
    }
    /**
     * Converts the transaction request to a byte array.
     *
     * @returns The transaction bytes.
     */
    toTransactionBytes() {
      return new TransactionCoder().encode(this.toTransaction());
    }
    /**
     * @hidden
     *
     * Pushes an input to the list without any side effects and returns the index
     */
    pushInput(input) {
      this.inputs.push(input);
      return this.inputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes an output to the list without any side effects and returns the index
     */
    pushOutput(output3) {
      this.outputs.push(output3);
      return this.outputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes a witness to the list and returns the index
     *
     * @param signature - The signature to add to the witness.
     * @returns The index of the created witness.
     */
    addWitness(signature) {
      this.witnesses.push(signature);
      return this.witnesses.length - 1;
    }
    /**
     * @hidden
     *
     * Creates an empty witness without any side effects and returns the index
     *
     * @returns The index of the created witness.
     */
    addEmptyWitness() {
      this.addWitness(concat([ZeroBytes32, ZeroBytes32]));
      return this.witnesses.length - 1;
    }
    /**
     * Updates the witness for a given owner and signature.
     *
     * @param address - The address to get the coin input witness index for.
     * @param signature - The signature to update the witness with.
     */
    updateWitnessByOwner(address, signature) {
      const ownerAddress = Address.fromAddressOrString(address);
      const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
      if (typeof witnessIndex === "number") {
        this.updateWitness(witnessIndex, signature);
      }
    }
    /**
     * Updates an existing witness without any side effects.
     *
     * @param index - The index of the witness to update.
     * @param witness - The new witness.
     * @throws If the witness does not exist.
     */
    updateWitness(index, witness) {
      if (!this.witnesses[index]) {
        throw new NoWitnessAtIndexError(index);
      }
      this.witnesses[index] = witness;
    }
    /**
     * Helper function to add an external signature to the transaction.
     *
     * @param account - The account/s to sign to the transaction.
     * @returns The transaction with the signature witness added.
     */
    async addAccountWitnesses(account) {
      const accounts = Array.isArray(account) ? account : [account];
      await Promise.all(
        accounts.map(async (acc) => {
          this.addWitness(await acc.signTransaction(this));
        })
      );
      return this;
    }
    /**
     * Gets the coin inputs for a transaction.
     *
     * @returns The coin inputs.
     */
    getCoinInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Coin
      );
    }
    /**
     * Gets the coin outputs for a transaction.
     *
     * @returns The coin outputs.
     */
    getCoinOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Coin
      );
    }
    /**
     * Gets the change outputs for a transaction.
     *
     * @returns The change outputs.
     */
    getChangeOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Change
      );
    }
    /**
     * @hidden
     *
     * Returns the witnessIndex of the found CoinInput.
     */
    getCoinInputWitnessIndexByOwner(owner) {
      const ownerAddress = addressify(owner);
      const found = this.inputs.find((input) => {
        switch (input.type) {
          case InputType.Coin:
            return hexlify(input.owner) === ownerAddress.toB256();
          case InputType.Message:
            return hexlify(input.recipient) === ownerAddress.toB256();
          default:
            return false;
        }
      });
      return found?.witnessIndex;
    }
    /**
     * Adds a single coin input to the transaction and a change output for the related
     * assetId, if one it was not added yet.
     *
     * @param coin - Coin resource.
     * @param predicate - Predicate bytes.
     * @param predicateData - Predicate data bytes.
     */
    addCoinInput(coin, predicate) {
      const { assetId, owner, amount } = coin;
      let witnessIndex;
      if (predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.addEmptyWitness();
        }
      }
      const input = {
        ...coin,
        type: InputType.Coin,
        owner: owner.toB256(),
        amount,
        assetId,
        txPointer: "0x00000000000000000000000000000000",
        witnessIndex,
        predicate: predicate?.bytes,
        predicateData: predicate?.predicateDataBytes
      };
      this.pushInput(input);
      this.addChangeOutput(owner, assetId);
    }
    /**
     * Adds a single message input to the transaction and a change output for the
     * baseAssetId, if one it was not added yet.
     *
     * @param message - Message resource.
     * @param predicate - Predicate bytes.
     * @param predicateData - Predicate data bytes.
     */
    addMessageInput(message, predicate) {
      const { recipient, sender, amount } = message;
      const assetId = BaseAssetId;
      let witnessIndex;
      if (predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.addEmptyWitness();
        }
      }
      const input = {
        ...message,
        type: InputType.Message,
        sender: sender.toB256(),
        recipient: recipient.toB256(),
        amount,
        witnessIndex,
        predicate: predicate?.bytes,
        predicateData: predicate?.predicateDataBytes
      };
      this.pushInput(input);
      this.addChangeOutput(recipient, assetId);
    }
    /**
     * Adds a single resource to the transaction by adding a coin/message input and a
     * change output for the related assetId, if one it was not added yet.
     *
     * @param resource - The resource to add.
     * @returns This transaction.
     */
    addResource(resource) {
      if (isCoin(resource)) {
        this.addCoinInput(resource);
      } else {
        this.addMessageInput(resource);
      }
      return this;
    }
    /**
     * Adds multiple resources to the transaction by adding coin/message inputs and change
     * outputs from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addResources(resources) {
      resources.forEach((resource) => this.addResource(resource));
      return this;
    }
    /**
     * Adds multiple resources to the transaction by adding coin/message inputs and change
     * outputs from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addPredicateResource(resource, predicate) {
      if (isCoin(resource)) {
        this.addCoinInput(resource, predicate);
      } else {
        this.addMessageInput(resource, predicate);
      }
      return this;
    }
    /**
     * Adds multiple predicate coin/message inputs to the transaction and change outputs
     * from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addPredicateResources(resources, predicate) {
      resources.forEach((resource) => this.addPredicateResource(resource, predicate));
      return this;
    }
    /**
     * Adds a coin output to the transaction.
     *
     * @param to - Address of the owner.
     * @param amount - Amount of coin.
     * @param assetId - Asset ID of coin.
     */
    addCoinOutput(to, amount, assetId = BaseAssetId) {
      this.pushOutput({
        type: OutputType.Coin,
        to: addressify(to).toB256(),
        amount,
        assetId
      });
      return this;
    }
    /**
     * Adds multiple coin outputs to the transaction.
     *
     * @param to - Address of the destination.
     * @param quantities - Quantities of coins.
     */
    addCoinOutputs(to, quantities) {
      quantities.map(coinQuantityfy).forEach((quantity) => {
        this.pushOutput({
          type: OutputType.Coin,
          to: addressify(to).toB256(),
          amount: quantity.amount,
          assetId: quantity.assetId
        });
      });
      return this;
    }
    /**
     * Adds a change output to the transaction.
     *
     * @param to - Address of the owner.
     * @param assetId - Asset ID of coin.
     */
    addChangeOutput(to, assetId = BaseAssetId) {
      const changeOutput = this.getChangeOutputs().find(
        (output3) => hexlify(output3.assetId) === assetId
      );
      if (!changeOutput) {
        this.pushOutput({
          type: OutputType.Change,
          to: addressify(to).toB256(),
          assetId
        });
      }
    }
    /**
     * @hidden
     */
    byteSize() {
      return this.toTransactionBytes().length;
    }
    /**
     * @hidden
     */
    metadataGas(_gasCosts) {
      throw new Error("Not implemented");
    }
    /**
     * @hidden
     */
    calculateMinGas(chainInfo) {
      const { gasCosts, consensusParameters } = chainInfo;
      const { gasPerByte } = consensusParameters;
      return getMinGas({
        gasPerByte,
        gasCosts,
        inputs: this.inputs,
        txBytesSize: this.byteSize(),
        metadataGas: this.metadataGas(gasCosts)
      });
    }
    calculateMaxGas(chainInfo, minGas) {
      const { consensusParameters } = chainInfo;
      const { gasPerByte } = consensusParameters;
      const witnessesLength = this.toTransaction().witnesses.reduce(
        (acc, wit) => acc + wit.dataLength,
        0
      );
      return getMaxGas({
        gasPerByte,
        minGas,
        witnessesLength,
        witnessLimit: this.witnessLimit
      });
    }
    /**
     * Funds the transaction with fake UTXOs for each assetId and amount in the
     * quantities array.
     *
     * @param quantities - CoinQuantity Array.
     */
    fundWithFakeUtxos(quantities, resourcesOwner) {
      let idCounter = 0;
      const generateId = () => {
        const counterString = String(idCounter++);
        const id = ZeroBytes32.slice(0, -counterString.length).concat(counterString);
        return id;
      };
      const findAssetInput = (assetId) => this.inputs.find((input) => {
        if ("assetId" in input) {
          return input.assetId === assetId;
        }
        return false;
      });
      const updateAssetInput = (assetId, quantity) => {
        const assetInput = findAssetInput(assetId);
        if (assetInput && "assetId" in assetInput) {
          assetInput.id = generateId();
          assetInput.amount = quantity;
        } else {
          this.addResources([
            {
              id: generateId(),
              amount: quantity,
              assetId,
              owner: resourcesOwner || Address.fromRandom(),
              maturity: 0,
              blockCreated: bn(1),
              txCreatedIdx: bn(1)
            }
          ]);
        }
      };
      updateAssetInput(BaseAssetId, bn(1e11));
      quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
    }
    /**
     * Retrieves an array of CoinQuantity for each coin output present in the transaction.
     * a transaction.
     *
     * @returns  CoinQuantity array.
     */
    getCoinOutputsQuantities() {
      const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
        amount: bn(amount),
        assetId: assetId.toString()
      }));
      return coinsQuantities;
    }
    /**
     * Return the minimum amount in native coins required to create
     * a transaction.
     *
     * @returns The transaction as a JSON object.
     */
    toJSON() {
      return normalizeJSON(this);
    }
    updatePredicateInputs(inputs) {
      this.inputs.forEach((i) => {
        let correspondingInput;
        switch (i.type) {
          case InputType.Coin:
            correspondingInput = inputs.find((x) => x.type === InputType.Coin && x.owner === i.owner);
            break;
          case InputType.Message:
            correspondingInput = inputs.find(
              (x) => x.type === InputType.Message && x.sender === i.sender
            );
            break;
          default:
            return;
        }
        if (correspondingInput && "predicateGasUsed" in correspondingInput && bn(correspondingInput.predicateGasUsed).gt(0)) {
          i.predicate = correspondingInput.predicate;
          i.predicateData = correspondingInput.predicateData;
          i.predicateGasUsed = correspondingInput.predicateGasUsed;
        }
      });
    }
  };
  function hashTransaction(transactionRequest, chainId) {
    const transaction = transactionRequest.toTransaction();
    if (transaction.type === TransactionType.Script) {
      transaction.receiptsRoot = ZeroBytes32;
    }
    transaction.inputs = transaction.inputs.map((input) => {
      const inputClone = clone_default(input);
      switch (inputClone.type) {
        case InputType.Coin: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Message: {
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Contract: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.txID = ZeroBytes32;
          inputClone.outputIndex = 0;
          inputClone.balanceRoot = ZeroBytes32;
          inputClone.stateRoot = ZeroBytes32;
          return inputClone;
        }
        default:
          return inputClone;
      }
    });
    transaction.outputs = transaction.outputs.map((output3) => {
      const outputClone = clone_default(output3);
      switch (outputClone.type) {
        case OutputType.Contract: {
          outputClone.balanceRoot = ZeroBytes32;
          outputClone.stateRoot = ZeroBytes32;
          return outputClone;
        }
        case OutputType.Change: {
          outputClone.amount = bn(0);
          return outputClone;
        }
        case OutputType.Variable: {
          outputClone.to = ZeroBytes32;
          outputClone.amount = bn(0);
          outputClone.assetId = ZeroBytes32;
          return outputClone;
        }
        default:
          return outputClone;
      }
    });
    transaction.witnessesCount = 0;
    transaction.witnesses = [];
    const chainIdBytes = uint64ToBytesBE(chainId);
    const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);
    return sha2563(concatenatedData);
  }
  var getStorageValue = (value) => {
    const v = new Uint8Array(32);
    v.set(arrayify(value));
    return v;
  };
  var storageSlotify = (storageSlot) => {
    let key;
    let value;
    if (Array.isArray(storageSlot)) {
      key = storageSlot[0];
      value = storageSlot[1];
    } else {
      key = storageSlot.key;
      value = storageSlot.value;
    }
    return {
      key: hexlify(key),
      value: hexlify(getStorageValue(value))
    };
  };
  var CreateTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      if (obj instanceof this) {
        return obj;
      }
      return new this(obj);
    }
    /** Type of the transaction */
    type = TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex;
    /** Salt */
    salt;
    /** List of storage slots to initialize */
    storageSlots;
    /**
     * Creates an instance `CreateTransactionRequest`.
     *
     * @param createTransactionRequestLike - The initial values for the instance
     */
    constructor({
      bytecodeWitnessIndex,
      salt,
      storageSlots,
      ...rest
    } = {}) {
      super(rest);
      this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
      this.salt = hexlify(salt ?? ZeroBytes32);
      this.storageSlots = [...storageSlots ?? []];
    }
    /**
     * Converts the transaction request to a `TransactionCreate`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
      const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];
      return {
        type: TransactionType.Create,
        ...baseTransaction,
        bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,
        bytecodeWitnessIndex,
        storageSlotsCount: storageSlots.length,
        salt: this.salt ? hexlify(this.salt) : ZeroBytes32,
        storageSlots
      };
    }
    /**
     * Get contract created outputs for the transaction.
     *
     * @returns An array of contract created transaction request outputs.
     */
    getContractCreatedOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.ContractCreated
      );
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction(this, chainId);
    }
    /**
     * Adds a contract created output to the transaction request.
     *
     * @param contractId - The contract ID.
     * @param stateRoot - The state root.
     */
    addContractCreatedOutput(contractId, stateRoot) {
      this.pushOutput({
        type: OutputType.ContractCreated,
        contractId,
        stateRoot
      });
    }
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxCreate({
        contractBytesSize: bn(arrayify(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
        gasCosts,
        stateRootSize: this.storageSlots.length,
        txBytesSize: this.byteSize()
      });
    }
  };
  var returnZeroScript = {
    /*
        Opcode::RET(REG_ZERO)
        Opcode::NOOP
      */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: arrayify("0x24000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var withdrawScript = {
    /*
            The following code loads some basic values into registers and calls SMO to create an output message
            5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
            5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
            4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
            24000000	- RET                [return 0]
            00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
            00000000 00000000 [amount value]
        */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: arrayify("0x5040C0105D44C0064C40001124000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var ScriptTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      if (obj instanceof this) {
        return obj;
      }
      return new this(obj);
    }
    /** Type of the transaction */
    type = TransactionType.Script;
    /** Gas limit for transaction */
    gasLimit;
    /** Script to execute */
    script;
    /** Script input data (parameters) */
    scriptData;
    abis;
    /**
     * Constructor for `ScriptTransactionRequest`.
     *
     * @param scriptTransactionRequestLike - The initial values for the instance.
     */
    constructor({ script, scriptData, gasLimit, ...rest } = {}) {
      super(rest);
      this.gasLimit = bn(gasLimit);
      this.script = arrayify(script ?? returnZeroScript.bytes);
      this.scriptData = arrayify(scriptData ?? returnZeroScript.encodeScriptData());
      this.abis = rest.abis;
    }
    /**
     * Converts the transaction request to a `TransactionScript`.
     *
     * @returns The transaction script object.
     */
    toTransaction() {
      const script = arrayify(this.script ?? "0x");
      const scriptData = arrayify(this.scriptData ?? "0x");
      return {
        type: TransactionType.Script,
        scriptGasLimit: this.gasLimit,
        ...super.getBaseTransaction(),
        scriptLength: script.length,
        scriptDataLength: scriptData.length,
        receiptsRoot: ZeroBytes32,
        script: hexlify(script),
        scriptData: hexlify(scriptData)
      };
    }
    /**
     * Get contract inputs for the transaction.
     *
     * @returns An array of contract transaction request inputs.
     */
    getContractInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Contract
      );
    }
    /**
     * Get contract outputs for the transaction.
     *
     * @returns An array of contract transaction request outputs.
     */
    getContractOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Contract
      );
    }
    /**
     * Get variable outputs for the transaction.
     *
     * @returns An array of variable transaction request outputs.
     */
    getVariableOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Variable
      );
    }
    /**
     * Set the script and its data.
     *
     * @param script - The abstract script request.
     * @param data - The script data.
     */
    setScript(script, data) {
      this.scriptData = script.encodeScriptData(data);
      this.script = script.bytes;
    }
    /**
     * Adds variable outputs to the transaction request.
     *
     * @param numberOfVariables - The number of variables to add.
     * @returns The new length of the outputs array.
     */
    addVariableOutputs(numberOfVariables = 1) {
      let outputsNumber = numberOfVariables;
      while (outputsNumber) {
        this.pushOutput({
          type: OutputType.Variable
        });
        outputsNumber -= 1;
      }
      return this.outputs.length - 1;
    }
    calculateMaxGas(chainInfo, minGas) {
      const { consensusParameters } = chainInfo;
      const { gasPerByte } = consensusParameters;
      const witnessesLength = this.toTransaction().witnesses.reduce(
        (acc, wit) => acc + wit.dataLength,
        0
      );
      return getMaxGas({
        gasPerByte,
        minGas,
        witnessesLength,
        witnessLimit: this.witnessLimit,
        gasLimit: this.gasLimit
      });
    }
    /**
     * Adds a contract input and output to the transaction request.
     *
     * @param contract - The contract ID.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    addContractInputAndOutput(contract) {
      const contractAddress = addressify(contract);
      if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
        return this;
      }
      const inputIndex = super.pushInput({
        type: InputType.Contract,
        contractId: contractAddress.toB256(),
        txPointer: "0x00000000000000000000000000000000"
      });
      this.pushOutput({
        type: OutputType.Contract,
        inputIndex
      });
      return this;
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction(this, chainId);
    }
    /**
     * Sets the data for the transaction request.
     *
     * @param abi - Script JSON ABI.
     * @param args - The input arguments.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    setData(abi, args) {
      const abiInterface = new Interface(abi);
      this.scriptData = abiInterface.functions.main.encodeArguments(args);
      return this;
    }
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxScript({
        gasCosts,
        txBytesSize: this.byteSize()
      });
    }
  };
  var transactionRequestify = (obj) => {
    if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {
      return obj;
    }
    const { type: type3 } = obj;
    switch (obj.type) {
      case TransactionType.Script: {
        return ScriptTransactionRequest.from(obj);
      }
      case TransactionType.Create: {
        return CreateTransactionRequest.from(obj);
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type3}.`);
      }
    }
  };
  var calculateTransactionFee = (params) => {
    const {
      gasUsed,
      rawPayload,
      consensusParameters: { gasCosts, feeParams }
    } = params;
    const gasPerByte = bn(feeParams.gasPerByte);
    const gasPriceFactor = bn(feeParams.gasPriceFactor);
    const transactionBytes = arrayify(rawPayload);
    const [transaction] = new TransactionCoder().decode(transactionBytes, 0);
    if (transaction.type === TransactionType.Mint) {
      return {
        fee: bn(0),
        minFee: bn(0),
        maxFee: bn(0),
        feeFromGasUsed: bn(0)
      };
    }
    const { type: type3, witnesses, inputs, policies } = transaction;
    let metadataGas = bn(0);
    let gasLimit = bn(0);
    if (type3 === TransactionType.Create) {
      const { bytecodeWitnessIndex, storageSlots } = transaction;
      const contractBytesSize = bn(arrayify(witnesses[bytecodeWitnessIndex].data).length);
      metadataGas = calculateMetadataGasForTxCreate({
        contractBytesSize,
        gasCosts,
        stateRootSize: storageSlots.length || 0,
        txBytesSize: transactionBytes.length
      });
    } else {
      const { scriptGasLimit } = transaction;
      if (scriptGasLimit) {
        gasLimit = scriptGasLimit;
      }
      metadataGas = calculateMetadataGasForTxScript({
        gasCosts,
        txBytesSize: transactionBytes.length
      });
    }
    const minGas = getMinGas({
      gasCosts,
      gasPerByte: bn(gasPerByte),
      inputs,
      metadataGas,
      txBytesSize: transactionBytes.length
    });
    const gasPrice = bn(policies.find((policy) => policy.type === PolicyType.GasPrice)?.data);
    const witnessLimit = policies.find((policy) => policy.type === PolicyType.WitnessLimit)?.data;
    const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
    const maxGas = getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      gasLimit,
      witnessLimit
    });
    const feeFromGasUsed = calculatePriceWithFactor(gasUsed, gasPrice, gasPriceFactor);
    const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor);
    const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor);
    const fee = minFee.add(feeFromGasUsed);
    return {
      fee,
      minFee,
      maxFee,
      feeFromGasUsed
    };
  };
  var getFunctionCall = ({ abi, receipt, rawPayload, maxInputs }) => {
    const abiInterface = new Interface(abi);
    const callFunctionSelector = receipt.param1.toHex(8);
    const functionFragment = abiInterface.getFunction(callFunctionSelector);
    const inputs = functionFragment.jsonFn.inputs;
    let encodedArgs;
    if (functionFragment.isInputDataPointer) {
      if (rawPayload) {
        const argsOffset = bn(receipt.param2).sub(calculateVmTxMemory({ maxInputs: maxInputs.toNumber() })).toNumber();
        encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;
      }
    } else {
      encodedArgs = receipt.param2.toHex();
    }
    let argumentsProvided;
    if (encodedArgs) {
      const data = functionFragment.decodeArguments(encodedArgs);
      if (data) {
        argumentsProvided = inputs.reduce((prev, input, index) => {
          const value = data[index];
          const name = input.name;
          if (name) {
            return {
              ...prev,
              // reparse to remove bn
              [name]: JSON.parse(JSON.stringify(value))
            };
          }
          return prev;
        }, {});
      }
    }
    const call2 = {
      functionSignature: functionFragment.signature,
      functionName: functionFragment.name,
      argumentsProvided,
      ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
    };
    return call2;
  };
  function getInputsByTypes(inputs, types2) {
    return inputs.filter((i) => types2.includes(i.type));
  }
  function getInputsByType(inputs, type3) {
    return inputs.filter((i) => i.type === type3);
  }
  function getInputsCoin(inputs) {
    return getInputsByType(inputs, InputType.Coin);
  }
  function getInputsMessage(inputs) {
    return getInputsByType(inputs, InputType.Message);
  }
  function getInputsCoinAndMessage(inputs) {
    return getInputsByTypes(inputs, [InputType.Coin, InputType.Message]);
  }
  function getInputsContract(inputs) {
    return getInputsByType(inputs, InputType.Contract);
  }
  function getInputFromAssetId(inputs, assetId) {
    const coinInputs = getInputsCoin(inputs);
    const messageInputs = getInputsMessage(inputs);
    const coinInput = coinInputs.find((i) => i.assetId === assetId);
    const messageInput = messageInputs.find(
      (_) => assetId === "0x0000000000000000000000000000000000000000000000000000000000000000"
    );
    return coinInput || messageInput;
  }
  function getInputContractFromIndex(inputs, inputIndex) {
    if (inputIndex == null) {
      return void 0;
    }
    const contractInput = inputs?.[inputIndex];
    if (!contractInput) {
      return void 0;
    }
    if (contractInput.type !== InputType.Contract) {
      throw new FuelError(
        ErrorCode.INVALID_TRANSACTION_INPUT,
        `Contract input should be of type 'contract'.`
      );
    }
    return contractInput;
  }
  function getInputAccountAddress(input) {
    if (input.type === InputType.Coin) {
      return input.owner.toString();
    }
    if (input.type === InputType.Message) {
      return input.recipient.toString();
    }
    return "";
  }
  function getOutputsByType(outputs, type3) {
    return outputs.filter((o) => o.type === type3);
  }
  function getOutputsContractCreated(outputs) {
    return getOutputsByType(outputs, OutputType.ContractCreated);
  }
  function getOutputsCoin(outputs) {
    return getOutputsByType(outputs, OutputType.Coin);
  }
  function getOutputsChange(outputs) {
    return getOutputsByType(outputs, OutputType.Change);
  }
  function getOutputsContract(outputs) {
    return getOutputsByType(outputs, OutputType.Contract);
  }
  function getReceiptsByType(receipts, type3) {
    return (receipts ?? []).filter((r) => r.type === type3);
  }
  function getTransactionTypeName(transactionType) {
    switch (transactionType) {
      case TransactionType.Mint:
        return "Mint";
      case TransactionType.Create:
        return "Create";
      case TransactionType.Script:
        return "Script";
      default:
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_TYPE,
          `Invalid transaction type: ${transactionType}.`
        );
    }
  }
  function isType(transactionType, type3) {
    const txType = getTransactionTypeName(transactionType);
    return txType === type3;
  }
  function isTypeMint(transactionType) {
    return isType(
      transactionType,
      "Mint"
      /* Mint */
    );
  }
  function isTypeCreate(transactionType) {
    return isType(
      transactionType,
      "Create"
      /* Create */
    );
  }
  function isTypeScript(transactionType) {
    return isType(
      transactionType,
      "Script"
      /* Script */
    );
  }
  function getReceiptsCall(receipts) {
    return getReceiptsByType(receipts, ReceiptType.Call);
  }
  function getReceiptsMessageOut(receipts) {
    return getReceiptsByType(receipts, ReceiptType.MessageOut);
  }
  var mergeAssets = (op1, op2) => {
    const assets1 = op1.assetsSent || [];
    const assets22 = op2.assetsSent || [];
    const filteredAssets = assets22.filter(
      (asset2) => !assets1.some((asset1) => asset1.assetId === asset2.assetId)
    );
    const mergedAssets = assets1.map((asset1) => {
      const matchingAsset = assets22.find((asset2) => asset2.assetId === asset1.assetId);
      if (!matchingAsset) {
        return asset1;
      }
      const mergedAmount = bn(asset1.amount).add(matchingAsset.amount);
      return { ...asset1, amount: mergedAmount };
    });
    return mergedAssets.concat(filteredAssets);
  };
  function isSameOperation(a, b) {
    return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
  }
  function addOperation(operations, toAdd) {
    const allOperations = [...operations];
    const index = allOperations.findIndex((op) => isSameOperation(op, toAdd));
    if (allOperations[index]) {
      const existentOperation = { ...allOperations[index] };
      if (toAdd.assetsSent?.length) {
        existentOperation.assetsSent = existentOperation.assetsSent?.length ? mergeAssets(existentOperation, toAdd) : toAdd.assetsSent;
      }
      if (toAdd.calls?.length) {
        existentOperation.calls = [...existentOperation.calls || [], ...toAdd.calls];
      }
      allOperations[index] = existentOperation;
    } else {
      allOperations.push(toAdd);
    }
    return allOperations;
  }
  function getWithdrawFromFuelOperations({
    inputs,
    receipts
  }) {
    const messageOutReceipts = getReceiptsMessageOut(receipts);
    const withdrawFromFuelOperations = messageOutReceipts.reduce(
      (prevWithdrawFromFuelOps, receipt) => {
        const assetId = "0x0000000000000000000000000000000000000000000000000000000000000000";
        const input = getInputFromAssetId(inputs, assetId);
        if (input) {
          const inputAddress = getInputAccountAddress(input);
          const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
            name: "Withdraw from Fuel",
            from: {
              type: 1,
              address: inputAddress
            },
            to: {
              type: 1,
              address: receipt.recipient.toString(),
              chain: "ethereum"
              /* ethereum */
            },
            assetsSent: [
              {
                amount: receipt.amount,
                assetId
              }
            ]
          });
          return newWithdrawFromFuelOps;
        }
        return prevWithdrawFromFuelOps;
      },
      []
    );
    return withdrawFromFuelOperations;
  }
  function getContractCallOperations({
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs
  }) {
    const contractCallReceipts = getReceiptsCall(receipts);
    const contractOutputs = getOutputsContract(outputs);
    const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output3) => {
      const contractInput = getInputContractFromIndex(inputs, output3.inputIndex);
      if (contractInput) {
        const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {
          if (receipt.to === contractInput.contractID) {
            const input = getInputFromAssetId(inputs, receipt.assetId);
            if (input) {
              const inputAddress = getInputAccountAddress(input);
              const calls = [];
              const abi = abiMap?.[contractInput.contractID];
              if (abi) {
                calls.push(
                  getFunctionCall({
                    abi,
                    receipt,
                    rawPayload,
                    maxInputs
                  })
                );
              }
              const newContractCallOps = addOperation(prevContractCallOps, {
                name: "Contract call",
                from: {
                  type: 1,
                  address: inputAddress
                },
                to: {
                  type: 0,
                  address: receipt.to
                },
                // if no amount is forwarded to the contract, skip showing assetsSent
                assetsSent: receipt.amount?.isZero() ? void 0 : [
                  {
                    amount: receipt.amount,
                    assetId: receipt.assetId
                  }
                ],
                calls
              });
              return newContractCallOps;
            }
          }
          return prevContractCallOps;
        }, prevOutputCallOps);
        return newCallOps;
      }
      return prevOutputCallOps;
    }, []);
    return contractCallOperations;
  }
  function extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs) {
    const { to: toAddress, assetId, amount } = receipt;
    let { from: fromAddress } = receipt;
    const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 : 1;
    if (ZeroBytes32 === fromAddress) {
      const change = changeOutputs.find((output3) => output3.assetId === assetId);
      fromAddress = change?.to || fromAddress;
    }
    const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 : 1;
    return {
      name: "Transfer asset",
      from: {
        type: fromType,
        address: fromAddress
      },
      to: {
        type: toType,
        address: toAddress
      },
      assetsSent: [
        {
          assetId: assetId.toString(),
          amount
        }
      ]
    };
  }
  function getTransferOperations({
    inputs,
    outputs,
    receipts
  }) {
    let operations = [];
    const coinOutputs = getOutputsCoin(outputs);
    const contractInputs = getInputsContract(inputs);
    const changeOutputs = getOutputsChange(outputs);
    coinOutputs.forEach((output3) => {
      const { amount, assetId, to } = output3;
      const changeOutput = changeOutputs.find((change) => change.assetId === assetId);
      if (changeOutput) {
        operations = addOperation(operations, {
          name: "Transfer asset",
          from: {
            type: 1,
            address: changeOutput.to
          },
          to: {
            type: 1,
            address: to
          },
          assetsSent: [
            {
              assetId,
              amount
            }
          ]
        });
      }
    });
    const transferReceipts = getReceiptsByType(
      receipts,
      ReceiptType.Transfer
    );
    const transferOutReceipts = getReceiptsByType(
      receipts,
      ReceiptType.TransferOut
    );
    [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
      const operation = extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs);
      operations = addOperation(operations, operation);
    });
    return operations;
  }
  function getPayProducerOperations(outputs) {
    const coinOutputs = getOutputsCoin(outputs);
    const payProducerOperations = coinOutputs.reduce((prev, output3) => {
      const operations = addOperation(prev, {
        name: "Pay network fee to block producer",
        from: {
          type: 1,
          address: "Network"
        },
        to: {
          type: 1,
          address: output3.to.toString()
        },
        assetsSent: [
          {
            assetId: output3.assetId.toString(),
            amount: output3.amount
          }
        ]
      });
      return operations;
    }, []);
    return payProducerOperations;
  }
  function getContractCreatedOperations({ inputs, outputs }) {
    const contractCreatedOutputs = getOutputsContractCreated(outputs);
    const input = getInputsCoinAndMessage(inputs)[0];
    const fromAddress = getInputAccountAddress(input);
    const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
      const operations = addOperation(prev, {
        name: "Contract created",
        from: {
          type: 1,
          address: fromAddress
        },
        to: {
          type: 0,
          address: contractCreatedOutput?.contractId || ""
        }
      });
      return operations;
    }, []);
    return contractCreatedOperations;
  }
  function getOperations({
    transactionType,
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs
  }) {
    if (isTypeCreate(transactionType)) {
      return [
        ...getContractCreatedOperations({ inputs, outputs }),
        ...getTransferOperations({ inputs, outputs, receipts })
      ];
    }
    if (isTypeScript(transactionType)) {
      return [
        ...getTransferOperations({ inputs, outputs, receipts }),
        ...getContractCallOperations({
          inputs,
          outputs,
          receipts,
          abiMap,
          rawPayload,
          maxInputs
        }),
        ...getWithdrawFromFuelOperations({ inputs, receipts })
      ];
    }
    return [...getPayProducerOperations(outputs)];
  }
  var processGqlReceipt = (gqlReceipt) => {
    const receipt = assembleReceiptByType(gqlReceipt);
    switch (receipt.type) {
      case ReceiptType.ReturnData: {
        return {
          ...receipt,
          data: gqlReceipt.data || "0x"
        };
      }
      case ReceiptType.LogData: {
        return {
          ...receipt,
          data: gqlReceipt.data || "0x"
        };
      }
      default:
        return receipt;
    }
  };
  var extractMintedAssetsFromReceipts = (receipts) => {
    const mintedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Mint) {
        mintedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return mintedAssets;
  };
  var extractBurnedAssetsFromReceipts = (receipts) => {
    const burnedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Burn) {
        burnedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return burnedAssets;
  };
  var getTransactionStatusName = (gqlStatus) => {
    switch (gqlStatus) {
      case "FailureStatus":
        return "failure";
      case "SuccessStatus":
        return "success";
      case "SubmittedStatus":
        return "submitted";
      case "SqueezedOutStatus":
        return "squeezedout";
      default:
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_STATUS,
          `Invalid transaction status: ${gqlStatus}.`
        );
    }
  };
  var processGraphqlStatus = (gqlTransactionStatus) => {
    let time;
    let blockId;
    let status;
    let isStatusFailure = false;
    let isStatusSuccess = false;
    let isStatusPending = false;
    if (gqlTransactionStatus?.type) {
      status = getTransactionStatusName(gqlTransactionStatus.type);
      switch (gqlTransactionStatus.type) {
        case "SuccessStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block.id;
          isStatusSuccess = true;
          break;
        case "FailureStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block.id;
          isStatusFailure = true;
          break;
        case "SubmittedStatus":
          time = gqlTransactionStatus.time;
          isStatusPending = true;
          break;
        default:
      }
    }
    const processedGraphqlStatus = {
      time,
      blockId,
      status,
      isStatusFailure,
      isStatusSuccess,
      isStatusPending
    };
    return processedGraphqlStatus;
  };
  function assembleTransactionSummary(params) {
    const {
      id,
      receipts,
      gasPerByte,
      gasPriceFactor,
      transaction,
      transactionBytes,
      gqlTransactionStatus,
      abiMap = {},
      maxInputs,
      gasCosts
    } = params;
    const gasUsed = getGasUsedFromReceipts(receipts);
    const rawPayload = hexlify(transactionBytes);
    const operations = getOperations({
      transactionType: transaction.type,
      inputs: transaction.inputs || [],
      outputs: transaction.outputs || [],
      receipts,
      rawPayload,
      abiMap,
      maxInputs
    });
    const typeName = getTransactionTypeName(transaction.type);
    const { fee } = calculateTransactionFee({
      gasUsed,
      rawPayload,
      consensusParameters: {
        gasCosts,
        feeParams: {
          gasPerByte,
          gasPriceFactor
        }
      }
    });
    const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } = processGraphqlStatus(gqlTransactionStatus);
    const mintedAssets = extractMintedAssetsFromReceipts(receipts);
    const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
    let date2;
    if (time) {
      date2 = DateTime.fromTai64(time);
    }
    const transactionSummary = {
      id,
      fee,
      gasUsed,
      operations,
      type: typeName,
      blockId,
      time,
      status,
      receipts,
      mintedAssets,
      burnedAssets,
      isTypeMint: isTypeMint(transaction.type),
      isTypeCreate: isTypeCreate(transaction.type),
      isTypeScript: isTypeScript(transaction.type),
      isStatusFailure,
      isStatusSuccess,
      isStatusPending,
      date: date2,
      transaction
    };
    return transactionSummary;
  }
  function getDecodedLogs(receipts, mainAbi, externalAbis = {}) {
    return receipts.reduce((logs, receipt) => {
      if (receipt.type === ReceiptType.LogData || receipt.type === ReceiptType.Log) {
        const interfaceToUse = new Interface(externalAbis[receipt.id] || mainAbi);
        const data = receipt.type === ReceiptType.Log ? new BigNumberCoder("u64").encode(receipt.val0) : receipt.data;
        const [decodedLog] = interfaceToUse.decodeLog(data, receipt.val1.toNumber());
        logs.push(decodedLog);
      }
      return logs;
    }, []);
  }
  var TransactionResponse2 = class {
    /** Transaction ID */
    id;
    /** Current provider */
    provider;
    /** Gas used on the transaction */
    gasUsed = bn(0);
    /** The graphql Transaction with receipts object. */
    gqlTransaction;
    abis;
    /**
     * Constructor for `TransactionResponse`.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    constructor(id, provider, abis) {
      this.id = id;
      this.provider = provider;
      this.abis = abis;
    }
    /**
     * Async constructor for `TransactionResponse`. This method can be used to create
     * an instance of `TransactionResponse` and wait for the transaction to be fetched
     * from the chain, ensuring that the `gqlTransaction` property is set.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    static async create(id, provider, abis) {
      const response = new TransactionResponse2(id, provider, abis);
      await response.fetch();
      return response;
    }
    /**
     * Fetch the transaction with receipts from the provider.
     *
     * @returns Transaction with receipts query result.
     */
    async fetch() {
      const response = await this.provider.operations.getTransactionWithReceipts({
        transactionId: this.id
      });
      if (!response.transaction) {
        const subscription = this.provider.operations.statusChange({
          transactionId: this.id
        });
        for await (const { statusChange } of subscription) {
          if (statusChange) {
            break;
          }
        }
        return this.fetch();
      }
      this.gqlTransaction = response.transaction;
      return response.transaction;
    }
    /**
     * Decode the raw payload of the transaction.
     *
     * @param transactionWithReceipts - The transaction with receipts object.
     * @returns The decoded transaction.
     */
    decodeTransaction(transactionWithReceipts) {
      return new TransactionCoder().decode(
        arrayify(transactionWithReceipts.rawPayload),
        0
      )?.[0];
    }
    /**
     * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
     * fetch it from the provider
     *
     * @param contractsAbiMap - The contracts ABI map.
     * @returns
     */
    async getTransactionSummary(contractsAbiMap) {
      let transaction = this.gqlTransaction;
      if (!transaction) {
        transaction = await this.fetch();
      }
      const decodedTransaction = this.decodeTransaction(
        transaction
      );
      const receipts = transaction.receipts?.map(processGqlReceipt) || [];
      const { gasPerByte, gasPriceFactor, gasCosts } = this.provider.getGasConfig();
      const maxInputs = this.provider.getChain().consensusParameters.maxInputs;
      const transactionSummary = assembleTransactionSummary({
        id: this.id,
        receipts,
        transaction: decodedTransaction,
        transactionBytes: arrayify(transaction.rawPayload),
        gqlTransactionStatus: transaction.status,
        gasPerByte,
        gasPriceFactor,
        abiMap: contractsAbiMap,
        maxInputs,
        gasCosts
      });
      return transactionSummary;
    }
    async waitForStatusChange() {
      const status = this.gqlTransaction?.status?.type;
      if (status && status !== "SubmittedStatus") {
        return;
      }
      const subscription = this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange } of subscription) {
        if (statusChange.type === "SqueezedOutStatus") {
          throw new FuelError(
            ErrorCode.TRANSACTION_SQUEEZED_OUT,
            `Transaction Squeezed Out with reason: ${statusChange.reason}`
          );
        }
        if (statusChange.type !== "SubmittedStatus") {
          break;
        }
      }
      await this.fetch();
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @returns The completed transaction result
     */
    async waitForResult(contractsAbiMap) {
      await this.waitForStatusChange();
      const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
      const transactionResult = {
        gqlTransaction: this.gqlTransaction,
        ...transactionSummary
      };
      if (this.abis) {
        const logs = getDecodedLogs(
          transactionSummary.receipts,
          this.abis.main,
          this.abis.otherContractsAbis
        );
        transactionResult.logs = logs;
      }
      return transactionResult;
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @param contractsAbiMap - The contracts ABI map.
     */
    async wait(contractsAbiMap) {
      const result = await this.waitForResult(contractsAbiMap);
      if (result.isStatusFailure) {
        throw new FuelError(
          ErrorCode.TRANSACTION_FAILED,
          `Transaction failed: ${result.gqlTransaction.status.reason}`
        );
      }
      return result;
    }
  };
  function getWaitDelay(options, retryAttemptNum) {
    const duration = options.baseDelay ?? 150;
    switch (options.backoff) {
      case "linear":
        return duration * retryAttemptNum;
      case "fixed":
        return duration;
      case "exponential":
      default:
        return 2 ** (retryAttemptNum - 1) * duration;
    }
  }
  function autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {
    if (options === void 0) {
      return fetchFn;
    }
    return async (...args) => {
      try {
        return await fetchFn(...args);
      } catch (_error) {
        const error2 = _error;
        if (error2.cause?.code !== "ECONNREFUSED") {
          throw error2;
        }
        const retryNum = retryAttemptNum + 1;
        if (retryNum > options.maxRetries) {
          throw error2;
        }
        const delay = getWaitDelay(options, retryNum);
        await sleep(delay);
        return autoRetryFetch(fetchFn, options, retryNum)(...args);
      }
    };
  }
  var mergeQuantities = (arr1, arr2) => {
    const resultMap = {};
    function addToMap({ amount, assetId }) {
      if (resultMap[assetId]) {
        resultMap[assetId] = resultMap[assetId].add(amount);
      } else {
        resultMap[assetId] = amount;
      }
    }
    arr1.forEach(addToMap);
    arr2.forEach(addToMap);
    return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
  };
  var MAX_RETRIES = 10;
  var processGqlChain = (chain) => {
    const { name, daHeight, consensusParameters, latestBlock } = chain;
    const { contractParams, feeParams, predicateParams, scriptParams, txParams, gasCosts } = consensusParameters;
    return {
      name,
      baseChainHeight: bn(daHeight),
      consensusParameters: {
        contractMaxSize: bn(contractParams.contractMaxSize),
        maxInputs: bn(txParams.maxInputs),
        maxOutputs: bn(txParams.maxOutputs),
        maxWitnesses: bn(txParams.maxWitnesses),
        maxGasPerTx: bn(txParams.maxGasPerTx),
        maxScriptLength: bn(scriptParams.maxScriptLength),
        maxScriptDataLength: bn(scriptParams.maxScriptDataLength),
        maxStorageSlots: bn(contractParams.maxStorageSlots),
        maxPredicateLength: bn(predicateParams.maxPredicateLength),
        maxPredicateDataLength: bn(predicateParams.maxPredicateDataLength),
        maxGasPerPredicate: bn(predicateParams.maxGasPerPredicate),
        gasPriceFactor: bn(feeParams.gasPriceFactor),
        gasPerByte: bn(feeParams.gasPerByte),
        maxMessageDataLength: bn(predicateParams.maxMessageDataLength),
        chainId: bn(consensusParameters.chainId),
        gasCosts
      },
      gasCosts,
      latestBlock: {
        id: latestBlock.id,
        height: bn(latestBlock.header.height),
        time: latestBlock.header.time,
        transactions: latestBlock.transactions.map((i) => ({
          id: i.id
        }))
      }
    };
  };
  var _cacheInputs;
  var cacheInputs_fn;
  var _Provider = class {
    /**
     * Constructor to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param chainInfo - Chain info of the Fuel node
     * @param options - Additional options for the provider
     * @hidden
     */
    constructor(url, options = {}) {
      this.url = url;
      __privateAdd3(this, _cacheInputs);
      __publicField6(this, "operations");
      __publicField6(this, "cache");
      __publicField6(this, "options", {
        timeout: void 0,
        cacheUtxo: void 0,
        fetch: void 0,
        retryOptions: void 0
      });
      this.options = { ...this.options, ...options };
      this.url = url;
      this.operations = this.createOperations();
      this.cache = options.cacheUtxo ? new MemoryCache(options.cacheUtxo) : void 0;
    }
    static clearChainAndNodeCaches() {
      _Provider.nodeInfoCache = {};
      _Provider.chainInfoCache = {};
    }
    static getFetchFn(options) {
      const { retryOptions, timeout } = options;
      return autoRetryFetch(async (...args) => {
        const url = args[0];
        const request = args[1];
        const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
        let fullRequest = { ...request, signal };
        if (options.requestMiddleware) {
          fullRequest = await options.requestMiddleware(fullRequest);
        }
        return options.fetch ? options.fetch(url, fullRequest, options) : fetch(url, fullRequest);
      }, retryOptions);
    }
    /**
     * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     */
    static async create(url, options = {}) {
      const provider = new _Provider(url, options);
      await provider.fetchChainAndNodeInfo();
      return provider;
    }
    /**
     * Returns the cached chainInfo for the current URL.
     */
    getChain() {
      const chain = _Provider.chainInfoCache[this.url];
      if (!chain) {
        throw new FuelError(
          ErrorCode.CHAIN_INFO_CACHE_EMPTY,
          "Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
        );
      }
      return chain;
    }
    /**
     * Returns the cached nodeInfo for the current URL.
     */
    getNode() {
      const node = _Provider.nodeInfoCache[this.url];
      if (!node) {
        throw new FuelError(
          ErrorCode.NODE_INFO_CACHE_EMPTY,
          "Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
        );
      }
      return node;
    }
    /**
     * Returns some helpful parameters related to gas fees.
     */
    getGasConfig() {
      const { minGasPrice } = this.getNode();
      const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte, gasCosts } = this.getChain().consensusParameters;
      return {
        minGasPrice,
        maxGasPerTx,
        maxGasPerPredicate,
        gasPriceFactor,
        gasPerByte,
        gasCosts
      };
    }
    /**
     * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
     */
    async connect(url, options) {
      this.url = url;
      this.options = options ?? this.options;
      this.operations = this.createOperations();
      await this.fetchChainAndNodeInfo();
    }
    /**
     * Fetches both the chain and node information, saves it to the cache, and return it.
     *
     * @returns NodeInfo and Chain
     */
    async fetchChainAndNodeInfo() {
      const chain = await this.fetchChain();
      const nodeInfo = await this.fetchNode();
      _Provider.ensureClientVersionIsSupported(nodeInfo);
      return {
        chain,
        nodeInfo
      };
    }
    static ensureClientVersionIsSupported(nodeInfo) {
      const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
      if (!isMajorSupported || !isMinorSupported) {
        throw new FuelError(
          FuelError.CODES.UNSUPPORTED_FUEL_CLIENT_VERSION,
          `Fuel client version: ${nodeInfo.nodeVersion}, Supported version: ${supportedVersion}`
        );
      }
    }
    /**
     * Create GraphQL client and set operations.
     *
     * @returns The operation SDK object
     */
    createOperations() {
      const fetchFn = _Provider.getFetchFn(this.options);
      const gqlClient = new import_graphql_request.GraphQLClient(this.url, {
        fetch: (url, requestInit) => fetchFn(url, requestInit, this.options)
      });
      const executeQuery = (query, vars) => {
        const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
        const isSubscription = opDefinition?.operation === "subscription";
        if (isSubscription) {
          return new FuelGraphqlSubscriber({
            url: this.url,
            query,
            fetchFn: (url, requestInit) => fetchFn(url, requestInit, this.options),
            variables: vars
          });
        }
        return gqlClient.request(query, vars);
      };
      return getSdk(executeQuery);
    }
    /**
     * Returns the version of the connected node.
     *
     * @returns A promise that resolves to the version string.
     */
    async getVersion() {
      const {
        nodeInfo: { nodeVersion }
      } = await this.operations.getVersion();
      return nodeVersion;
    }
    /**
     * @hidden
     *
     * Returns the network configuration of the connected Fuel node.
     *
     * @returns A promise that resolves to the network configuration object
     */
    async getNetwork() {
      const {
        name,
        consensusParameters: { chainId }
      } = await this.getChain();
      const network = new Network(name, chainId.toNumber());
      return Promise.resolve(network);
    }
    /**
     * Returns the block number.
     *
     * @returns A promise that resolves to the block number
     */
    async getBlockNumber() {
      const { chain } = await this.operations.getChain();
      return bn(chain.latestBlock.header.height, 10);
    }
    /**
     * Returns the chain information.
     * @param url - The URL of the Fuel node
     * @returns NodeInfo object
     */
    async fetchNode() {
      const { nodeInfo } = await this.operations.getNodeInfo();
      const processedNodeInfo = {
        maxDepth: bn(nodeInfo.maxDepth),
        maxTx: bn(nodeInfo.maxTx),
        minGasPrice: bn(nodeInfo.minGasPrice),
        nodeVersion: nodeInfo.nodeVersion,
        utxoValidation: nodeInfo.utxoValidation,
        vmBacktrace: nodeInfo.vmBacktrace,
        peers: nodeInfo.peers
      };
      _Provider.nodeInfoCache[this.url] = processedNodeInfo;
      return processedNodeInfo;
    }
    /**
     * Fetches the `chainInfo` for the given node URL.
     * @param url - The URL of the Fuel node
     * @returns ChainInfo object
     */
    async fetchChain() {
      const { chain } = await this.operations.getChain();
      const processedChain = processGqlChain(chain);
      _Provider.chainInfoCache[this.url] = processedChain;
      return processedChain;
    }
    /**
     * Returns the chain ID
     * @returns A promise that resolves to the chain ID number
     */
    getChainId() {
      const {
        consensusParameters: { chainId }
      } = this.getChain();
      return chainId.toNumber();
    }
    /**
     * Submits a transaction to the chain to be executed.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @returns A promise that resolves to the transaction response object.
     */
    // #region Provider-sendTransaction
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution = false } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      __privateMethod3(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs);
      if (estimateTxDependencies) {
        await this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      let abis;
      if (transactionRequest.type === TransactionType.Script) {
        abis = transactionRequest.abis;
      }
      if (awaitExecution) {
        const subscription = this.operations.submitAndAwait({ encodedTransaction });
        for await (const { submitAndAwait } of subscription) {
          if (submitAndAwait.type === "SqueezedOutStatus") {
            throw new FuelError(
              ErrorCode.TRANSACTION_SQUEEZED_OUT,
              `Transaction Squeezed Out with reason: ${submitAndAwait.reason}`
            );
          }
          if (submitAndAwait.type !== "SubmittedStatus") {
            break;
          }
        }
        const transactionId2 = transactionRequest.getTransactionId(this.getChainId());
        const response = new TransactionResponse2(transactionId2, this, abis);
        await response.fetch();
        return response;
      }
      const {
        submit: { id: transactionId }
      } = await this.operations.submit({ encodedTransaction });
      return new TransactionResponse2(transactionId, this, abis);
    }
    /**
     * Executes a transaction without actually submitting it to the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param utxoValidation - Additional provider call parameters.
     * @returns A promise that resolves to the call result object.
     */
    async call(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        return this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction,
        utxoValidation: utxoValidation || false
      });
      const receipts = gqlReceipts.map(processGqlReceipt);
      return {
        receipts
      };
    }
    /**
     * Verifies whether enough gas is available to complete transaction.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimated transaction request object.
     */
    async estimatePredicates(transactionRequest) {
      const shouldEstimatePredicates = Boolean(
        transactionRequest.inputs.find(
          (input) => "predicate" in input && input.predicate && !equalBytes(arrayify(input.predicate), arrayify("0x")) && new BN(input.predicateGasUsed).isZero()
        )
      );
      if (!shouldEstimatePredicates) {
        return transactionRequest;
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const response = await this.operations.estimatePredicates({
        encodedTransaction
      });
      const {
        estimatePredicates: { inputs }
      } = response;
      if (inputs) {
        inputs.forEach((input, index) => {
          if ("predicateGasUsed" in input && bn(input.predicateGasUsed).gt(0)) {
            transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
          }
        });
      }
      return transactionRequest;
    }
    /**
     * Will dryRun a transaction and check for missing dependencies.
     *
     * If there are missing variable outputs,
     * `addVariableOutputs` is called on the transaction.
     *
     * @privateRemarks
     * TODO: Investigate support for missing contract IDs
     * TODO: Add support for missing output messages
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise.
     */
    async estimateTxDependencies(transactionRequest) {
      if (transactionRequest.type === TransactionType.Create) {
        return {
          receipts: [],
          outputVariables: 0,
          missingContractIds: []
        };
      }
      await this.estimatePredicates(transactionRequest);
      let receipts = [];
      const missingContractIds = [];
      let outputVariables = 0;
      for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        const { dryRun: gqlReceipts } = await this.operations.dryRun({
          encodedTransaction: hexlify(transactionRequest.toTransactionBytes()),
          utxoValidation: false
        });
        receipts = gqlReceipts.map(processGqlReceipt);
        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
        const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
        if (hasMissingOutputs) {
          outputVariables += missingOutputVariables.length;
          transactionRequest.addVariableOutputs(missingOutputVariables.length);
          missingOutputContractIds.forEach(({ contractId }) => {
            transactionRequest.addContractInputAndOutput(Address.fromString(contractId));
            missingContractIds.push(contractId);
          });
        } else {
          break;
        }
      }
      return {
        receipts,
        outputVariables,
        missingContractIds
      };
    }
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added
     *
     * @param transactionRequestLike - The transaction request object.
     * @returns A promise that resolves to the call result object.
     */
    async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        return this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction,
        utxoValidation: true
      });
      const receipts = gqlReceipts.map(processGqlReceipt);
      return {
        receipts
      };
    }
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the the transaction.
     *
     * @privateRemarks
     * The tolerance is add on top of the gasUsed calculated
     * from the node, this create a safe margin costs like
     * change states on transfer that don't occur on the dryRun
     * transaction. The default value is 0.2 or 20%
     *
     * @param transactionRequestLike - The transaction request object.
     * @param tolerance - The tolerance to add on top of the gasUsed.
     * @returns A promise that resolves to the transaction cost object.
     */
    async getTransactionCost(transactionRequestLike, forwardingQuantities = [], {
      estimateTxDependencies = true,
      estimatePredicates = true,
      resourcesOwner,
      signatureCallback
    } = {}) {
      const txRequestClone = clone_default(transactionRequestify(transactionRequestLike));
      const chainInfo = this.getChain();
      const { gasPriceFactor, minGasPrice, maxGasPerTx } = this.getGasConfig();
      const gasPrice = max(txRequestClone.gasPrice, minGasPrice);
      const isScriptTransaction = txRequestClone.type === TransactionType.Script;
      const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
      const allQuantities = mergeQuantities(coinOutputsQuantities, forwardingQuantities);
      txRequestClone.fundWithFakeUtxos(allQuantities, resourcesOwner?.address);
      if (estimatePredicates) {
        if (isScriptTransaction) {
          txRequestClone.gasLimit = bn(0);
        }
        if (resourcesOwner && "populateTransactionPredicateData" in resourcesOwner) {
          resourcesOwner.populateTransactionPredicateData(txRequestClone);
        }
        await this.estimatePredicates(txRequestClone);
      }
      if (signatureCallback && isScriptTransaction) {
        await signatureCallback(txRequestClone);
      }
      const minGas = txRequestClone.calculateMinGas(chainInfo);
      const maxGas = txRequestClone.calculateMaxGas(chainInfo, minGas);
      let receipts = [];
      let missingContractIds = [];
      let outputVariables = 0;
      if (isScriptTransaction && estimateTxDependencies) {
        txRequestClone.gasPrice = bn(0);
        txRequestClone.gasLimit = bn(maxGasPerTx.sub(maxGas).toNumber() * 0.9);
        const result = await this.estimateTxDependencies(txRequestClone);
        receipts = result.receipts;
        outputVariables = result.outputVariables;
        missingContractIds = result.missingContractIds;
      }
      const gasUsed = isScriptTransaction ? getGasUsedFromReceipts(receipts) : minGas;
      const usedFee = calculatePriceWithFactor(
        gasUsed,
        gasPrice,
        gasPriceFactor
      ).normalizeZeroToOne();
      const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
      const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
      return {
        requiredQuantities: allQuantities,
        receipts,
        gasUsed,
        minGasPrice,
        gasPrice,
        minGas,
        maxGas,
        usedFee,
        minFee,
        maxFee,
        estimatedInputs: txRequestClone.inputs,
        outputVariables,
        missingContractIds
      };
    }
    async getResourcesForTransaction(owner, transactionRequestLike, forwardingQuantities = []) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const transactionRequest = transactionRequestify(clone_default(transactionRequestLike));
      const transactionCost = await this.getTransactionCost(transactionRequest, forwardingQuantities);
      transactionRequest.addResources(
        await this.getResourcesToSpend(ownerAddress, transactionCost.requiredQuantities)
      );
      const { requiredQuantities, ...txCost } = await this.getTransactionCost(
        transactionRequest,
        forwardingQuantities
      );
      const resources = await this.getResourcesToSpend(ownerAddress, requiredQuantities);
      return {
        resources,
        requiredQuantities,
        ...txCost
      };
    }
    /**
     * Returns coins for the given owner.
     */
    async getCoins(owner, assetId, paginationArgs) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const result = await this.operations.getCoins({
        first: 10,
        ...paginationArgs,
        filter: { owner: ownerAddress.toB256(), assetId: assetId && hexlify(assetId) }
      });
      const coins = result.coins.edges.map((edge) => edge.node);
      return coins.map((coin) => ({
        id: coin.utxoId,
        assetId: coin.assetId,
        amount: bn(coin.amount),
        owner: Address.fromAddressOrString(coin.owner),
        maturity: bn(coin.maturity).toNumber(),
        blockCreated: bn(coin.blockCreated),
        txCreatedIdx: bn(coin.txCreatedIdx)
      }));
    }
    /**
     * Returns resources for the given owner satisfying the spend query.
     *
     * @param owner - The address to get resources for.
     * @param quantities - The quantities to get.
     * @param excludedIds - IDs of excluded resources from the selection.
     * @returns A promise that resolves to the resources.
     */
    async getResourcesToSpend(owner, quantities, excludedIds) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const excludeInput = {
        messages: excludedIds?.messages?.map((nonce) => hexlify(nonce)) || [],
        utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || []
      };
      if (this.cache) {
        const uniqueUtxos = new Set(
          excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => hexlify(id)))
        );
        excludeInput.utxos = Array.from(uniqueUtxos);
      }
      const coinsQuery = {
        owner: ownerAddress.toB256(),
        queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
          assetId: hexlify(assetId),
          amount: amount.toString(10),
          max: maxPerAsset ? maxPerAsset.toString(10) : void 0
        })),
        excludedIds: excludeInput
      };
      const result = await this.operations.getCoinsToSpend(coinsQuery);
      const coins = result.coinsToSpend.flat().map((coin) => {
        switch (coin.__typename) {
          case "MessageCoin":
            return {
              amount: bn(coin.amount),
              assetId: coin.assetId,
              daHeight: bn(coin.daHeight),
              sender: Address.fromAddressOrString(coin.sender),
              recipient: Address.fromAddressOrString(coin.recipient),
              nonce: coin.nonce
            };
          case "Coin":
            return {
              id: coin.utxoId,
              amount: bn(coin.amount),
              assetId: coin.assetId,
              owner: Address.fromAddressOrString(coin.owner),
              maturity: bn(coin.maturity).toNumber(),
              blockCreated: bn(coin.blockCreated),
              txCreatedIdx: bn(coin.txCreatedIdx)
            };
          default:
            return null;
        }
      }).filter((v) => !!v);
      return coins;
    }
    /**
     * Returns block matching the given ID or height.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    async getBlock(idOrHeight) {
      let variables;
      if (typeof idOrHeight === "number") {
        variables = { height: bn(idOrHeight).toString(10) };
      } else if (idOrHeight === "latest") {
        variables = { height: (await this.getBlockNumber()).toString(10) };
      } else if (idOrHeight.length === 66) {
        variables = { blockId: idOrHeight };
      } else {
        variables = { blockId: bn(idOrHeight).toString(10) };
      }
      const { block: block2 } = await this.operations.getBlock(variables);
      if (!block2) {
        return null;
      }
      return {
        id: block2.id,
        height: bn(block2.header.height),
        time: block2.header.time,
        transactionIds: block2.transactions.map((tx) => tx.id)
      };
    }
    /**
     * Returns all the blocks matching the given parameters.
     *
     * @param params - The parameters to query blocks.
     * @returns A promise that resolves to the blocks.
     */
    async getBlocks(params) {
      const { blocks: fetchedData } = await this.operations.getBlocks(params);
      const blocks = fetchedData.edges.map(({ node: block2 }) => ({
        id: block2.id,
        height: bn(block2.header.height),
        time: block2.header.time,
        transactionIds: block2.transactions.map((tx) => tx.id)
      }));
      return blocks;
    }
    /**
     * Returns block matching the given ID or type, including transaction data.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    async getBlockWithTransactions(idOrHeight) {
      let variables;
      if (typeof idOrHeight === "number") {
        variables = { blockHeight: bn(idOrHeight).toString(10) };
      } else if (idOrHeight === "latest") {
        variables = { blockHeight: (await this.getBlockNumber()).toString() };
      } else {
        variables = { blockId: idOrHeight };
      }
      const { block: block2 } = await this.operations.getBlockWithTransactions(variables);
      if (!block2) {
        return null;
      }
      return {
        id: block2.id,
        height: bn(block2.header.height, 10),
        time: block2.header.time,
        transactionIds: block2.transactions.map((tx) => tx.id),
        transactions: block2.transactions.map(
          (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]
        )
      };
    }
    /**
     * Get transaction with the given ID.
     *
     * @param transactionId - ID of the transaction.
     * @returns A promise that resolves to the transaction.
     */
    async getTransaction(transactionId) {
      const { transaction } = await this.operations.getTransaction({ transactionId });
      if (!transaction) {
        return null;
      }
      return new TransactionCoder().decode(
        arrayify(transaction.rawPayload),
        0
      )?.[0];
    }
    /**
     * Get deployed contract with the given ID.
     *
     * @param contractId - ID of the contract.
     * @returns A promise that resolves to the contract.
     */
    async getContract(contractId) {
      const { contract } = await this.operations.getContract({ contractId });
      if (!contract) {
        return null;
      }
      return contract;
    }
    /**
     * Returns the balance for the given contract for the given asset ID.
     *
     * @param contractId - The contract ID to get the balance for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getContractBalance(contractId, assetId) {
      const { contractBalance } = await this.operations.getContractBalance({
        contract: Address.fromAddressOrString(contractId).toB256(),
        asset: hexlify(assetId)
      });
      return bn(contractBalance.amount, 10);
    }
    /**
     * Returns the balance for the given owner for the given asset ID.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getBalance(owner, assetId) {
      const { balance } = await this.operations.getBalance({
        owner: Address.fromAddressOrString(owner).toB256(),
        assetId: hexlify(assetId)
      });
      return bn(balance.amount, 10);
    }
    /**
     * Returns balances for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param paginationArgs - Pagination arguments.
     * @returns A promise that resolves to the balances.
     */
    async getBalances(owner, paginationArgs) {
      const result = await this.operations.getBalances({
        first: 10,
        ...paginationArgs,
        filter: { owner: Address.fromAddressOrString(owner).toB256() }
      });
      const balances = result.balances.edges.map((edge) => edge.node);
      return balances.map((balance) => ({
        assetId: balance.assetId,
        amount: bn(balance.amount)
      }));
    }
    /**
     * Returns message for the given address.
     *
     * @param address - The address to get message from.
     * @param paginationArgs - Pagination arguments.
     * @returns A promise that resolves to the messages.
     */
    async getMessages(address, paginationArgs) {
      const result = await this.operations.getMessages({
        first: 10,
        ...paginationArgs,
        owner: Address.fromAddressOrString(address).toB256()
      });
      const messages = result.messages.edges.map((edge) => edge.node);
      return messages.map((message) => ({
        messageId: InputMessageCoder.getMessageId({
          sender: message.sender,
          recipient: message.recipient,
          nonce: message.nonce,
          amount: bn(message.amount),
          data: message.data
        }),
        sender: Address.fromAddressOrString(message.sender),
        recipient: Address.fromAddressOrString(message.recipient),
        nonce: message.nonce,
        amount: bn(message.amount),
        data: InputMessageCoder.decodeData(message.data),
        daHeight: bn(message.daHeight)
      }));
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param transactionId - The transaction to get message from.
     * @param messageId - The message id from MessageOut receipt.
     * @param commitBlockId - The commit block id.
     * @param commitBlockHeight - The commit block height.
     * @returns A promise that resolves to the message proof.
     */
    async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
      let inputObject = {
        transactionId,
        nonce
      };
      if (commitBlockId && commitBlockHeight) {
        throw new FuelError(
          ErrorCode.INVALID_INPUT_PARAMETERS,
          "commitBlockId and commitBlockHeight cannot be used together"
        );
      }
      if (commitBlockId) {
        inputObject = {
          ...inputObject,
          commitBlockId
        };
      }
      if (commitBlockHeight) {
        inputObject = {
          ...inputObject,
          // Conver BN into a number string required on the query
          // This should problably be fixed on the fuel client side
          commitBlockHeight: commitBlockHeight.toNumber().toString()
        };
      }
      const result = await this.operations.getMessageProof(inputObject);
      if (!result.messageProof) {
        return null;
      }
      const {
        messageProof,
        messageBlockHeader,
        commitBlockHeader,
        blockProof,
        sender,
        recipient,
        amount,
        data
      } = result.messageProof;
      return {
        messageProof: {
          proofIndex: bn(messageProof.proofIndex),
          proofSet: messageProof.proofSet
        },
        blockProof: {
          proofIndex: bn(blockProof.proofIndex),
          proofSet: blockProof.proofSet
        },
        messageBlockHeader: {
          id: messageBlockHeader.id,
          daHeight: bn(messageBlockHeader.daHeight),
          transactionsCount: bn(messageBlockHeader.transactionsCount),
          transactionsRoot: messageBlockHeader.transactionsRoot,
          height: bn(messageBlockHeader.height),
          prevRoot: messageBlockHeader.prevRoot,
          time: messageBlockHeader.time,
          applicationHash: messageBlockHeader.applicationHash,
          messageReceiptRoot: messageBlockHeader.messageReceiptRoot,
          messageReceiptCount: bn(messageBlockHeader.messageReceiptCount)
        },
        commitBlockHeader: {
          id: commitBlockHeader.id,
          daHeight: bn(commitBlockHeader.daHeight),
          transactionsCount: bn(commitBlockHeader.transactionsCount),
          transactionsRoot: commitBlockHeader.transactionsRoot,
          height: bn(commitBlockHeader.height),
          prevRoot: commitBlockHeader.prevRoot,
          time: commitBlockHeader.time,
          applicationHash: commitBlockHeader.applicationHash,
          messageReceiptRoot: commitBlockHeader.messageReceiptRoot,
          messageReceiptCount: bn(commitBlockHeader.messageReceiptCount)
        },
        sender: Address.fromAddressOrString(sender),
        recipient: Address.fromAddressOrString(recipient),
        nonce,
        amount: bn(amount),
        data
      };
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param nonce - The nonce of the message to get status from.
     * @returns A promise that resolves to the message status
     */
    async getMessageStatus(nonce) {
      const result = await this.operations.getMessageStatus({ nonce });
      return result.messageStatus;
    }
    /**
     * Lets you produce blocks with custom timestamps and the block number of the last block produced.
     *
     * @param amount - The amount of blocks to produce
     * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block
     * @returns A promise that resolves to the block number of the last produced block.
     */
    async produceBlocks(amount, startTime) {
      const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
        blocksToProduce: bn(amount).toString(10),
        startTimestamp: startTime ? DateTime.fromUnixMilliseconds(startTime).toTai64() : void 0
      });
      return bn(latestBlockHeight);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getTransactionResponse(transactionId) {
      return new TransactionResponse2(transactionId, this);
    }
  };
  var Provider = _Provider;
  _cacheInputs = /* @__PURE__ */ new WeakSet();
  cacheInputs_fn = function(inputs) {
    if (!this.cache) {
      return;
    }
    inputs.forEach((input) => {
      if (input.type === InputType.Coin) {
        this.cache?.set(input.id);
      }
    });
  };
  __publicField6(Provider, "chainInfoCache", {});
  __publicField6(Provider, "nodeInfoCache", {});
  var CHAIN_IDS = {
    eth: {
      sepolia: 11155111,
      foundry: 31337
    },
    fuel: {
      beta5: 0,
      devnet: 10
    }
  };
  var assets = [
    {
      name: "Ethereum",
      symbol: "ETH",
      icon: "eth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.sepolia,
          decimals: 18
        },
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.foundry,
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.beta5,
          decimals: 9,
          assetId: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.devnet,
          decimals: 9,
          assetId: "0x0000000000000000000000000000000000000000000000000000000000000000"
        }
      ]
    }
  ];
  var formatTransferToContractScriptData = (params) => {
    const { assetId, amountToTransfer, hexlifiedContractId } = params;
    const numberCoder = new BigNumberCoder("u64");
    const encoded = numberCoder.encode(new BN(amountToTransfer).toNumber());
    const scriptData = Uint8Array.from([
      ...arrayify(hexlifiedContractId),
      ...encoded,
      ...arrayify(assetId)
    ]);
    return scriptData;
  };
  var assembleTransferToContractScript = async (params) => {
    const scriptData = formatTransferToContractScriptData(params);
    await asm.initWasm();
    const gtf22 = asm.gtf(16, 0, asm.GTFArgs.ScriptData);
    const addi22 = asm.addi(17, 16, 32);
    const lw22 = asm.lw(18, 17, 0);
    const addi222 = asm.addi(19, 17, 8);
    const tr22 = asm.tr(16, 18, 19);
    const ret22 = asm.ret(1);
    const script = Uint8Array.from([
      ...gtf22.to_bytes(),
      ...addi22.to_bytes(),
      ...lw22.to_bytes(),
      ...addi222.to_bytes(),
      ...tr22.to_bytes(),
      ...ret22.to_bytes()
    ]);
    return { script, scriptData };
  };
  var Account = class extends AbstractAccount {
    /**
     * The address associated with the account.
     */
    address;
    /**
     * The provider used to interact with the network.
     */
    _provider;
    _connector;
    /**
     * Creates a new Account instance.
     *
     * @param address - The address of the account.
     * @param provider - A Provider instance  (optional).
     */
    constructor(address, provider, connector) {
      super();
      this._provider = provider;
      this._connector = connector;
      this.address = Address.fromDynamicInput(address);
    }
    /**
     * The provider used to interact with the network.
     *
     * @returns A Provider instance.
     *
     * @throws `FuelError` if the provider is not set.
     */
    get provider() {
      if (!this._provider) {
        throw new FuelError(ErrorCode.MISSING_PROVIDER, "Provider not set");
      }
      return this._provider;
    }
    /**
     * Sets the provider for the account.
     *
     * @param provider - A Provider instance.
     */
    set provider(provider) {
      this._provider = provider;
    }
    /**
     * Changes the provider connection for the account.
     *
     * @param provider - A Provider instance.
     * @returns The updated Provider instance.
     */
    connect(provider) {
      this._provider = provider;
      return this.provider;
    }
    /**
     * Retrieves resources satisfying the spend query for the account.
     *
     * @param quantities - IDs of coins to exclude.
     * @param excludedIds - IDs of resources to be excluded from the query.
     * @returns A promise that resolves to an array of Resources.
     */
    async getResourcesToSpend(quantities, excludedIds) {
      return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
    }
    /**
     * Retrieves coins owned by the account.
     *
     * @param assetId - The asset ID of the coins to retrieve.
     * @returns A promise that resolves to an array of Coins.
     */
    async getCoins(assetId) {
      const coins = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageCoins = await this.provider.getCoins(this.address, assetId, {
          first: pageSize,
          after: cursor
        });
        coins.push(...pageCoins);
        const hasNextPage = pageCoins.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
        );
      }
      return coins;
    }
    /**
     * Retrieves messages owned by the account.
     *
     * @returns A promise that resolves to an array of Messages.
     */
    async getMessages() {
      const messages = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageMessages = await this.provider.getMessages(this.address, {
          first: pageSize,
          after: cursor
        });
        messages.push(...pageMessages);
        const hasNextPage = pageMessages.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
        );
      }
      return messages;
    }
    /**
     * Retrieves the balance of the account for the given asset.
     *
     * @param assetId - The asset ID to check the balance for.
     * @returns A promise that resolves to the balance amount.
     */
    async getBalance(assetId = BaseAssetId) {
      const amount = await this.provider.getBalance(this.address, assetId);
      return amount;
    }
    /**
     * Retrieves all the balances for the account.
     *
     * @returns A promise that resolves to an array of Coins and their quantities.
     */
    async getBalances() {
      const balances = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageBalances = await this.provider.getBalances(this.address, {
          first: pageSize,
          after: cursor
        });
        balances.push(...pageBalances);
        const hasNextPage = pageBalances.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
        );
      }
      return balances;
    }
    /**
     * Adds resources to the transaction enough to fund it.
     *
     * @param request - The transaction request.
     * @param coinQuantities - The coin quantities required to execute the transaction.
     * @param fee - The estimated transaction fee.
     * @returns A promise that resolves when the resources are added to the transaction.
     */
    async fund(request, coinQuantities, fee) {
      const updatedQuantities = addAmountToAsset({
        amount: bn(fee),
        assetId: BaseAssetId,
        coinQuantities
      });
      const quantitiesDict = {};
      updatedQuantities.forEach(({ amount, assetId }) => {
        quantitiesDict[assetId] = {
          required: amount,
          owned: bn(0)
        };
      });
      const cachedUtxos = [];
      const cachedMessages = [];
      const owner = this.address.toB256();
      request.inputs.forEach((input) => {
        const isResource = "amount" in input;
        if (isResource) {
          const isCoin22 = "owner" in input;
          if (isCoin22) {
            const assetId = String(input.assetId);
            if (input.owner === owner && quantitiesDict[assetId]) {
              const amount = bn(input.amount);
              quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(amount);
              cachedUtxos.push(input.id);
            }
          } else if (input.recipient === owner && input.amount && quantitiesDict[BaseAssetId]) {
            quantitiesDict[BaseAssetId].owned = quantitiesDict[BaseAssetId].owned.add(input.amount);
            cachedMessages.push(input.nonce);
          }
        }
      });
      const missingQuantities = [];
      Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
        if (owned.lt(required)) {
          missingQuantities.push({
            assetId,
            amount: required.sub(owned)
          });
        }
      });
      const needsToBeFunded = missingQuantities.length;
      if (needsToBeFunded) {
        const resources = await this.getResourcesToSpend(missingQuantities, {
          messages: cachedMessages,
          utxos: cachedUtxos
        });
        request.addResources(resources);
      }
    }
    /**
     * A helper that creates a transfer transaction request and returns it.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
     * @returns A promise that resolves to the prepared transaction request.
     */
    async createTransfer(destination, amount, assetId = BaseAssetId, txParams = {}) {
      const { minGasPrice } = this.provider.getGasConfig();
      const params = { gasPrice: minGasPrice, ...txParams };
      const request = new ScriptTransactionRequest(params);
      request.addCoinOutput(Address.fromAddressOrString(destination), amount, assetId);
      const { maxFee, requiredQuantities, gasUsed, estimatedInputs } = await this.provider.getTransactionCost(request, [], {
        estimateTxDependencies: true,
        resourcesOwner: this
      });
      request.gasPrice = bn(txParams.gasPrice ?? minGasPrice);
      request.gasLimit = bn(txParams.gasLimit ?? gasUsed);
      this.validateGas({
        gasUsed,
        gasPrice: request.gasPrice,
        gasLimit: request.gasLimit,
        minGasPrice
      });
      await this.fund(request, requiredQuantities, maxFee);
      request.updatePredicateInputs(estimatedInputs);
      return request;
    }
    /**
     * Transfers coins to a destination address.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
     * @returns A promise that resolves to the transaction response.
     */
    async transfer(destination, amount, assetId = BaseAssetId, txParams = {}) {
      if (bn(amount).lte(0)) {
        throw new FuelError(
          ErrorCode.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      }
      const request = await this.createTransfer(destination, amount, assetId, txParams);
      return this.sendTransaction(request, { estimateTxDependencies: false });
    }
    /**
     * Transfers coins to a contract address.
     *
     * @param contractId - The address of the contract.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The optional transaction parameters.
     * @returns A promise that resolves to the transaction response.
     */
    async transferToContract(contractId, amount, assetId = BaseAssetId, txParams = {}) {
      if (bn(amount).lte(0)) {
        throw new FuelError(
          ErrorCode.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      }
      const contractAddress = Address.fromAddressOrString(contractId);
      const { minGasPrice } = this.provider.getGasConfig();
      const params = { gasPrice: minGasPrice, ...txParams };
      const { script, scriptData } = await assembleTransferToContractScript({
        hexlifiedContractId: contractAddress.toB256(),
        amountToTransfer: bn(amount),
        assetId
      });
      const request = new ScriptTransactionRequest({
        ...params,
        script,
        scriptData
      });
      request.addContractInputAndOutput(contractAddress);
      const { maxFee, requiredQuantities, gasUsed } = await this.provider.getTransactionCost(
        request,
        [{ amount: bn(amount), assetId: String(assetId) }]
      );
      request.gasLimit = bn(params.gasLimit ?? gasUsed);
      this.validateGas({
        gasUsed,
        gasPrice: request.gasPrice,
        gasLimit: request.gasLimit,
        minGasPrice
      });
      await this.fund(request, requiredQuantities, maxFee);
      return this.sendTransaction(request);
    }
    /**
     * Withdraws an amount of the base asset to the base chain.
     *
     * @param recipient - Address of the recipient on the base chain.
     * @param amount - Amount of base asset.
     * @param txParams - The optional transaction parameters.
     * @returns A promise that resolves to the transaction response.
     */
    async withdrawToBaseLayer(recipient, amount, txParams = {}) {
      const { minGasPrice } = this.provider.getGasConfig();
      const recipientAddress = Address.fromAddressOrString(recipient);
      const recipientDataArray = arrayify(
        "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
      );
      const amountDataArray = arrayify(
        "0x".concat(bn(amount).toHex().substring(2).padStart(16, "0"))
      );
      const script = new Uint8Array([
        ...arrayify(withdrawScript.bytes),
        ...recipientDataArray,
        ...amountDataArray
      ]);
      const params = { script, gasPrice: minGasPrice, ...txParams };
      const request = new ScriptTransactionRequest(params);
      const forwardingQuantities = [{ amount: bn(amount), assetId: BaseAssetId }];
      const { requiredQuantities, maxFee, gasUsed } = await this.provider.getTransactionCost(
        request,
        forwardingQuantities
      );
      request.gasLimit = bn(params.gasLimit ?? gasUsed);
      this.validateGas({
        gasUsed,
        gasPrice: request.gasPrice,
        gasLimit: request.gasLimit,
        minGasPrice
      });
      await this.fund(request, requiredQuantities, maxFee);
      return this.sendTransaction(request);
    }
    async signMessage(message) {
      if (!this._connector) {
        throw new FuelError(ErrorCode.MISSING_CONNECTOR, "A connector is required to sign messages.");
      }
      return this._connector.signMessage(this.address.toString(), message);
    }
    /**
     * Signs a transaction with the wallet's private key.
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature of the transaction.
     */
    async signTransaction(transactionRequestLike) {
      if (!this._connector) {
        throw new FuelError(
          ErrorCode.MISSING_CONNECTOR,
          "A connector is required to sign transactions."
        );
      }
      return this._connector.signTransaction(this.address.toString(), transactionRequestLike);
    }
    /**
     * Sends a transaction to the network.
     *
     * @param transactionRequestLike - The transaction request to be sent.
     * @returns A promise that resolves to the transaction response.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution } = {}) {
      if (this._connector) {
        return this.provider.getTransactionResponse(
          await this._connector.sendTransaction(this.address.toString(), transactionRequestLike)
        );
      }
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.sendTransaction(transactionRequest, {
        awaitExecution,
        estimateTxDependencies: false
      });
    }
    /**
     * Simulates a transaction.
     *
     * @param transactionRequestLike - The transaction request to be simulated.
     * @returns A promise that resolves to the call result.
     */
    async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
    }
    validateGas({
      gasUsed,
      gasPrice,
      gasLimit,
      minGasPrice
    }) {
      if (minGasPrice.gt(gasPrice)) {
        throw new FuelError(
          ErrorCode.GAS_PRICE_TOO_LOW,
          `Gas price '${gasPrice}' is lower than the required: '${minGasPrice}'.`
        );
      }
      if (gasUsed.gt(gasLimit)) {
        throw new FuelError(
          ErrorCode.GAS_LIMIT_TOO_LOW,
          `Gas limit '${gasLimit}' is lower than the required: '${gasUsed}'.`
        );
      }
    }
  };
  var Signer = class {
    address;
    publicKey;
    compressedPublicKey;
    privateKey;
    /**
     * Create a Signer instance from a given private key
     *
     * @param privateKey - The private key to use for signing
     * @returns A new Signer instance
     */
    constructor(privateKey) {
      if (typeof privateKey === "string") {
        if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
          privateKey = `0x${privateKey}`;
        }
      }
      const privateKeyBytes = toBytes3(privateKey, 32);
      this.privateKey = hexlify(privateKeyBytes);
      this.publicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
      this.compressedPublicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, true));
      this.address = Address.fromPublicKey(this.publicKey);
    }
    /**
     * Sign data using the Signer instance
     *
     * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
     * @ignore
     * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
     *
     * @param data - The data to be sign
     * @returns hashed signature
     */
    sign(data) {
      const signature = secp256k1.sign(arrayify(data), arrayify(this.privateKey));
      const r = toBytes3(`0x${signature.r.toString(16)}`, 32);
      const s = toBytes3(`0x${signature.s.toString(16)}`, 32);
      s[0] |= (signature.recovery || 0) << 7;
      return hexlify(concat([r, s]));
    }
    /**
     * Add point on the current elliptic curve
     *
     * @param point - Point to add on the curve
     * @returns compressed point on the curve
     */
    addPoint(point) {
      const p0 = secp256k1.ProjectivePoint.fromHex(arrayify(this.compressedPublicKey));
      const p1 = secp256k1.ProjectivePoint.fromHex(arrayify(point));
      const result = p0.add(p1);
      return `0x${result.toHex(true)}`;
    }
    /**
     * Recover the public key from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - hashed signature
     * @returns public key from signature from the
     */
    static recoverPublicKey(data, signature) {
      const signedMessageBytes = arrayify(signature);
      const r = signedMessageBytes.slice(0, 32);
      const s = signedMessageBytes.slice(32, 64);
      const recoveryParam = (s[0] & 128) >> 7;
      s[0] &= 127;
      const sig = new secp256k1.Signature(BigInt(hexlify(r)), BigInt(hexlify(s))).addRecoveryBit(
        recoveryParam
      );
      const publicKey = sig.recoverPublicKey(arrayify(data)).toRawBytes(false).slice(1);
      return hexlify(publicKey);
    }
    /**
     * Recover the address from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - Signature
     * @returns Address from signature
     */
    static recoverAddress(data, signature) {
      return Address.fromPublicKey(Signer.recoverPublicKey(data, signature));
    }
    /**
     * Generate a random privateKey
     *
     * @param entropy - Adds extra entropy to generate the privateKey
     * @returns random 32-byte hashed
     */
    static generatePrivateKey(entropy) {
      return entropy ? hash3(concat([randomBytes22(32), arrayify(entropy)])) : randomBytes22(32);
    }
    /**
     * Extended publicKey from a compact publicKey
     *
     * @param publicKey - Compact publicKey
     * @returns extended publicKey
     */
    static extendPublicKey(publicKey) {
      const point = secp256k1.ProjectivePoint.fromHex(arrayify(publicKey));
      return hexlify(point.toRawBytes(false).slice(1));
    }
  };
  var DEFAULT_KDF_PARAMS_LOG_N = 13;
  var DEFAULT_KDF_PARAMS_R = 8;
  var DEFAULT_KDF_PARAMS_P = 1;
  var DEFAULT_KEY_SIZE = 32;
  var DEFAULT_IV_SIZE = 16;
  var removeHexPrefix = (hexString) => {
    if (/^0x/.test(hexString)) {
      return hexString.slice(2);
    }
    return hexString;
  };
  async function encryptKeystoreWallet(privateKey, address, password) {
    const privateKeyBuffer = bufferFromString2(removeHexPrefix(privateKey), "hex");
    const ownerAddress = Address.fromAddressOrString(address);
    const salt = randomBytes22(DEFAULT_KEY_SIZE);
    const key = scrypt22({
      password: bufferFromString2(password),
      salt,
      dklen: DEFAULT_KEY_SIZE,
      n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
      r: DEFAULT_KDF_PARAMS_R,
      p: DEFAULT_KDF_PARAMS_P
    });
    const iv = randomBytes22(DEFAULT_IV_SIZE);
    const ciphertext = await encryptJsonWalletData2(privateKeyBuffer, key, iv);
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
    const macHashUint8Array = keccak25622(data);
    const mac = stringFromBuffer2(macHashUint8Array, "hex");
    const keystore = {
      id: v4_default(),
      version: 3,
      address: removeHexPrefix(ownerAddress.toHexString()),
      crypto: {
        cipher: "aes-128-ctr",
        mac,
        cipherparams: { iv: stringFromBuffer2(iv, "hex") },
        ciphertext: stringFromBuffer2(ciphertext, "hex"),
        kdf: "scrypt",
        kdfparams: {
          dklen: DEFAULT_KEY_SIZE,
          n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
          p: DEFAULT_KDF_PARAMS_P,
          r: DEFAULT_KDF_PARAMS_R,
          salt: stringFromBuffer2(salt, "hex")
        }
      }
    };
    return JSON.stringify(keystore);
  }
  async function decryptKeystoreWallet(jsonWallet, password) {
    const keystoreWallet = JSON.parse(jsonWallet);
    const {
      crypto: {
        mac,
        ciphertext,
        cipherparams: { iv },
        kdfparams: { dklen, n, r, p, salt }
      }
    } = keystoreWallet;
    const ciphertextBuffer = bufferFromString2(ciphertext, "hex");
    const ivBuffer = bufferFromString2(iv, "hex");
    const saltBuffer = bufferFromString2(salt, "hex");
    const passwordBuffer = bufferFromString2(password);
    const key = scrypt22({
      password: passwordBuffer,
      salt: saltBuffer,
      n,
      p,
      r,
      dklen
    });
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
    const macHashUint8Array = keccak25622(data);
    const macHash = stringFromBuffer2(macHashUint8Array, "hex");
    if (mac !== macHash) {
      throw new FuelError(
        ErrorCode.INVALID_PASSWORD,
        "Failed to decrypt the keystore wallet, the provided password is incorrect."
      );
    }
    const buffer = await decryptJsonWalletData2(ciphertextBuffer, key, ivBuffer);
    const privateKey = hexlify(buffer);
    return privateKey;
  }
  var BaseWalletUnlocked = class extends Account {
    /**
     * A function that returns the wallet's signer.
     */
    signer;
    /**
     * Creates a new BaseWalletUnlocked instance.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance (optional).
     */
    constructor(privateKey, provider) {
      const signer = new Signer(privateKey);
      super(signer.address, provider);
      this.signer = () => signer;
    }
    /**
     * Gets the private key of the wallet.
     *
     * @returns The private key of the wallet.
     */
    get privateKey() {
      return this.signer().privateKey;
    }
    /**
     * Gets the public key of the wallet.
     *
     * @returns
     */
    get publicKey() {
      return this.signer().publicKey;
    }
    /**
     * Signs a message with the wallet's private key.
     *
     * @param message - The message to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signMessage(message) {
      const signedMessage = await this.signer().sign(hashMessage(message));
      return hexlify(signedMessage);
    }
    /**
     * Signs a transaction with the wallet's private key.
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      const chainId = this.provider.getChainId();
      const hashedTransaction = transactionRequest.getTransactionId(chainId);
      const signature = await this.signer().sign(hashedTransaction);
      return hexlify(signature);
    }
    /**
     * Populates a transaction with the witnesses signature.
     *
     * @param transactionRequestLike - The transaction request to populate.
     * @returns The populated transaction request.
     */
    async populateTransactionWitnessesSignature(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      const signedTransaction = await this.signTransaction(transactionRequest);
      transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
      return transactionRequest;
    }
    /**
     * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequestLike - The transaction request to send.
     * @returns A promise that resolves to the TransactionResponse object.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.sendTransaction(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        { awaitExecution, estimateTxDependencies: false }
      );
    }
    /**
     * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
     *
     * @param transactionRequestLike - The transaction request to simulate.
     * @returns A promise that resolves to the CallResult object.
     */
    async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.call(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        {
          utxoValidation: true,
          estimateTxDependencies: false
        }
      );
    }
    async encrypt(password) {
      return encryptKeystoreWallet(this.privateKey, this.address, password);
    }
  };
  __publicField6(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");
  var english = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  function toUtf8Bytes2(stri) {
    const str = stri.normalize("NFKD");
    const result = [];
    for (let i = 0; i < str.length; i += 1) {
      const c = str.charCodeAt(i);
      if (c < 128) {
        result.push(c);
      } else if (c < 2048) {
        result.push(c >> 6 | 192);
        result.push(c & 63 | 128);
      } else if ((c & 64512) === 55296) {
        i += 1;
        const c2 = str.charCodeAt(i);
        if (i >= str.length || (c2 & 64512) !== 56320) {
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            "Invalid UTF-8 in the input string."
          );
        }
        const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c >> 12 | 224);
        result.push(c >> 6 & 63 | 128);
        result.push(c & 63 | 128);
      }
    }
    return Uint8Array.from(result);
  }
  function getLowerMask(bits) {
    return (1 << bits) - 1;
  }
  function getUpperMask(bits) {
    return (1 << bits) - 1 << 8 - bits;
  }
  function getWords(mnemonic) {
    if (!Array.isArray(mnemonic)) {
      return mnemonic.split(/\s+/);
    }
    return mnemonic;
  }
  function getPhrase(mnemonic) {
    if (Array.isArray(mnemonic)) {
      return mnemonic.join(" ");
    }
    return mnemonic;
  }
  function entropyToMnemonicIndices(entropy) {
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i += 1) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        indices.push(entropy[i] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
      }
    }
    const checksumBits = entropy.length / 4;
    const checksum = arrayify(sha2563(entropy))[0] & getUpperMask(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return indices;
  }
  function mnemonicWordsToEntropy(words, wordlist) {
    const size = Math.ceil(11 * words.length / 8);
    const entropy = arrayify(new Uint8Array(size));
    let offset = 0;
    for (let i = 0; i < words.length; i += 1) {
      const index = wordlist.indexOf(words[i].normalize("NFKD"));
      if (index === -1) {
        throw new FuelError(
          ErrorCode.INVALID_MNEMONIC,
          `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
        );
      }
      for (let bit = 0; bit < 11; bit += 1) {
        if (index & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset += 1;
      }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = arrayify(sha2563(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
      throw new FuelError(
        ErrorCode.INVALID_CHECKSUM,
        "Checksum validation failed for the provided mnemonic."
      );
    }
    return entropy.slice(0, entropyBits / 8);
  }
  var MasterSecret = toUtf8Bytes2("Bitcoin seed");
  var MainnetPRV = "0x0488ade4";
  var TestnetPRV = "0x04358394";
  var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
  function assertWordList(wordlist) {
    if (wordlist.length !== 2048) {
      throw new FuelError(
        ErrorCode.INVALID_WORD_LIST,
        `Expected word list length of 2048, but got ${wordlist.length}.`
      );
    }
  }
  function assertEntropy(entropy) {
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
      throw new FuelError(
        ErrorCode.INVALID_ENTROPY,
        `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
      );
    }
  }
  function assertMnemonic(words) {
    if (!MNEMONIC_SIZES.includes(words.length)) {
      const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
        ", "
      )}] words, but got ${words.length}.`;
      throw new FuelError(ErrorCode.INVALID_MNEMONIC, errorMsg);
    }
  }
  var Mnemonic = class {
    wordlist;
    /**
     *
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic instance
     */
    constructor(wordlist = english) {
      this.wordlist = wordlist;
      assertWordList(this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns Entropy hash
     */
    mnemonicToEntropy(phrase) {
      return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
    }
    /**
     *
     * @param entropy - Entropy source to the mnemonic phrase.
     * @returns Mnemonic phrase
     */
    entropyToMnemonic(entropy) {
      return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic phrase
     */
    static mnemonicToEntropy(phrase, wordlist = english) {
      const words = getWords(phrase);
      assertMnemonic(words);
      return hexlify(mnemonicWordsToEntropy(words, wordlist));
    }
    /**
     * @param entropy - Entropy source to the mnemonic phrase.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static entropyToMnemonic(entropy, wordlist = english) {
      const entropyBytes = arrayify(entropy);
      assertWordList(wordlist);
      assertEntropy(entropyBytes);
      return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToSeed(phrase, passphrase = "") {
      assertMnemonic(getWords(phrase));
      const phraseBytes = toUtf8Bytes2(getPhrase(phrase));
      const salt = toUtf8Bytes2(`mnemonic${passphrase}`);
      return pbkdf22(phraseBytes, salt, 2048, 64, "sha512");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToMasterKeys(phrase, passphrase = "") {
      const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);
      return Mnemonic.masterKeysFromSeed(seed);
    }
    /**
     * Validates if given mnemonic is  valid
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns true if phrase is a valid mnemonic
     */
    static isMnemonicValid(phrase) {
      const words = getWords(phrase);
      let i = 0;
      try {
        assertMnemonic(words);
      } catch {
        return false;
      }
      while (i < words.length) {
        if (Mnemonic.binarySearch(words[i]) === false) {
          return false;
        }
        i += 1;
      }
      return true;
    }
    static binarySearch(target) {
      const words = english;
      let left = 0;
      let right = words.length - 1;
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (words[mid] === target) {
          return true;
        }
        if (target < words[mid]) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
      return false;
    }
    /**
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static masterKeysFromSeed(seed) {
      const seedArray = arrayify(seed);
      if (seedArray.length < 16 || seedArray.length > 64) {
        throw new FuelError(
          ErrorCode.INVALID_SEED,
          `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
        );
      }
      return arrayify(computeHmac("sha512", MasterSecret, seedArray));
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    static seedToExtendedKey(seed, testnet = false) {
      const masterKey = Mnemonic.masterKeysFromSeed(seed);
      const prefix = arrayify(testnet ? TestnetPRV : MainnetPRV);
      const depth = "0x00";
      const fingerprint = "0x00000000";
      const index = "0x00000000";
      const chainCode = masterKey.slice(32);
      const privateKey = masterKey.slice(0, 32);
      const extendedKey = concat([
        prefix,
        depth,
        fingerprint,
        index,
        chainCode,
        concat(["0x00", privateKey])
      ]);
      const checksum = dataSlice(sha2563(sha2563(extendedKey)), 0, 4);
      return encodeBase58(concat([extendedKey, checksum]));
    }
    /**
     *  Create a new mnemonic using a randomly generated number as entropy.
     *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
     *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
     *  If not provided, the default entropy length will be set to 256 bits.
     *  The return is a list of words that encodes the generated entropy.
     *
     *
     * @param size - Number of bytes used as an entropy
     * @param extraEntropy - Optional extra entropy to increase randomness
     * @returns A randomly generated mnemonic
     */
    static generate(size = 32, extraEntropy = "") {
      const entropy = extraEntropy ? sha2563(concat([randomBytes22(size), arrayify(extraEntropy)])) : randomBytes22(size);
      return Mnemonic.entropyToMnemonic(entropy);
    }
  };
  var mnemonic_default = Mnemonic;
  var HARDENED_INDEX = 2147483648;
  var MainnetPRV2 = hexlify("0x0488ade4");
  var MainnetPUB = hexlify("0x0488b21e");
  var TestnetPRV2 = hexlify("0x04358394");
  var TestnetPUB = hexlify("0x043587cf");
  function base58check(data) {
    return encodeBase58(concat([data, dataSlice(sha2563(sha2563(data)), 0, 4)]));
  }
  function getExtendedKeyPrefix(isPublic = false, testnet = false) {
    if (isPublic) {
      return testnet ? TestnetPUB : MainnetPUB;
    }
    return testnet ? TestnetPRV2 : MainnetPRV2;
  }
  function isPublicExtendedKey(extendedKey) {
    return [MainnetPUB, TestnetPUB].includes(hexlify(extendedKey.slice(0, 4)));
  }
  function isValidExtendedKey(extendedKey) {
    return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
      hexlify(extendedKey.slice(0, 4))
    );
  }
  function parsePath(path5, depth = 0) {
    const components = path5.split("/");
    if (components.length === 0 || components[0] === "m" && depth !== 0) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, `invalid path - ${path5}`);
    }
    if (components[0] === "m") {
      components.shift();
    }
    return components.map(
      (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
    );
  }
  var HDWallet = class {
    depth = 0;
    index = 0;
    fingerprint = hexlify("0x00000000");
    parentFingerprint = hexlify("0x00000000");
    privateKey;
    publicKey;
    chainCode;
    /**
     * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
     *
     * @param config - Wallet configurations
     */
    constructor(config) {
      if (config.privateKey) {
        const signer = new Signer(config.privateKey);
        this.publicKey = hexlify(signer.compressedPublicKey);
        this.privateKey = hexlify(config.privateKey);
      } else {
        if (!config.publicKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Both public and private Key cannot be missing. At least one should be provided."
          );
        }
        this.publicKey = hexlify(config.publicKey);
      }
      this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
      this.fingerprint = dataSlice(ripemd1602(sha2563(this.publicKey)), 0, 4);
      this.depth = config.depth || this.depth;
      this.index = config.index || this.index;
      this.chainCode = config.chainCode;
    }
    get extendedKey() {
      return this.toExtendedKey();
    }
    /**
     * Derive the current HDWallet instance navigating only on the index.
     * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param index - Index of the child HDWallet.
     * @returns A new instance of HDWallet on the derived index
     */
    deriveIndex(index) {
      const privateKey = this.privateKey && arrayify(this.privateKey);
      const publicKey = arrayify(this.publicKey);
      const chainCode = arrayify(this.chainCode);
      const data = new Uint8Array(37);
      if (index & HARDENED_INDEX) {
        if (!privateKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Cannot derive a hardened index without a private Key."
          );
        }
        data.set(privateKey, 1);
      } else {
        data.set(arrayify(this.publicKey));
      }
      data.set(toBytes3(index, 4), 33);
      const bytes3 = arrayify(computeHmac("sha512", chainCode, data));
      const IL = bytes3.slice(0, 32);
      const IR = bytes3.slice(32);
      if (privateKey) {
        const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
        const ki = bn(IL).add(privateKey).mod(N).toBytes(32);
        return new HDWallet({
          privateKey: ki,
          chainCode: IR,
          index,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint
        });
      }
      const signer = new Signer(hexlify(IL));
      const Ki = signer.addPoint(publicKey);
      return new HDWallet({
        publicKey: Ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    /**
     * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
     * @returns A new instance of HDWallet on the derived path
     */
    derivePath(path5) {
      const paths = parsePath(path5, this.depth);
      return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    toExtendedKey(isPublic = false, testnet = false) {
      if (this.depth >= 256) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          `Exceeded max depth of 255. Current depth: ${this.depth}.`
        );
      }
      const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
      const depth = hexlify(Uint8Array.from([this.depth]));
      const parentFingerprint = this.parentFingerprint;
      const index = toHex(this.index, 4);
      const chainCode = this.chainCode;
      const key = this.privateKey != null && !isPublic ? concat(["0x00", this.privateKey]) : this.publicKey;
      const extendedKey = arrayify(concat([prefix, depth, parentFingerprint, index, chainCode, key]));
      return base58check(extendedKey);
    }
    /**
     * Create HDWallet instance from seed
     *
     * @param seed - Seed
     * @returns A new instance of HDWallet
     */
    static fromSeed(seed) {
      const masterKey = mnemonic_default.masterKeysFromSeed(seed);
      return new HDWallet({
        chainCode: arrayify(masterKey.slice(32)),
        privateKey: arrayify(masterKey.slice(0, 32))
      });
    }
    static fromExtendedKey(extendedKey) {
      const decoded = toBeHex(decodeBase58(extendedKey));
      const bytes3 = arrayify(decoded);
      const validChecksum = base58check(bytes3.slice(0, 78)) === extendedKey;
      if (bytes3.length !== 82 || !isValidExtendedKey(bytes3)) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
      }
      if (!validChecksum) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
      }
      const depth = bytes3[4];
      const parentFingerprint = hexlify(bytes3.slice(5, 9));
      const index = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
      const chainCode = hexlify(bytes3.slice(13, 45));
      const key = bytes3.slice(45, 78);
      if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
        );
      }
      if (isPublicExtendedKey(bytes3)) {
        if (key[0] !== 3) {
          throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
        }
        return new HDWallet({
          publicKey: key,
          chainCode,
          index,
          depth,
          parentFingerprint
        });
      }
      if (key[0] !== 0) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
      }
      return new HDWallet({
        privateKey: key.slice(1),
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
  };
  var hdwallet_default = HDWallet;
  var WalletLocked = class extends Account {
    /**
     * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
     *
     * @param privateKey - The private key used to unlock the wallet.
     * @returns An instance of WalletUnlocked.
     */
    unlock(privateKey) {
      return new WalletUnlocked(privateKey, this._provider);
    }
  };
  var WalletUnlocked = class extends BaseWalletUnlocked {
    /**
     * Locks the wallet and returns an instance of WalletLocked.
     *
     * @returns An instance of WalletLocked.
     */
    lock() {
      this.signer = () => new Signer("0x00");
      return new WalletLocked(this.address, this._provider);
    }
    /**
     * Generate a new Wallet Unlocked with a random key pair.
     *
     * @param generateOptions - Options to customize the generation process (optional).
     * @returns An instance of WalletUnlocked.
     */
    static generate(generateOptions) {
      const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);
      return new WalletUnlocked(privateKey, generateOptions?.provider);
    }
    /**
     * Create a Wallet Unlocked from a seed.
     *
     * @param seed - The seed phrase.
     * @param provider - A Provider instance (optional).
     * @param path - The derivation path (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromSeed(seed, path5, provider) {
      const hdWallet = hdwallet_default.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path5 || WalletUnlocked.defaultPath);
      return new WalletUnlocked(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from a mnemonic phrase.
     *
     * @param mnemonic - The mnemonic phrase.
     * @param provider - A Provider instance (optional).
     * @param path - The derivation path (optional).
     * @param passphrase - The passphrase for the mnemonic (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromMnemonic(mnemonic, path5, passphrase, provider) {
      const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
      const hdWallet = hdwallet_default.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path5 || WalletUnlocked.defaultPath);
      return new WalletUnlocked(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an extended key.
     *
     * @param extendedKey - The extended key.
     * @param provider - A Provider instance (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromExtendedKey(extendedKey, provider) {
      const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
      return new WalletUnlocked(hdWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an encrypted JSON.
     *
     * @param jsonWallet - The encrypted JSON keystore.
     * @param password - The password to decrypt the JSON.
     * @param provider - A Provider instance (optional).
     * @returns An unlocked wallet instance.
     */
    static async fromEncryptedJson(jsonWallet, password, provider) {
      const privateKey = await decryptKeystoreWallet(jsonWallet, password);
      return new WalletUnlocked(privateKey, provider);
    }
  };
  var Wallet = class {
    /**
     * Creates a locked wallet instance from an address and a provider.
     *
     * @param address - The address of the wallet.
     * @param provider - A Provider instance (optional).
     * @returns A locked wallet instance.
     */
    static fromAddress(address, provider) {
      return new WalletLocked(address, provider);
    }
    /**
     * Creates an unlocked wallet instance from a private key and a provider.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance (optional).
     * @returns An unlocked wallet instance.
     */
    static fromPrivateKey(privateKey, provider) {
      return new WalletUnlocked(privateKey, provider);
    }
  };
  __publicField6(Wallet, "generate", WalletUnlocked.generate);
  __publicField6(Wallet, "fromSeed", WalletUnlocked.fromSeed);
  __publicField6(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
  __publicField6(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
  __publicField6(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);
  var MemoryStorage = class {
    storage = /* @__PURE__ */ new Map();
    async getItem(key) {
      const item = await this.storage.get(key);
      return item;
    }
    async setItem(key, value) {
      await this.storage.set(key, value);
    }
    async removeItem(key) {
      await this.storage.delete(key);
    }
    async clear() {
      await this.storage.clear();
    }
  };
  var _secret;
  var MnemonicVault = class {
    constructor(options) {
      __privateAdd3(this, _secret, void 0);
      __publicField6(this, "pathKey", "{}");
      __publicField6(this, "rootPath", `m/44'/1179993420'/${this.pathKey}'/0/0`);
      __publicField6(this, "numberOfAccounts", 0);
      __privateSet2(this, _secret, options.secret || mnemonic_default.generate());
      this.rootPath = options.rootPath || this.rootPath;
      this.numberOfAccounts = options.numberOfAccounts || 1;
    }
    getDerivePath(index) {
      if (this.rootPath.includes(this.pathKey)) {
        return this.rootPath.replace(this.pathKey, String(index));
      }
      return `${this.rootPath}/${index}`;
    }
    serialize() {
      return {
        secret: __privateGet2(this, _secret),
        rootPath: this.rootPath,
        numberOfAccounts: this.numberOfAccounts
      };
    }
    getAccounts() {
      const accounts = [];
      let numberOfAccounts = 0;
      do {
        const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(numberOfAccounts));
        accounts.push({
          publicKey: wallet.publicKey,
          address: wallet.address
        });
        numberOfAccounts += 1;
      } while (numberOfAccounts < this.numberOfAccounts);
      return accounts;
    }
    addAccount() {
      this.numberOfAccounts += 1;
      const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(this.numberOfAccounts - 1));
      return {
        publicKey: wallet.publicKey,
        address: wallet.address
      };
    }
    exportAccount(address) {
      let numberOfAccounts = 0;
      const ownerAddress = Address.fromAddressOrString(address);
      do {
        const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(numberOfAccounts));
        if (wallet.address.equals(ownerAddress)) {
          return wallet.privateKey;
        }
        numberOfAccounts += 1;
      } while (numberOfAccounts < this.numberOfAccounts);
      throw new FuelError(
        ErrorCode.WALLET_MANAGER_ERROR,
        `Account with address '${address}' not found in derived wallets.`
      );
    }
    getWallet(address) {
      const privateKey = this.exportAccount(address);
      return Wallet.fromPrivateKey(privateKey);
    }
  };
  _secret = /* @__PURE__ */ new WeakMap();
  __publicField6(MnemonicVault, "type", "mnemonic");
  var _privateKeys;
  var PrivateKeyVault = class {
    /**
     * If privateKey vault is initialized with a secretKey, it creates
     * one account with the fallowing secret
     */
    constructor(options = {}) {
      __privateAdd3(this, _privateKeys, []);
      if (options.secret) {
        __privateSet2(this, _privateKeys, [options.secret]);
      } else {
        __privateSet2(this, _privateKeys, options.accounts || [Wallet.generate().privateKey]);
      }
    }
    serialize() {
      return {
        accounts: __privateGet2(this, _privateKeys)
      };
    }
    getPublicAccount(privateKey) {
      const wallet = Wallet.fromPrivateKey(privateKey);
      return {
        address: wallet.address,
        publicKey: wallet.publicKey
      };
    }
    getAccounts() {
      return __privateGet2(this, _privateKeys).map((pk) => this.getPublicAccount(pk));
    }
    addAccount() {
      const wallet = Wallet.generate();
      __privateGet2(this, _privateKeys).push(wallet.privateKey);
      return this.getPublicAccount(wallet.privateKey);
    }
    exportAccount(address) {
      const ownerAddress = Address.fromAddressOrString(address);
      const privateKey = __privateGet2(this, _privateKeys).find(
        (pk) => Wallet.fromPrivateKey(pk).address.equals(ownerAddress)
      );
      if (!privateKey) {
        throw new FuelError(
          ErrorCode.WALLET_MANAGER_ERROR,
          `No private key found for address '${address}'.`
        );
      }
      return privateKey;
    }
    getWallet(address) {
      const privateKey = this.exportAccount(address);
      return Wallet.fromPrivateKey(privateKey);
    }
  };
  _privateKeys = /* @__PURE__ */ new WeakMap();
  __publicField6(PrivateKeyVault, "type", "privateKey");
  var ERROR_MESSAGES = {
    invalid_vault_type: "The provided Vault type is invalid.",
    address_not_found: "No private key found for address the specified wallet address.",
    vault_not_found: "The specified vault was not found.",
    wallet_not_unlocked: "The wallet is currently locked.",
    passphrase_not_match: "The provided passphrase did not match the expected value."
  };
  function assert3(condition, message) {
    if (!condition) {
      throw new FuelError(ErrorCode.WALLET_MANAGER_ERROR, message);
    }
  }
  var _vaults;
  var _passphrase;
  var _isLocked;
  var _serializeVaults;
  var serializeVaults_fn;
  var _deserializeVaults;
  var deserializeVaults_fn;
  var _WalletManager = class extends import_events2.EventEmitter {
    constructor(options) {
      super();
      __privateAdd3(this, _serializeVaults);
      __privateAdd3(this, _deserializeVaults);
      __publicField6(this, "storage", new MemoryStorage());
      __publicField6(this, "STORAGE_KEY", "WalletManager");
      __privateAdd3(this, _vaults, []);
      __privateAdd3(this, _passphrase, "");
      __privateAdd3(this, _isLocked, true);
      this.storage = options?.storage || this.storage;
    }
    get isLocked() {
      return __privateGet2(this, _isLocked);
    }
    /**
     * Return the vault serialized object containing all the privateKeys,
     * the format of the return depends on the Vault type.
     */
    exportVault(vaultId) {
      assert3(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
      const vaultState = __privateGet2(this, _vaults).find((_, idx) => idx === vaultId);
      assert3(vaultState, ERROR_MESSAGES.vault_not_found);
      return vaultState.vault.serialize();
    }
    /**
     * List all vaults on the Wallet Manager, this function not return secret's
     */
    getVaults() {
      return __privateGet2(this, _vaults).map((v, idx) => ({
        title: v.title,
        type: v.type,
        vaultId: idx
      }));
    }
    /**
     * List all accounts on the Wallet Manager not vault information is revealed
     */
    getAccounts() {
      return __privateGet2(this, _vaults).flatMap(
        (vaultState, vaultId) => vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))
      );
    }
    /**
     * Create a Wallet instance for the specific account
     */
    getWallet(address) {
      const ownerAddress = Address.fromAddressOrString(address);
      const vaultState = __privateGet2(this, _vaults).find(
        (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))
      );
      assert3(vaultState, ERROR_MESSAGES.address_not_found);
      return vaultState.vault.getWallet(ownerAddress);
    }
    /**
     * Export specific account privateKey
     */
    exportPrivateKey(address) {
      const ownerAddress = Address.fromAddressOrString(address);
      assert3(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
      const vaultState = __privateGet2(this, _vaults).find(
        (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))
      );
      assert3(vaultState, ERROR_MESSAGES.address_not_found);
      return vaultState.vault.exportAccount(ownerAddress);
    }
    /**
     * Add account to a selected vault or on the first vault as default.
     * If not vaults are adds it will return error
     */
    async addAccount(options) {
      await this.loadState();
      const vaultState = __privateGet2(this, _vaults)[options?.vaultId || 0];
      await assert3(vaultState, ERROR_MESSAGES.vault_not_found);
      const account = vaultState.vault.addAccount();
      await this.saveState();
      return account;
    }
    /**
     * Remove vault by index, by remove the vault you also remove all accounts
     * created by the vault.
     */
    async removeVault(index) {
      __privateGet2(this, _vaults).splice(index, 1);
      await this.saveState();
    }
    /**
     * Add Vault, the `vaultConfig.type` will look for the Vaults supported if
     * didn't found it will throw.
     */
    async addVault(vaultConfig) {
      await this.loadState();
      const Vault2 = this.getVaultClass(vaultConfig.type);
      const vault = new Vault2(vaultConfig);
      __privateSet2(this, _vaults, __privateGet2(this, _vaults).concat({
        title: vaultConfig.title,
        type: vaultConfig.type,
        vault
      }));
      await this.saveState();
    }
    /**
     * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and
     * secrets.
     */
    lock() {
      __privateSet2(this, _isLocked, true);
      __privateSet2(this, _vaults, []);
      __privateSet2(this, _passphrase, "");
      this.emit("lock");
    }
    /**
     * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.
     * Vaults with secrets are not unlocked or instantiated on this moment.
     */
    async unlock(passphrase) {
      __privateSet2(this, _passphrase, passphrase);
      __privateSet2(this, _isLocked, false);
      try {
        await this.loadState();
        this.emit("unlock");
      } catch (err) {
        await this.lock();
        throw err;
      }
    }
    /**
     * Update WalletManager encryption passphrase
     */
    async updatePassphrase(oldpass, newpass) {
      const isLocked = __privateGet2(this, _isLocked);
      await this.unlock(oldpass);
      __privateSet2(this, _passphrase, newpass);
      await this.saveState();
      await this.loadState();
      if (isLocked) {
        await this.lock();
      }
    }
    /**
     * Retrieve and decrypt WalletManager state from storage
     */
    async loadState() {
      await assert3(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
      const data = await this.storage.getItem(this.STORAGE_KEY);
      if (data) {
        const state = await decrypt2(__privateGet2(this, _passphrase), JSON.parse(data));
        __privateSet2(this, _vaults, __privateMethod3(this, _deserializeVaults, deserializeVaults_fn).call(this, state.vaults));
      }
    }
    /**
     * Store encrypted WalletManager state on storage
     */
    async saveState() {
      await assert3(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
      const encryptedData = await encrypt2(__privateGet2(this, _passphrase), {
        vaults: __privateMethod3(this, _serializeVaults, serializeVaults_fn).call(this, __privateGet2(this, _vaults))
      });
      await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));
      this.emit("update");
    }
    /**
     * Return a instantiable Class reference from `WalletManager.Vaults` supported list.
     */
    getVaultClass(type3) {
      const VaultClass = _WalletManager.Vaults.find((v) => v.type === type3);
      assert3(VaultClass, ERROR_MESSAGES.invalid_vault_type);
      return VaultClass;
    }
  };
  var WalletManager = _WalletManager;
  _vaults = /* @__PURE__ */ new WeakMap();
  _passphrase = /* @__PURE__ */ new WeakMap();
  _isLocked = /* @__PURE__ */ new WeakMap();
  _serializeVaults = /* @__PURE__ */ new WeakSet();
  serializeVaults_fn = function(vaults) {
    return vaults.map(({ title, type: type3, vault }) => ({
      title,
      type: type3,
      data: vault.serialize()
    }));
  };
  _deserializeVaults = /* @__PURE__ */ new WeakSet();
  deserializeVaults_fn = function(vaults) {
    return vaults.map(({ title, type: type3, data: vaultConfig }) => {
      const VaultClass = this.getVaultClass(type3);
      return {
        title,
        type: type3,
        vault: new VaultClass(vaultConfig)
      };
    });
  };
  __publicField6(WalletManager, "Vaults", [MnemonicVault, PrivateKeyVault]);
  var Vault = class {
    constructor(_options2) {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    serialize() {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    getAccounts() {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    addAccount() {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    exportAccount(_address) {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    getWallet(_address) {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
  };
  __publicField6(Vault, "type");
  var FuelConnectorMethods = /* @__PURE__ */ ((FuelConnectorMethods2) => {
    FuelConnectorMethods2["ping"] = "ping";
    FuelConnectorMethods2["version"] = "version";
    FuelConnectorMethods2["connect"] = "connect";
    FuelConnectorMethods2["disconnect"] = "disconnect";
    FuelConnectorMethods2["isConnected"] = "isConnected";
    FuelConnectorMethods2["accounts"] = "accounts";
    FuelConnectorMethods2["currentAccount"] = "currentAccount";
    FuelConnectorMethods2["signMessage"] = "signMessage";
    FuelConnectorMethods2["sendTransaction"] = "sendTransaction";
    FuelConnectorMethods2["assets"] = "assets";
    FuelConnectorMethods2["addAsset"] = "addAsset";
    FuelConnectorMethods2["addAssets"] = "addAssets";
    FuelConnectorMethods2["networks"] = "networks";
    FuelConnectorMethods2["currentNetwork"] = "currentNetwork";
    FuelConnectorMethods2["addNetwork"] = "addNetwork";
    FuelConnectorMethods2["selectNetwork"] = "selectNetwork";
    FuelConnectorMethods2["addABI"] = "addABI";
    FuelConnectorMethods2["getABI"] = "getABI";
    FuelConnectorMethods2["hasABI"] = "hasABI";
    return FuelConnectorMethods2;
  })(FuelConnectorMethods || {});
  var FuelConnectorEventTypes = /* @__PURE__ */ ((FuelConnectorEventTypes2) => {
    FuelConnectorEventTypes2["connectors"] = "connectors";
    FuelConnectorEventTypes2["currentConnector"] = "currentConnector";
    FuelConnectorEventTypes2["connection"] = "connection";
    FuelConnectorEventTypes2["accounts"] = "accounts";
    FuelConnectorEventTypes2["currentAccount"] = "currentAccount";
    FuelConnectorEventTypes2["networks"] = "networks";
    FuelConnectorEventTypes2["currentNetwork"] = "currentNetwork";
    FuelConnectorEventTypes2["assets"] = "assets";
    FuelConnectorEventTypes2["abis"] = "abis";
    return FuelConnectorEventTypes2;
  })(FuelConnectorEventTypes || {});
  var FuelConnectorEventType = "FuelConnector";
  var LocalStorage = class {
    storage;
    constructor(localStorage2) {
      this.storage = localStorage2;
    }
    async setItem(key, value) {
      this.storage.setItem(key, value);
    }
    async getItem(key) {
      return this.storage.getItem(key);
    }
    async removeItem(key) {
      this.storage.removeItem(key);
    }
    async clear() {
      this.storage.clear();
    }
  };
  var FuelConnector = class extends import_events3.EventEmitter {
    name = "";
    metadata = {};
    connected = false;
    installed = false;
    events = FuelConnectorEventTypes;
    /**
     * Should return true if the connector is loaded
     * in less then one second.
     *
     * @returns Always true.
     */
    async ping() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return the current version of the connector
     * and the network version that is compatible.
     *
     * @returns boolean - connection status.
     */
    async version() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return true if the connector is connected
     * to any of the accounts available.
     *
     * @returns The connection status.
     */
    async isConnected() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return all the accounts authorized for the
     * current connection.
     *
     * @returns The accounts addresses strings
     */
    async accounts() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should start the connection process and return
     * true if the account authorize the connection.
     *
     * and return false if the user reject the connection.
     *
     * @emits accounts
     * @returns boolean - connection status.
     */
    async connect() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should disconnect the current connection and
     * return false if the disconnection was successful.
     *
     * @emits assets connection
     * @returns The connection status.
     */
    async disconnect() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should start the sign message process and return
     * the signed message.
     *
     * @param address - The address to sign the message
     * @param message - The message to sign all text will be treated as text utf-8
     *
     * @returns Message signature
     */
    async signMessage(_address, _message) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should start the sign transaction process and return
     * the signed transaction.
     *
     * @param address - The address to sign the transaction
     * @param transaction - The transaction to sign
     *
     * @returns Transaction signature
     */
    async signTransaction(_address, _transaction) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should start the send transaction process and return
     * the transaction id submitted to the network.
     *
     * If the network is not available for the connection
     * it should throw an error to avoid the transaction
     * to be sent to the wrong network and lost.
     *
     * @param address - The address to sign the transaction
     * @param transaction - The transaction to send
     *
     * @returns The transaction id
     */
    async sendTransaction(_address, _transaction) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return the current account selected inside the connector, if the account
     * is authorized for the connection.
     *
     * If the account is not authorized it should return null.
     *
     * @returns The current account selected otherwise null.
     */
    async currentAccount() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should add the the assets metadata to the connector and return true if the asset
     * was added successfully.
     *
     * If the asset already exists it should throw an error.
     *
     * @emits assets
     * @param assets - The assets to add the metadata to the connection.
     * @throws Error if the asset already exists
     * @returns True if the asset was added successfully
     */
    async addAssets(_assets) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should add the the asset metadata to the connector and return true if the asset
     * was added successfully.
     *
     * If the asset already exists it should throw an error.
     *
     * @emits assets
     * @param asset - The asset to add the metadata to the connection.
     * @throws Error if the asset already exists
     * @returns True if the asset was added successfully
     */
    async addAsset(_asset) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return all the assets added to the connector. If a connection is already established.
     *
     * @returns Array of assets metadata from the connector vinculated to the all accounts from a specific Wallet.
     */
    async assets() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should start the add network process and return true if the network was added successfully.
     *
     * @emits networks
     * @throws Error if the network already exists
     * @param networkUrl - The URL of the network to be added.
     * @returns Return true if the network was added successfully
     */
    async addNetwork(_networkUrl) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should start the select network process and return true if the network has change successfully.
     *
     * @emits networks
     * @throws Error if the network already exists
     * @param network - The network to be selected.
     * @returns Return true if the network was added successfully
     */
    async selectNetwork(_network) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return all the networks available from the connector. If the connection is already established.
     *
     * @returns Return all the networks added to the connector.
     */
    async networks() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return the current network selected inside the connector. Even if the connection is not established.
     *
     * @returns Return the current network selected inside the connector.
     */
    async currentNetwork() {
      throw new Error("Method not implemented.");
    }
    /**
     * Should add the ABI to the connector and return true if the ABI was added successfully.
     *
     * @param contractId - The contract id to add the ABI.
     * @param abi - The JSON ABI that represents a contract.
     * @returns Return true if the ABI was added successfully.
     */
    async addABI(_contractId, _abi) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.
     *
     * @param id - The contract id to get the ABI.
     * @returns The ABI if it exists, otherwise return null.
     */
    async getABI(_id) {
      throw new Error("Method not implemented.");
    }
    /**
     * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.
     *
     * @param id - The contract id to get the abi
     * @returns Returns true if the abi exists or false if not.
     */
    async hasABI(_id) {
      throw new Error("Method not implemented.");
    }
    /**
     * Event listener for the connector.
     *
     * @param eventName - The event name to listen
     * @param listener - The listener function
     */
    on(eventName, listener) {
      super.on(eventName, listener);
      return this;
    }
  };
  function cacheFor(fn, { cache: cache22, cacheTime, key }) {
    return async (...args) => {
      if (cache22[key] && cache22[key]?.value) {
        return cache22[key]?.value;
      }
      clearTimeout(cache22[key]?.timeout);
      const result = await fn(...args);
      cache22[key] = {
        timeout: Number(
          setTimeout(() => {
            cache22[key] = null;
          }, cacheTime)
        ),
        value: result
      };
      return result;
    };
  }
  function deferPromise() {
    const defer2 = {};
    defer2.promise = new Promise((resolve4, reject) => {
      defer2.reject = reject;
      defer2.resolve = resolve4;
    });
    return defer2;
  }
  async function withTimeout(promise, timeout = 1050) {
    const timeoutPromise = new Promise((resolve4, reject) => {
      setTimeout(() => {
        reject(new Error("Promise timed out"));
      }, timeout);
    });
    return Promise.race([timeoutPromise, promise]);
  }
  var HAS_CONNECTOR_TIMEOUT = 2e3;
  var PING_CACHE_TIME = 5e3;
  var { warn } = console;
  var _Fuel = class extends FuelConnector {
    _storage = null;
    _connectors = [];
    _targetObject = null;
    _unsubscribes = [];
    _targetUnsubscribe;
    _pingCache = {};
    _currentConnector;
    constructor(config = _Fuel.defaultConfig) {
      super();
      this.setMaxListeners(1e3);
      this._connectors = config.connectors ?? [];
      this._targetObject = this.getTargetObject(config.targetObject);
      this._storage = config.storage === void 0 ? this.getStorage() : config.storage;
      this.setupMethods();
      this.setDefaultConnector();
      this._targetUnsubscribe = this.setupConnectorListener();
    }
    /**
     * Return the target object to listen for global events.
     */
    getTargetObject(targetObject) {
      if (targetObject) {
        return targetObject;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof document !== "undefined") {
        return document;
      }
      return null;
    }
    /**
     * Return the storage used.
     */
    getStorage() {
      if (typeof window !== "undefined") {
        return new LocalStorage(window.localStorage);
      }
      return void 0;
    }
    /**
     * Setup the default connector from the storage.
     */
    async setDefaultConnector() {
      const connectorName = await this._storage?.getItem(_Fuel.STORAGE_KEY) || this._connectors[0]?.name;
      if (connectorName) {
        return this.selectConnector(connectorName, {
          emitEvents: false
        });
      }
      return void 0;
    }
    /**
     * Start listener for all the events of the current
     * connector and emit them to the Fuel instance
     */
    setupConnectorEvents(events) {
      if (!this._currentConnector) {
        return;
      }
      const currentConnector = this._currentConnector;
      this._unsubscribes.map((unSub) => unSub());
      this._unsubscribes = events.map((event) => {
        const handler = (...args) => this.emit(event, ...args);
        currentConnector.on(event, handler);
        return () => currentConnector.off(event, handler);
      });
    }
    /**
     * Call method from the current connector.
     */
    async callMethod(method, ...args) {
      const hasConnector = await this.hasConnector();
      await this.pingConnector();
      if (!this._currentConnector || !hasConnector) {
        throw new Error(
          `No connector selected for calling ${method}. Use hasConnector before executing other methods.`
        );
      }
      if (typeof this._currentConnector[method] === "function") {
        return this._currentConnector[method](...args);
      }
      return void 0;
    }
    /**
     * Create a method for each method proxy that is available on the Common interface
     * and call the method from the current connector.
     */
    setupMethods() {
      Object.values(FuelConnectorMethods).forEach((method) => {
        this[method] = async (...args) => this.callMethod(method, ...args);
      });
    }
    /**
     * Fetch the status of a connector and set the installed and connected
     * status.
     */
    async fetchConnectorStatus(connector) {
      const requestTimestamp = Date.now();
      const [isConnected, ping] = await Promise.allSettled([
        withTimeout(connector.isConnected()),
        withTimeout(this.pingConnector(connector))
      ]);
      const isStale = requestTimestamp < (connector._latestUpdate || 0);
      if (!isStale) {
        connector._latestUpdate = Date.now();
        connector.installed = ping.status === "fulfilled" && ping.value;
        connector.connected = isConnected.status === "fulfilled" && isConnected.value;
      }
      return {
        installed: connector.installed,
        connected: connector.connected
      };
    }
    /**
     * Fetch the status of all connectors and set the installed and connected
     * status.
     */
    async fetchConnectorsStatus() {
      return Promise.all(
        this._connectors.map(async (connector) => this.fetchConnectorStatus(connector))
      );
    }
    /**
     * Fetch the status of a connector and set the installed and connected
     * status. If no connector is provided it will ping the current connector.
     */
    async pingConnector(connector) {
      const curConnector = connector || this._currentConnector;
      if (!curConnector) {
        return false;
      }
      try {
        return await cacheFor(async () => withTimeout(curConnector.ping()), {
          key: curConnector.name,
          cache: this._pingCache,
          cacheTime: PING_CACHE_TIME
        })();
      } catch {
        throw new Error("Current connector is not available.");
      }
    }
    /**
     * Setup a listener for the FuelConnector event and add the connector
     * to the list of new connectors.
     */
    setupConnectorListener = () => {
      const { _targetObject: targetObject } = this;
      const eventName = FuelConnectorEventType;
      if (targetObject?.on) {
        targetObject.on(eventName, this.addConnector);
        return () => {
          targetObject.off?.(eventName, this.addConnector);
        };
      }
      if (targetObject?.addEventListener) {
        const handler = (e) => {
          this.addConnector(e.detail);
        };
        targetObject.addEventListener(eventName, handler);
        return () => {
          targetObject.removeEventListener?.(eventName, handler);
        };
      }
      return () => {
      };
    };
    /**
     * Add a new connector to the list of connectors.
     */
    addConnector = async (connector) => {
      if (!this.getConnector(connector)) {
        this._connectors.push(connector);
      }
      await this.fetchConnectorStatus(connector);
      this.emit(this.events.connectors, this._connectors);
      if (!this._currentConnector) {
        await this.selectConnector(connector.name, {
          emitEvents: false
        });
      }
    };
    triggerConnectorEvents = async () => {
      const [isConnected, networks, currentNetwork] = await Promise.all([
        this.isConnected(),
        this.networks(),
        this.currentNetwork()
      ]);
      this.emit(this.events.connection, isConnected);
      this.emit(this.events.networks, networks);
      this.emit(this.events.currentNetwork, currentNetwork);
      if (isConnected) {
        const [accounts, currentAccount] = await Promise.all([
          this.accounts(),
          this.currentAccount()
        ]);
        this.emit(this.events.accounts, accounts);
        this.emit(this.events.currentAccount, currentAccount);
      }
    };
    /**
     * Get a connector from the list of connectors.
     */
    getConnector = (connector) => this._connectors.find((c) => {
      const connectorName = typeof connector === "string" ? connector : connector.name;
      return c.name === connectorName || c === connector;
    }) || null;
    /**
     * Return the list of connectors with the status of installed and connected.
     */
    async connectors() {
      await this.fetchConnectorsStatus();
      return this._connectors;
    }
    /**
     * Set the current connector to be used.
     */
    async selectConnector(connectorName, options = {
      emitEvents: true
    }) {
      const connector = this.getConnector(connectorName);
      if (!connector) {
        return false;
      }
      if (this._currentConnector?.name === connectorName) {
        return true;
      }
      const { installed } = await this.fetchConnectorStatus(connector);
      if (installed) {
        this._currentConnector = connector;
        this.emit(this.events.currentConnector, connector);
        this.setupConnectorEvents(Object.values(FuelConnectorEventTypes));
        await this._storage?.setItem(_Fuel.STORAGE_KEY, connector.name);
        if (options.emitEvents) {
          this.triggerConnectorEvents();
        }
        return true;
      }
      return false;
    }
    /**
     * Return the current selected connector.
     */
    currentConnector() {
      return this._currentConnector;
    }
    /**
     * Return true if any connector is available.
     */
    async hasConnector() {
      if (this._currentConnector) {
        return true;
      }
      const defer2 = deferPromise();
      this.once(this.events.currentConnector, () => {
        defer2.resolve(true);
      });
      return withTimeout(defer2.promise, HAS_CONNECTOR_TIMEOUT).then(() => true).catch(() => false);
    }
    async hasWallet() {
      return this.hasConnector();
    }
    /**
     * Return a Fuel Provider instance with extends features to work with
     * connectors.
     *
     * @deprecated getProvider is deprecated and is going to be removed in the future, use getWallet instead.
     */
    async getProvider(providerOrNetwork) {
      warn(
        "getProvider is deprecated and is going to be removed in the future, use getWallet instead."
      );
      return this._getProvider(providerOrNetwork);
    }
    /**
     * Return a Fuel Provider instance with extends features to work with
     * connectors.
     */
    async _getProvider(providerOrNetwork) {
      let provider;
      if (providerOrNetwork && "getTransactionResponse" in providerOrNetwork) {
        provider = providerOrNetwork;
      } else if (providerOrNetwork && "chainId" in providerOrNetwork && "url" in providerOrNetwork) {
        provider = await Provider.create(providerOrNetwork.url);
      } else if (!providerOrNetwork) {
        const currentNetwork = await this.currentNetwork();
        provider = await Provider.create(currentNetwork.url);
      } else {
        throw new FuelError(ErrorCode.INVALID_PROVIDER, "Provider is not valid.");
      }
      return provider;
    }
    /**
     * Return a Fuel Wallet Locked instance with extends features to work with
     * connectors.
     */
    async getWallet(address, providerOrNetwork) {
      const provider = await this._getProvider(providerOrNetwork);
      return new Account(address, provider, this);
    }
    /**
     * Remove all open listeners this is useful when you want to
     * remove the Fuel instance and avoid memory leaks.
     */
    unsubscribe() {
      this._unsubscribes.map((unSub) => unSub());
      this._targetUnsubscribe();
      this.removeAllListeners();
    }
    /**
     * Clean all the data from the storage.
     */
    async clean() {
      await this._storage?.removeItem(_Fuel.STORAGE_KEY);
    }
    /**
     * Removes all listeners and cleans the storage.
     */
    async destroy() {
      this.unsubscribe();
      await this.clean();
    }
  };
  var Fuel = _Fuel;
  __publicField6(Fuel, "STORAGE_KEY", "fuel-current-connector");
  __publicField6(Fuel, "defaultConfig", {});

  // src/cli/commands/deploy/createWallet.ts
  async function createWallet(providerUrl, privateKey) {
    let pvtKey;
    if (privateKey) {
      pvtKey = privateKey;
    } else if (process.env.PRIVATE_KEY) {
      pvtKey = process.env.PRIVATE_KEY;
    } else {
      throw new Error("You must provide a privateKey via config.privateKey or env PRIVATE_KEY");
    }
    try {
      const provider = await Provider.create(providerUrl);
      return Wallet.fromPrivateKey(pvtKey, provider);
    } catch (e) {
      const error2 = e;
      if (error2.cause?.code === "ECONNREFUSED") {
        throw new FuelError(
          FuelError.CODES.CONNECTION_REFUSED,
          `Couldn't connect to the node at "${providerUrl}". Check that you've got a node running at the config's providerUrl or set autoStartFuelCore to true.`
        );
      } else {
        throw error2;
      }
    }
  }

  // ../program/dist/index.mjs
  var asm2 = __toESM(require_node(), 1);
  var asm3 = __toESM(require_node(), 1);
  var PANIC_REASONS = [
    "Success",
    "Revert",
    "OutOfGas",
    "TransactionValidity",
    "MemoryOverflow",
    "ArithmeticOverflow",
    "ContractNotFound",
    "MemoryOwnership",
    "NotEnoughBalance",
    "ExpectedInternalContext",
    "AssetIdNotFound",
    "InputNotFound",
    "OutputNotFound",
    "WitnessNotFound",
    "TransactionMaturity",
    "InvalidMetadataIdentifier",
    "MalformedCallStructure",
    "ReservedRegisterNotWritable",
    "ErrorFlag",
    "InvalidImmediateValue",
    "ExpectedCoinInput",
    "MaxMemoryAccess",
    "MemoryWriteOverlap",
    "ContractNotInInputs",
    "InternalBalanceOverflow",
    "ContractMaxSize",
    "ExpectedUnallocatedStack",
    "MaxStaticContractsReached",
    "TransferAmountCannotBeZero",
    "ExpectedOutputVariable",
    "ExpectedParentInternalContext",
    "IllegalJump",
    "NonZeroMessageOutputRecipient",
    "ZeroedMessageOutputRecipient"
  ];
  var PANIC_DOC_URL = "https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html";
  var getFailureReason = (reason) => {
    if (PANIC_REASONS.includes(reason)) {
      return reason;
    }
    return reason === "Revert(123)" ? "MismatchedSelector" : "unknown";
  };
  var getDocs = (status) => {
    if (status?.type === "FailureStatus") {
      const reason = getFailureReason(status.reason);
      return {
        doc: reason !== "unknown" ? `${PANIC_DOC_URL}#variant.${reason}` : PANIC_DOC_URL,
        reason
      };
    }
    return { doc: PANIC_DOC_URL, reason: "unknown" };
  };
  function assert4(condition, message) {
    if (!condition) {
      throw new FuelError(ErrorCode.TRANSACTION_ERROR, message);
    }
  }
  function getAbisFromAllCalls(functionScopes) {
    return functionScopes.reduce((acc, funcScope, i) => {
      const { program: program2, externalAbis } = funcScope.getCallConfig();
      if (i === 0) {
        acc.main = program2.interface.jsonAbi;
        acc.otherContractsAbis = {};
      } else {
        acc.otherContractsAbis[program2.id.toB256()] = program2.interface.jsonAbi;
      }
      acc.otherContractsAbis = { ...acc.otherContractsAbis, ...externalAbis };
      return acc;
    }, {});
  }
  var REVERT_MAP = {
    [FAILED_REQUIRE_SIGNAL]: "RequireFailed",
    [FAILED_TRANSFER_TO_ADDRESS_SIGNAL]: "TransferToAddressFailed",
    [FAILED_SEND_MESSAGE_SIGNAL]: "SendMessageFailed",
    [FAILED_ASSERT_EQ_SIGNAL]: "AssertEqFailed",
    [FAILED_ASSERT_SIGNAL]: "AssertFailed",
    [FAILED_UNKNOWN_SIGNAL]: "Unknown"
  };
  var decodeRevertErrorCode = (receipt) => {
    const signalHex = receipt.val.toHex();
    return REVERT_MAP[signalHex] ? REVERT_MAP[signalHex] : void 0;
  };
  var RevertError = class extends Error {
    /**
     * The receipt associated with the revert error.
     */
    receipt;
    /**
     * Creates a new instance of RevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason, logs) {
      super(
        `The script reverted with reason ${reason}. (Reason: "${RevertError.extractErrorReasonFromLogs(
          logs
        )}")`
      );
      this.name = "RevertError";
      this.receipt = receipt;
    }
    static extractErrorReasonFromLogs(logs) {
      return logs.filter((l) => typeof l === "string");
    }
    /**
     * Returns a string representation of the RevertError.
     *
     * @returns The string representation of the error.
     */
    toString() {
      const { id, ...r } = this.receipt;
      return `${this.name}: ${this.message}
    ${id}: ${JSON.stringify(r)}`;
    }
  };
  var RequireRevertError = class extends RevertError {
    /**
     * Creates a new instance of RequireRevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason, logs) {
      super(receipt, reason, logs);
      this.name = "RequireRevertError";
    }
  };
  var TransferToAddressRevertError = class extends RevertError {
    /**
     * Creates a new instance of TransferToAddressRevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason, logs) {
      super(receipt, reason, logs);
      this.name = "TransferToAddressRevertError";
    }
  };
  var SendMessageRevertError = class extends RevertError {
    /**
     * Creates a new instance of SendMessageRevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason, logs) {
      super(receipt, reason, logs);
      this.name = "SendMessageRevertError";
    }
  };
  var AssertFailedRevertError = class extends RevertError {
    /**
     * Creates a new instance of AssertFailedRevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason, logs) {
      super(receipt, reason, logs);
      this.name = "AssertFailedRevertError";
    }
  };
  var revertErrorFactory = (receipt, logs) => {
    const reason = decodeRevertErrorCode(receipt);
    if (!reason) {
      return void 0;
    }
    switch (reason) {
      case "RequireFailed":
        return new RequireRevertError(receipt, reason, logs);
      case "TransferToAddressFailed":
        return new TransferToAddressRevertError(receipt, reason, logs);
      case "SendMessageFailed":
        return new SendMessageRevertError(receipt, reason, logs);
      case "AssertFailed":
        return new AssertFailedRevertError(receipt, reason, logs);
      default:
        return new RevertError(receipt, reason, logs);
    }
  };
  var { warn: warn2 } = console;
  var getRevertReceipts = (receipts) => receipts.filter((r) => r.type === ReceiptType.Revert);
  var RevertErrorCodes = class {
    revertReceipts;
    logs;
    constructor(receipts, logs) {
      this.revertReceipts = getRevertReceipts(receipts);
      this.logs = logs;
    }
    assert(detailedError) {
      const revertError = this.getError();
      if (revertError) {
        revertError.cause = detailedError;
        throw revertError;
      }
    }
    getError() {
      if (!this.revertReceipts.length) {
        return void 0;
      }
      if (this.revertReceipts.length !== 1) {
        warn2(
          "Multiple revert receipts found, expected one. Receipts:",
          JSON.stringify(this.revertReceipts)
        );
      }
      return revertErrorFactory(this.revertReceipts[0], this.logs);
    }
  };
  var bigintReplacer = (key, value) => typeof value === "bigint" ? value.toString() : value;
  var ScriptResultDecoderError = class extends Error {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logs;
    constructor(result, message, logs) {
      let docLink = "";
      if (result?.gqlTransaction?.status) {
        docLink = `${JSON.stringify(getDocs(result.gqlTransaction.status), null, 2)}

`;
      }
      const logsText = logs.length ? `Logs:
${JSON.stringify(logs, null, 2)}

` : "";
      const receiptsText = `Receipts:
${JSON.stringify(
        result.receipts.map(({ type: type3, ...r }) => ({ type: ReceiptType[type3], ...r })),
        bigintReplacer,
        2
      )}`;
      super(`${message}

${docLink}${logsText}${receiptsText}`);
      this.logs = logs;
      new RevertErrorCodes(result.receipts, logs).assert(this);
    }
  };
  var InstructionSet = class {
    #operations;
    constructor(...args) {
      this.#operations = args || [];
    }
    entries() {
      return this.#operations;
    }
    push(...args) {
      this.#operations.push(...args);
    }
    concat(ops) {
      return this.#operations.concat(ops);
    }
    extend(ops) {
      this.#operations.push(...ops);
    }
    toBytes() {
      return concat(
        this.#operations.reduce((instructions, line) => {
          instructions.push(line.to_bytes());
          return instructions;
        }, [])
      );
    }
    toHex() {
      return hexlify(this.toBytes());
    }
    toString() {
      return `Program:
${JSON.stringify(this.#operations, null, 2)}`;
    }
    byteLength() {
      return this.toBytes().byteLength;
    }
  };
  var calculateScriptDataBaseOffset = (maxInputs) => SCRIPT_FIXED_SIZE + calculateVmTxMemory({ maxInputs });
  var POINTER_DATA_OFFSET = WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;
  function callResultToScriptResult(callResult) {
    const receipts = [...callResult.receipts];
    let scriptResultReceipt;
    let returnReceipt;
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.ScriptResult) {
        scriptResultReceipt = receipt;
      } else if (receipt.type === ReceiptType.Return || receipt.type === ReceiptType.ReturnData || receipt.type === ReceiptType.Revert) {
        returnReceipt = receipt;
      }
    });
    if (!scriptResultReceipt) {
      throw new FuelError(
        ErrorCode.TRANSACTION_ERROR,
        `The script call result does not contain a 'scriptResultReceipt'.`
      );
    }
    if (!returnReceipt) {
      throw new FuelError(
        ErrorCode.TRANSACTION_ERROR,
        `The script call result does not contain a 'returnReceipt'.`
      );
    }
    const scriptResult = {
      code: scriptResultReceipt.result,
      gasUsed: scriptResultReceipt.gasUsed,
      receipts,
      scriptResultReceipt,
      returnReceipt,
      callResult
    };
    return scriptResult;
  }
  function decodeCallResult(callResult, decoder, logs = []) {
    try {
      const scriptResult = callResultToScriptResult(callResult);
      return decoder(scriptResult);
    } catch (error2) {
      throw new ScriptResultDecoderError(
        callResult,
        error2.message,
        logs
      );
    }
  }
  function callResultToInvocationResult(callResult, call2, logs) {
    return decodeCallResult(
      callResult,
      (scriptResult) => {
        if (scriptResult.returnReceipt.type === ReceiptType.Revert) {
          throw new FuelError(
            ErrorCode.SCRIPT_REVERTED,
            `Script Reverted. Logs: ${JSON.stringify(logs)}`
          );
        }
        if (scriptResult.returnReceipt.type !== ReceiptType.Return && scriptResult.returnReceipt.type !== ReceiptType.ReturnData) {
          const { type: type3 } = scriptResult.returnReceipt;
          throw new FuelError(
            ErrorCode.SCRIPT_REVERTED,
            `Script Return Type [${type3}] Invalid. Logs: ${JSON.stringify({
              logs,
              receipt: scriptResult.returnReceipt
            })}`
          );
        }
        let value;
        if (scriptResult.returnReceipt.type === ReceiptType.Return) {
          value = scriptResult.returnReceipt.val;
        }
        if (scriptResult.returnReceipt.type === ReceiptType.ReturnData) {
          const decoded = call2.func.decodeOutput(scriptResult.returnReceipt.data);
          value = decoded[0];
        }
        return value;
      },
      logs
    );
  }
  var ScriptRequest = class {
    /**
     * The bytes of the script.
     */
    bytes;
    /**
     * A function to encode the script data.
     */
    scriptDataEncoder;
    /**
     * A function to decode the script result.
     */
    scriptResultDecoder;
    /**
     * Creates an instance of the ScriptRequest class.
     *
     * @param bytes - The bytes of the script.
     * @param scriptDataEncoder - The script data encoder function.
     * @param scriptResultDecoder - The script result decoder function.
     */
    constructor(bytes3, scriptDataEncoder, scriptResultDecoder2) {
      this.bytes = arrayify(bytes3);
      this.scriptDataEncoder = scriptDataEncoder;
      this.scriptResultDecoder = scriptResultDecoder2;
    }
    /**
     * Gets the script data offset for the given bytes.
     *
     * @param byteLength - The byte length of the script.
     * @param maxInputs - The maxInputs value from the chain's consensus params.
     * @returns The script data offset.
     */
    static getScriptDataOffsetWithScriptBytes(byteLength, maxInputs) {
      const scriptDataBaseOffset = calculateVmTxMemory({ maxInputs }) + SCRIPT_FIXED_SIZE;
      return scriptDataBaseOffset + byteLength;
    }
    /**
     * Gets the script data offset.
     *
     * @param maxInputs - The maxInputs value from the chain's consensus params.
     * @returns The script data offset.
     */
    getScriptDataOffset(maxInputs) {
      return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);
    }
    /**
     * Encodes the data for a script call.
     *
     * @param data - The script data.
     * @returns The encoded data.
     */
    encodeScriptData(data) {
      const callScript = this.scriptDataEncoder(data);
      if (ArrayBuffer.isView(callScript)) {
        return callScript;
      }
      this.bytes = arrayify(callScript.script);
      return callScript.data;
    }
    /**
     * Decodes the result of a script call.
     *
     * @param callResult - The CallResult from the script call.
     * @param logs - Optional logs associated with the decoding.
     * @returns The decoded result.
     */
    decodeCallResult(callResult, logs = []) {
      return decodeCallResult(callResult, this.scriptResultDecoder, logs);
    }
  };
  var DEFAULT_OPCODE_PARAMS = {
    assetIdOffset: 0,
    amountOffset: 0,
    gasForwardedOffset: 0,
    callDataOffset: 0
  };
  var SCRIPT_WRAPPER_CONTRACT_ID = ZeroBytes32;
  var getSingleCallInstructions = ({ callDataOffset, gasForwardedOffset, amountOffset, assetIdOffset }, outputInfo) => {
    const inst = new InstructionSet(
      asm3.movi(16, callDataOffset),
      asm3.movi(17, amountOffset),
      asm3.lw(17, 17, 0),
      asm3.movi(18, assetIdOffset)
    );
    if (gasForwardedOffset) {
      inst.push(
        asm3.movi(19, gasForwardedOffset),
        asm3.lw(19, 19, 0),
        asm3.call(16, 17, 18, 19)
      );
    } else {
      inst.push(asm3.call(16, 17, 18, asm3.RegId.cgas().to_u8()));
    }
    if (outputInfo.isHeap) {
      inst.extend([
        // The RET register contains the pointer address of the `CALL` return (a stack
        // address).
        // The RETL register contains the length of the `CALL` return (=24 because the Vec/Bytes
        // struct takes 3 WORDs). We don't actually need it unless the Vec/Bytes struct encoding
        // changes in the compiler.
        // Load the word located at the address contained in RET, it's a word that
        // translates to a heap address. 0x15 is a free register.
        asm3.lw(21, asm3.RegId.ret().to_u8(), 0),
        // We know a Vec/Bytes struct has its third WORD contain the length of the underlying
        // vector, so use a 2 offset to store the length in 0x16, which is a free register.
        asm3.lw(22, asm3.RegId.ret().to_u8(), 2),
        // The in-memory size of the type is (in-memory size of the inner type) * length
        asm3.muli(22, 22, outputInfo.encodedLength),
        asm3.retd(21, 22)
      ]);
    }
    return inst;
  };
  function getInstructions(offsets, outputs) {
    if (!offsets.length) {
      return new Uint8Array();
    }
    const multiCallInstructions = new InstructionSet();
    for (let i = 0; i < offsets.length; i += 1) {
      multiCallInstructions.extend(getSingleCallInstructions(offsets[i], outputs[i]).entries());
    }
    multiCallInstructions.push(asm3.ret(1));
    return multiCallInstructions.toBytes();
  }
  var isReturnType = (type3) => type3 === ReceiptType.Return || type3 === ReceiptType.ReturnData;
  var getMainCallReceipt = (receipts, contractId) => receipts.find(
    ({ type: type3, from, to }) => type3 === ReceiptType.Call && from === SCRIPT_WRAPPER_CONTRACT_ID && to === contractId
  );
  var scriptResultDecoder = (contractId, isOutputDataHeap) => (result) => {
    if (toNumber2(result.code) !== 0) {
      throw new FuelError(
        ErrorCode.TRANSACTION_ERROR,
        `Execution of the script associated with contract ${contractId} resulted in a non-zero exit code: ${result.code}.`
      );
    }
    const mainCallResult = getMainCallReceipt(
      result.receipts,
      contractId.toB256()
    );
    const mainCallInstructionStart = bn(mainCallResult?.is);
    const receipts = result.receipts;
    return receipts.filter(({ type: type3 }) => isReturnType(type3)).flatMap((receipt, index, filtered) => {
      if (!mainCallInstructionStart.eq(bn(receipt.is))) {
        return [];
      }
      if (receipt.type === ReceiptType.Return) {
        return [
          new BigNumberCoder("u64").encode(receipt.val)
        ];
      }
      if (receipt.type === ReceiptType.ReturnData) {
        const encodedScriptReturn = arrayify(receipt.data);
        if (isOutputDataHeap && isReturnType(filtered[index + 1]?.type)) {
          const nextReturnData = filtered[index + 1];
          return concat([encodedScriptReturn, arrayify(nextReturnData.data)]);
        }
        return [encodedScriptReturn];
      }
      return [new Uint8Array()];
    });
  };
  var decodeContractCallScriptResult = (callResult, contractId, isOutputDataHeap, logs = []) => decodeCallResult(callResult, scriptResultDecoder(contractId, isOutputDataHeap), logs);
  var getCallInstructionsLength = (contractCalls) => contractCalls.reduce(
    (sum, call2) => {
      const offset = { ...DEFAULT_OPCODE_PARAMS };
      if (call2.gas) {
        offset.gasForwardedOffset = 1;
      }
      const output3 = {
        isHeap: call2.isOutputDataHeap,
        encodedLength: call2.outputEncodedLength
      };
      return sum + getSingleCallInstructions(offset, output3).byteLength();
    },
    asm3.Instruction.size()
    // placeholder for single RET instruction which is added later
  );
  var getFunctionOutputInfos = (functionScopes) => functionScopes.map((funcScope) => {
    const { func } = funcScope.getCallConfig();
    return {
      isHeap: func.outputMetadata.isHeapType,
      encodedLength: func.outputMetadata.encodedLength
    };
  });
  var getContractCallScript = (functionScopes, maxInputs) => new ScriptRequest(
    // Script to call the contract, start with stub size matching length of calls
    getInstructions(
      new Array(functionScopes.length).fill(DEFAULT_OPCODE_PARAMS),
      getFunctionOutputInfos(functionScopes)
    ),
    (contractCalls) => {
      const TOTAL_CALLS = contractCalls.length;
      if (TOTAL_CALLS === 0) {
        return { data: new Uint8Array(), script: new Uint8Array() };
      }
      const callInstructionsLength = getCallInstructionsLength(contractCalls);
      const paddingLength = (8 - callInstructionsLength % 8) % 8;
      const paddedInstructionsLength = callInstructionsLength + paddingLength;
      const dataOffset = calculateScriptDataBaseOffset(maxInputs.toNumber()) + paddedInstructionsLength;
      const paramOffsets = [];
      let segmentOffset = dataOffset;
      const outputInfos = [];
      const scriptData = [];
      for (let i = 0; i < TOTAL_CALLS; i += 1) {
        const call2 = contractCalls[i];
        outputInfos.push({
          isHeap: call2.isOutputDataHeap,
          encodedLength: call2.outputEncodedLength
        });
        let gasForwardedSize = 0;
        paramOffsets.push({
          amountOffset: segmentOffset,
          assetIdOffset: segmentOffset + WORD_SIZE,
          gasForwardedOffset: call2.gas ? segmentOffset + WORD_SIZE + ASSET_ID_LEN : 0,
          callDataOffset: segmentOffset + WORD_SIZE + ASSET_ID_LEN + gasForwardedSize
        });
        scriptData.push(new BigNumberCoder("u64").encode(call2.amount || 0));
        scriptData.push(new B256Coder().encode(call2.assetId?.toString() || BaseAssetId));
        scriptData.push(call2.contractId.toBytes());
        scriptData.push(new BigNumberCoder("u64").encode(call2.fnSelector));
        if (call2.gas) {
          scriptData.push(new BigNumberCoder("u64").encode(call2.gas));
          gasForwardedSize = WORD_SIZE;
        }
        if (call2.isInputDataPointer) {
          const pointerInputOffset = segmentOffset + POINTER_DATA_OFFSET + gasForwardedSize;
          scriptData.push(new BigNumberCoder("u64").encode(pointerInputOffset));
        }
        const args = arrayify(call2.data);
        scriptData.push(args);
        segmentOffset = dataOffset + concat(scriptData).byteLength;
      }
      const script = getInstructions(paramOffsets, outputInfos);
      const finalScriptData = concat(scriptData);
      return { data: finalScriptData, script };
    },
    () => [new Uint8Array()]
  );
  function getGasUsage(callResult) {
    const scriptResult = callResult.receipts.find((r) => r.type === ReceiptType.ScriptResult);
    return scriptResult?.gasUsed || bn(0);
  }
  var InvocationResult = class {
    functionScopes;
    isMultiCall;
    gasUsed;
    value;
    /**
     * Constructs an instance of InvocationResult.
     *
     * @param funcScopes - The function scopes.
     * @param callResult - The call result.
     * @param isMultiCall - Whether it's a multi-call.
     */
    constructor(funcScopes, callResult, isMultiCall) {
      this.functionScopes = Array.isArray(funcScopes) ? funcScopes : [funcScopes];
      this.isMultiCall = isMultiCall;
      this.value = this.getDecodedValue(callResult);
      this.gasUsed = getGasUsage(callResult);
    }
    /**
     * Gets the first call config.
     *
     * @returns The first call config.
     */
    getFirstCallConfig() {
      if (!this.functionScopes[0]) {
        return void 0;
      }
      return this.functionScopes[0].getCallConfig();
    }
    /**
     * Gets the ABI from all calls.
     *
     * @returns The ABIs from all calls.
     */
    getAbiFromAllCalls() {
      return getAbisFromAllCalls(this.functionScopes);
    }
    /**
     * Decodes the value from the call result.
     *
     * @param callResult - The call result.
     * @returns The decoded value.
     */
    getDecodedValue(callResult) {
      const logs = this.getDecodedLogs(callResult.receipts);
      const callConfig = this.getFirstCallConfig();
      if (this.functionScopes.length === 1 && callConfig && "bytes" in callConfig.program) {
        return callResultToInvocationResult(callResult, callConfig, logs);
      }
      const encodedResults = decodeContractCallScriptResult(
        callResult,
        (callConfig?.program).id,
        callConfig?.func.outputMetadata.isHeapType || false,
        logs
      );
      const returnValues = encodedResults.map((encodedResult, i) => {
        const { func } = this.functionScopes[i].getCallConfig();
        return func.decodeOutput(encodedResult)?.[0];
      });
      return this.isMultiCall ? returnValues : returnValues?.[0];
    }
    /**
     * Decodes the logs from the receipts.
     *
     * @param receipts - The transaction result receipts.
     * @returns The decoded logs.
     */
    getDecodedLogs(receipts) {
      const mainCallConfig = this.getFirstCallConfig();
      if (!mainCallConfig) {
        return [];
      }
      const { main, otherContractsAbis } = this.getAbiFromAllCalls();
      return getDecodedLogs(receipts, main, otherContractsAbis);
    }
  };
  var FunctionInvocationResult = class extends InvocationResult {
    transactionId;
    transactionResponse;
    transactionResult;
    program;
    logs;
    /**
     * Constructs an instance of FunctionInvocationResult.
     *
     * @param funcScopes - The function scopes.
     * @param transactionResponse - The transaction response.
     * @param transactionResult - The transaction result.
     * @param program - The program.
     * @param isMultiCall - Whether it's a multi-call.
     */
    constructor(funcScopes, transactionResponse, transactionResult, program2, isMultiCall) {
      super(funcScopes, transactionResult, isMultiCall);
      this.transactionResponse = transactionResponse;
      this.transactionResult = transactionResult;
      this.transactionId = this.transactionResponse.id;
      this.program = program2;
      this.logs = this.getDecodedLogs(transactionResult.receipts);
    }
    /**
     * Builds an instance of FunctionInvocationResult.
     *
     * @param funcScope - The function scope.
     * @param transactionResponse - The transaction response.
     * @param isMultiCall - Whether it's a multi-call.
     * @param program - The program.
     * @returns The function invocation result.
     */
    static async build(funcScope, transactionResponse, isMultiCall, program2) {
      const txResult = await transactionResponse.waitForResult();
      const fnResult = new FunctionInvocationResult(
        funcScope,
        transactionResponse,
        txResult,
        program2,
        isMultiCall
      );
      return fnResult;
    }
  };
  var InvocationCallResult = class extends InvocationResult {
    callResult;
    /**
     * Constructs an instance of InvocationCallResult.
     *
     * @param funcScopes - The function scopes.
     * @param callResult - The call result.
     * @param isMultiCall - Whether it's a multi-call.
     */
    constructor(funcScopes, callResult, isMultiCall) {
      super(funcScopes, callResult, isMultiCall);
      this.callResult = callResult;
    }
    /**
     * Builds an instance of InvocationCallResult.
     *
     * @param funcScopes - The function scopes.
     * @param callResult - The call result.
     * @param isMultiCall - Whether it's a multi-call.
     * @returns The invocation call result.
     */
    static async build(funcScopes, callResult, isMultiCall) {
      const fnResult = await new InvocationCallResult(funcScopes, callResult, isMultiCall);
      return fnResult;
    }
  };
  function createContractCall(funcScope, offset) {
    const { program: program2, args, forward, func, callParameters } = funcScope.getCallConfig();
    const DATA_POINTER_OFFSET = funcScope.getCallConfig().func.isInputDataPointer ? POINTER_DATA_OFFSET : 0;
    const data = func.encodeArguments(args, offset + DATA_POINTER_OFFSET);
    return {
      contractId: program2.id,
      fnSelector: func.selector,
      data,
      isInputDataPointer: func.isInputDataPointer,
      isOutputDataHeap: func.outputMetadata.isHeapType,
      outputEncodedLength: func.outputMetadata.encodedLength,
      assetId: forward?.assetId,
      amount: forward?.amount,
      gas: callParameters?.gasLimit
    };
  }
  var BaseInvocationScope = class {
    transactionRequest;
    program;
    functionInvocationScopes = [];
    txParameters;
    requiredCoins = [];
    isMultiCall = false;
    hasCallParamsGasLimit = false;
    // flag to check if any of the callParams has gasLimit set
    externalAbis = {};
    addSignersCallback;
    /**
     * Constructs an instance of BaseInvocationScope.
     *
     * @param program - The abstract program to be invoked.
     * @param isMultiCall - A flag indicating whether the invocation is a multi-call.
     */
    constructor(program2, isMultiCall) {
      this.program = program2;
      this.isMultiCall = isMultiCall;
      this.transactionRequest = new ScriptTransactionRequest();
    }
    /**
     * Getter for the contract calls.
     *
     * @returns An array of contract calls.
     */
    get calls() {
      const provider = this.getProvider();
      const consensusParams = provider.getChain().consensusParameters;
      if (!consensusParams) {
        throw new FuelError(
          FuelError.CODES.CHAIN_INFO_CACHE_EMPTY,
          "Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `await Provider.create()``"
        );
      }
      const maxInputs = consensusParams.maxInputs;
      const script = getContractCallScript(this.functionInvocationScopes, maxInputs);
      return this.functionInvocationScopes.map(
        (funcScope) => createContractCall(funcScope, script.getScriptDataOffset(maxInputs.toNumber()))
      );
    }
    /**
     * Updates the script request with the current contract calls.
     */
    updateScriptRequest() {
      const maxInputs = this.program.provider.getChain().consensusParameters.maxInputs;
      const contractCallScript = getContractCallScript(this.functionInvocationScopes, maxInputs);
      this.transactionRequest.setScript(contractCallScript, this.calls);
    }
    /**
     * Updates the transaction request with the current input/output.
     */
    updateContractInputAndOutput() {
      const calls = this.calls;
      calls.forEach((c) => {
        if (c.contractId) {
          this.transactionRequest.addContractInputAndOutput(c.contractId);
        }
      });
    }
    /**
     * Gets the required coins for the transaction.
     *
     * @returns An array of required coin quantities.
     */
    getRequiredCoins() {
      const forwardingAssets = this.calls.map((call2) => ({
        assetId: String(call2.assetId),
        amount: bn(call2.amount || 0)
      })).filter(({ assetId, amount }) => assetId && !bn(amount).isZero());
      return forwardingAssets;
    }
    /**
     * Updates the required coins for the transaction.
     */
    updateRequiredCoins() {
      const assets3 = this.getRequiredCoins();
      const reduceForwardCoins = (requiredCoins, { assetId, amount }) => {
        const currentAmount = requiredCoins.get(assetId)?.amount || bn(0);
        return requiredCoins.set(assetId, {
          assetId: String(assetId),
          amount: currentAmount.add(amount)
        });
      };
      this.requiredCoins = Array.from(
        assets3.reduce(reduceForwardCoins, /* @__PURE__ */ new Map()).values()
      );
    }
    /**
     * Adds a single call to the invocation scope.
     *
     * @param funcScope - The function scope to add.
     * @returns The current instance of the class.
     */
    addCall(funcScope) {
      this.addCalls([funcScope]);
      return this;
    }
    /**
     * Adds multiple calls to the invocation scope.
     *
     * @param funcScopes - An array of function scopes to add.
     * @returns The current instance of the class.
     */
    addCalls(funcScopes) {
      this.functionInvocationScopes.push(...funcScopes);
      this.updateContractInputAndOutput();
      this.updateRequiredCoins();
      return this;
    }
    /**
     * Prepares the transaction by updating the script request, required coins, and checking the gas limit.
     */
    async prepareTransaction() {
      await asm2.initWasm();
      this.updateScriptRequest();
      this.updateRequiredCoins();
      this.checkGasLimitTotal();
      if (this.transactionRequest.type === TransactionType.Script) {
        this.transactionRequest.abis = getAbisFromAllCalls(this.functionInvocationScopes);
      }
    }
    /**
     * Checks if the total gas limit is within the acceptable range.
     */
    checkGasLimitTotal() {
      const gasLimitOnCalls = this.calls.reduce((total, call2) => total.add(call2.gas || 0), bn(0));
      if (this.transactionRequest.gasLimit.eq(0)) {
        this.transactionRequest.gasLimit = gasLimitOnCalls;
      } else if (gasLimitOnCalls.gt(this.transactionRequest.gasLimit)) {
        throw new FuelError(
          ErrorCode.TRANSACTION_ERROR,
          "Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls."
        );
      }
    }
    /**
     * Gets the transaction cost ny dry running the transaction.
     *
     * @param options - Optional transaction cost options.
     * @returns The transaction cost details.
     */
    async getTransactionCost(options) {
      const provider = this.getProvider();
      const request = await this.getTransactionRequest();
      request.gasPrice = bn(toNumber2(request.gasPrice) || toNumber2(options?.gasPrice || 0));
      const txCost = await provider.getTransactionCost(request, this.getRequiredCoins(), {
        resourcesOwner: this.program.account,
        signatureCallback: this.addSignersCallback
      });
      return txCost;
    }
    /**
     * Funds the transaction with the required coins.
     *
     * @returns The current instance of the class.
     */
    async fundWithRequiredCoins() {
      const transactionRequest = await this.getTransactionRequest();
      const {
        maxFee,
        gasUsed,
        minGasPrice,
        estimatedInputs,
        outputVariables,
        missingContractIds,
        requiredQuantities
      } = await this.getTransactionCost();
      this.setDefaultTxParams(transactionRequest, minGasPrice, gasUsed);
      this.transactionRequest.inputs = this.transactionRequest.inputs.filter(
        (i) => i.type !== InputType.Coin
      );
      await this.program.account?.fund(this.transactionRequest, requiredQuantities, maxFee);
      this.transactionRequest.updatePredicateInputs(estimatedInputs);
      missingContractIds.forEach((contractId) => {
        this.transactionRequest.addContractInputAndOutput(Address.fromString(contractId));
      });
      this.transactionRequest.addVariableOutputs(outputVariables);
      if (this.addSignersCallback) {
        await this.addSignersCallback(this.transactionRequest);
      }
      return this;
    }
    /**
     * Sets the transaction parameters.
     *
     * @param txParams - The transaction parameters to set.
     * @returns The current instance of the class.
     */
    txParams(txParams) {
      this.txParameters = txParams;
      const request = this.transactionRequest;
      const { minGasPrice } = this.getProvider().getGasConfig();
      request.gasPrice = bn(txParams.gasPrice || request.gasPrice || minGasPrice);
      request.gasLimit = bn(txParams.gasLimit || request.gasLimit);
      request.maxFee = txParams.maxFee ? bn(txParams.maxFee) : request.maxFee;
      request.witnessLimit = txParams.witnessLimit ? bn(txParams.witnessLimit) : request.witnessLimit;
      request.maturity = txParams.maturity || request.maturity;
      request.addVariableOutputs(this.txParameters?.variableOutputs || 0);
      return this;
    }
    /**
     * Adds contracts to the invocation scope.
     *
     * @param contracts - An array of contracts to add.
     * @returns The current instance of the class.
     */
    addContracts(contracts) {
      contracts.forEach((contract) => {
        this.transactionRequest.addContractInputAndOutput(contract.id);
        this.externalAbis[contract.id.toB256()] = contract.interface.jsonAbi;
      });
      return this;
    }
    /**
     * Adds an asset transfer to an Account on the contract call transaction request.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @returns The current instance of the class.
     */
    addTransfer(destination, amount, assetId) {
      this.transactionRequest = this.transactionRequest.addCoinOutput(
        Address.fromAddressOrString(destination),
        amount,
        assetId
      );
      return this;
    }
    addSigners(signers) {
      this.addSignersCallback = async (transactionRequest) => transactionRequest.addAccountWitnesses(signers);
      return this;
    }
    /**
     * Prepares and returns the transaction request object.
     *
     * @returns The prepared transaction request.
     */
    async getTransactionRequest() {
      await this.prepareTransaction();
      return this.transactionRequest;
    }
    /**
     * Submits a transaction.
     *
     * @returns The result of the function invocation.
     */
    async call() {
      assert4(this.program.account, "Wallet is required!");
      await this.fundWithRequiredCoins();
      const response = await this.program.account.sendTransaction(
        await this.getTransactionRequest(),
        {
          awaitExecution: true,
          estimateTxDependencies: false
        }
      );
      return FunctionInvocationResult.build(
        this.functionInvocationScopes,
        response,
        this.isMultiCall,
        this.program
      );
    }
    /**
     * Simulates a transaction.
     *
     * @returns The result of the invocation call.
     */
    async simulate() {
      assert4(this.program.account, "Wallet is required!");
      if (!("populateTransactionWitnessesSignature" in this.program.account)) {
        throw new FuelError(
          ErrorCode.ABI_MAIN_METHOD_MISSING,
          "An unlocked wallet is required to simulate a contract call."
        );
      }
      await this.fundWithRequiredCoins();
      const result = await this.program.account.simulateTransaction(
        await this.getTransactionRequest(),
        {
          estimateTxDependencies: false
        }
      );
      return InvocationCallResult.build(this.functionInvocationScopes, result, this.isMultiCall);
    }
    /**
     * Executes a transaction in dry run mode.
     *
     * @returns The result of the invocation call.
     */
    async dryRun() {
      const { receipts } = await this.getTransactionCost();
      const callResult = {
        receipts
      };
      return InvocationCallResult.build(
        this.functionInvocationScopes,
        callResult,
        this.isMultiCall
      );
    }
    async get() {
      const { receipts } = await this.getTransactionCost();
      const callResult = {
        receipts
      };
      return InvocationCallResult.build(
        this.functionInvocationScopes,
        callResult,
        this.isMultiCall
      );
    }
    getProvider() {
      const provider = this.program.provider;
      return provider;
    }
    /**
     * Obtains the ID of a transaction.
     *
     * @param chainId - the chainId to use to hash the transaction with
     * @returns the ID of the transaction.
     */
    async getTransactionId(chainId) {
      const chainIdToHash = chainId ?? await this.getProvider().getChainId();
      const transactionRequest = await this.getTransactionRequest();
      return transactionRequest.getTransactionId(chainIdToHash);
    }
    /**
     * In case the gasLimit and gasPrice are *not* set by the user, this method sets some default values.
     */
    setDefaultTxParams(transactionRequest, minGasPrice, gasUsed) {
      const gasLimitSpecified = !!this.txParameters?.gasLimit || this.hasCallParamsGasLimit;
      const gasPriceSpecified = !!this.txParameters?.gasPrice;
      const { gasLimit, gasPrice } = transactionRequest;
      if (!gasLimitSpecified) {
        transactionRequest.gasLimit = gasUsed;
      } else if (gasLimit.lt(gasUsed)) {
        throw new FuelError(
          ErrorCode.GAS_LIMIT_TOO_LOW,
          `Gas limit '${gasLimit}' is lower than the required: '${gasUsed}'.`
        );
      }
      if (!gasPriceSpecified) {
        transactionRequest.gasPrice = minGasPrice;
      } else if (gasPrice.lt(minGasPrice)) {
        throw new FuelError(
          ErrorCode.GAS_PRICE_TOO_LOW,
          `Gas price '${gasPrice}' is lower than the required: '${minGasPrice}'.`
        );
      }
    }
  };
  var FunctionInvocationScope = class extends BaseInvocationScope {
    func;
    callParameters;
    forward;
    args;
    /**
     * Constructs an instance of FunctionInvocationScope.
     *
     * @param program - The program.
     * @param func - The function fragment.
     * @param args - The arguments.
     */
    constructor(program2, func, args) {
      super(program2, false);
      this.func = func;
      this.args = args || [];
      this.setArguments(...args);
      super.addCall(this);
    }
    /**
     * Gets the call configuration.
     *
     * @returns The call configuration.
     */
    getCallConfig() {
      return {
        func: this.func,
        program: this.program,
        callParameters: this.callParameters,
        txParameters: this.txParameters,
        forward: this.forward,
        args: this.args,
        externalAbis: this.externalAbis
      };
    }
    /**
     * Sets the arguments for the function invocation.
     *
     * @param args - The arguments.
     * @returns The instance of FunctionInvocationScope.
     */
    setArguments(...args) {
      this.args = args || [];
      return this;
    }
    /**
     * Sets the call parameters for the function invocation.
     *
     * @param callParams - The call parameters.
     * @returns The instance of FunctionInvocationScope.
     * @throws If the function is not payable and forward is set.
     */
    callParams(callParams) {
      if (!this.hasCallParamsGasLimit && callParams?.gasLimit !== void 0) {
        this.hasCallParamsGasLimit = true;
      }
      this.callParameters = callParams;
      if (callParams?.forward) {
        if (!this.func.attributes.find((attr) => attr.name === "payable")) {
          throw new FuelError(
            ErrorCode.TRANSACTION_ERROR,
            `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`
          );
        }
        this.forward = coinQuantityfy(callParams.forward);
      }
      this.setArguments(...this.args);
      this.updateRequiredCoins();
      return this;
    }
  };
  var MultiCallInvocationScope = class extends BaseInvocationScope {
    /**
     * Constructs an instance of MultiCallInvocationScope.
     *
     * @param contract - The contract.
     * @param funcScopes - An array of function invocation scopes.
     */
    constructor(contract, funcScopes) {
      super(contract, true);
      this.addCalls(funcScopes);
      this.validateHeapTypeReturnCalls();
    }
    /**
     * Adds a single function invocation scope to the multi-call invocation scope.
     *
     * @param funcScope - The function invocation scope.
     * @returns The instance of MultiCallInvocationScope.
     */
    addCall(funcScope) {
      return super.addCalls([funcScope]);
    }
    /**
     * Adds multiple function invocation scopes to the multi-call invocation scope.
     *
     * @param funcScopes - An array of function invocation scopes.
     * @returns The instance of MultiCallInvocationScope.
     */
    addCalls(funcScopes) {
      return super.addCalls(funcScopes);
    }
    validateHeapTypeReturnCalls() {
      let heapOutputIndex = -1;
      let numberOfHeaps = 0;
      this.calls.forEach((call2, callIndex) => {
        const { isOutputDataHeap } = call2;
        if (isOutputDataHeap) {
          heapOutputIndex = callIndex;
          if (++numberOfHeaps > 1) {
            throw new FuelError(
              ErrorCode.INVALID_MULTICALL,
              "A multicall can have only one call that returns a heap type."
            );
          }
        }
      });
      const hasHeapTypeReturn = heapOutputIndex !== -1;
      const isOnLastCall = heapOutputIndex === this.calls.length - 1;
      if (hasHeapTypeReturn && !isOnLastCall) {
        throw new FuelError(
          ErrorCode.INVALID_MULTICALL,
          "In a multicall, the contract call returning a heap type must be the last call."
        );
      }
    }
  };
  var Contract = class {
    /**
     * The unique contract identifier.
     */
    id;
    /**
     * The provider for interacting with the contract.
     */
    provider;
    /**
     * The contract's ABI interface.
     */
    interface;
    /**
     * The account associated with the contract, if available.
     */
    account;
    /**
     * A collection of functions available on the contract.
     */
    functions = {};
    /**
     * Creates an instance of the Contract class.
     *
     * @param id - The contract's address.
     * @param abi - The contract's ABI (JSON ABI or Interface instance).
     * @param accountOrProvider - The account or provider for interaction.
     */
    constructor(id, abi, accountOrProvider) {
      this.interface = abi instanceof Interface ? abi : new Interface(abi);
      this.id = Address.fromAddressOrString(id);
      if (accountOrProvider && "provider" in accountOrProvider) {
        this.provider = accountOrProvider.provider;
        this.account = accountOrProvider;
      } else {
        this.provider = accountOrProvider;
        this.account = null;
      }
      Object.keys(this.interface.functions).forEach((name) => {
        const fragment = this.interface.getFunction(name);
        Object.defineProperty(this.functions, fragment.name, {
          value: this.buildFunction(fragment),
          writable: false
        });
      });
    }
    /**
     * Build a function invocation scope for the provided function fragment.
     *
     * @param func - The function fragment to build a scope for.
     * @returns A function that creates a FunctionInvocationScope.
     */
    buildFunction(func) {
      return (...args) => new FunctionInvocationScope(this, func, args);
    }
    /**
     * Create a multi-call invocation scope for the provided function invocation scopes.
     *
     * @param calls - An array of FunctionInvocationScopes to execute in a batch.
     * @returns A MultiCallInvocationScope instance.
     */
    multiCall(calls) {
      return new MultiCallInvocationScope(this, calls);
    }
    /**
     * Get the balance for a given asset ID for this contract.
     *
     * @param assetId - The specified asset ID.
     * @returns The balance of the contract for the specified asset.
     */
    // #region contract-balance-1
    getBalance(assetId) {
      return this.provider.getContractBalance(this.id, assetId);
    }
    // #endregion contract-balance-1
  };

  // ../contract/dist/index.mjs
  var __defProp7 = Object.defineProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp7(target, name, { get: all[name], enumerable: true });
  };
  var util_exports = {};
  __export2(util_exports, {
    getContractId: () => getContractId,
    getContractRoot: () => getContractRoot,
    getContractStorageRoot: () => getContractStorageRoot,
    hexlifyWithPrefix: () => hexlifyWithPrefix
  });
  var getContractRoot = (bytecode) => {
    const chunkSize = 16 * 1024;
    const bytes3 = arrayify(bytecode);
    const chunks = chunkAndPadBytes(bytes3, chunkSize);
    return calcRoot(chunks.map((c) => hexlify(c)));
  };
  var getContractStorageRoot = (storageSlots) => {
    const tree = new SparseMerkleTree();
    storageSlots.forEach(({ key, value }) => tree.update(sha2563(key), value));
    return tree.root;
  };
  var getContractId = (bytecode, salt, stateRoot) => {
    const root = getContractRoot(arrayify(bytecode));
    const contractId = sha2563(concat(["0x4655454C", salt, root, stateRoot]));
    return contractId;
  };
  var hexlifyWithPrefix = (value, isKnownHex = false) => {
    if (value.startsWith("0x")) {
      return hexlify(value);
    }
    if (isKnownHex) {
      return hexlify(`0x${value}`);
    }
    throw new FuelError(FuelError.CODES.UNEXPECTED_HEX_VALUE, `Value should be hex string ${value}.`);
  };
  var ContractFactory = class {
    bytecode;
    interface;
    provider;
    account;
    /**
     * Create a ContractFactory instance.
     *
     * @param bytecode - The bytecode of the contract.
     * @param abi - The contract's ABI (Application Binary Interface).
     * @param accountOrProvider - An account or provider to be associated with the factory.
     */
    constructor(bytecode, abi, accountOrProvider = null) {
      this.bytecode = arrayify(bytecode);
      if (abi instanceof Interface) {
        this.interface = abi;
      } else {
        this.interface = new Interface(abi);
      }
      if (accountOrProvider && "provider" in accountOrProvider) {
        this.provider = accountOrProvider.provider;
        this.account = accountOrProvider;
      } else {
        this.provider = accountOrProvider;
        this.account = null;
      }
    }
    /**
     * Connect the factory to a provider.
     *
     * @param provider - The provider to be associated with the factory.
     * @returns A new ContractFactory instance.
     */
    connect(provider) {
      return new ContractFactory(this.bytecode, this.interface, provider);
    }
    /**
     * Create a transaction request to deploy a contract with the specified options.
     *
     * @param deployContractOptions - Options for deploying the contract.
     * @returns The CreateTransactionRequest object for deploying the contract.
     */
    createTransactionRequest(deployContractOptions) {
      const storageSlots = deployContractOptions?.storageSlots?.map(({ key, value }) => ({
        key: hexlifyWithPrefix(key, true),
        value: hexlifyWithPrefix(value, true)
      })).sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));
      const options = {
        salt: randomBytes22(32),
        ...deployContractOptions,
        storageSlots: storageSlots || []
      };
      if (!this.provider) {
        throw new FuelError(
          ErrorCode.MISSING_PROVIDER,
          "Cannot create transaction request without provider"
        );
      }
      const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);
      const contractId = getContractId(this.bytecode, options.salt, stateRoot);
      const transactionRequest = new CreateTransactionRequest({
        gasPrice: 0,
        bytecodeWitnessIndex: 0,
        witnesses: [this.bytecode],
        ...options
      });
      transactionRequest.addContractCreatedOutput(contractId, stateRoot);
      return {
        contractId,
        transactionRequest
      };
    }
    /**
     * Deploy a contract with the specified options.
     *
     * @param deployContractOptions - Options for deploying the contract.
     * @returns A promise that resolves to the deployed contract instance.
     */
    async deployContract(deployContractOptions = {}) {
      if (!this.account) {
        throw new FuelError(ErrorCode.ACCOUNT_REQUIRED, "Cannot deploy Contract without account.");
      }
      const { configurableConstants } = deployContractOptions;
      if (configurableConstants) {
        this.setConfigurableConstants(configurableConstants);
      }
      const { contractId, transactionRequest } = this.createTransactionRequest(deployContractOptions);
      const { requiredQuantities, maxFee } = await this.account.provider.getTransactionCost(transactionRequest);
      transactionRequest.gasPrice = this.account.provider.getGasConfig().minGasPrice;
      transactionRequest.maxFee = this.account.provider.getGasConfig().maxGasPerTx;
      await this.account.fund(transactionRequest, requiredQuantities, maxFee);
      await this.account.sendTransaction(transactionRequest, {
        awaitExecution: true
      });
      return new Contract(contractId, this.interface, this.account);
    }
    /**
     * Set configurable constants of the contract with the specified values.
     *
     * @param configurableConstants - An object containing configurable names and their values.
     */
    setConfigurableConstants(configurableConstants) {
      try {
        const hasConfigurable = Object.keys(this.interface.configurables).length;
        if (!hasConfigurable) {
          throw new Error("Contract does not have configurables to be set");
        }
        Object.entries(configurableConstants).forEach(([key, value]) => {
          if (!this.interface.configurables[key]) {
            throw new Error(`Contract does not have a configurable named: '${key}'`);
          }
          const { offset } = this.interface.configurables[key];
          const encoded = this.interface.encodeConfigurable(key, value);
          const bytes3 = arrayify(this.bytecode);
          bytes3.set(encoded, offset);
          this.bytecode = bytes3;
        });
      } catch (err) {
        throw new FuelError(
          ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
          `Error setting configurable constants on contract: ${err.message}.`
        );
      }
    }
  };

  // src/cli/commands/deploy/deployContract.ts
  var import_fs7 = __require2("fs");
  async function deployContract(wallet, binaryPath, abiPath, storageSlotsPath, deployConfig) {
    debug(`Deploying contract for ABI: ${abiPath}`);
    const bytecode = (0, import_fs7.readFileSync)(binaryPath);
    if ((0, import_fs7.existsSync)(storageSlotsPath)) {
      const storageSlots = JSON.parse((0, import_fs7.readFileSync)(storageSlotsPath, "utf-8"));
      deployConfig.storageSlots = storageSlots;
    }
    const { minGasPrice: gasPrice } = wallet.provider.getGasConfig();
    const abi = JSON.parse((0, import_fs7.readFileSync)(abiPath, "utf-8"));
    const contractFactory = new ContractFactory(bytecode, abi, wallet);
    deployConfig.gasPrice = deployConfig.gasPrice ?? gasPrice;
    const contract = await contractFactory.deployContract(deployConfig);
    return contract.id.toB256();
  }

  // src/cli/commands/deploy/getDeployConfig.ts
  async function getDeployConfig(deployConfig, options) {
    let config;
    if (typeof deployConfig === "function") {
      config = await deployConfig(options);
    } else {
      config = deployConfig;
    }
    return config;
  }

  // src/cli/commands/deploy/saveContractIds.ts
  var import_promises2 = __require2("fs/promises");
  var import_path14 = __require2("path");
  async function saveContractIds(contracts, output3) {
    const contractsMap = contracts.reduce(
      (cConfig, { name, contractId }) => ({
        ...cConfig,
        [name]: contractId
      }),
      {}
    );
    const filePath = (0, import_path14.resolve)(output3, "contract-ids.json");
    await (0, import_promises2.mkdir)(output3, { recursive: true });
    await (0, import_promises2.writeFile)(filePath, JSON.stringify(contractsMap, null, 2));
    log(`Contract IDs saved at: ${filePath}`);
  }

  // src/cli/commands/deploy/index.ts
  async function deploy(config) {
    const contracts = [];
    const wallet = await createWallet(config.providerUrl, config.privateKey);
    log(`Deploying contracts to: ${wallet.provider.url}`);
    const contractsLen = config.contracts.length;
    for (let i = 0; i < contractsLen; i++) {
      const contractPath = config.contracts[i];
      const binaryPath = getBinaryPath(contractPath, config);
      const abiPath = getABIPath(contractPath, config);
      const storageSlotsPath = getStorageSlotsPath(contractPath, config);
      const projectName = getContractName(contractPath);
      const contractName = getContractCamelCase(contractPath);
      const deployConfig = await getDeployConfig(config.deployConfig, {
        contracts: Array.from(contracts),
        contractName,
        contractPath
      });
      const contractId = await deployContract(
        wallet,
        binaryPath,
        abiPath,
        storageSlotsPath,
        deployConfig
      );
      debug(`Contract deployed: ${projectName} - ${contractId}`);
      contracts.push({
        name: contractName,
        contractId
      });
    }
    await saveContractIds(contracts, config.output);
    return contracts;
  }

  // ../account/dist/test-utils.mjs
  var import_graphql_request2 = __toESM(require_dist2(), 1);
  var asm4 = __toESM(require_node(), 1);
  var import_child_process2 = __require2("child_process");
  var import_crypto25 = __require2("crypto");
  var import_fs8 = __require2("fs");
  var import_os = __toESM(__require2("os"), 1);
  var import_path15 = __toESM(__require2("path"), 1);
  var import_portfinder = __toESM(require_portfinder(), 1);
  var import_tree_kill = __toESM(require_tree_kill(), 1);
  var __defProp8 = Object.defineProperty;
  var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField7 = (obj, key, value) => {
    __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck4 = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateAdd4 = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateMethod4 = (obj, member, method) => {
    __accessCheck4(obj, member, "access private method");
    return method;
  };
  var coinQuantityfy2 = (coinQuantityLike) => {
    let assetId;
    let amount;
    let max2;
    if (Array.isArray(coinQuantityLike)) {
      amount = coinQuantityLike[0];
      assetId = coinQuantityLike[1] ?? BaseAssetId;
      max2 = coinQuantityLike[2] ?? void 0;
    } else {
      amount = coinQuantityLike.amount;
      assetId = coinQuantityLike.assetId ?? BaseAssetId;
      max2 = coinQuantityLike.max ?? void 0;
    }
    const bnAmount = bn(amount);
    return {
      assetId: hexlify(assetId),
      amount: bnAmount.lt(1) ? bn(1) : bnAmount,
      max: max2 ? bn(max2) : void 0
    };
  };
  var addAmountToAsset2 = (params) => {
    const { amount, assetId } = params;
    const coinQuantities = [...params.coinQuantities];
    const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
    if (assetIdx !== -1) {
      coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
    } else {
      coinQuantities.push({ assetId, amount });
    }
    return coinQuantities;
  };
  var ReceiptFragmentFragmentDoc2 = lib_default2`
    fragment receiptFragment on Receipt {
  contract {
    id
  }
  pc
  is
  to {
    id
  }
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
  var TransactionStatusFragmentFragmentDoc2 = lib_default2`
    fragment transactionStatusFragment on TransactionStatus {
  type: __typename
  ... on SubmittedStatus {
    time
  }
  ... on SuccessStatus {
    block {
      id
    }
    time
    programState {
      returnType
      data
    }
  }
  ... on FailureStatus {
    block {
      id
    }
    time
    reason
  }
  ... on SqueezedOutStatus {
    reason
  }
}
    `;
  var TransactionFragmentFragmentDoc2 = lib_default2`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  gasPrice
  receipts {
    ...receiptFragment
  }
  status {
    ...transactionStatusFragment
  }
}
    ${ReceiptFragmentFragmentDoc2}
${TransactionStatusFragmentFragmentDoc2}`;
  var InputEstimatePredicatesFragmentFragmentDoc2 = lib_default2`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
  var TransactionEstimatePredicatesFragmentFragmentDoc2 = lib_default2`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentFragmentDoc2}`;
  var CoinFragmentFragmentDoc2 = lib_default2`
    fragment coinFragment on Coin {
  __typename
  utxoId
  owner
  amount
  assetId
  maturity
  blockCreated
  txCreatedIdx
}
    `;
  var MessageCoinFragmentFragmentDoc2 = lib_default2`
    fragment messageCoinFragment on MessageCoin {
  __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
  var MessageFragmentFragmentDoc2 = lib_default2`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  nonce
  daHeight
}
    `;
  var MessageProofFragmentFragmentDoc2 = lib_default2`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  commitBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  sender
  recipient
  nonce
  amount
  data
}
    `;
  var BalanceFragmentFragmentDoc2 = lib_default2`
    fragment balanceFragment on Balance {
  owner
  amount
  assetId
}
    `;
  var BlockFragmentFragmentDoc2 = lib_default2`
    fragment blockFragment on Block {
  id
  header {
    height
    time
  }
  transactions {
    id
  }
}
    `;
  var TxParametersFragmentFragmentDoc2 = lib_default2`
    fragment TxParametersFragment on TxParameters {
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
}
    `;
  var PredicateParametersFragmentFragmentDoc2 = lib_default2`
    fragment PredicateParametersFragment on PredicateParameters {
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
  var ScriptParametersFragmentFragmentDoc2 = lib_default2`
    fragment ScriptParametersFragment on ScriptParameters {
  maxScriptLength
  maxScriptDataLength
}
    `;
  var ContractParametersFragmentFragmentDoc2 = lib_default2`
    fragment ContractParametersFragment on ContractParameters {
  contractMaxSize
  maxStorageSlots
}
    `;
  var FeeParametersFragmentFragmentDoc2 = lib_default2`
    fragment FeeParametersFragment on FeeParameters {
  gasPriceFactor
  gasPerByte
}
    `;
  var DependentCostFragmentFragmentDoc2 = lib_default2`
    fragment DependentCostFragment on DependentCost {
  __typename
  ... on LightOperation {
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    base
    gasPerUnit
  }
}
    `;
  var GasCostsFragmentFragmentDoc2 = lib_default2`
    fragment GasCostsFragment on GasCosts {
  add
  addi
  aloc
  and
  andi
  bal
  bhei
  bhsh
  burn
  cb
  cfei
  cfsi
  croo
  div
  divi
  ecr1
  eck1
  ed19
  eq
  exp
  expi
  flag
  gm
  gt
  gtf
  ji
  jmp
  jne
  jnei
  jnzi
  jmpf
  jmpb
  jnzf
  jnzb
  jnef
  jneb
  lb
  log
  lt
  lw
  mint
  mlog
  modOp
  modi
  moveOp
  movi
  mroo
  mul
  muli
  mldv
  noop
  not
  or
  ori
  poph
  popl
  pshh
  pshl
  ret
  rvrt
  sb
  sll
  slli
  srl
  srli
  srw
  sub
  subi
  sw
  sww
  time
  tr
  tro
  wdcm
  wqcm
  wdop
  wqop
  wdml
  wqml
  wddv
  wqdv
  wdmd
  wqmd
  wdam
  wqam
  wdmm
  wqmm
  xor
  xori
  call {
    ...DependentCostFragment
  }
  ccp {
    ...DependentCostFragment
  }
  csiz {
    ...DependentCostFragment
  }
  k256 {
    ...DependentCostFragment
  }
  ldc {
    ...DependentCostFragment
  }
  logd {
    ...DependentCostFragment
  }
  mcl {
    ...DependentCostFragment
  }
  mcli {
    ...DependentCostFragment
  }
  mcp {
    ...DependentCostFragment
  }
  mcpi {
    ...DependentCostFragment
  }
  meq {
    ...DependentCostFragment
  }
  retd {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  scwq {
    ...DependentCostFragment
  }
  smo {
    ...DependentCostFragment
  }
  srwq {
    ...DependentCostFragment
  }
  swwq {
    ...DependentCostFragment
  }
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  newStoragePerByte
}
    ${DependentCostFragmentFragmentDoc2}`;
  var ConsensusParametersFragmentFragmentDoc2 = lib_default2`
    fragment consensusParametersFragment on ConsensusParameters {
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentFragmentDoc2}
${PredicateParametersFragmentFragmentDoc2}
${ScriptParametersFragmentFragmentDoc2}
${ContractParametersFragmentFragmentDoc2}
${FeeParametersFragmentFragmentDoc2}
${GasCostsFragmentFragmentDoc2}`;
  var ChainInfoFragmentFragmentDoc2 = lib_default2`
    fragment chainInfoFragment on ChainInfo {
  name
  latestBlock {
    ...blockFragment
  }
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${BlockFragmentFragmentDoc2}
${ConsensusParametersFragmentFragmentDoc2}`;
  var ContractBalanceFragmentFragmentDoc2 = lib_default2`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
  var PageInfoFragmentFragmentDoc2 = lib_default2`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
  var NodeInfoFragmentFragmentDoc2 = lib_default2`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  minGasPrice
  maxTx
  maxDepth
  nodeVersion
  peers {
    id
    addresses
    clientVersion
    blockHeight
    lastHeartbeatMs
    appScore
  }
}
    `;
  var GetVersionDocument2 = lib_default2`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
  var GetNodeInfoDocument2 = lib_default2`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentFragmentDoc2}`;
  var GetChainDocument2 = lib_default2`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentFragmentDoc2}`;
  var GetTransactionDocument2 = lib_default2`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc2}`;
  var GetTransactionWithReceiptsDocument2 = lib_default2`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
    receipts {
      ...receiptFragment
    }
  }
}
    ${TransactionFragmentFragmentDoc2}
${ReceiptFragmentFragmentDoc2}`;
  var GetTransactionsDocument2 = lib_default2`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${TransactionFragmentFragmentDoc2}`;
  var GetTransactionsByOwnerDocument2 = lib_default2`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentFragmentDoc2}
${TransactionFragmentFragmentDoc2}`;
  var EstimatePredicatesDocument2 = lib_default2`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentFragmentDoc2}`;
  var GetBlockDocument2 = lib_default2`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentFragmentDoc2}`;
  var GetBlockWithTransactionsDocument2 = lib_default2`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionFragment
    }
  }
}
    ${BlockFragmentFragmentDoc2}
${TransactionFragmentFragmentDoc2}`;
  var GetBlocksDocument2 = lib_default2`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${BlockFragmentFragmentDoc2}`;
  var GetCoinDocument2 = lib_default2`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
  }
}
    ${CoinFragmentFragmentDoc2}`;
  var GetCoinsDocument2 = lib_default2`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${CoinFragmentFragmentDoc2}`;
  var GetCoinsToSpendDocument2 = lib_default2`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentFragmentDoc2}
${MessageCoinFragmentFragmentDoc2}`;
  var GetContractDocument2 = lib_default2`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
  var GetContractBalanceDocument2 = lib_default2`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentFragmentDoc2}`;
  var GetBalanceDocument2 = lib_default2`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    ...balanceFragment
  }
}
    ${BalanceFragmentFragmentDoc2}`;
  var GetBalancesDocument2 = lib_default2`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...balanceFragment
      }
    }
  }
}
    ${BalanceFragmentFragmentDoc2}`;
  var GetMessagesDocument2 = lib_default2`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...messageFragment
      }
    }
  }
}
    ${MessageFragmentFragmentDoc2}`;
  var GetMessageProofDocument2 = lib_default2`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentFragmentDoc2}`;
  var GetMessageStatusDocument2 = lib_default2`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
  var DryRunDocument2 = lib_default2`
    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {
  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {
    ...receiptFragment
  }
}
    ${ReceiptFragmentFragmentDoc2}`;
  var SubmitDocument2 = lib_default2`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
  var ProduceBlocksDocument2 = lib_default2`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
  var SubmitAndAwaitDocument2 = lib_default2`
    subscription submitAndAwait($encodedTransaction: HexString!) {
  submitAndAwait(tx: $encodedTransaction) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc2}`;
  var StatusChangeDocument2 = lib_default2`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc2}`;
  function getSdk2(requester) {
    return {
      getVersion(variables, options) {
        return requester(GetVersionDocument2, variables, options);
      },
      getNodeInfo(variables, options) {
        return requester(GetNodeInfoDocument2, variables, options);
      },
      getChain(variables, options) {
        return requester(GetChainDocument2, variables, options);
      },
      getTransaction(variables, options) {
        return requester(GetTransactionDocument2, variables, options);
      },
      getTransactionWithReceipts(variables, options) {
        return requester(GetTransactionWithReceiptsDocument2, variables, options);
      },
      getTransactions(variables, options) {
        return requester(GetTransactionsDocument2, variables, options);
      },
      getTransactionsByOwner(variables, options) {
        return requester(GetTransactionsByOwnerDocument2, variables, options);
      },
      estimatePredicates(variables, options) {
        return requester(EstimatePredicatesDocument2, variables, options);
      },
      getBlock(variables, options) {
        return requester(GetBlockDocument2, variables, options);
      },
      getBlockWithTransactions(variables, options) {
        return requester(GetBlockWithTransactionsDocument2, variables, options);
      },
      getBlocks(variables, options) {
        return requester(GetBlocksDocument2, variables, options);
      },
      getCoin(variables, options) {
        return requester(GetCoinDocument2, variables, options);
      },
      getCoins(variables, options) {
        return requester(GetCoinsDocument2, variables, options);
      },
      getCoinsToSpend(variables, options) {
        return requester(GetCoinsToSpendDocument2, variables, options);
      },
      getContract(variables, options) {
        return requester(GetContractDocument2, variables, options);
      },
      getContractBalance(variables, options) {
        return requester(GetContractBalanceDocument2, variables, options);
      },
      getBalance(variables, options) {
        return requester(GetBalanceDocument2, variables, options);
      },
      getBalances(variables, options) {
        return requester(GetBalancesDocument2, variables, options);
      },
      getMessages(variables, options) {
        return requester(GetMessagesDocument2, variables, options);
      },
      getMessageProof(variables, options) {
        return requester(GetMessageProofDocument2, variables, options);
      },
      getMessageStatus(variables, options) {
        return requester(GetMessageStatusDocument2, variables, options);
      },
      dryRun(variables, options) {
        return requester(DryRunDocument2, variables, options);
      },
      submit(variables, options) {
        return requester(SubmitDocument2, variables, options);
      },
      produceBlocks(variables, options) {
        return requester(ProduceBlocksDocument2, variables, options);
      },
      submitAndAwait(variables, options) {
        return requester(SubmitAndAwaitDocument2, variables, options);
      },
      statusChange(variables, options) {
        return requester(StatusChangeDocument2, variables, options);
      }
    };
  }
  var _FuelGraphqlSubscriber2 = class {
    constructor(options) {
      this.options = options;
    }
    stream;
    async setStream() {
      const { url, query, variables, fetchFn } = this.options;
      const response = await fetchFn(`${url}-sub`, {
        method: "POST",
        body: JSON.stringify({
          query: print(query),
          variables
        }),
        headers: {
          "Content-Type": "application/json",
          Accept: "text/event-stream"
        }
      });
      this.stream = response.body.getReader();
    }
    async next() {
      if (!this.stream) {
        await this.setStream();
      }
      while (true) {
        const { value, done } = await this.stream.read();
        if (done) {
          return { value, done };
        }
        const text = _FuelGraphqlSubscriber2.textDecoder.decode(value);
        if (!text.startsWith("data:")) {
          continue;
        }
        let data;
        let errors;
        try {
          ({ data, errors } = JSON.parse(text.replace(/^data:/, "")));
        } catch (e) {
          throw new FuelError(
            ErrorCode.STREAM_PARSING_ERROR,
            `Error while parsing stream data response: ${text}`
          );
        }
        if (Array.isArray(errors)) {
          throw new FuelError(
            FuelError.CODES.INVALID_REQUEST,
            errors.map((err) => err.message).join("\n\n")
          );
        }
        return { value: data, done: false };
      }
    }
    /**
     * Gets called when `break` is called in a `for-await-of` loop.
     */
    async return() {
      await this.stream.cancel();
      this.stream.releaseLock();
      return { done: true, value: void 0 };
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  var FuelGraphqlSubscriber2 = _FuelGraphqlSubscriber2;
  __publicField7(FuelGraphqlSubscriber2, "textDecoder", new TextDecoder());
  var cache2 = {};
  var DEFAULT_TTL_IN_MS2 = 30 * 1e3;
  var MemoryCache2 = class {
    ttl;
    constructor(ttlInMs = DEFAULT_TTL_IN_MS2) {
      this.ttl = ttlInMs;
      if (typeof ttlInMs !== "number" || this.ttl <= 0) {
        throw new FuelError(
          ErrorCode.INVALID_TTL,
          `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
        );
      }
    }
    get(value, isAutoExpiring = true) {
      const key = hexlify(value);
      if (cache2[key]) {
        if (!isAutoExpiring || cache2[key].expires > Date.now()) {
          return cache2[key].value;
        }
        this.del(value);
      }
      return void 0;
    }
    set(value) {
      const expiresAt = Date.now() + this.ttl;
      const key = hexlify(value);
      cache2[key] = {
        expires: expiresAt,
        value
      };
      return expiresAt;
    }
    getAllData() {
      return Object.keys(cache2).reduce((list, key) => {
        const data = this.get(key, false);
        if (data) {
          list.push(data);
        }
        return list;
      }, []);
    }
    getActiveData() {
      return Object.keys(cache2).reduce((list, key) => {
        const data = this.get(key);
        if (data) {
          list.push(data);
        }
        return list;
      }, []);
    }
    del(value) {
      const key = hexlify(value);
      delete cache2[key];
    }
  };
  var inputify2 = (value) => {
    const { type: type3 } = value;
    switch (value.type) {
      case InputType.Coin: {
        const predicate = arrayify(value.predicate ?? "0x");
        const predicateData = arrayify(value.predicateData ?? "0x");
        return {
          type: InputType.Coin,
          txID: hexlify(arrayify(value.id).slice(0, 32)),
          outputIndex: arrayify(value.id)[32],
          owner: hexlify(value.owner),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId),
          txPointer: {
            blockHeight: toNumber2(arrayify(value.txPointer).slice(0, 8)),
            txIndex: toNumber2(arrayify(value.txPointer).slice(8, 16))
          },
          witnessIndex: value.witnessIndex,
          maturity: value.maturity ?? 0,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: predicate.length,
          predicateDataLength: predicateData.length,
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData)
        };
      }
      case InputType.Contract: {
        return {
          type: InputType.Contract,
          txID: ZeroBytes32,
          outputIndex: 0,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32,
          txPointer: {
            blockHeight: toNumber2(arrayify(value.txPointer).slice(0, 8)),
            txIndex: toNumber2(arrayify(value.txPointer).slice(8, 16))
          },
          contractID: hexlify(value.contractId)
        };
      }
      case InputType.Message: {
        const predicate = arrayify(value.predicate ?? "0x");
        const predicateData = arrayify(value.predicateData ?? "0x");
        const data = arrayify(value.data ?? "0x");
        return {
          type: InputType.Message,
          sender: hexlify(value.sender),
          recipient: hexlify(value.recipient),
          amount: bn(value.amount),
          nonce: hexlify(value.nonce),
          witnessIndex: value.witnessIndex,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: predicate.length,
          predicateDataLength: predicateData.length,
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData),
          data: hexlify(data),
          dataLength: data.length
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${type3}.`
        );
      }
    }
  };
  var outputify2 = (value) => {
    const { type: type3 } = value;
    switch (type3) {
      case OutputType.Coin: {
        return {
          type: OutputType.Coin,
          to: hexlify(value.to),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Contract: {
        return {
          type: OutputType.Contract,
          inputIndex: value.inputIndex,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32
        };
      }
      case OutputType.Change: {
        return {
          type: OutputType.Change,
          to: hexlify(value.to),
          amount: bn(0),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Variable: {
        return {
          type: OutputType.Variable,
          to: ZeroBytes32,
          amount: bn(0),
          assetId: ZeroBytes32
        };
      }
      case OutputType.ContractCreated: {
        return {
          type: OutputType.ContractCreated,
          contractId: hexlify(value.contractId),
          stateRoot: hexlify(value.stateRoot)
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction output type: ${type3}.`
        );
      }
    }
  };
  var isCoin2 = (resource) => "id" in resource;
  var doesReceiptHaveMissingOutputVariables2 = (receipt) => receipt.type === ReceiptType.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
  var doesReceiptHaveMissingContractId2 = (receipt) => receipt.type === ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
  var getReceiptsWithMissingData2 = (receipts) => receipts.reduce(
    (memo, receipt) => {
      if (doesReceiptHaveMissingOutputVariables2(receipt)) {
        memo.missingOutputVariables.push(receipt);
      }
      if (doesReceiptHaveMissingContractId2(receipt)) {
        memo.missingOutputContractIds.push(receipt);
      }
      return memo;
    },
    {
      missingOutputVariables: [],
      missingOutputContractIds: []
    }
  );
  var hexOrZero2 = (hex) => hex || ZeroBytes32;
  function assembleReceiptByType2(receipt) {
    const { receiptType } = receipt;
    switch (receiptType) {
      case "CALL": {
        const callReceipt = {
          type: ReceiptType.Call,
          from: hexOrZero2(receipt.contract?.id),
          to: hexOrZero2(receipt?.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero2(receipt.assetId),
          gas: bn(receipt.gas),
          param1: bn(receipt.param1),
          param2: bn(receipt.param2),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return callReceipt;
      }
      case "RETURN": {
        const returnReceipt = {
          type: ReceiptType.Return,
          id: hexOrZero2(receipt.contract?.id),
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return returnReceipt;
      }
      case "RETURN_DATA": {
        const returnDataReceipt = {
          type: ReceiptType.ReturnData,
          id: hexOrZero2(receipt.contract?.id),
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero2(receipt.digest),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return returnDataReceipt;
      }
      case "PANIC": {
        const panicReceipt = {
          type: ReceiptType.Panic,
          id: hexOrZero2(receipt.contract?.id),
          reason: bn(receipt.reason),
          pc: bn(receipt.pc),
          is: bn(receipt.is),
          contractId: hexOrZero2(receipt.contractId)
        };
        return panicReceipt;
      }
      case "REVERT": {
        const revertReceipt = {
          type: ReceiptType.Revert,
          id: hexOrZero2(receipt.contract?.id),
          val: bn(receipt.ra),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return revertReceipt;
      }
      case "LOG": {
        const logReceipt = {
          type: ReceiptType.Log,
          id: hexOrZero2(receipt.contract?.id),
          val0: bn(receipt.ra),
          val1: bn(receipt.rb),
          val2: bn(receipt.rc),
          val3: bn(receipt.rd),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return logReceipt;
      }
      case "LOG_DATA": {
        const logDataReceipt = {
          type: ReceiptType.LogData,
          id: hexOrZero2(receipt.contract?.id),
          val0: bn(receipt.ra),
          val1: bn(receipt.rb),
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero2(receipt.digest),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return logDataReceipt;
      }
      case "TRANSFER": {
        const transferReceipt = {
          type: ReceiptType.Transfer,
          from: hexOrZero2(receipt.contract?.id),
          to: hexOrZero2(receipt.toAddress || receipt?.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero2(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferReceipt;
      }
      case "TRANSFER_OUT": {
        const transferOutReceipt = {
          type: ReceiptType.TransferOut,
          from: hexOrZero2(receipt.contract?.id),
          to: hexOrZero2(receipt.toAddress || receipt.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero2(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferOutReceipt;
      }
      case "SCRIPT_RESULT": {
        const scriptResultReceipt = {
          type: ReceiptType.ScriptResult,
          result: bn(receipt.result),
          gasUsed: bn(receipt.gasUsed)
        };
        return scriptResultReceipt;
      }
      case "MESSAGE_OUT": {
        const sender = hexOrZero2(receipt.sender);
        const recipient = hexOrZero2(receipt.recipient);
        const nonce = hexOrZero2(receipt.nonce);
        const amount = bn(receipt.amount);
        const data = receipt.data ? arrayify(receipt.data) : Uint8Array.from([]);
        const digest = hexOrZero2(receipt.digest);
        const messageId = ReceiptMessageOutCoder.getMessageId({
          sender,
          recipient,
          nonce,
          amount,
          data
        });
        const receiptMessageOut = {
          type: ReceiptType.MessageOut,
          sender,
          recipient,
          amount,
          nonce,
          data,
          digest,
          messageId
        };
        return receiptMessageOut;
      }
      case "MINT": {
        const contractId = hexOrZero2(receipt.contract?.id);
        const subId = hexOrZero2(receipt.subId);
        const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
        const mintReceipt = {
          type: ReceiptType.Mint,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return mintReceipt;
      }
      case "BURN": {
        const contractId = hexOrZero2(receipt.contract?.id);
        const subId = hexOrZero2(receipt.subId);
        const assetId = ReceiptBurnCoder.getAssetId(contractId, subId);
        const burnReceipt = {
          type: ReceiptType.Burn,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return burnReceipt;
      }
      default:
        throw new FuelError(ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
    }
  }
  var calculatePriceWithFactor2 = (gas, gasPrice, priceFactor) => bn(Math.ceil(gas.mul(gasPrice).toNumber() / priceFactor.toNumber()));
  var getGasUsedFromReceipts2 = (receipts) => {
    const scriptResult = receipts.filter(
      (receipt) => receipt.type === ReceiptType.ScriptResult
    );
    const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn(0));
    return gasUsed;
  };
  function resolveGasDependentCosts2(byteSize, gasDependentCost) {
    const base = bn(gasDependentCost.base);
    let dependentValue = bn(0);
    if (gasDependentCost.__typename === "LightOperation") {
      dependentValue = bn(byteSize).div(bn(gasDependentCost.unitsPerGas));
    }
    if (gasDependentCost.__typename === "HeavyOperation") {
      dependentValue = bn(byteSize).mul(bn(gasDependentCost.gasPerUnit));
    }
    return base.add(dependentValue);
  }
  function gasUsedByInputs2(inputs, txBytesSize, gasCosts) {
    const witnessCache = [];
    const totalGas = inputs.reduce((total, input) => {
      if ("predicate" in input && input.predicate && input.predicate !== "0x") {
        return total.add(
          resolveGasDependentCosts2(txBytesSize, gasCosts.vmInitialization).add(resolveGasDependentCosts2(arrayify(input.predicate).length, gasCosts.contractRoot)).add(bn(input.predicateGasUsed))
        );
      }
      if ("witnessIndex" in input && !witnessCache.includes(input.witnessIndex)) {
        witnessCache.push(input.witnessIndex);
        return total.add(gasCosts.ecr1);
      }
      return total;
    }, bn());
    return totalGas;
  }
  function getMinGas2(params) {
    const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
    const vmInitGas = resolveGasDependentCosts2(txBytesSize, gasCosts.vmInitialization);
    const bytesGas = bn(txBytesSize).mul(gasPerByte);
    const inputsGas = gasUsedByInputs2(inputs, txBytesSize, gasCosts);
    const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
    return minGas;
  }
  function getMaxGas2(params) {
    const { gasPerByte, witnessesLength, witnessLimit, minGas, gasLimit = bn(0) } = params;
    let remainingAllowedWitnessGas = bn(0);
    if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
      remainingAllowedWitnessGas = bn(witnessLimit).sub(witnessesLength).mul(gasPerByte);
    }
    return remainingAllowedWitnessGas.add(minGas).add(gasLimit);
  }
  function calculateMetadataGasForTxCreate2({
    gasCosts,
    stateRootSize,
    txBytesSize,
    contractBytesSize
  }) {
    const contractRootGas = resolveGasDependentCosts2(contractBytesSize, gasCosts.contractRoot);
    const stateRootGas = resolveGasDependentCosts2(stateRootSize, gasCosts.stateRoot);
    const txIdGas = resolveGasDependentCosts2(txBytesSize, gasCosts.s256);
    const contractIdInputSize = bn(4 + 32 + 32 + 32);
    const contractIdGas = resolveGasDependentCosts2(contractIdInputSize, gasCosts.s256);
    const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
    return metadataGas.maxU64();
  }
  function calculateMetadataGasForTxScript2({
    gasCosts,
    txBytesSize
  }) {
    return resolveGasDependentCosts2(txBytesSize, gasCosts.s256);
  }
  function normalize4(object2) {
    Object.keys(object2).forEach((key) => {
      switch (object2[key]?.constructor.name) {
        case "Uint8Array":
          object2[key] = hexlify(object2[key]);
          break;
        case "Array":
          object2[key] = normalize4(object2[key]);
          break;
        case "BN":
          object2[key] = object2[key].toHex();
          break;
        case "Address":
          object2[key] = object2[key].toB256();
          break;
        case "Object":
          object2[key] = normalize4(object2[key]);
          break;
        default:
          break;
      }
    });
    return object2;
  }
  function normalizeJSON2(root) {
    return normalize4(clone_default(root));
  }
  function sleep2(time) {
    return new Promise((resolve4) => {
      setTimeout(() => {
        resolve4(true);
      }, time);
    });
  }
  var NoWitnessAtIndexError2 = class extends Error {
    constructor(index) {
      super();
      this.index = index;
      this.message = `Witness at index "${index}" was not found`;
    }
    name = "NoWitnessAtIndexError";
  };
  var witnessify2 = (value) => {
    const data = arrayify(value);
    return {
      data: hexlify(data),
      dataLength: data.length
    };
  };
  var BaseTransactionRequest2 = class {
    /** Gas price for transaction */
    gasPrice;
    /** Block until which tx cannot be included */
    maturity;
    /** The maximum fee payable by this transaction using BASE_ASSET. */
    maxFee;
    /** The maximum amount of witness data allowed for the transaction */
    witnessLimit;
    /** List of inputs */
    inputs = [];
    /** List of outputs */
    outputs = [];
    /** List of witnesses */
    witnesses = [];
    /**
     * Constructor for initializing a base transaction request.
     *
     * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
     */
    constructor({
      gasPrice,
      maturity,
      maxFee,
      witnessLimit,
      inputs,
      outputs,
      witnesses
    } = {}) {
      this.gasPrice = bn(gasPrice);
      this.maturity = maturity ?? 0;
      this.witnessLimit = witnessLimit ? bn(witnessLimit) : void 0;
      this.maxFee = maxFee ? bn(maxFee) : void 0;
      this.inputs = inputs ?? [];
      this.outputs = outputs ?? [];
      this.witnesses = witnesses ?? [];
    }
    static getPolicyMeta(req2) {
      let policyTypes = 0;
      const policies = [];
      if (req2.gasPrice) {
        policyTypes += PolicyType.GasPrice;
        policies.push({ data: req2.gasPrice, type: PolicyType.GasPrice });
      }
      if (req2.witnessLimit) {
        policyTypes += PolicyType.WitnessLimit;
        policies.push({ data: req2.witnessLimit, type: PolicyType.WitnessLimit });
      }
      if (req2.maturity > 0) {
        policyTypes += PolicyType.Maturity;
        policies.push({ data: req2.maturity, type: PolicyType.Maturity });
      }
      if (req2.maxFee) {
        policyTypes += PolicyType.MaxFee;
        policies.push({ data: req2.maxFee, type: PolicyType.MaxFee });
      }
      return {
        policyTypes,
        policies
      };
    }
    /**
     * Method to obtain the base transaction details.
     *
     * @returns The base transaction details.
     */
    getBaseTransaction() {
      const inputs = this.inputs?.map(inputify2) ?? [];
      const outputs = this.outputs?.map(outputify2) ?? [];
      const witnesses = this.witnesses?.map(witnessify2) ?? [];
      const { policyTypes, policies } = BaseTransactionRequest2.getPolicyMeta(this);
      return {
        policyTypes,
        inputs,
        outputs,
        policies,
        witnesses,
        inputsCount: inputs.length,
        outputsCount: outputs.length,
        witnessesCount: witnesses.length
      };
    }
    /**
     * Converts the transaction request to a byte array.
     *
     * @returns The transaction bytes.
     */
    toTransactionBytes() {
      return new TransactionCoder().encode(this.toTransaction());
    }
    /**
     * @hidden
     *
     * Pushes an input to the list without any side effects and returns the index
     */
    pushInput(input) {
      this.inputs.push(input);
      return this.inputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes an output to the list without any side effects and returns the index
     */
    pushOutput(output3) {
      this.outputs.push(output3);
      return this.outputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes a witness to the list and returns the index
     *
     * @param signature - The signature to add to the witness.
     * @returns The index of the created witness.
     */
    addWitness(signature) {
      this.witnesses.push(signature);
      return this.witnesses.length - 1;
    }
    /**
     * @hidden
     *
     * Creates an empty witness without any side effects and returns the index
     *
     * @returns The index of the created witness.
     */
    addEmptyWitness() {
      this.addWitness(concat([ZeroBytes32, ZeroBytes32]));
      return this.witnesses.length - 1;
    }
    /**
     * Updates the witness for a given owner and signature.
     *
     * @param address - The address to get the coin input witness index for.
     * @param signature - The signature to update the witness with.
     */
    updateWitnessByOwner(address, signature) {
      const ownerAddress = Address.fromAddressOrString(address);
      const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
      if (typeof witnessIndex === "number") {
        this.updateWitness(witnessIndex, signature);
      }
    }
    /**
     * Updates an existing witness without any side effects.
     *
     * @param index - The index of the witness to update.
     * @param witness - The new witness.
     * @throws If the witness does not exist.
     */
    updateWitness(index, witness) {
      if (!this.witnesses[index]) {
        throw new NoWitnessAtIndexError2(index);
      }
      this.witnesses[index] = witness;
    }
    /**
     * Helper function to add an external signature to the transaction.
     *
     * @param account - The account/s to sign to the transaction.
     * @returns The transaction with the signature witness added.
     */
    async addAccountWitnesses(account) {
      const accounts = Array.isArray(account) ? account : [account];
      await Promise.all(
        accounts.map(async (acc) => {
          this.addWitness(await acc.signTransaction(this));
        })
      );
      return this;
    }
    /**
     * Gets the coin inputs for a transaction.
     *
     * @returns The coin inputs.
     */
    getCoinInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Coin
      );
    }
    /**
     * Gets the coin outputs for a transaction.
     *
     * @returns The coin outputs.
     */
    getCoinOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Coin
      );
    }
    /**
     * Gets the change outputs for a transaction.
     *
     * @returns The change outputs.
     */
    getChangeOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Change
      );
    }
    /**
     * @hidden
     *
     * Returns the witnessIndex of the found CoinInput.
     */
    getCoinInputWitnessIndexByOwner(owner) {
      const ownerAddress = addressify(owner);
      const found = this.inputs.find((input) => {
        switch (input.type) {
          case InputType.Coin:
            return hexlify(input.owner) === ownerAddress.toB256();
          case InputType.Message:
            return hexlify(input.recipient) === ownerAddress.toB256();
          default:
            return false;
        }
      });
      return found?.witnessIndex;
    }
    /**
     * Adds a single coin input to the transaction and a change output for the related
     * assetId, if one it was not added yet.
     *
     * @param coin - Coin resource.
     * @param predicate - Predicate bytes.
     * @param predicateData - Predicate data bytes.
     */
    addCoinInput(coin, predicate) {
      const { assetId, owner, amount } = coin;
      let witnessIndex;
      if (predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.addEmptyWitness();
        }
      }
      const input = {
        ...coin,
        type: InputType.Coin,
        owner: owner.toB256(),
        amount,
        assetId,
        txPointer: "0x00000000000000000000000000000000",
        witnessIndex,
        predicate: predicate?.bytes,
        predicateData: predicate?.predicateDataBytes
      };
      this.pushInput(input);
      this.addChangeOutput(owner, assetId);
    }
    /**
     * Adds a single message input to the transaction and a change output for the
     * baseAssetId, if one it was not added yet.
     *
     * @param message - Message resource.
     * @param predicate - Predicate bytes.
     * @param predicateData - Predicate data bytes.
     */
    addMessageInput(message, predicate) {
      const { recipient, sender, amount } = message;
      const assetId = BaseAssetId;
      let witnessIndex;
      if (predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.addEmptyWitness();
        }
      }
      const input = {
        ...message,
        type: InputType.Message,
        sender: sender.toB256(),
        recipient: recipient.toB256(),
        amount,
        witnessIndex,
        predicate: predicate?.bytes,
        predicateData: predicate?.predicateDataBytes
      };
      this.pushInput(input);
      this.addChangeOutput(recipient, assetId);
    }
    /**
     * Adds a single resource to the transaction by adding a coin/message input and a
     * change output for the related assetId, if one it was not added yet.
     *
     * @param resource - The resource to add.
     * @returns This transaction.
     */
    addResource(resource) {
      if (isCoin2(resource)) {
        this.addCoinInput(resource);
      } else {
        this.addMessageInput(resource);
      }
      return this;
    }
    /**
     * Adds multiple resources to the transaction by adding coin/message inputs and change
     * outputs from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addResources(resources) {
      resources.forEach((resource) => this.addResource(resource));
      return this;
    }
    /**
     * Adds multiple resources to the transaction by adding coin/message inputs and change
     * outputs from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addPredicateResource(resource, predicate) {
      if (isCoin2(resource)) {
        this.addCoinInput(resource, predicate);
      } else {
        this.addMessageInput(resource, predicate);
      }
      return this;
    }
    /**
     * Adds multiple predicate coin/message inputs to the transaction and change outputs
     * from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addPredicateResources(resources, predicate) {
      resources.forEach((resource) => this.addPredicateResource(resource, predicate));
      return this;
    }
    /**
     * Adds a coin output to the transaction.
     *
     * @param to - Address of the owner.
     * @param amount - Amount of coin.
     * @param assetId - Asset ID of coin.
     */
    addCoinOutput(to, amount, assetId = BaseAssetId) {
      this.pushOutput({
        type: OutputType.Coin,
        to: addressify(to).toB256(),
        amount,
        assetId
      });
      return this;
    }
    /**
     * Adds multiple coin outputs to the transaction.
     *
     * @param to - Address of the destination.
     * @param quantities - Quantities of coins.
     */
    addCoinOutputs(to, quantities) {
      quantities.map(coinQuantityfy2).forEach((quantity) => {
        this.pushOutput({
          type: OutputType.Coin,
          to: addressify(to).toB256(),
          amount: quantity.amount,
          assetId: quantity.assetId
        });
      });
      return this;
    }
    /**
     * Adds a change output to the transaction.
     *
     * @param to - Address of the owner.
     * @param assetId - Asset ID of coin.
     */
    addChangeOutput(to, assetId = BaseAssetId) {
      const changeOutput = this.getChangeOutputs().find(
        (output3) => hexlify(output3.assetId) === assetId
      );
      if (!changeOutput) {
        this.pushOutput({
          type: OutputType.Change,
          to: addressify(to).toB256(),
          assetId
        });
      }
    }
    /**
     * @hidden
     */
    byteSize() {
      return this.toTransactionBytes().length;
    }
    /**
     * @hidden
     */
    metadataGas(_gasCosts) {
      throw new Error("Not implemented");
    }
    /**
     * @hidden
     */
    calculateMinGas(chainInfo) {
      const { gasCosts, consensusParameters } = chainInfo;
      const { gasPerByte } = consensusParameters;
      return getMinGas2({
        gasPerByte,
        gasCosts,
        inputs: this.inputs,
        txBytesSize: this.byteSize(),
        metadataGas: this.metadataGas(gasCosts)
      });
    }
    calculateMaxGas(chainInfo, minGas) {
      const { consensusParameters } = chainInfo;
      const { gasPerByte } = consensusParameters;
      const witnessesLength = this.toTransaction().witnesses.reduce(
        (acc, wit) => acc + wit.dataLength,
        0
      );
      return getMaxGas2({
        gasPerByte,
        minGas,
        witnessesLength,
        witnessLimit: this.witnessLimit
      });
    }
    /**
     * Funds the transaction with fake UTXOs for each assetId and amount in the
     * quantities array.
     *
     * @param quantities - CoinQuantity Array.
     */
    fundWithFakeUtxos(quantities, resourcesOwner) {
      let idCounter = 0;
      const generateId = () => {
        const counterString = String(idCounter++);
        const id = ZeroBytes32.slice(0, -counterString.length).concat(counterString);
        return id;
      };
      const findAssetInput = (assetId) => this.inputs.find((input) => {
        if ("assetId" in input) {
          return input.assetId === assetId;
        }
        return false;
      });
      const updateAssetInput = (assetId, quantity) => {
        const assetInput = findAssetInput(assetId);
        if (assetInput && "assetId" in assetInput) {
          assetInput.id = generateId();
          assetInput.amount = quantity;
        } else {
          this.addResources([
            {
              id: generateId(),
              amount: quantity,
              assetId,
              owner: resourcesOwner || Address.fromRandom(),
              maturity: 0,
              blockCreated: bn(1),
              txCreatedIdx: bn(1)
            }
          ]);
        }
      };
      updateAssetInput(BaseAssetId, bn(1e11));
      quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
    }
    /**
     * Retrieves an array of CoinQuantity for each coin output present in the transaction.
     * a transaction.
     *
     * @returns  CoinQuantity array.
     */
    getCoinOutputsQuantities() {
      const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
        amount: bn(amount),
        assetId: assetId.toString()
      }));
      return coinsQuantities;
    }
    /**
     * Return the minimum amount in native coins required to create
     * a transaction.
     *
     * @returns The transaction as a JSON object.
     */
    toJSON() {
      return normalizeJSON2(this);
    }
    updatePredicateInputs(inputs) {
      this.inputs.forEach((i) => {
        let correspondingInput;
        switch (i.type) {
          case InputType.Coin:
            correspondingInput = inputs.find((x) => x.type === InputType.Coin && x.owner === i.owner);
            break;
          case InputType.Message:
            correspondingInput = inputs.find(
              (x) => x.type === InputType.Message && x.sender === i.sender
            );
            break;
          default:
            return;
        }
        if (correspondingInput && "predicateGasUsed" in correspondingInput && bn(correspondingInput.predicateGasUsed).gt(0)) {
          i.predicate = correspondingInput.predicate;
          i.predicateData = correspondingInput.predicateData;
          i.predicateGasUsed = correspondingInput.predicateGasUsed;
        }
      });
    }
  };
  function hashTransaction2(transactionRequest, chainId) {
    const transaction = transactionRequest.toTransaction();
    if (transaction.type === TransactionType.Script) {
      transaction.receiptsRoot = ZeroBytes32;
    }
    transaction.inputs = transaction.inputs.map((input) => {
      const inputClone = clone_default(input);
      switch (inputClone.type) {
        case InputType.Coin: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Message: {
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Contract: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.txID = ZeroBytes32;
          inputClone.outputIndex = 0;
          inputClone.balanceRoot = ZeroBytes32;
          inputClone.stateRoot = ZeroBytes32;
          return inputClone;
        }
        default:
          return inputClone;
      }
    });
    transaction.outputs = transaction.outputs.map((output3) => {
      const outputClone = clone_default(output3);
      switch (outputClone.type) {
        case OutputType.Contract: {
          outputClone.balanceRoot = ZeroBytes32;
          outputClone.stateRoot = ZeroBytes32;
          return outputClone;
        }
        case OutputType.Change: {
          outputClone.amount = bn(0);
          return outputClone;
        }
        case OutputType.Variable: {
          outputClone.to = ZeroBytes32;
          outputClone.amount = bn(0);
          outputClone.assetId = ZeroBytes32;
          return outputClone;
        }
        default:
          return outputClone;
      }
    });
    transaction.witnessesCount = 0;
    transaction.witnesses = [];
    const chainIdBytes = uint64ToBytesBE(chainId);
    const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);
    return sha2563(concatenatedData);
  }
  var getStorageValue2 = (value) => {
    const v = new Uint8Array(32);
    v.set(arrayify(value));
    return v;
  };
  var storageSlotify2 = (storageSlot) => {
    let key;
    let value;
    if (Array.isArray(storageSlot)) {
      key = storageSlot[0];
      value = storageSlot[1];
    } else {
      key = storageSlot.key;
      value = storageSlot.value;
    }
    return {
      key: hexlify(key),
      value: hexlify(getStorageValue2(value))
    };
  };
  var CreateTransactionRequest2 = class extends BaseTransactionRequest2 {
    static from(obj) {
      if (obj instanceof this) {
        return obj;
      }
      return new this(obj);
    }
    /** Type of the transaction */
    type = TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex;
    /** Salt */
    salt;
    /** List of storage slots to initialize */
    storageSlots;
    /**
     * Creates an instance `CreateTransactionRequest`.
     *
     * @param createTransactionRequestLike - The initial values for the instance
     */
    constructor({
      bytecodeWitnessIndex,
      salt,
      storageSlots,
      ...rest
    } = {}) {
      super(rest);
      this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
      this.salt = hexlify(salt ?? ZeroBytes32);
      this.storageSlots = [...storageSlots ?? []];
    }
    /**
     * Converts the transaction request to a `TransactionCreate`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
      const storageSlots = this.storageSlots?.map(storageSlotify2) ?? [];
      return {
        type: TransactionType.Create,
        ...baseTransaction,
        bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,
        bytecodeWitnessIndex,
        storageSlotsCount: storageSlots.length,
        salt: this.salt ? hexlify(this.salt) : ZeroBytes32,
        storageSlots
      };
    }
    /**
     * Get contract created outputs for the transaction.
     *
     * @returns An array of contract created transaction request outputs.
     */
    getContractCreatedOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.ContractCreated
      );
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction2(this, chainId);
    }
    /**
     * Adds a contract created output to the transaction request.
     *
     * @param contractId - The contract ID.
     * @param stateRoot - The state root.
     */
    addContractCreatedOutput(contractId, stateRoot) {
      this.pushOutput({
        type: OutputType.ContractCreated,
        contractId,
        stateRoot
      });
    }
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxCreate2({
        contractBytesSize: bn(arrayify(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
        gasCosts,
        stateRootSize: this.storageSlots.length,
        txBytesSize: this.byteSize()
      });
    }
  };
  var returnZeroScript2 = {
    /*
        Opcode::RET(REG_ZERO)
        Opcode::NOOP
      */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: arrayify("0x24000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var withdrawScript2 = {
    /*
            The following code loads some basic values into registers and calls SMO to create an output message
            5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
            5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
            4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
            24000000	- RET                [return 0]
            00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
            00000000 00000000 [amount value]
        */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: arrayify("0x5040C0105D44C0064C40001124000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var ScriptTransactionRequest2 = class extends BaseTransactionRequest2 {
    static from(obj) {
      if (obj instanceof this) {
        return obj;
      }
      return new this(obj);
    }
    /** Type of the transaction */
    type = TransactionType.Script;
    /** Gas limit for transaction */
    gasLimit;
    /** Script to execute */
    script;
    /** Script input data (parameters) */
    scriptData;
    abis;
    /**
     * Constructor for `ScriptTransactionRequest`.
     *
     * @param scriptTransactionRequestLike - The initial values for the instance.
     */
    constructor({ script, scriptData, gasLimit, ...rest } = {}) {
      super(rest);
      this.gasLimit = bn(gasLimit);
      this.script = arrayify(script ?? returnZeroScript2.bytes);
      this.scriptData = arrayify(scriptData ?? returnZeroScript2.encodeScriptData());
      this.abis = rest.abis;
    }
    /**
     * Converts the transaction request to a `TransactionScript`.
     *
     * @returns The transaction script object.
     */
    toTransaction() {
      const script = arrayify(this.script ?? "0x");
      const scriptData = arrayify(this.scriptData ?? "0x");
      return {
        type: TransactionType.Script,
        scriptGasLimit: this.gasLimit,
        ...super.getBaseTransaction(),
        scriptLength: script.length,
        scriptDataLength: scriptData.length,
        receiptsRoot: ZeroBytes32,
        script: hexlify(script),
        scriptData: hexlify(scriptData)
      };
    }
    /**
     * Get contract inputs for the transaction.
     *
     * @returns An array of contract transaction request inputs.
     */
    getContractInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Contract
      );
    }
    /**
     * Get contract outputs for the transaction.
     *
     * @returns An array of contract transaction request outputs.
     */
    getContractOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Contract
      );
    }
    /**
     * Get variable outputs for the transaction.
     *
     * @returns An array of variable transaction request outputs.
     */
    getVariableOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Variable
      );
    }
    /**
     * Set the script and its data.
     *
     * @param script - The abstract script request.
     * @param data - The script data.
     */
    setScript(script, data) {
      this.scriptData = script.encodeScriptData(data);
      this.script = script.bytes;
    }
    /**
     * Adds variable outputs to the transaction request.
     *
     * @param numberOfVariables - The number of variables to add.
     * @returns The new length of the outputs array.
     */
    addVariableOutputs(numberOfVariables = 1) {
      let outputsNumber = numberOfVariables;
      while (outputsNumber) {
        this.pushOutput({
          type: OutputType.Variable
        });
        outputsNumber -= 1;
      }
      return this.outputs.length - 1;
    }
    calculateMaxGas(chainInfo, minGas) {
      const { consensusParameters } = chainInfo;
      const { gasPerByte } = consensusParameters;
      const witnessesLength = this.toTransaction().witnesses.reduce(
        (acc, wit) => acc + wit.dataLength,
        0
      );
      return getMaxGas2({
        gasPerByte,
        minGas,
        witnessesLength,
        witnessLimit: this.witnessLimit,
        gasLimit: this.gasLimit
      });
    }
    /**
     * Adds a contract input and output to the transaction request.
     *
     * @param contract - The contract ID.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    addContractInputAndOutput(contract) {
      const contractAddress = addressify(contract);
      if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
        return this;
      }
      const inputIndex = super.pushInput({
        type: InputType.Contract,
        contractId: contractAddress.toB256(),
        txPointer: "0x00000000000000000000000000000000"
      });
      this.pushOutput({
        type: OutputType.Contract,
        inputIndex
      });
      return this;
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction2(this, chainId);
    }
    /**
     * Sets the data for the transaction request.
     *
     * @param abi - Script JSON ABI.
     * @param args - The input arguments.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    setData(abi, args) {
      const abiInterface = new Interface(abi);
      this.scriptData = abiInterface.functions.main.encodeArguments(args);
      return this;
    }
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxScript2({
        gasCosts,
        txBytesSize: this.byteSize()
      });
    }
  };
  var transactionRequestify2 = (obj) => {
    if (obj instanceof ScriptTransactionRequest2 || obj instanceof CreateTransactionRequest2) {
      return obj;
    }
    const { type: type3 } = obj;
    switch (obj.type) {
      case TransactionType.Script: {
        return ScriptTransactionRequest2.from(obj);
      }
      case TransactionType.Create: {
        return CreateTransactionRequest2.from(obj);
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type3}.`);
      }
    }
  };
  var calculateTransactionFee2 = (params) => {
    const {
      gasUsed,
      rawPayload,
      consensusParameters: { gasCosts, feeParams }
    } = params;
    const gasPerByte = bn(feeParams.gasPerByte);
    const gasPriceFactor = bn(feeParams.gasPriceFactor);
    const transactionBytes = arrayify(rawPayload);
    const [transaction] = new TransactionCoder().decode(transactionBytes, 0);
    if (transaction.type === TransactionType.Mint) {
      return {
        fee: bn(0),
        minFee: bn(0),
        maxFee: bn(0),
        feeFromGasUsed: bn(0)
      };
    }
    const { type: type3, witnesses, inputs, policies } = transaction;
    let metadataGas = bn(0);
    let gasLimit = bn(0);
    if (type3 === TransactionType.Create) {
      const { bytecodeWitnessIndex, storageSlots } = transaction;
      const contractBytesSize = bn(arrayify(witnesses[bytecodeWitnessIndex].data).length);
      metadataGas = calculateMetadataGasForTxCreate2({
        contractBytesSize,
        gasCosts,
        stateRootSize: storageSlots.length || 0,
        txBytesSize: transactionBytes.length
      });
    } else {
      const { scriptGasLimit } = transaction;
      if (scriptGasLimit) {
        gasLimit = scriptGasLimit;
      }
      metadataGas = calculateMetadataGasForTxScript2({
        gasCosts,
        txBytesSize: transactionBytes.length
      });
    }
    const minGas = getMinGas2({
      gasCosts,
      gasPerByte: bn(gasPerByte),
      inputs,
      metadataGas,
      txBytesSize: transactionBytes.length
    });
    const gasPrice = bn(policies.find((policy) => policy.type === PolicyType.GasPrice)?.data);
    const witnessLimit = policies.find((policy) => policy.type === PolicyType.WitnessLimit)?.data;
    const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
    const maxGas = getMaxGas2({
      gasPerByte,
      minGas,
      witnessesLength,
      gasLimit,
      witnessLimit
    });
    const feeFromGasUsed = calculatePriceWithFactor2(gasUsed, gasPrice, gasPriceFactor);
    const minFee = calculatePriceWithFactor2(minGas, gasPrice, gasPriceFactor);
    const maxFee = calculatePriceWithFactor2(maxGas, gasPrice, gasPriceFactor);
    const fee = minFee.add(feeFromGasUsed);
    return {
      fee,
      minFee,
      maxFee,
      feeFromGasUsed
    };
  };
  var getFunctionCall2 = ({ abi, receipt, rawPayload, maxInputs }) => {
    const abiInterface = new Interface(abi);
    const callFunctionSelector = receipt.param1.toHex(8);
    const functionFragment = abiInterface.getFunction(callFunctionSelector);
    const inputs = functionFragment.jsonFn.inputs;
    let encodedArgs;
    if (functionFragment.isInputDataPointer) {
      if (rawPayload) {
        const argsOffset = bn(receipt.param2).sub(calculateVmTxMemory({ maxInputs: maxInputs.toNumber() })).toNumber();
        encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;
      }
    } else {
      encodedArgs = receipt.param2.toHex();
    }
    let argumentsProvided;
    if (encodedArgs) {
      const data = functionFragment.decodeArguments(encodedArgs);
      if (data) {
        argumentsProvided = inputs.reduce((prev, input, index) => {
          const value = data[index];
          const name = input.name;
          if (name) {
            return {
              ...prev,
              // reparse to remove bn
              [name]: JSON.parse(JSON.stringify(value))
            };
          }
          return prev;
        }, {});
      }
    }
    const call2 = {
      functionSignature: functionFragment.signature,
      functionName: functionFragment.name,
      argumentsProvided,
      ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
    };
    return call2;
  };
  function getInputsByTypes2(inputs, types2) {
    return inputs.filter((i) => types2.includes(i.type));
  }
  function getInputsByType2(inputs, type3) {
    return inputs.filter((i) => i.type === type3);
  }
  function getInputsCoin2(inputs) {
    return getInputsByType2(inputs, InputType.Coin);
  }
  function getInputsMessage2(inputs) {
    return getInputsByType2(inputs, InputType.Message);
  }
  function getInputsCoinAndMessage2(inputs) {
    return getInputsByTypes2(inputs, [InputType.Coin, InputType.Message]);
  }
  function getInputsContract2(inputs) {
    return getInputsByType2(inputs, InputType.Contract);
  }
  function getInputFromAssetId2(inputs, assetId) {
    const coinInputs = getInputsCoin2(inputs);
    const messageInputs = getInputsMessage2(inputs);
    const coinInput = coinInputs.find((i) => i.assetId === assetId);
    const messageInput = messageInputs.find(
      (_) => assetId === "0x0000000000000000000000000000000000000000000000000000000000000000"
    );
    return coinInput || messageInput;
  }
  function getInputContractFromIndex2(inputs, inputIndex) {
    if (inputIndex == null) {
      return void 0;
    }
    const contractInput = inputs?.[inputIndex];
    if (!contractInput) {
      return void 0;
    }
    if (contractInput.type !== InputType.Contract) {
      throw new FuelError(
        ErrorCode.INVALID_TRANSACTION_INPUT,
        `Contract input should be of type 'contract'.`
      );
    }
    return contractInput;
  }
  function getInputAccountAddress2(input) {
    if (input.type === InputType.Coin) {
      return input.owner.toString();
    }
    if (input.type === InputType.Message) {
      return input.recipient.toString();
    }
    return "";
  }
  function getOutputsByType2(outputs, type3) {
    return outputs.filter((o) => o.type === type3);
  }
  function getOutputsContractCreated2(outputs) {
    return getOutputsByType2(outputs, OutputType.ContractCreated);
  }
  function getOutputsCoin2(outputs) {
    return getOutputsByType2(outputs, OutputType.Coin);
  }
  function getOutputsChange2(outputs) {
    return getOutputsByType2(outputs, OutputType.Change);
  }
  function getOutputsContract2(outputs) {
    return getOutputsByType2(outputs, OutputType.Contract);
  }
  function getReceiptsByType2(receipts, type3) {
    return (receipts ?? []).filter((r) => r.type === type3);
  }
  function getTransactionTypeName2(transactionType) {
    switch (transactionType) {
      case TransactionType.Mint:
        return "Mint";
      case TransactionType.Create:
        return "Create";
      case TransactionType.Script:
        return "Script";
      default:
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_TYPE,
          `Invalid transaction type: ${transactionType}.`
        );
    }
  }
  function isType2(transactionType, type3) {
    const txType = getTransactionTypeName2(transactionType);
    return txType === type3;
  }
  function isTypeMint2(transactionType) {
    return isType2(
      transactionType,
      "Mint"
      /* Mint */
    );
  }
  function isTypeCreate2(transactionType) {
    return isType2(
      transactionType,
      "Create"
      /* Create */
    );
  }
  function isTypeScript2(transactionType) {
    return isType2(
      transactionType,
      "Script"
      /* Script */
    );
  }
  function getReceiptsCall2(receipts) {
    return getReceiptsByType2(receipts, ReceiptType.Call);
  }
  function getReceiptsMessageOut2(receipts) {
    return getReceiptsByType2(receipts, ReceiptType.MessageOut);
  }
  var mergeAssets2 = (op1, op2) => {
    const assets1 = op1.assetsSent || [];
    const assets22 = op2.assetsSent || [];
    const filteredAssets = assets22.filter(
      (asset2) => !assets1.some((asset1) => asset1.assetId === asset2.assetId)
    );
    const mergedAssets = assets1.map((asset1) => {
      const matchingAsset = assets22.find((asset2) => asset2.assetId === asset1.assetId);
      if (!matchingAsset) {
        return asset1;
      }
      const mergedAmount = bn(asset1.amount).add(matchingAsset.amount);
      return { ...asset1, amount: mergedAmount };
    });
    return mergedAssets.concat(filteredAssets);
  };
  function isSameOperation2(a, b) {
    return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
  }
  function addOperation2(operations, toAdd) {
    const allOperations = [...operations];
    const index = allOperations.findIndex((op) => isSameOperation2(op, toAdd));
    if (allOperations[index]) {
      const existentOperation = { ...allOperations[index] };
      if (toAdd.assetsSent?.length) {
        existentOperation.assetsSent = existentOperation.assetsSent?.length ? mergeAssets2(existentOperation, toAdd) : toAdd.assetsSent;
      }
      if (toAdd.calls?.length) {
        existentOperation.calls = [...existentOperation.calls || [], ...toAdd.calls];
      }
      allOperations[index] = existentOperation;
    } else {
      allOperations.push(toAdd);
    }
    return allOperations;
  }
  function getWithdrawFromFuelOperations2({
    inputs,
    receipts
  }) {
    const messageOutReceipts = getReceiptsMessageOut2(receipts);
    const withdrawFromFuelOperations = messageOutReceipts.reduce(
      (prevWithdrawFromFuelOps, receipt) => {
        const assetId = "0x0000000000000000000000000000000000000000000000000000000000000000";
        const input = getInputFromAssetId2(inputs, assetId);
        if (input) {
          const inputAddress = getInputAccountAddress2(input);
          const newWithdrawFromFuelOps = addOperation2(prevWithdrawFromFuelOps, {
            name: "Withdraw from Fuel",
            from: {
              type: 1,
              address: inputAddress
            },
            to: {
              type: 1,
              address: receipt.recipient.toString(),
              chain: "ethereum"
              /* ethereum */
            },
            assetsSent: [
              {
                amount: receipt.amount,
                assetId
              }
            ]
          });
          return newWithdrawFromFuelOps;
        }
        return prevWithdrawFromFuelOps;
      },
      []
    );
    return withdrawFromFuelOperations;
  }
  function getContractCallOperations2({
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs
  }) {
    const contractCallReceipts = getReceiptsCall2(receipts);
    const contractOutputs = getOutputsContract2(outputs);
    const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output3) => {
      const contractInput = getInputContractFromIndex2(inputs, output3.inputIndex);
      if (contractInput) {
        const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {
          if (receipt.to === contractInput.contractID) {
            const input = getInputFromAssetId2(inputs, receipt.assetId);
            if (input) {
              const inputAddress = getInputAccountAddress2(input);
              const calls = [];
              const abi = abiMap?.[contractInput.contractID];
              if (abi) {
                calls.push(
                  getFunctionCall2({
                    abi,
                    receipt,
                    rawPayload,
                    maxInputs
                  })
                );
              }
              const newContractCallOps = addOperation2(prevContractCallOps, {
                name: "Contract call",
                from: {
                  type: 1,
                  address: inputAddress
                },
                to: {
                  type: 0,
                  address: receipt.to
                },
                // if no amount is forwarded to the contract, skip showing assetsSent
                assetsSent: receipt.amount?.isZero() ? void 0 : [
                  {
                    amount: receipt.amount,
                    assetId: receipt.assetId
                  }
                ],
                calls
              });
              return newContractCallOps;
            }
          }
          return prevContractCallOps;
        }, prevOutputCallOps);
        return newCallOps;
      }
      return prevOutputCallOps;
    }, []);
    return contractCallOperations;
  }
  function extractTransferOperationFromReceipt2(receipt, contractInputs, changeOutputs) {
    const { to: toAddress, assetId, amount } = receipt;
    let { from: fromAddress } = receipt;
    const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 : 1;
    if (ZeroBytes32 === fromAddress) {
      const change = changeOutputs.find((output3) => output3.assetId === assetId);
      fromAddress = change?.to || fromAddress;
    }
    const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 : 1;
    return {
      name: "Transfer asset",
      from: {
        type: fromType,
        address: fromAddress
      },
      to: {
        type: toType,
        address: toAddress
      },
      assetsSent: [
        {
          assetId: assetId.toString(),
          amount
        }
      ]
    };
  }
  function getTransferOperations2({
    inputs,
    outputs,
    receipts
  }) {
    let operations = [];
    const coinOutputs = getOutputsCoin2(outputs);
    const contractInputs = getInputsContract2(inputs);
    const changeOutputs = getOutputsChange2(outputs);
    coinOutputs.forEach((output3) => {
      const { amount, assetId, to } = output3;
      const changeOutput = changeOutputs.find((change) => change.assetId === assetId);
      if (changeOutput) {
        operations = addOperation2(operations, {
          name: "Transfer asset",
          from: {
            type: 1,
            address: changeOutput.to
          },
          to: {
            type: 1,
            address: to
          },
          assetsSent: [
            {
              assetId,
              amount
            }
          ]
        });
      }
    });
    const transferReceipts = getReceiptsByType2(
      receipts,
      ReceiptType.Transfer
    );
    const transferOutReceipts = getReceiptsByType2(
      receipts,
      ReceiptType.TransferOut
    );
    [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
      const operation = extractTransferOperationFromReceipt2(receipt, contractInputs, changeOutputs);
      operations = addOperation2(operations, operation);
    });
    return operations;
  }
  function getPayProducerOperations2(outputs) {
    const coinOutputs = getOutputsCoin2(outputs);
    const payProducerOperations = coinOutputs.reduce((prev, output3) => {
      const operations = addOperation2(prev, {
        name: "Pay network fee to block producer",
        from: {
          type: 1,
          address: "Network"
        },
        to: {
          type: 1,
          address: output3.to.toString()
        },
        assetsSent: [
          {
            assetId: output3.assetId.toString(),
            amount: output3.amount
          }
        ]
      });
      return operations;
    }, []);
    return payProducerOperations;
  }
  function getContractCreatedOperations2({ inputs, outputs }) {
    const contractCreatedOutputs = getOutputsContractCreated2(outputs);
    const input = getInputsCoinAndMessage2(inputs)[0];
    const fromAddress = getInputAccountAddress2(input);
    const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
      const operations = addOperation2(prev, {
        name: "Contract created",
        from: {
          type: 1,
          address: fromAddress
        },
        to: {
          type: 0,
          address: contractCreatedOutput?.contractId || ""
        }
      });
      return operations;
    }, []);
    return contractCreatedOperations;
  }
  function getOperations2({
    transactionType,
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs
  }) {
    if (isTypeCreate2(transactionType)) {
      return [
        ...getContractCreatedOperations2({ inputs, outputs }),
        ...getTransferOperations2({ inputs, outputs, receipts })
      ];
    }
    if (isTypeScript2(transactionType)) {
      return [
        ...getTransferOperations2({ inputs, outputs, receipts }),
        ...getContractCallOperations2({
          inputs,
          outputs,
          receipts,
          abiMap,
          rawPayload,
          maxInputs
        }),
        ...getWithdrawFromFuelOperations2({ inputs, receipts })
      ];
    }
    return [...getPayProducerOperations2(outputs)];
  }
  var processGqlReceipt2 = (gqlReceipt) => {
    const receipt = assembleReceiptByType2(gqlReceipt);
    switch (receipt.type) {
      case ReceiptType.ReturnData: {
        return {
          ...receipt,
          data: gqlReceipt.data || "0x"
        };
      }
      case ReceiptType.LogData: {
        return {
          ...receipt,
          data: gqlReceipt.data || "0x"
        };
      }
      default:
        return receipt;
    }
  };
  var extractMintedAssetsFromReceipts2 = (receipts) => {
    const mintedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Mint) {
        mintedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return mintedAssets;
  };
  var extractBurnedAssetsFromReceipts2 = (receipts) => {
    const burnedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Burn) {
        burnedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return burnedAssets;
  };
  var getTransactionStatusName2 = (gqlStatus) => {
    switch (gqlStatus) {
      case "FailureStatus":
        return "failure";
      case "SuccessStatus":
        return "success";
      case "SubmittedStatus":
        return "submitted";
      case "SqueezedOutStatus":
        return "squeezedout";
      default:
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_STATUS,
          `Invalid transaction status: ${gqlStatus}.`
        );
    }
  };
  var processGraphqlStatus2 = (gqlTransactionStatus) => {
    let time;
    let blockId;
    let status;
    let isStatusFailure = false;
    let isStatusSuccess = false;
    let isStatusPending = false;
    if (gqlTransactionStatus?.type) {
      status = getTransactionStatusName2(gqlTransactionStatus.type);
      switch (gqlTransactionStatus.type) {
        case "SuccessStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block.id;
          isStatusSuccess = true;
          break;
        case "FailureStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block.id;
          isStatusFailure = true;
          break;
        case "SubmittedStatus":
          time = gqlTransactionStatus.time;
          isStatusPending = true;
          break;
        default:
      }
    }
    const processedGraphqlStatus = {
      time,
      blockId,
      status,
      isStatusFailure,
      isStatusSuccess,
      isStatusPending
    };
    return processedGraphqlStatus;
  };
  function assembleTransactionSummary2(params) {
    const {
      id,
      receipts,
      gasPerByte,
      gasPriceFactor,
      transaction,
      transactionBytes,
      gqlTransactionStatus,
      abiMap = {},
      maxInputs,
      gasCosts
    } = params;
    const gasUsed = getGasUsedFromReceipts2(receipts);
    const rawPayload = hexlify(transactionBytes);
    const operations = getOperations2({
      transactionType: transaction.type,
      inputs: transaction.inputs || [],
      outputs: transaction.outputs || [],
      receipts,
      rawPayload,
      abiMap,
      maxInputs
    });
    const typeName = getTransactionTypeName2(transaction.type);
    const { fee } = calculateTransactionFee2({
      gasUsed,
      rawPayload,
      consensusParameters: {
        gasCosts,
        feeParams: {
          gasPerByte,
          gasPriceFactor
        }
      }
    });
    const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } = processGraphqlStatus2(gqlTransactionStatus);
    const mintedAssets = extractMintedAssetsFromReceipts2(receipts);
    const burnedAssets = extractBurnedAssetsFromReceipts2(receipts);
    let date2;
    if (time) {
      date2 = DateTime.fromTai64(time);
    }
    const transactionSummary = {
      id,
      fee,
      gasUsed,
      operations,
      type: typeName,
      blockId,
      time,
      status,
      receipts,
      mintedAssets,
      burnedAssets,
      isTypeMint: isTypeMint2(transaction.type),
      isTypeCreate: isTypeCreate2(transaction.type),
      isTypeScript: isTypeScript2(transaction.type),
      isStatusFailure,
      isStatusSuccess,
      isStatusPending,
      date: date2,
      transaction
    };
    return transactionSummary;
  }
  function getDecodedLogs2(receipts, mainAbi, externalAbis = {}) {
    return receipts.reduce((logs, receipt) => {
      if (receipt.type === ReceiptType.LogData || receipt.type === ReceiptType.Log) {
        const interfaceToUse = new Interface(externalAbis[receipt.id] || mainAbi);
        const data = receipt.type === ReceiptType.Log ? new BigNumberCoder("u64").encode(receipt.val0) : receipt.data;
        const [decodedLog] = interfaceToUse.decodeLog(data, receipt.val1.toNumber());
        logs.push(decodedLog);
      }
      return logs;
    }, []);
  }
  var TransactionResponse3 = class {
    /** Transaction ID */
    id;
    /** Current provider */
    provider;
    /** Gas used on the transaction */
    gasUsed = bn(0);
    /** The graphql Transaction with receipts object. */
    gqlTransaction;
    abis;
    /**
     * Constructor for `TransactionResponse`.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    constructor(id, provider, abis) {
      this.id = id;
      this.provider = provider;
      this.abis = abis;
    }
    /**
     * Async constructor for `TransactionResponse`. This method can be used to create
     * an instance of `TransactionResponse` and wait for the transaction to be fetched
     * from the chain, ensuring that the `gqlTransaction` property is set.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    static async create(id, provider, abis) {
      const response = new TransactionResponse3(id, provider, abis);
      await response.fetch();
      return response;
    }
    /**
     * Fetch the transaction with receipts from the provider.
     *
     * @returns Transaction with receipts query result.
     */
    async fetch() {
      const response = await this.provider.operations.getTransactionWithReceipts({
        transactionId: this.id
      });
      if (!response.transaction) {
        const subscription = this.provider.operations.statusChange({
          transactionId: this.id
        });
        for await (const { statusChange } of subscription) {
          if (statusChange) {
            break;
          }
        }
        return this.fetch();
      }
      this.gqlTransaction = response.transaction;
      return response.transaction;
    }
    /**
     * Decode the raw payload of the transaction.
     *
     * @param transactionWithReceipts - The transaction with receipts object.
     * @returns The decoded transaction.
     */
    decodeTransaction(transactionWithReceipts) {
      return new TransactionCoder().decode(
        arrayify(transactionWithReceipts.rawPayload),
        0
      )?.[0];
    }
    /**
     * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
     * fetch it from the provider
     *
     * @param contractsAbiMap - The contracts ABI map.
     * @returns
     */
    async getTransactionSummary(contractsAbiMap) {
      let transaction = this.gqlTransaction;
      if (!transaction) {
        transaction = await this.fetch();
      }
      const decodedTransaction = this.decodeTransaction(
        transaction
      );
      const receipts = transaction.receipts?.map(processGqlReceipt2) || [];
      const { gasPerByte, gasPriceFactor, gasCosts } = this.provider.getGasConfig();
      const maxInputs = this.provider.getChain().consensusParameters.maxInputs;
      const transactionSummary = assembleTransactionSummary2({
        id: this.id,
        receipts,
        transaction: decodedTransaction,
        transactionBytes: arrayify(transaction.rawPayload),
        gqlTransactionStatus: transaction.status,
        gasPerByte,
        gasPriceFactor,
        abiMap: contractsAbiMap,
        maxInputs,
        gasCosts
      });
      return transactionSummary;
    }
    async waitForStatusChange() {
      const status = this.gqlTransaction?.status?.type;
      if (status && status !== "SubmittedStatus") {
        return;
      }
      const subscription = this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange } of subscription) {
        if (statusChange.type === "SqueezedOutStatus") {
          throw new FuelError(
            ErrorCode.TRANSACTION_SQUEEZED_OUT,
            `Transaction Squeezed Out with reason: ${statusChange.reason}`
          );
        }
        if (statusChange.type !== "SubmittedStatus") {
          break;
        }
      }
      await this.fetch();
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @returns The completed transaction result
     */
    async waitForResult(contractsAbiMap) {
      await this.waitForStatusChange();
      const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
      const transactionResult = {
        gqlTransaction: this.gqlTransaction,
        ...transactionSummary
      };
      if (this.abis) {
        const logs = getDecodedLogs2(
          transactionSummary.receipts,
          this.abis.main,
          this.abis.otherContractsAbis
        );
        transactionResult.logs = logs;
      }
      return transactionResult;
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @param contractsAbiMap - The contracts ABI map.
     */
    async wait(contractsAbiMap) {
      const result = await this.waitForResult(contractsAbiMap);
      if (result.isStatusFailure) {
        throw new FuelError(
          ErrorCode.TRANSACTION_FAILED,
          `Transaction failed: ${result.gqlTransaction.status.reason}`
        );
      }
      return result;
    }
  };
  function getWaitDelay2(options, retryAttemptNum) {
    const duration = options.baseDelay ?? 150;
    switch (options.backoff) {
      case "linear":
        return duration * retryAttemptNum;
      case "fixed":
        return duration;
      case "exponential":
      default:
        return 2 ** (retryAttemptNum - 1) * duration;
    }
  }
  function autoRetryFetch2(fetchFn, options, retryAttemptNum = 0) {
    if (options === void 0) {
      return fetchFn;
    }
    return async (...args) => {
      try {
        return await fetchFn(...args);
      } catch (_error) {
        const error2 = _error;
        if (error2.cause?.code !== "ECONNREFUSED") {
          throw error2;
        }
        const retryNum = retryAttemptNum + 1;
        if (retryNum > options.maxRetries) {
          throw error2;
        }
        const delay = getWaitDelay2(options, retryNum);
        await sleep2(delay);
        return autoRetryFetch2(fetchFn, options, retryNum)(...args);
      }
    };
  }
  var mergeQuantities2 = (arr1, arr2) => {
    const resultMap = {};
    function addToMap({ amount, assetId }) {
      if (resultMap[assetId]) {
        resultMap[assetId] = resultMap[assetId].add(amount);
      } else {
        resultMap[assetId] = amount;
      }
    }
    arr1.forEach(addToMap);
    arr2.forEach(addToMap);
    return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
  };
  var MAX_RETRIES2 = 10;
  var processGqlChain2 = (chain) => {
    const { name, daHeight, consensusParameters, latestBlock } = chain;
    const { contractParams, feeParams, predicateParams, scriptParams, txParams, gasCosts } = consensusParameters;
    return {
      name,
      baseChainHeight: bn(daHeight),
      consensusParameters: {
        contractMaxSize: bn(contractParams.contractMaxSize),
        maxInputs: bn(txParams.maxInputs),
        maxOutputs: bn(txParams.maxOutputs),
        maxWitnesses: bn(txParams.maxWitnesses),
        maxGasPerTx: bn(txParams.maxGasPerTx),
        maxScriptLength: bn(scriptParams.maxScriptLength),
        maxScriptDataLength: bn(scriptParams.maxScriptDataLength),
        maxStorageSlots: bn(contractParams.maxStorageSlots),
        maxPredicateLength: bn(predicateParams.maxPredicateLength),
        maxPredicateDataLength: bn(predicateParams.maxPredicateDataLength),
        maxGasPerPredicate: bn(predicateParams.maxGasPerPredicate),
        gasPriceFactor: bn(feeParams.gasPriceFactor),
        gasPerByte: bn(feeParams.gasPerByte),
        maxMessageDataLength: bn(predicateParams.maxMessageDataLength),
        chainId: bn(consensusParameters.chainId),
        gasCosts
      },
      gasCosts,
      latestBlock: {
        id: latestBlock.id,
        height: bn(latestBlock.header.height),
        time: latestBlock.header.time,
        transactions: latestBlock.transactions.map((i) => ({
          id: i.id
        }))
      }
    };
  };
  var _cacheInputs2;
  var cacheInputs_fn2;
  var _Provider2 = class {
    /**
     * Constructor to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param chainInfo - Chain info of the Fuel node
     * @param options - Additional options for the provider
     * @hidden
     */
    constructor(url, options = {}) {
      this.url = url;
      __privateAdd4(this, _cacheInputs2);
      __publicField7(this, "operations");
      __publicField7(this, "cache");
      __publicField7(this, "options", {
        timeout: void 0,
        cacheUtxo: void 0,
        fetch: void 0,
        retryOptions: void 0
      });
      this.options = { ...this.options, ...options };
      this.url = url;
      this.operations = this.createOperations();
      this.cache = options.cacheUtxo ? new MemoryCache2(options.cacheUtxo) : void 0;
    }
    static clearChainAndNodeCaches() {
      _Provider2.nodeInfoCache = {};
      _Provider2.chainInfoCache = {};
    }
    static getFetchFn(options) {
      const { retryOptions, timeout } = options;
      return autoRetryFetch2(async (...args) => {
        const url = args[0];
        const request = args[1];
        const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
        let fullRequest = { ...request, signal };
        if (options.requestMiddleware) {
          fullRequest = await options.requestMiddleware(fullRequest);
        }
        return options.fetch ? options.fetch(url, fullRequest, options) : fetch(url, fullRequest);
      }, retryOptions);
    }
    /**
     * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     */
    static async create(url, options = {}) {
      const provider = new _Provider2(url, options);
      await provider.fetchChainAndNodeInfo();
      return provider;
    }
    /**
     * Returns the cached chainInfo for the current URL.
     */
    getChain() {
      const chain = _Provider2.chainInfoCache[this.url];
      if (!chain) {
        throw new FuelError(
          ErrorCode.CHAIN_INFO_CACHE_EMPTY,
          "Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
        );
      }
      return chain;
    }
    /**
     * Returns the cached nodeInfo for the current URL.
     */
    getNode() {
      const node = _Provider2.nodeInfoCache[this.url];
      if (!node) {
        throw new FuelError(
          ErrorCode.NODE_INFO_CACHE_EMPTY,
          "Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
        );
      }
      return node;
    }
    /**
     * Returns some helpful parameters related to gas fees.
     */
    getGasConfig() {
      const { minGasPrice } = this.getNode();
      const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte, gasCosts } = this.getChain().consensusParameters;
      return {
        minGasPrice,
        maxGasPerTx,
        maxGasPerPredicate,
        gasPriceFactor,
        gasPerByte,
        gasCosts
      };
    }
    /**
     * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
     */
    async connect(url, options) {
      this.url = url;
      this.options = options ?? this.options;
      this.operations = this.createOperations();
      await this.fetchChainAndNodeInfo();
    }
    /**
     * Fetches both the chain and node information, saves it to the cache, and return it.
     *
     * @returns NodeInfo and Chain
     */
    async fetchChainAndNodeInfo() {
      const chain = await this.fetchChain();
      const nodeInfo = await this.fetchNode();
      _Provider2.ensureClientVersionIsSupported(nodeInfo);
      return {
        chain,
        nodeInfo
      };
    }
    static ensureClientVersionIsSupported(nodeInfo) {
      const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
      if (!isMajorSupported || !isMinorSupported) {
        throw new FuelError(
          FuelError.CODES.UNSUPPORTED_FUEL_CLIENT_VERSION,
          `Fuel client version: ${nodeInfo.nodeVersion}, Supported version: ${supportedVersion}`
        );
      }
    }
    /**
     * Create GraphQL client and set operations.
     *
     * @returns The operation SDK object
     */
    createOperations() {
      const fetchFn = _Provider2.getFetchFn(this.options);
      const gqlClient = new import_graphql_request2.GraphQLClient(this.url, {
        fetch: (url, requestInit) => fetchFn(url, requestInit, this.options)
      });
      const executeQuery = (query, vars) => {
        const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
        const isSubscription = opDefinition?.operation === "subscription";
        if (isSubscription) {
          return new FuelGraphqlSubscriber2({
            url: this.url,
            query,
            fetchFn: (url, requestInit) => fetchFn(url, requestInit, this.options),
            variables: vars
          });
        }
        return gqlClient.request(query, vars);
      };
      return getSdk2(executeQuery);
    }
    /**
     * Returns the version of the connected node.
     *
     * @returns A promise that resolves to the version string.
     */
    async getVersion() {
      const {
        nodeInfo: { nodeVersion }
      } = await this.operations.getVersion();
      return nodeVersion;
    }
    /**
     * @hidden
     *
     * Returns the network configuration of the connected Fuel node.
     *
     * @returns A promise that resolves to the network configuration object
     */
    async getNetwork() {
      const {
        name,
        consensusParameters: { chainId }
      } = await this.getChain();
      const network = new Network(name, chainId.toNumber());
      return Promise.resolve(network);
    }
    /**
     * Returns the block number.
     *
     * @returns A promise that resolves to the block number
     */
    async getBlockNumber() {
      const { chain } = await this.operations.getChain();
      return bn(chain.latestBlock.header.height, 10);
    }
    /**
     * Returns the chain information.
     * @param url - The URL of the Fuel node
     * @returns NodeInfo object
     */
    async fetchNode() {
      const { nodeInfo } = await this.operations.getNodeInfo();
      const processedNodeInfo = {
        maxDepth: bn(nodeInfo.maxDepth),
        maxTx: bn(nodeInfo.maxTx),
        minGasPrice: bn(nodeInfo.minGasPrice),
        nodeVersion: nodeInfo.nodeVersion,
        utxoValidation: nodeInfo.utxoValidation,
        vmBacktrace: nodeInfo.vmBacktrace,
        peers: nodeInfo.peers
      };
      _Provider2.nodeInfoCache[this.url] = processedNodeInfo;
      return processedNodeInfo;
    }
    /**
     * Fetches the `chainInfo` for the given node URL.
     * @param url - The URL of the Fuel node
     * @returns ChainInfo object
     */
    async fetchChain() {
      const { chain } = await this.operations.getChain();
      const processedChain = processGqlChain2(chain);
      _Provider2.chainInfoCache[this.url] = processedChain;
      return processedChain;
    }
    /**
     * Returns the chain ID
     * @returns A promise that resolves to the chain ID number
     */
    getChainId() {
      const {
        consensusParameters: { chainId }
      } = this.getChain();
      return chainId.toNumber();
    }
    /**
     * Submits a transaction to the chain to be executed.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @returns A promise that resolves to the transaction response object.
     */
    // #region Provider-sendTransaction
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution = false } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      __privateMethod4(this, _cacheInputs2, cacheInputs_fn2).call(this, transactionRequest.inputs);
      if (estimateTxDependencies) {
        await this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      let abis;
      if (transactionRequest.type === TransactionType.Script) {
        abis = transactionRequest.abis;
      }
      if (awaitExecution) {
        const subscription = this.operations.submitAndAwait({ encodedTransaction });
        for await (const { submitAndAwait } of subscription) {
          if (submitAndAwait.type === "SqueezedOutStatus") {
            throw new FuelError(
              ErrorCode.TRANSACTION_SQUEEZED_OUT,
              `Transaction Squeezed Out with reason: ${submitAndAwait.reason}`
            );
          }
          if (submitAndAwait.type !== "SubmittedStatus") {
            break;
          }
        }
        const transactionId2 = transactionRequest.getTransactionId(this.getChainId());
        const response = new TransactionResponse3(transactionId2, this, abis);
        await response.fetch();
        return response;
      }
      const {
        submit: { id: transactionId }
      } = await this.operations.submit({ encodedTransaction });
      return new TransactionResponse3(transactionId, this, abis);
    }
    /**
     * Executes a transaction without actually submitting it to the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param utxoValidation - Additional provider call parameters.
     * @returns A promise that resolves to the call result object.
     */
    async call(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        return this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction,
        utxoValidation: utxoValidation || false
      });
      const receipts = gqlReceipts.map(processGqlReceipt2);
      return {
        receipts
      };
    }
    /**
     * Verifies whether enough gas is available to complete transaction.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimated transaction request object.
     */
    async estimatePredicates(transactionRequest) {
      const shouldEstimatePredicates = Boolean(
        transactionRequest.inputs.find(
          (input) => "predicate" in input && input.predicate && !equalBytes(arrayify(input.predicate), arrayify("0x")) && new BN(input.predicateGasUsed).isZero()
        )
      );
      if (!shouldEstimatePredicates) {
        return transactionRequest;
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const response = await this.operations.estimatePredicates({
        encodedTransaction
      });
      const {
        estimatePredicates: { inputs }
      } = response;
      if (inputs) {
        inputs.forEach((input, index) => {
          if ("predicateGasUsed" in input && bn(input.predicateGasUsed).gt(0)) {
            transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
          }
        });
      }
      return transactionRequest;
    }
    /**
     * Will dryRun a transaction and check for missing dependencies.
     *
     * If there are missing variable outputs,
     * `addVariableOutputs` is called on the transaction.
     *
     * @privateRemarks
     * TODO: Investigate support for missing contract IDs
     * TODO: Add support for missing output messages
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise.
     */
    async estimateTxDependencies(transactionRequest) {
      if (transactionRequest.type === TransactionType.Create) {
        return {
          receipts: [],
          outputVariables: 0,
          missingContractIds: []
        };
      }
      await this.estimatePredicates(transactionRequest);
      let receipts = [];
      const missingContractIds = [];
      let outputVariables = 0;
      for (let attempt = 0; attempt < MAX_RETRIES2; attempt++) {
        const { dryRun: gqlReceipts } = await this.operations.dryRun({
          encodedTransaction: hexlify(transactionRequest.toTransactionBytes()),
          utxoValidation: false
        });
        receipts = gqlReceipts.map(processGqlReceipt2);
        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData2(receipts);
        const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
        if (hasMissingOutputs) {
          outputVariables += missingOutputVariables.length;
          transactionRequest.addVariableOutputs(missingOutputVariables.length);
          missingOutputContractIds.forEach(({ contractId }) => {
            transactionRequest.addContractInputAndOutput(Address.fromString(contractId));
            missingContractIds.push(contractId);
          });
        } else {
          break;
        }
      }
      return {
        receipts,
        outputVariables,
        missingContractIds
      };
    }
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added
     *
     * @param transactionRequestLike - The transaction request object.
     * @returns A promise that resolves to the call result object.
     */
    async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        return this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction,
        utxoValidation: true
      });
      const receipts = gqlReceipts.map(processGqlReceipt2);
      return {
        receipts
      };
    }
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the the transaction.
     *
     * @privateRemarks
     * The tolerance is add on top of the gasUsed calculated
     * from the node, this create a safe margin costs like
     * change states on transfer that don't occur on the dryRun
     * transaction. The default value is 0.2 or 20%
     *
     * @param transactionRequestLike - The transaction request object.
     * @param tolerance - The tolerance to add on top of the gasUsed.
     * @returns A promise that resolves to the transaction cost object.
     */
    async getTransactionCost(transactionRequestLike, forwardingQuantities = [], {
      estimateTxDependencies = true,
      estimatePredicates = true,
      resourcesOwner,
      signatureCallback
    } = {}) {
      const txRequestClone = clone_default(transactionRequestify2(transactionRequestLike));
      const chainInfo = this.getChain();
      const { gasPriceFactor, minGasPrice, maxGasPerTx } = this.getGasConfig();
      const gasPrice = max(txRequestClone.gasPrice, minGasPrice);
      const isScriptTransaction = txRequestClone.type === TransactionType.Script;
      const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
      const allQuantities = mergeQuantities2(coinOutputsQuantities, forwardingQuantities);
      txRequestClone.fundWithFakeUtxos(allQuantities, resourcesOwner?.address);
      if (estimatePredicates) {
        if (isScriptTransaction) {
          txRequestClone.gasLimit = bn(0);
        }
        if (resourcesOwner && "populateTransactionPredicateData" in resourcesOwner) {
          resourcesOwner.populateTransactionPredicateData(txRequestClone);
        }
        await this.estimatePredicates(txRequestClone);
      }
      if (signatureCallback && isScriptTransaction) {
        await signatureCallback(txRequestClone);
      }
      const minGas = txRequestClone.calculateMinGas(chainInfo);
      const maxGas = txRequestClone.calculateMaxGas(chainInfo, minGas);
      let receipts = [];
      let missingContractIds = [];
      let outputVariables = 0;
      if (isScriptTransaction && estimateTxDependencies) {
        txRequestClone.gasPrice = bn(0);
        txRequestClone.gasLimit = bn(maxGasPerTx.sub(maxGas).toNumber() * 0.9);
        const result = await this.estimateTxDependencies(txRequestClone);
        receipts = result.receipts;
        outputVariables = result.outputVariables;
        missingContractIds = result.missingContractIds;
      }
      const gasUsed = isScriptTransaction ? getGasUsedFromReceipts2(receipts) : minGas;
      const usedFee = calculatePriceWithFactor2(
        gasUsed,
        gasPrice,
        gasPriceFactor
      ).normalizeZeroToOne();
      const minFee = calculatePriceWithFactor2(minGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
      const maxFee = calculatePriceWithFactor2(maxGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
      return {
        requiredQuantities: allQuantities,
        receipts,
        gasUsed,
        minGasPrice,
        gasPrice,
        minGas,
        maxGas,
        usedFee,
        minFee,
        maxFee,
        estimatedInputs: txRequestClone.inputs,
        outputVariables,
        missingContractIds
      };
    }
    async getResourcesForTransaction(owner, transactionRequestLike, forwardingQuantities = []) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const transactionRequest = transactionRequestify2(clone_default(transactionRequestLike));
      const transactionCost = await this.getTransactionCost(transactionRequest, forwardingQuantities);
      transactionRequest.addResources(
        await this.getResourcesToSpend(ownerAddress, transactionCost.requiredQuantities)
      );
      const { requiredQuantities, ...txCost } = await this.getTransactionCost(
        transactionRequest,
        forwardingQuantities
      );
      const resources = await this.getResourcesToSpend(ownerAddress, requiredQuantities);
      return {
        resources,
        requiredQuantities,
        ...txCost
      };
    }
    /**
     * Returns coins for the given owner.
     */
    async getCoins(owner, assetId, paginationArgs) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const result = await this.operations.getCoins({
        first: 10,
        ...paginationArgs,
        filter: { owner: ownerAddress.toB256(), assetId: assetId && hexlify(assetId) }
      });
      const coins = result.coins.edges.map((edge) => edge.node);
      return coins.map((coin) => ({
        id: coin.utxoId,
        assetId: coin.assetId,
        amount: bn(coin.amount),
        owner: Address.fromAddressOrString(coin.owner),
        maturity: bn(coin.maturity).toNumber(),
        blockCreated: bn(coin.blockCreated),
        txCreatedIdx: bn(coin.txCreatedIdx)
      }));
    }
    /**
     * Returns resources for the given owner satisfying the spend query.
     *
     * @param owner - The address to get resources for.
     * @param quantities - The quantities to get.
     * @param excludedIds - IDs of excluded resources from the selection.
     * @returns A promise that resolves to the resources.
     */
    async getResourcesToSpend(owner, quantities, excludedIds) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const excludeInput = {
        messages: excludedIds?.messages?.map((nonce) => hexlify(nonce)) || [],
        utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || []
      };
      if (this.cache) {
        const uniqueUtxos = new Set(
          excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => hexlify(id)))
        );
        excludeInput.utxos = Array.from(uniqueUtxos);
      }
      const coinsQuery = {
        owner: ownerAddress.toB256(),
        queryPerAsset: quantities.map(coinQuantityfy2).map(({ assetId, amount, max: maxPerAsset }) => ({
          assetId: hexlify(assetId),
          amount: amount.toString(10),
          max: maxPerAsset ? maxPerAsset.toString(10) : void 0
        })),
        excludedIds: excludeInput
      };
      const result = await this.operations.getCoinsToSpend(coinsQuery);
      const coins = result.coinsToSpend.flat().map((coin) => {
        switch (coin.__typename) {
          case "MessageCoin":
            return {
              amount: bn(coin.amount),
              assetId: coin.assetId,
              daHeight: bn(coin.daHeight),
              sender: Address.fromAddressOrString(coin.sender),
              recipient: Address.fromAddressOrString(coin.recipient),
              nonce: coin.nonce
            };
          case "Coin":
            return {
              id: coin.utxoId,
              amount: bn(coin.amount),
              assetId: coin.assetId,
              owner: Address.fromAddressOrString(coin.owner),
              maturity: bn(coin.maturity).toNumber(),
              blockCreated: bn(coin.blockCreated),
              txCreatedIdx: bn(coin.txCreatedIdx)
            };
          default:
            return null;
        }
      }).filter((v) => !!v);
      return coins;
    }
    /**
     * Returns block matching the given ID or height.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    async getBlock(idOrHeight) {
      let variables;
      if (typeof idOrHeight === "number") {
        variables = { height: bn(idOrHeight).toString(10) };
      } else if (idOrHeight === "latest") {
        variables = { height: (await this.getBlockNumber()).toString(10) };
      } else if (idOrHeight.length === 66) {
        variables = { blockId: idOrHeight };
      } else {
        variables = { blockId: bn(idOrHeight).toString(10) };
      }
      const { block: block2 } = await this.operations.getBlock(variables);
      if (!block2) {
        return null;
      }
      return {
        id: block2.id,
        height: bn(block2.header.height),
        time: block2.header.time,
        transactionIds: block2.transactions.map((tx) => tx.id)
      };
    }
    /**
     * Returns all the blocks matching the given parameters.
     *
     * @param params - The parameters to query blocks.
     * @returns A promise that resolves to the blocks.
     */
    async getBlocks(params) {
      const { blocks: fetchedData } = await this.operations.getBlocks(params);
      const blocks = fetchedData.edges.map(({ node: block2 }) => ({
        id: block2.id,
        height: bn(block2.header.height),
        time: block2.header.time,
        transactionIds: block2.transactions.map((tx) => tx.id)
      }));
      return blocks;
    }
    /**
     * Returns block matching the given ID or type, including transaction data.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    async getBlockWithTransactions(idOrHeight) {
      let variables;
      if (typeof idOrHeight === "number") {
        variables = { blockHeight: bn(idOrHeight).toString(10) };
      } else if (idOrHeight === "latest") {
        variables = { blockHeight: (await this.getBlockNumber()).toString() };
      } else {
        variables = { blockId: idOrHeight };
      }
      const { block: block2 } = await this.operations.getBlockWithTransactions(variables);
      if (!block2) {
        return null;
      }
      return {
        id: block2.id,
        height: bn(block2.header.height, 10),
        time: block2.header.time,
        transactionIds: block2.transactions.map((tx) => tx.id),
        transactions: block2.transactions.map(
          (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]
        )
      };
    }
    /**
     * Get transaction with the given ID.
     *
     * @param transactionId - ID of the transaction.
     * @returns A promise that resolves to the transaction.
     */
    async getTransaction(transactionId) {
      const { transaction } = await this.operations.getTransaction({ transactionId });
      if (!transaction) {
        return null;
      }
      return new TransactionCoder().decode(
        arrayify(transaction.rawPayload),
        0
      )?.[0];
    }
    /**
     * Get deployed contract with the given ID.
     *
     * @param contractId - ID of the contract.
     * @returns A promise that resolves to the contract.
     */
    async getContract(contractId) {
      const { contract } = await this.operations.getContract({ contractId });
      if (!contract) {
        return null;
      }
      return contract;
    }
    /**
     * Returns the balance for the given contract for the given asset ID.
     *
     * @param contractId - The contract ID to get the balance for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getContractBalance(contractId, assetId) {
      const { contractBalance } = await this.operations.getContractBalance({
        contract: Address.fromAddressOrString(contractId).toB256(),
        asset: hexlify(assetId)
      });
      return bn(contractBalance.amount, 10);
    }
    /**
     * Returns the balance for the given owner for the given asset ID.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getBalance(owner, assetId) {
      const { balance } = await this.operations.getBalance({
        owner: Address.fromAddressOrString(owner).toB256(),
        assetId: hexlify(assetId)
      });
      return bn(balance.amount, 10);
    }
    /**
     * Returns balances for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param paginationArgs - Pagination arguments.
     * @returns A promise that resolves to the balances.
     */
    async getBalances(owner, paginationArgs) {
      const result = await this.operations.getBalances({
        first: 10,
        ...paginationArgs,
        filter: { owner: Address.fromAddressOrString(owner).toB256() }
      });
      const balances = result.balances.edges.map((edge) => edge.node);
      return balances.map((balance) => ({
        assetId: balance.assetId,
        amount: bn(balance.amount)
      }));
    }
    /**
     * Returns message for the given address.
     *
     * @param address - The address to get message from.
     * @param paginationArgs - Pagination arguments.
     * @returns A promise that resolves to the messages.
     */
    async getMessages(address, paginationArgs) {
      const result = await this.operations.getMessages({
        first: 10,
        ...paginationArgs,
        owner: Address.fromAddressOrString(address).toB256()
      });
      const messages = result.messages.edges.map((edge) => edge.node);
      return messages.map((message) => ({
        messageId: InputMessageCoder.getMessageId({
          sender: message.sender,
          recipient: message.recipient,
          nonce: message.nonce,
          amount: bn(message.amount),
          data: message.data
        }),
        sender: Address.fromAddressOrString(message.sender),
        recipient: Address.fromAddressOrString(message.recipient),
        nonce: message.nonce,
        amount: bn(message.amount),
        data: InputMessageCoder.decodeData(message.data),
        daHeight: bn(message.daHeight)
      }));
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param transactionId - The transaction to get message from.
     * @param messageId - The message id from MessageOut receipt.
     * @param commitBlockId - The commit block id.
     * @param commitBlockHeight - The commit block height.
     * @returns A promise that resolves to the message proof.
     */
    async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
      let inputObject = {
        transactionId,
        nonce
      };
      if (commitBlockId && commitBlockHeight) {
        throw new FuelError(
          ErrorCode.INVALID_INPUT_PARAMETERS,
          "commitBlockId and commitBlockHeight cannot be used together"
        );
      }
      if (commitBlockId) {
        inputObject = {
          ...inputObject,
          commitBlockId
        };
      }
      if (commitBlockHeight) {
        inputObject = {
          ...inputObject,
          // Conver BN into a number string required on the query
          // This should problably be fixed on the fuel client side
          commitBlockHeight: commitBlockHeight.toNumber().toString()
        };
      }
      const result = await this.operations.getMessageProof(inputObject);
      if (!result.messageProof) {
        return null;
      }
      const {
        messageProof,
        messageBlockHeader,
        commitBlockHeader,
        blockProof,
        sender,
        recipient,
        amount,
        data
      } = result.messageProof;
      return {
        messageProof: {
          proofIndex: bn(messageProof.proofIndex),
          proofSet: messageProof.proofSet
        },
        blockProof: {
          proofIndex: bn(blockProof.proofIndex),
          proofSet: blockProof.proofSet
        },
        messageBlockHeader: {
          id: messageBlockHeader.id,
          daHeight: bn(messageBlockHeader.daHeight),
          transactionsCount: bn(messageBlockHeader.transactionsCount),
          transactionsRoot: messageBlockHeader.transactionsRoot,
          height: bn(messageBlockHeader.height),
          prevRoot: messageBlockHeader.prevRoot,
          time: messageBlockHeader.time,
          applicationHash: messageBlockHeader.applicationHash,
          messageReceiptRoot: messageBlockHeader.messageReceiptRoot,
          messageReceiptCount: bn(messageBlockHeader.messageReceiptCount)
        },
        commitBlockHeader: {
          id: commitBlockHeader.id,
          daHeight: bn(commitBlockHeader.daHeight),
          transactionsCount: bn(commitBlockHeader.transactionsCount),
          transactionsRoot: commitBlockHeader.transactionsRoot,
          height: bn(commitBlockHeader.height),
          prevRoot: commitBlockHeader.prevRoot,
          time: commitBlockHeader.time,
          applicationHash: commitBlockHeader.applicationHash,
          messageReceiptRoot: commitBlockHeader.messageReceiptRoot,
          messageReceiptCount: bn(commitBlockHeader.messageReceiptCount)
        },
        sender: Address.fromAddressOrString(sender),
        recipient: Address.fromAddressOrString(recipient),
        nonce,
        amount: bn(amount),
        data
      };
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param nonce - The nonce of the message to get status from.
     * @returns A promise that resolves to the message status
     */
    async getMessageStatus(nonce) {
      const result = await this.operations.getMessageStatus({ nonce });
      return result.messageStatus;
    }
    /**
     * Lets you produce blocks with custom timestamps and the block number of the last block produced.
     *
     * @param amount - The amount of blocks to produce
     * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block
     * @returns A promise that resolves to the block number of the last produced block.
     */
    async produceBlocks(amount, startTime) {
      const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
        blocksToProduce: bn(amount).toString(10),
        startTimestamp: startTime ? DateTime.fromUnixMilliseconds(startTime).toTai64() : void 0
      });
      return bn(latestBlockHeight);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getTransactionResponse(transactionId) {
      return new TransactionResponse3(transactionId, this);
    }
  };
  var Provider2 = _Provider2;
  _cacheInputs2 = /* @__PURE__ */ new WeakSet();
  cacheInputs_fn2 = function(inputs) {
    if (!this.cache) {
      return;
    }
    inputs.forEach((input) => {
      if (input.type === InputType.Coin) {
        this.cache?.set(input.id);
      }
    });
  };
  __publicField7(Provider2, "chainInfoCache", {});
  __publicField7(Provider2, "nodeInfoCache", {});
  var CHAIN_IDS2 = {
    eth: {
      sepolia: 11155111,
      foundry: 31337
    },
    fuel: {
      beta5: 0,
      devnet: 10
    }
  };
  var assets2 = [
    {
      name: "Ethereum",
      symbol: "ETH",
      icon: "eth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.sepolia,
          decimals: 18
        },
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.foundry,
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.beta5,
          decimals: 9,
          assetId: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.devnet,
          decimals: 9,
          assetId: "0x0000000000000000000000000000000000000000000000000000000000000000"
        }
      ]
    }
  ];
  var formatTransferToContractScriptData2 = (params) => {
    const { assetId, amountToTransfer, hexlifiedContractId } = params;
    const numberCoder = new BigNumberCoder("u64");
    const encoded = numberCoder.encode(new BN(amountToTransfer).toNumber());
    const scriptData = Uint8Array.from([
      ...arrayify(hexlifiedContractId),
      ...encoded,
      ...arrayify(assetId)
    ]);
    return scriptData;
  };
  var assembleTransferToContractScript2 = async (params) => {
    const scriptData = formatTransferToContractScriptData2(params);
    await asm4.initWasm();
    const gtf22 = asm4.gtf(16, 0, asm4.GTFArgs.ScriptData);
    const addi22 = asm4.addi(17, 16, 32);
    const lw22 = asm4.lw(18, 17, 0);
    const addi222 = asm4.addi(19, 17, 8);
    const tr22 = asm4.tr(16, 18, 19);
    const ret22 = asm4.ret(1);
    const script = Uint8Array.from([
      ...gtf22.to_bytes(),
      ...addi22.to_bytes(),
      ...lw22.to_bytes(),
      ...addi222.to_bytes(),
      ...tr22.to_bytes(),
      ...ret22.to_bytes()
    ]);
    return { script, scriptData };
  };
  var Account2 = class extends AbstractAccount {
    /**
     * The address associated with the account.
     */
    address;
    /**
     * The provider used to interact with the network.
     */
    _provider;
    _connector;
    /**
     * Creates a new Account instance.
     *
     * @param address - The address of the account.
     * @param provider - A Provider instance  (optional).
     */
    constructor(address, provider, connector) {
      super();
      this._provider = provider;
      this._connector = connector;
      this.address = Address.fromDynamicInput(address);
    }
    /**
     * The provider used to interact with the network.
     *
     * @returns A Provider instance.
     *
     * @throws `FuelError` if the provider is not set.
     */
    get provider() {
      if (!this._provider) {
        throw new FuelError(ErrorCode.MISSING_PROVIDER, "Provider not set");
      }
      return this._provider;
    }
    /**
     * Sets the provider for the account.
     *
     * @param provider - A Provider instance.
     */
    set provider(provider) {
      this._provider = provider;
    }
    /**
     * Changes the provider connection for the account.
     *
     * @param provider - A Provider instance.
     * @returns The updated Provider instance.
     */
    connect(provider) {
      this._provider = provider;
      return this.provider;
    }
    /**
     * Retrieves resources satisfying the spend query for the account.
     *
     * @param quantities - IDs of coins to exclude.
     * @param excludedIds - IDs of resources to be excluded from the query.
     * @returns A promise that resolves to an array of Resources.
     */
    async getResourcesToSpend(quantities, excludedIds) {
      return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
    }
    /**
     * Retrieves coins owned by the account.
     *
     * @param assetId - The asset ID of the coins to retrieve.
     * @returns A promise that resolves to an array of Coins.
     */
    async getCoins(assetId) {
      const coins = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageCoins = await this.provider.getCoins(this.address, assetId, {
          first: pageSize,
          after: cursor
        });
        coins.push(...pageCoins);
        const hasNextPage = pageCoins.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
        );
      }
      return coins;
    }
    /**
     * Retrieves messages owned by the account.
     *
     * @returns A promise that resolves to an array of Messages.
     */
    async getMessages() {
      const messages = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageMessages = await this.provider.getMessages(this.address, {
          first: pageSize,
          after: cursor
        });
        messages.push(...pageMessages);
        const hasNextPage = pageMessages.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
        );
      }
      return messages;
    }
    /**
     * Retrieves the balance of the account for the given asset.
     *
     * @param assetId - The asset ID to check the balance for.
     * @returns A promise that resolves to the balance amount.
     */
    async getBalance(assetId = BaseAssetId) {
      const amount = await this.provider.getBalance(this.address, assetId);
      return amount;
    }
    /**
     * Retrieves all the balances for the account.
     *
     * @returns A promise that resolves to an array of Coins and their quantities.
     */
    async getBalances() {
      const balances = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageBalances = await this.provider.getBalances(this.address, {
          first: pageSize,
          after: cursor
        });
        balances.push(...pageBalances);
        const hasNextPage = pageBalances.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
        );
      }
      return balances;
    }
    /**
     * Adds resources to the transaction enough to fund it.
     *
     * @param request - The transaction request.
     * @param coinQuantities - The coin quantities required to execute the transaction.
     * @param fee - The estimated transaction fee.
     * @returns A promise that resolves when the resources are added to the transaction.
     */
    async fund(request, coinQuantities, fee) {
      const updatedQuantities = addAmountToAsset2({
        amount: bn(fee),
        assetId: BaseAssetId,
        coinQuantities
      });
      const quantitiesDict = {};
      updatedQuantities.forEach(({ amount, assetId }) => {
        quantitiesDict[assetId] = {
          required: amount,
          owned: bn(0)
        };
      });
      const cachedUtxos = [];
      const cachedMessages = [];
      const owner = this.address.toB256();
      request.inputs.forEach((input) => {
        const isResource = "amount" in input;
        if (isResource) {
          const isCoin22 = "owner" in input;
          if (isCoin22) {
            const assetId = String(input.assetId);
            if (input.owner === owner && quantitiesDict[assetId]) {
              const amount = bn(input.amount);
              quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(amount);
              cachedUtxos.push(input.id);
            }
          } else if (input.recipient === owner && input.amount && quantitiesDict[BaseAssetId]) {
            quantitiesDict[BaseAssetId].owned = quantitiesDict[BaseAssetId].owned.add(input.amount);
            cachedMessages.push(input.nonce);
          }
        }
      });
      const missingQuantities = [];
      Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
        if (owned.lt(required)) {
          missingQuantities.push({
            assetId,
            amount: required.sub(owned)
          });
        }
      });
      const needsToBeFunded = missingQuantities.length;
      if (needsToBeFunded) {
        const resources = await this.getResourcesToSpend(missingQuantities, {
          messages: cachedMessages,
          utxos: cachedUtxos
        });
        request.addResources(resources);
      }
    }
    /**
     * A helper that creates a transfer transaction request and returns it.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
     * @returns A promise that resolves to the prepared transaction request.
     */
    async createTransfer(destination, amount, assetId = BaseAssetId, txParams = {}) {
      const { minGasPrice } = this.provider.getGasConfig();
      const params = { gasPrice: minGasPrice, ...txParams };
      const request = new ScriptTransactionRequest2(params);
      request.addCoinOutput(Address.fromAddressOrString(destination), amount, assetId);
      const { maxFee, requiredQuantities, gasUsed, estimatedInputs } = await this.provider.getTransactionCost(request, [], {
        estimateTxDependencies: true,
        resourcesOwner: this
      });
      request.gasPrice = bn(txParams.gasPrice ?? minGasPrice);
      request.gasLimit = bn(txParams.gasLimit ?? gasUsed);
      this.validateGas({
        gasUsed,
        gasPrice: request.gasPrice,
        gasLimit: request.gasLimit,
        minGasPrice
      });
      await this.fund(request, requiredQuantities, maxFee);
      request.updatePredicateInputs(estimatedInputs);
      return request;
    }
    /**
     * Transfers coins to a destination address.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
     * @returns A promise that resolves to the transaction response.
     */
    async transfer(destination, amount, assetId = BaseAssetId, txParams = {}) {
      if (bn(amount).lte(0)) {
        throw new FuelError(
          ErrorCode.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      }
      const request = await this.createTransfer(destination, amount, assetId, txParams);
      return this.sendTransaction(request, { estimateTxDependencies: false });
    }
    /**
     * Transfers coins to a contract address.
     *
     * @param contractId - The address of the contract.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The optional transaction parameters.
     * @returns A promise that resolves to the transaction response.
     */
    async transferToContract(contractId, amount, assetId = BaseAssetId, txParams = {}) {
      if (bn(amount).lte(0)) {
        throw new FuelError(
          ErrorCode.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      }
      const contractAddress = Address.fromAddressOrString(contractId);
      const { minGasPrice } = this.provider.getGasConfig();
      const params = { gasPrice: minGasPrice, ...txParams };
      const { script, scriptData } = await assembleTransferToContractScript2({
        hexlifiedContractId: contractAddress.toB256(),
        amountToTransfer: bn(amount),
        assetId
      });
      const request = new ScriptTransactionRequest2({
        ...params,
        script,
        scriptData
      });
      request.addContractInputAndOutput(contractAddress);
      const { maxFee, requiredQuantities, gasUsed } = await this.provider.getTransactionCost(
        request,
        [{ amount: bn(amount), assetId: String(assetId) }]
      );
      request.gasLimit = bn(params.gasLimit ?? gasUsed);
      this.validateGas({
        gasUsed,
        gasPrice: request.gasPrice,
        gasLimit: request.gasLimit,
        minGasPrice
      });
      await this.fund(request, requiredQuantities, maxFee);
      return this.sendTransaction(request);
    }
    /**
     * Withdraws an amount of the base asset to the base chain.
     *
     * @param recipient - Address of the recipient on the base chain.
     * @param amount - Amount of base asset.
     * @param txParams - The optional transaction parameters.
     * @returns A promise that resolves to the transaction response.
     */
    async withdrawToBaseLayer(recipient, amount, txParams = {}) {
      const { minGasPrice } = this.provider.getGasConfig();
      const recipientAddress = Address.fromAddressOrString(recipient);
      const recipientDataArray = arrayify(
        "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
      );
      const amountDataArray = arrayify(
        "0x".concat(bn(amount).toHex().substring(2).padStart(16, "0"))
      );
      const script = new Uint8Array([
        ...arrayify(withdrawScript2.bytes),
        ...recipientDataArray,
        ...amountDataArray
      ]);
      const params = { script, gasPrice: minGasPrice, ...txParams };
      const request = new ScriptTransactionRequest2(params);
      const forwardingQuantities = [{ amount: bn(amount), assetId: BaseAssetId }];
      const { requiredQuantities, maxFee, gasUsed } = await this.provider.getTransactionCost(
        request,
        forwardingQuantities
      );
      request.gasLimit = bn(params.gasLimit ?? gasUsed);
      this.validateGas({
        gasUsed,
        gasPrice: request.gasPrice,
        gasLimit: request.gasLimit,
        minGasPrice
      });
      await this.fund(request, requiredQuantities, maxFee);
      return this.sendTransaction(request);
    }
    async signMessage(message) {
      if (!this._connector) {
        throw new FuelError(ErrorCode.MISSING_CONNECTOR, "A connector is required to sign messages.");
      }
      return this._connector.signMessage(this.address.toString(), message);
    }
    /**
     * Signs a transaction with the wallet's private key.
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature of the transaction.
     */
    async signTransaction(transactionRequestLike) {
      if (!this._connector) {
        throw new FuelError(
          ErrorCode.MISSING_CONNECTOR,
          "A connector is required to sign transactions."
        );
      }
      return this._connector.signTransaction(this.address.toString(), transactionRequestLike);
    }
    /**
     * Sends a transaction to the network.
     *
     * @param transactionRequestLike - The transaction request to be sent.
     * @returns A promise that resolves to the transaction response.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution } = {}) {
      if (this._connector) {
        return this.provider.getTransactionResponse(
          await this._connector.sendTransaction(this.address.toString(), transactionRequestLike)
        );
      }
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.sendTransaction(transactionRequest, {
        awaitExecution,
        estimateTxDependencies: false
      });
    }
    /**
     * Simulates a transaction.
     *
     * @param transactionRequestLike - The transaction request to be simulated.
     * @returns A promise that resolves to the call result.
     */
    async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
    }
    validateGas({
      gasUsed,
      gasPrice,
      gasLimit,
      minGasPrice
    }) {
      if (minGasPrice.gt(gasPrice)) {
        throw new FuelError(
          ErrorCode.GAS_PRICE_TOO_LOW,
          `Gas price '${gasPrice}' is lower than the required: '${minGasPrice}'.`
        );
      }
      if (gasUsed.gt(gasLimit)) {
        throw new FuelError(
          ErrorCode.GAS_LIMIT_TOO_LOW,
          `Gas limit '${gasLimit}' is lower than the required: '${gasUsed}'.`
        );
      }
    }
  };
  var Signer2 = class {
    address;
    publicKey;
    compressedPublicKey;
    privateKey;
    /**
     * Create a Signer instance from a given private key
     *
     * @param privateKey - The private key to use for signing
     * @returns A new Signer instance
     */
    constructor(privateKey) {
      if (typeof privateKey === "string") {
        if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
          privateKey = `0x${privateKey}`;
        }
      }
      const privateKeyBytes = toBytes3(privateKey, 32);
      this.privateKey = hexlify(privateKeyBytes);
      this.publicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
      this.compressedPublicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, true));
      this.address = Address.fromPublicKey(this.publicKey);
    }
    /**
     * Sign data using the Signer instance
     *
     * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
     * @ignore
     * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
     *
     * @param data - The data to be sign
     * @returns hashed signature
     */
    sign(data) {
      const signature = secp256k1.sign(arrayify(data), arrayify(this.privateKey));
      const r = toBytes3(`0x${signature.r.toString(16)}`, 32);
      const s = toBytes3(`0x${signature.s.toString(16)}`, 32);
      s[0] |= (signature.recovery || 0) << 7;
      return hexlify(concat([r, s]));
    }
    /**
     * Add point on the current elliptic curve
     *
     * @param point - Point to add on the curve
     * @returns compressed point on the curve
     */
    addPoint(point) {
      const p0 = secp256k1.ProjectivePoint.fromHex(arrayify(this.compressedPublicKey));
      const p1 = secp256k1.ProjectivePoint.fromHex(arrayify(point));
      const result = p0.add(p1);
      return `0x${result.toHex(true)}`;
    }
    /**
     * Recover the public key from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - hashed signature
     * @returns public key from signature from the
     */
    static recoverPublicKey(data, signature) {
      const signedMessageBytes = arrayify(signature);
      const r = signedMessageBytes.slice(0, 32);
      const s = signedMessageBytes.slice(32, 64);
      const recoveryParam = (s[0] & 128) >> 7;
      s[0] &= 127;
      const sig = new secp256k1.Signature(BigInt(hexlify(r)), BigInt(hexlify(s))).addRecoveryBit(
        recoveryParam
      );
      const publicKey = sig.recoverPublicKey(arrayify(data)).toRawBytes(false).slice(1);
      return hexlify(publicKey);
    }
    /**
     * Recover the address from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - Signature
     * @returns Address from signature
     */
    static recoverAddress(data, signature) {
      return Address.fromPublicKey(Signer2.recoverPublicKey(data, signature));
    }
    /**
     * Generate a random privateKey
     *
     * @param entropy - Adds extra entropy to generate the privateKey
     * @returns random 32-byte hashed
     */
    static generatePrivateKey(entropy) {
      return entropy ? hash3(concat([randomBytes22(32), arrayify(entropy)])) : randomBytes22(32);
    }
    /**
     * Extended publicKey from a compact publicKey
     *
     * @param publicKey - Compact publicKey
     * @returns extended publicKey
     */
    static extendPublicKey(publicKey) {
      const point = secp256k1.ProjectivePoint.fromHex(arrayify(publicKey));
      return hexlify(point.toRawBytes(false).slice(1));
    }
  };
  var DEFAULT_KDF_PARAMS_LOG_N2 = 13;
  var DEFAULT_KDF_PARAMS_R2 = 8;
  var DEFAULT_KDF_PARAMS_P2 = 1;
  var DEFAULT_KEY_SIZE2 = 32;
  var DEFAULT_IV_SIZE2 = 16;
  var removeHexPrefix2 = (hexString) => {
    if (/^0x/.test(hexString)) {
      return hexString.slice(2);
    }
    return hexString;
  };
  async function encryptKeystoreWallet2(privateKey, address, password) {
    const privateKeyBuffer = bufferFromString2(removeHexPrefix2(privateKey), "hex");
    const ownerAddress = Address.fromAddressOrString(address);
    const salt = randomBytes22(DEFAULT_KEY_SIZE2);
    const key = scrypt22({
      password: bufferFromString2(password),
      salt,
      dklen: DEFAULT_KEY_SIZE2,
      n: 2 ** DEFAULT_KDF_PARAMS_LOG_N2,
      r: DEFAULT_KDF_PARAMS_R2,
      p: DEFAULT_KDF_PARAMS_P2
    });
    const iv = randomBytes22(DEFAULT_IV_SIZE2);
    const ciphertext = await encryptJsonWalletData2(privateKeyBuffer, key, iv);
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
    const macHashUint8Array = keccak25622(data);
    const mac = stringFromBuffer2(macHashUint8Array, "hex");
    const keystore = {
      id: v4_default(),
      version: 3,
      address: removeHexPrefix2(ownerAddress.toHexString()),
      crypto: {
        cipher: "aes-128-ctr",
        mac,
        cipherparams: { iv: stringFromBuffer2(iv, "hex") },
        ciphertext: stringFromBuffer2(ciphertext, "hex"),
        kdf: "scrypt",
        kdfparams: {
          dklen: DEFAULT_KEY_SIZE2,
          n: 2 ** DEFAULT_KDF_PARAMS_LOG_N2,
          p: DEFAULT_KDF_PARAMS_P2,
          r: DEFAULT_KDF_PARAMS_R2,
          salt: stringFromBuffer2(salt, "hex")
        }
      }
    };
    return JSON.stringify(keystore);
  }
  async function decryptKeystoreWallet2(jsonWallet, password) {
    const keystoreWallet = JSON.parse(jsonWallet);
    const {
      crypto: {
        mac,
        ciphertext,
        cipherparams: { iv },
        kdfparams: { dklen, n, r, p, salt }
      }
    } = keystoreWallet;
    const ciphertextBuffer = bufferFromString2(ciphertext, "hex");
    const ivBuffer = bufferFromString2(iv, "hex");
    const saltBuffer = bufferFromString2(salt, "hex");
    const passwordBuffer = bufferFromString2(password);
    const key = scrypt22({
      password: passwordBuffer,
      salt: saltBuffer,
      n,
      p,
      r,
      dklen
    });
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
    const macHashUint8Array = keccak25622(data);
    const macHash = stringFromBuffer2(macHashUint8Array, "hex");
    if (mac !== macHash) {
      throw new FuelError(
        ErrorCode.INVALID_PASSWORD,
        "Failed to decrypt the keystore wallet, the provided password is incorrect."
      );
    }
    const buffer = await decryptJsonWalletData2(ciphertextBuffer, key, ivBuffer);
    const privateKey = hexlify(buffer);
    return privateKey;
  }
  var BaseWalletUnlocked2 = class extends Account2 {
    /**
     * A function that returns the wallet's signer.
     */
    signer;
    /**
     * Creates a new BaseWalletUnlocked instance.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance (optional).
     */
    constructor(privateKey, provider) {
      const signer = new Signer2(privateKey);
      super(signer.address, provider);
      this.signer = () => signer;
    }
    /**
     * Gets the private key of the wallet.
     *
     * @returns The private key of the wallet.
     */
    get privateKey() {
      return this.signer().privateKey;
    }
    /**
     * Gets the public key of the wallet.
     *
     * @returns
     */
    get publicKey() {
      return this.signer().publicKey;
    }
    /**
     * Signs a message with the wallet's private key.
     *
     * @param message - The message to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signMessage(message) {
      const signedMessage = await this.signer().sign(hashMessage(message));
      return hexlify(signedMessage);
    }
    /**
     * Signs a transaction with the wallet's private key.
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      const chainId = this.provider.getChainId();
      const hashedTransaction = transactionRequest.getTransactionId(chainId);
      const signature = await this.signer().sign(hashedTransaction);
      return hexlify(signature);
    }
    /**
     * Populates a transaction with the witnesses signature.
     *
     * @param transactionRequestLike - The transaction request to populate.
     * @returns The populated transaction request.
     */
    async populateTransactionWitnessesSignature(transactionRequestLike) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      const signedTransaction = await this.signTransaction(transactionRequest);
      transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
      return transactionRequest;
    }
    /**
     * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequestLike - The transaction request to send.
     * @returns A promise that resolves to the TransactionResponse object.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.sendTransaction(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        { awaitExecution, estimateTxDependencies: false }
      );
    }
    /**
     * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
     *
     * @param transactionRequestLike - The transaction request to simulate.
     * @returns A promise that resolves to the CallResult object.
     */
    async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.call(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        {
          utxoValidation: true,
          estimateTxDependencies: false
        }
      );
    }
    async encrypt(password) {
      return encryptKeystoreWallet2(this.privateKey, this.address, password);
    }
  };
  __publicField7(BaseWalletUnlocked2, "defaultPath", "m/44'/1179993420'/0'/0/0");
  var english2 = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  function toUtf8Bytes3(stri) {
    const str = stri.normalize("NFKD");
    const result = [];
    for (let i = 0; i < str.length; i += 1) {
      const c = str.charCodeAt(i);
      if (c < 128) {
        result.push(c);
      } else if (c < 2048) {
        result.push(c >> 6 | 192);
        result.push(c & 63 | 128);
      } else if ((c & 64512) === 55296) {
        i += 1;
        const c2 = str.charCodeAt(i);
        if (i >= str.length || (c2 & 64512) !== 56320) {
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            "Invalid UTF-8 in the input string."
          );
        }
        const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c >> 12 | 224);
        result.push(c >> 6 & 63 | 128);
        result.push(c & 63 | 128);
      }
    }
    return Uint8Array.from(result);
  }
  function getLowerMask2(bits) {
    return (1 << bits) - 1;
  }
  function getUpperMask2(bits) {
    return (1 << bits) - 1 << 8 - bits;
  }
  function getWords2(mnemonic) {
    if (!Array.isArray(mnemonic)) {
      return mnemonic.split(/\s+/);
    }
    return mnemonic;
  }
  function getPhrase2(mnemonic) {
    if (Array.isArray(mnemonic)) {
      return mnemonic.join(" ");
    }
    return mnemonic;
  }
  function entropyToMnemonicIndices2(entropy) {
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i += 1) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        indices.push(entropy[i] & getLowerMask2(8 - remainingBits));
        remainingBits += 3;
      }
    }
    const checksumBits = entropy.length / 4;
    const checksum = arrayify(sha2563(entropy))[0] & getUpperMask2(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return indices;
  }
  function mnemonicWordsToEntropy2(words, wordlist) {
    const size = Math.ceil(11 * words.length / 8);
    const entropy = arrayify(new Uint8Array(size));
    let offset = 0;
    for (let i = 0; i < words.length; i += 1) {
      const index = wordlist.indexOf(words[i].normalize("NFKD"));
      if (index === -1) {
        throw new FuelError(
          ErrorCode.INVALID_MNEMONIC,
          `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
        );
      }
      for (let bit = 0; bit < 11; bit += 1) {
        if (index & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset += 1;
      }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask2(checksumBits);
    const checksum = arrayify(sha2563(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
      throw new FuelError(
        ErrorCode.INVALID_CHECKSUM,
        "Checksum validation failed for the provided mnemonic."
      );
    }
    return entropy.slice(0, entropyBits / 8);
  }
  var MasterSecret2 = toUtf8Bytes3("Bitcoin seed");
  var MainnetPRV3 = "0x0488ade4";
  var TestnetPRV3 = "0x04358394";
  var MNEMONIC_SIZES2 = [12, 15, 18, 21, 24];
  function assertWordList2(wordlist) {
    if (wordlist.length !== 2048) {
      throw new FuelError(
        ErrorCode.INVALID_WORD_LIST,
        `Expected word list length of 2048, but got ${wordlist.length}.`
      );
    }
  }
  function assertEntropy2(entropy) {
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
      throw new FuelError(
        ErrorCode.INVALID_ENTROPY,
        `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
      );
    }
  }
  function assertMnemonic2(words) {
    if (!MNEMONIC_SIZES2.includes(words.length)) {
      const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES2.join(
        ", "
      )}] words, but got ${words.length}.`;
      throw new FuelError(ErrorCode.INVALID_MNEMONIC, errorMsg);
    }
  }
  var Mnemonic2 = class {
    wordlist;
    /**
     *
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic instance
     */
    constructor(wordlist = english2) {
      this.wordlist = wordlist;
      assertWordList2(this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns Entropy hash
     */
    mnemonicToEntropy(phrase) {
      return Mnemonic2.mnemonicToEntropy(phrase, this.wordlist);
    }
    /**
     *
     * @param entropy - Entropy source to the mnemonic phrase.
     * @returns Mnemonic phrase
     */
    entropyToMnemonic(entropy) {
      return Mnemonic2.entropyToMnemonic(entropy, this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic phrase
     */
    static mnemonicToEntropy(phrase, wordlist = english2) {
      const words = getWords2(phrase);
      assertMnemonic2(words);
      return hexlify(mnemonicWordsToEntropy2(words, wordlist));
    }
    /**
     * @param entropy - Entropy source to the mnemonic phrase.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static entropyToMnemonic(entropy, wordlist = english2) {
      const entropyBytes = arrayify(entropy);
      assertWordList2(wordlist);
      assertEntropy2(entropyBytes);
      return entropyToMnemonicIndices2(entropyBytes).map((i) => wordlist[i]).join(" ");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToSeed(phrase, passphrase = "") {
      assertMnemonic2(getWords2(phrase));
      const phraseBytes = toUtf8Bytes3(getPhrase2(phrase));
      const salt = toUtf8Bytes3(`mnemonic${passphrase}`);
      return pbkdf22(phraseBytes, salt, 2048, 64, "sha512");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToMasterKeys(phrase, passphrase = "") {
      const seed = Mnemonic2.mnemonicToSeed(phrase, passphrase);
      return Mnemonic2.masterKeysFromSeed(seed);
    }
    /**
     * Validates if given mnemonic is  valid
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns true if phrase is a valid mnemonic
     */
    static isMnemonicValid(phrase) {
      const words = getWords2(phrase);
      let i = 0;
      try {
        assertMnemonic2(words);
      } catch {
        return false;
      }
      while (i < words.length) {
        if (Mnemonic2.binarySearch(words[i]) === false) {
          return false;
        }
        i += 1;
      }
      return true;
    }
    static binarySearch(target) {
      const words = english2;
      let left = 0;
      let right = words.length - 1;
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (words[mid] === target) {
          return true;
        }
        if (target < words[mid]) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
      return false;
    }
    /**
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static masterKeysFromSeed(seed) {
      const seedArray = arrayify(seed);
      if (seedArray.length < 16 || seedArray.length > 64) {
        throw new FuelError(
          ErrorCode.INVALID_SEED,
          `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
        );
      }
      return arrayify(computeHmac("sha512", MasterSecret2, seedArray));
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    static seedToExtendedKey(seed, testnet = false) {
      const masterKey = Mnemonic2.masterKeysFromSeed(seed);
      const prefix = arrayify(testnet ? TestnetPRV3 : MainnetPRV3);
      const depth = "0x00";
      const fingerprint = "0x00000000";
      const index = "0x00000000";
      const chainCode = masterKey.slice(32);
      const privateKey = masterKey.slice(0, 32);
      const extendedKey = concat([
        prefix,
        depth,
        fingerprint,
        index,
        chainCode,
        concat(["0x00", privateKey])
      ]);
      const checksum = dataSlice(sha2563(sha2563(extendedKey)), 0, 4);
      return encodeBase58(concat([extendedKey, checksum]));
    }
    /**
     *  Create a new mnemonic using a randomly generated number as entropy.
     *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
     *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
     *  If not provided, the default entropy length will be set to 256 bits.
     *  The return is a list of words that encodes the generated entropy.
     *
     *
     * @param size - Number of bytes used as an entropy
     * @param extraEntropy - Optional extra entropy to increase randomness
     * @returns A randomly generated mnemonic
     */
    static generate(size = 32, extraEntropy = "") {
      const entropy = extraEntropy ? sha2563(concat([randomBytes22(size), arrayify(extraEntropy)])) : randomBytes22(size);
      return Mnemonic2.entropyToMnemonic(entropy);
    }
  };
  var mnemonic_default2 = Mnemonic2;
  var HARDENED_INDEX2 = 2147483648;
  var MainnetPRV22 = hexlify("0x0488ade4");
  var MainnetPUB2 = hexlify("0x0488b21e");
  var TestnetPRV22 = hexlify("0x04358394");
  var TestnetPUB2 = hexlify("0x043587cf");
  function base58check2(data) {
    return encodeBase58(concat([data, dataSlice(sha2563(sha2563(data)), 0, 4)]));
  }
  function getExtendedKeyPrefix2(isPublic = false, testnet = false) {
    if (isPublic) {
      return testnet ? TestnetPUB2 : MainnetPUB2;
    }
    return testnet ? TestnetPRV22 : MainnetPRV22;
  }
  function isPublicExtendedKey2(extendedKey) {
    return [MainnetPUB2, TestnetPUB2].includes(hexlify(extendedKey.slice(0, 4)));
  }
  function isValidExtendedKey2(extendedKey) {
    return [MainnetPRV22, TestnetPRV22, MainnetPUB2, TestnetPUB2].includes(
      hexlify(extendedKey.slice(0, 4))
    );
  }
  function parsePath2(path23, depth = 0) {
    const components = path23.split("/");
    if (components.length === 0 || components[0] === "m" && depth !== 0) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, `invalid path - ${path23}`);
    }
    if (components[0] === "m") {
      components.shift();
    }
    return components.map(
      (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX2 : parseInt(p, 10)
    );
  }
  var HDWallet2 = class {
    depth = 0;
    index = 0;
    fingerprint = hexlify("0x00000000");
    parentFingerprint = hexlify("0x00000000");
    privateKey;
    publicKey;
    chainCode;
    /**
     * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
     *
     * @param config - Wallet configurations
     */
    constructor(config) {
      if (config.privateKey) {
        const signer = new Signer2(config.privateKey);
        this.publicKey = hexlify(signer.compressedPublicKey);
        this.privateKey = hexlify(config.privateKey);
      } else {
        if (!config.publicKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Both public and private Key cannot be missing. At least one should be provided."
          );
        }
        this.publicKey = hexlify(config.publicKey);
      }
      this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
      this.fingerprint = dataSlice(ripemd1602(sha2563(this.publicKey)), 0, 4);
      this.depth = config.depth || this.depth;
      this.index = config.index || this.index;
      this.chainCode = config.chainCode;
    }
    get extendedKey() {
      return this.toExtendedKey();
    }
    /**
     * Derive the current HDWallet instance navigating only on the index.
     * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param index - Index of the child HDWallet.
     * @returns A new instance of HDWallet on the derived index
     */
    deriveIndex(index) {
      const privateKey = this.privateKey && arrayify(this.privateKey);
      const publicKey = arrayify(this.publicKey);
      const chainCode = arrayify(this.chainCode);
      const data = new Uint8Array(37);
      if (index & HARDENED_INDEX2) {
        if (!privateKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Cannot derive a hardened index without a private Key."
          );
        }
        data.set(privateKey, 1);
      } else {
        data.set(arrayify(this.publicKey));
      }
      data.set(toBytes3(index, 4), 33);
      const bytes3 = arrayify(computeHmac("sha512", chainCode, data));
      const IL = bytes3.slice(0, 32);
      const IR = bytes3.slice(32);
      if (privateKey) {
        const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
        const ki = bn(IL).add(privateKey).mod(N).toBytes(32);
        return new HDWallet2({
          privateKey: ki,
          chainCode: IR,
          index,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint
        });
      }
      const signer = new Signer2(hexlify(IL));
      const Ki = signer.addPoint(publicKey);
      return new HDWallet2({
        publicKey: Ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    /**
     * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
     * @returns A new instance of HDWallet on the derived path
     */
    derivePath(path23) {
      const paths = parsePath2(path23, this.depth);
      return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    toExtendedKey(isPublic = false, testnet = false) {
      if (this.depth >= 256) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          `Exceeded max depth of 255. Current depth: ${this.depth}.`
        );
      }
      const prefix = getExtendedKeyPrefix2(this.privateKey == null || isPublic, testnet);
      const depth = hexlify(Uint8Array.from([this.depth]));
      const parentFingerprint = this.parentFingerprint;
      const index = toHex(this.index, 4);
      const chainCode = this.chainCode;
      const key = this.privateKey != null && !isPublic ? concat(["0x00", this.privateKey]) : this.publicKey;
      const extendedKey = arrayify(concat([prefix, depth, parentFingerprint, index, chainCode, key]));
      return base58check2(extendedKey);
    }
    /**
     * Create HDWallet instance from seed
     *
     * @param seed - Seed
     * @returns A new instance of HDWallet
     */
    static fromSeed(seed) {
      const masterKey = mnemonic_default2.masterKeysFromSeed(seed);
      return new HDWallet2({
        chainCode: arrayify(masterKey.slice(32)),
        privateKey: arrayify(masterKey.slice(0, 32))
      });
    }
    static fromExtendedKey(extendedKey) {
      const decoded = toBeHex(decodeBase58(extendedKey));
      const bytes3 = arrayify(decoded);
      const validChecksum = base58check2(bytes3.slice(0, 78)) === extendedKey;
      if (bytes3.length !== 82 || !isValidExtendedKey2(bytes3)) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
      }
      if (!validChecksum) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
      }
      const depth = bytes3[4];
      const parentFingerprint = hexlify(bytes3.slice(5, 9));
      const index = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
      const chainCode = hexlify(bytes3.slice(13, 45));
      const key = bytes3.slice(45, 78);
      if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
        );
      }
      if (isPublicExtendedKey2(bytes3)) {
        if (key[0] !== 3) {
          throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
        }
        return new HDWallet2({
          publicKey: key,
          chainCode,
          index,
          depth,
          parentFingerprint
        });
      }
      if (key[0] !== 0) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
      }
      return new HDWallet2({
        privateKey: key.slice(1),
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
  };
  var hdwallet_default2 = HDWallet2;
  var WalletLocked2 = class extends Account2 {
    /**
     * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
     *
     * @param privateKey - The private key used to unlock the wallet.
     * @returns An instance of WalletUnlocked.
     */
    unlock(privateKey) {
      return new WalletUnlocked2(privateKey, this._provider);
    }
  };
  var WalletUnlocked2 = class extends BaseWalletUnlocked2 {
    /**
     * Locks the wallet and returns an instance of WalletLocked.
     *
     * @returns An instance of WalletLocked.
     */
    lock() {
      this.signer = () => new Signer2("0x00");
      return new WalletLocked2(this.address, this._provider);
    }
    /**
     * Generate a new Wallet Unlocked with a random key pair.
     *
     * @param generateOptions - Options to customize the generation process (optional).
     * @returns An instance of WalletUnlocked.
     */
    static generate(generateOptions) {
      const privateKey = Signer2.generatePrivateKey(generateOptions?.entropy);
      return new WalletUnlocked2(privateKey, generateOptions?.provider);
    }
    /**
     * Create a Wallet Unlocked from a seed.
     *
     * @param seed - The seed phrase.
     * @param provider - A Provider instance (optional).
     * @param path - The derivation path (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromSeed(seed, path23, provider) {
      const hdWallet = hdwallet_default2.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path23 || WalletUnlocked2.defaultPath);
      return new WalletUnlocked2(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from a mnemonic phrase.
     *
     * @param mnemonic - The mnemonic phrase.
     * @param provider - A Provider instance (optional).
     * @param path - The derivation path (optional).
     * @param passphrase - The passphrase for the mnemonic (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromMnemonic(mnemonic, path23, passphrase, provider) {
      const seed = mnemonic_default2.mnemonicToSeed(mnemonic, passphrase);
      const hdWallet = hdwallet_default2.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path23 || WalletUnlocked2.defaultPath);
      return new WalletUnlocked2(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an extended key.
     *
     * @param extendedKey - The extended key.
     * @param provider - A Provider instance (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromExtendedKey(extendedKey, provider) {
      const hdWallet = hdwallet_default2.fromExtendedKey(extendedKey);
      return new WalletUnlocked2(hdWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an encrypted JSON.
     *
     * @param jsonWallet - The encrypted JSON keystore.
     * @param password - The password to decrypt the JSON.
     * @param provider - A Provider instance (optional).
     * @returns An unlocked wallet instance.
     */
    static async fromEncryptedJson(jsonWallet, password, provider) {
      const privateKey = await decryptKeystoreWallet2(jsonWallet, password);
      return new WalletUnlocked2(privateKey, provider);
    }
  };
  var Wallet2 = class {
    /**
     * Creates a locked wallet instance from an address and a provider.
     *
     * @param address - The address of the wallet.
     * @param provider - A Provider instance (optional).
     * @returns A locked wallet instance.
     */
    static fromAddress(address, provider) {
      return new WalletLocked2(address, provider);
    }
    /**
     * Creates an unlocked wallet instance from a private key and a provider.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance (optional).
     * @returns An unlocked wallet instance.
     */
    static fromPrivateKey(privateKey, provider) {
      return new WalletUnlocked2(privateKey, provider);
    }
  };
  __publicField7(Wallet2, "generate", WalletUnlocked2.generate);
  __publicField7(Wallet2, "fromSeed", WalletUnlocked2.fromSeed);
  __publicField7(Wallet2, "fromMnemonic", WalletUnlocked2.fromMnemonic);
  __publicField7(Wallet2, "fromExtendedKey", WalletUnlocked2.fromExtendedKey);
  __publicField7(Wallet2, "fromEncryptedJson", WalletUnlocked2.fromEncryptedJson);
  var getFlagValueFromArgs = (args, flag) => {
    const flagIndex = args.indexOf(flag);
    if (flagIndex === -1) {
      return void 0;
    }
    return args[flagIndex + 1];
  };
  var extractRemainingArgs = (args, flagsToRemove) => {
    const newArgs = [...args];
    flagsToRemove.forEach((flag) => {
      const flagIndex = newArgs.indexOf(flag);
      if (flagIndex !== -1) {
        newArgs.splice(flagIndex, 2);
      }
    });
    return newArgs;
  };
  var killNode = (params) => {
    const { child, configPath, state, killFn } = params;
    if (!state.isDead) {
      if (child.pid) {
        state.isDead = true;
        killFn(Number(child.pid));
      }
      child.stdout.removeAllListeners();
      child.stderr.removeAllListeners();
      if ((0, import_fs8.existsSync)(configPath)) {
        (0, import_fs8.rmSync)(configPath, { recursive: true });
      }
    }
  };
  var launchNode = async ({
    ip,
    port,
    args = [],
    useSystemFuelCore = false,
    loggingEnabled = true,
    debugEnabled = false,
    basePath
  }) => (
    // eslint-disable-next-line no-async-promise-executor
    new Promise(async (resolve4, reject) => {
      const remainingArgs = extractRemainingArgs(args, [
        "--chain",
        "--consensus-key",
        "--db-type",
        "--poa-instant"
      ]);
      const chainConfigPath = getFlagValueFromArgs(args, "--chain");
      const consensusKey = getFlagValueFromArgs(args, "--consensus-key") || defaultConsensusKey;
      const dbTypeFlagValue = getFlagValueFromArgs(args, "--db-type");
      const useInMemoryDb = dbTypeFlagValue === "in-memory" || dbTypeFlagValue === void 0;
      const poaInstantFlagValue = getFlagValueFromArgs(args, "--poa-instant");
      const poaInstant = poaInstantFlagValue === "true" || poaInstantFlagValue === void 0;
      const graphQLStartSubstring = "Binding GraphQL provider to";
      const binPath = findBinPath("fuels-core", __dirname);
      const command = useSystemFuelCore ? "fuel-core" : binPath;
      const ipToUse = ip || "0.0.0.0";
      const portToUse = port || (await (0, import_portfinder.getPortPromise)({
        port: 4e3,
        // tries 4000 first, then 4001, then 4002, etc.
        stopPort: 5e3
        // don't try ports above 5000
      })).toString();
      let chainConfigPathToUse;
      const prefix = basePath || import_os.default.tmpdir();
      const suffix = basePath ? "" : (0, import_crypto25.randomUUID)();
      const tempDirPath = import_path15.default.join(prefix, ".fuels", suffix);
      if (chainConfigPath) {
        chainConfigPathToUse = chainConfigPath;
      } else {
        if (!(0, import_fs8.existsSync)(tempDirPath)) {
          (0, import_fs8.mkdirSync)(tempDirPath, { recursive: true });
        }
        const tempChainConfigFilePath = import_path15.default.join(tempDirPath, "chainConfig.json");
        let chainConfig = defaultChainConfig;
        if (!process.env.GENESIS_SECRET) {
          const pk = Signer2.generatePrivateKey();
          const signer = new Signer2(pk);
          process.env.GENESIS_SECRET = hexlify(pk);
          chainConfig = {
            ...defaultChainConfig,
            initial_state: {
              ...defaultChainConfig.initial_state,
              coins: [
                ...defaultChainConfig.initial_state.coins,
                {
                  owner: signer.address.toHexString(),
                  amount: toHex(1e9),
                  asset_id: BaseAssetId
                }
              ]
            }
          };
        }
        (0, import_fs8.writeFileSync)(tempChainConfigFilePath, JSON.stringify(chainConfig), "utf8");
        chainConfigPathToUse = tempChainConfigFilePath;
      }
      const child = (0, import_child_process2.spawn)(
        command,
        [
          "run",
          ["--ip", ipToUse],
          ["--port", portToUse],
          useInMemoryDb ? ["--db-type", "in-memory"] : ["--db-path", tempDirPath],
          ["--min-gas-price", "0"],
          poaInstant ? ["--poa-instant", "true"] : [],
          ["--consensus-key", consensusKey],
          ["--chain", chainConfigPathToUse],
          "--vm-backtrace",
          "--utxo-validation",
          "--debug",
          ...remainingArgs
        ].flat(),
        {
          stdio: "pipe"
        }
      );
      if (loggingEnabled) {
        child.stderr.pipe(process.stderr);
      }
      if (debugEnabled) {
        child.stdout.pipe(process.stdout);
      }
      const cleanupConfig = {
        child,
        configPath: tempDirPath,
        killFn: import_tree_kill.default,
        state: {
          isDead: false
        }
      };
      child.stderr.on("data", (chunk) => {
        if (chunk.indexOf(graphQLStartSubstring) !== -1) {
          resolve4({
            cleanup: () => killNode(cleanupConfig),
            ip: ipToUse,
            port: portToUse,
            chainConfigPath: chainConfigPathToUse
          });
        }
        if (/error/i.test(chunk)) {
          reject(chunk.toString());
        }
      });
      process.on("exit", () => killNode(cleanupConfig));
      process.on("SIGINT", () => killNode(cleanupConfig));
      process.on("SIGUSR1", () => killNode(cleanupConfig));
      process.on("SIGUSR2", () => killNode(cleanupConfig));
      process.on("beforeExit", () => killNode(cleanupConfig));
      process.on("uncaughtException", () => killNode(cleanupConfig));
      child.on("error", reject);
    })
  );

  // src/cli/commands/dev/autoStartFuelCore.ts
  var import_portfinder2 = __toESM(require_portfinder());

  // src/cli/utils/getBinarySource.ts
  var import_chalk4 = __toESM(require_source());
  var getBinarySource = (useBuiltIn) => ({
    true: import_chalk4.default.cyan("built-in"),
    false: import_chalk4.default.green("source")
  })[`${useBuiltIn}`];

  // src/cli/commands/dev/autoStartFuelCore.ts
  var autoStartFuelCore = async (config) => {
    let fuelCore;
    if (config.autoStartFuelCore) {
      log(`Starting ${getBinarySource(config.useBuiltinFuelCore)} 'fuel-core' node..`);
      const bindIp = "0.0.0.0";
      const accessIp = "127.0.0.1";
      const port = config.fuelCorePort ?? await (0, import_portfinder2.getPortPromise)({ port: 4e3 });
      const providerUrl = `http://${accessIp}:${port}/graphql`;
      const { cleanup, chainConfigPath } = await launchNode({
        args: [
          ["--chain", config.chainConfig],
          ["--db-type", "rocks-db"]
        ].flat(),
        ip: bindIp,
        port: port.toString(),
        loggingEnabled: loggingConfig.isLoggingEnabled,
        debugEnabled: loggingConfig.isDebugEnabled,
        basePath: config.basePath,
        useSystemFuelCore: !config.useBuiltinFuelCore
      });
      fuelCore = {
        bindIp,
        accessIp,
        port,
        providerUrl,
        chainConfigPath,
        killChildProcess: cleanup
      };
      config.providerUrl = fuelCore.providerUrl;
      config.privateKey = defaultConsensusKey;
    }
    return fuelCore;
  };

  // src/cli/commands/build/buildSwayProgram.ts
  var import_child_process3 = __require2("child_process");

  // src/cli/commands/build/forcHandlers.ts
  var onForcExit = (onResultFn, onErrorFn) => (code) => {
    if (code) {
      onErrorFn(code);
    } else {
      onResultFn();
    }
  };
  var onForcError = (onError) => (err) => {
    error(err);
    onError(err);
  };

  // src/cli/commands/build/buildSwayProgram.ts
  var buildSwayProgram = async (config, path5) => {
    debug("Building Sway program", path5);
    return new Promise((resolve4, reject) => {
      const builtInForcPath = findBinPath("fuels-forc", __dirname);
      const command = config.useBuiltinForc ? builtInForcPath : "forc";
      const args = ["build", "-p", path5].concat(config.forcBuildFlags);
      const forc = (0, import_child_process3.spawn)(command, args, { stdio: "pipe" });
      if (loggingConfig.isLoggingEnabled) {
        forc.stderr?.pipe(process.stderr);
      }
      if (loggingConfig.isDebugEnabled) {
        forc.stdout?.pipe(process.stdout);
      }
      const onExit = onForcExit(resolve4, reject);
      const onError = onForcError(reject);
      forc.on("exit", onExit);
      forc.on("error", onError);
    });
  };

  // src/cli/commands/build/buildSwayPrograms.ts
  async function buildSwayPrograms(config) {
    log(`Building Sway programs using ${getBinarySource(config.useBuiltinFuelCore)} 'forc' binary`);
    const paths = config.workspace ? [config.workspace] : [config.contracts, config.predicates, config.scripts].flat();
    await Promise.all(paths.map((path5) => buildSwayProgram(config, path5)));
  }

  // ../abi-typegen/dist/index.mjs
  var import_handlebars2 = __toESM(require_lib(), 1);
  var __defProp9 = Object.defineProperty;
  var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField8 = (obj, key, value) => {
    __defNormalProp8(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function findType2(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  function parseTypeArguments2(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType2({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      let currentLabel;
      const currentTypeId = typeArgument.type;
      try {
        const currentType = findType2({ types: types2, typeId: currentTypeId });
        currentLabel = currentType.attributes[attributeKey];
      } catch (_err) {
        currentLabel = "void";
      }
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments2({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output3 = buffer.join(", ");
    if (parentLabel) {
      output3 = `${parentLabel}<${output3}>`;
    }
    return output3;
  }
  var AType2 = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _ArrayType2 = class extends AType2 {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType2.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType2({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType2 = _ArrayType2;
  __publicField8(ArrayType2, "swayType", "[_; 2]");
  __publicField8(ArrayType2, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType2 = class extends AType2 {
    name = "str";
    static isSuitableFor(params) {
      return _StrType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType2 = _StrType2;
  __publicField8(StrType2, "swayType", "str[3]");
  __publicField8(StrType2, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type2 = class extends StrType2 {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type2.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type2 = _B256Type2;
  __publicField8(B256Type2, "swayType", "b256");
  __publicField8(B256Type2, "MATCH_REGEX", /^b256$/m);
  var _B512Type2 = class extends B256Type2 {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type2.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type2 = _B512Type2;
  __publicField8(B512Type2, "swayType", "struct B512");
  __publicField8(B512Type2, "MATCH_REGEX", /^struct B512$/m);
  var _BoolType2 = class extends AType2 {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType2 = _BoolType2;
  __publicField8(BoolType2, "swayType", "bool");
  __publicField8(BoolType2, "MATCH_REGEX", /^bool$/m);
  var _BytesType2 = class extends ArrayType2 {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType2 = _BytesType2;
  __publicField8(BytesType2, "swayType", "struct Bytes");
  __publicField8(BytesType2, "MATCH_REGEX", /^struct Bytes/m);
  function extractStructName2(params) {
    const { rawAbiType, regex } = params;
    const match3 = rawAbiType.type.match(params.regex)?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _EnumType2 = class extends AType2 {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType2.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _EnumType2.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash4, row) => ({
          ...hash4,
          [row.rawAbiType.typeId]: row
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => !typeHash[type3])) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const { attributes } = findType2({ types: types2, typeId });
        return `${name}: ${attributes[attributeKey]}`;
      });
      return contents.join(", ");
    }
  };
  var EnumType2 = _EnumType2;
  __publicField8(EnumType2, "swayType", "enum MyEnumName");
  __publicField8(EnumType2, "MATCH_REGEX", /^enum (.+)$/m);
  __publicField8(EnumType2, "IGNORE_REGEX", /^enum Option$/m);
  var _EvmAddressType2 = class extends AType2 {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType2 = _EvmAddressType2;
  __publicField8(EvmAddressType2, "swayType", "struct EvmAddress");
  __publicField8(EvmAddressType2, "MATCH_REGEX", /^struct EvmAddress$/m);
  var _GenericType2 = class extends AType2 {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType2.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _GenericType2.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType2 = _GenericType2;
  __publicField8(GenericType2, "swayType", "generic T");
  __publicField8(GenericType2, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _OptionType2 = class extends AType2 {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType2 = _OptionType2;
  __publicField8(OptionType2, "swayType", "enum Option");
  __publicField8(OptionType2, "MATCH_REGEX", /^enum Option$/m);
  var _U8Type2 = class extends AType2 {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type2 = _U8Type2;
  __publicField8(U8Type2, "swayType", "u8");
  __publicField8(U8Type2, "MATCH_REGEX", /^u8$/m);
  var _U64Type2 = class extends U8Type2 {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type2 = _U64Type2;
  __publicField8(U64Type2, "swayType", "u64");
  __publicField8(U64Type2, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr2 = class extends U64Type2 {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr2.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr2 = _RawUntypedPtr2;
  __publicField8(RawUntypedPtr2, "swayType", "raw untyped ptr");
  __publicField8(RawUntypedPtr2, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice2 = class extends ArrayType2 {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice2 = _RawUntypedSlice2;
  __publicField8(RawUntypedSlice2, "swayType", "raw untyped slice");
  __publicField8(RawUntypedSlice2, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType2 = class extends AType2 {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType2 = _StdStringType2;
  __publicField8(StdStringType2, "swayType", "struct String");
  __publicField8(StdStringType2, "MATCH_REGEX", /^struct String/m);
  var _StrSliceType2 = class extends AType2 {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "StrSlice",
        outputLabel: "StrSlice"
      };
      return this.attributes;
    }
  };
  var StrSliceType2 = _StrSliceType2;
  __publicField8(StrSliceType2, "swayType", "str");
  __publicField8(StrSliceType2, "MATCH_REGEX", /^str$/m);
  var _StructType2 = class extends AType2 {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType2.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _StructType2.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType2({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments2({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType2({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType2 = _StructType2;
  __publicField8(StructType2, "swayType", "struct MyStruct");
  __publicField8(StructType2, "MATCH_REGEX", /^struct (.+)$/m);
  __publicField8(StructType2, "IGNORE_REGEX", /^struct (Vec|RawVec|EvmAddress|Bytes|String)$/m);
  var _TupleType2 = class extends AType2 {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType2({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType2 = _TupleType2;
  __publicField8(TupleType2, "swayType", "(_, _, _)");
  __publicField8(TupleType2, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type2 = class extends U8Type2 {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type2 = _U16Type2;
  __publicField8(U16Type2, "swayType", "u16");
  __publicField8(U16Type2, "MATCH_REGEX", /^u16$/m);
  var _U256Type2 = class extends U64Type2 {
    name = "u256";
    static isSuitableFor(params) {
      return _U256Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U256Type2 = _U256Type2;
  __publicField8(U256Type2, "swayType", "u256");
  __publicField8(U256Type2, "MATCH_REGEX", /^u256$/m);
  var _U32Type2 = class extends U8Type2 {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type2 = _U32Type2;
  __publicField8(U32Type2, "swayType", "u32");
  __publicField8(U32Type2, "MATCH_REGEX", /^u32$/m);
  var _VectorType2 = class extends ArrayType2 {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType2.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType2 = _VectorType2;
  __publicField8(VectorType2, "swayType", "struct Vec");
  __publicField8(VectorType2, "MATCH_REGEX", /^struct Vec/m);
  __publicField8(VectorType2, "IGNORE_REGEX", /^struct RawVec$/m);
  var ProgramTypeEnum2 = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum2 || {});

  // ../abi-typegen/dist/runTypegen.mjs
  var import_fs9 = __require2("fs");
  var import_mkdirp2 = __toESM(require_mkdirp(), 1);
  var import_path16 = __require2("path");
  var import_rimraf2 = __toESM(require_rimraf(), 1);
  var import_path17 = __require2("path");
  var import_handlebars3 = __toESM(require_lib(), 1);
  var import_path18 = __require2("path");
  var import_path19 = __require2("path");
  var import_fs10 = __require2("fs");
  var import_fs11 = __require2("fs");
  var __defProp10 = Object.defineProperty;
  var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField9 = (obj, key, value) => {
    __defNormalProp9(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function findType3(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  var Configurable2 = class {
    name;
    type;
    rawAbiConfigurable;
    constructor(params) {
      const { types: types2, rawAbiConfigurable } = params;
      this.name = rawAbiConfigurable.name;
      this.rawAbiConfigurable = rawAbiConfigurable;
      this.type = findType3({ types: types2, typeId: rawAbiConfigurable.configurableType.type });
    }
  };
  function makeConfigurable2(params) {
    const { types: types2, rawAbiConfigurable } = params;
    return new Configurable2({ types: types2, rawAbiConfigurable });
  }
  function parseConfigurables2(params) {
    const { types: types2, rawAbiConfigurables } = params;
    const configurables = rawAbiConfigurables.map(
      (rawAbiConfigurable) => makeConfigurable2({ types: types2, rawAbiConfigurable })
    );
    return configurables;
  }
  function parseTypeArguments3(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType3({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      let currentLabel;
      const currentTypeId = typeArgument.type;
      try {
        const currentType = findType3({ types: types2, typeId: currentTypeId });
        currentLabel = currentType.attributes[attributeKey];
      } catch (_err) {
        currentLabel = "void";
      }
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments3({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output3 = buffer.join(", ");
    if (parentLabel) {
      output3 = `${parentLabel}<${output3}>`;
    }
    return output3;
  }
  var Function3 = class {
    name;
    types;
    rawAbiFunction;
    attributes;
    constructor(params) {
      this.rawAbiFunction = params.rawAbiFunction;
      this.types = params.types;
      this.name = params.rawAbiFunction.name;
      this.attributes = {
        inputs: this.bundleInputTypes(),
        output: this.bundleOutputTypes(),
        prefixedInputs: this.bundleInputTypes(true)
      };
    }
    bundleInputTypes(shouldPrefixParams = false) {
      const { types: types2 } = this;
      const inputs = this.rawAbiFunction.inputs.map((input) => {
        const { name, type: typeId, typeArguments } = input;
        const type3 = findType3({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments3({
            types: types2,
            target: "input",
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          typeDecl = type3.attributes.inputLabel;
        }
        if (shouldPrefixParams) {
          return `${name}: ${typeDecl}`;
        }
        return typeDecl;
      });
      return inputs.join(", ");
    }
    bundleOutputTypes() {
      return parseTypeArguments3({
        types: this.types,
        target: "output",
        typeArguments: [this.rawAbiFunction.output]
      });
    }
    getDeclaration() {
      const { name } = this;
      const { prefixedInputs, output: output3 } = this.attributes;
      const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output3}>`;
      return decl;
    }
  };
  function makeFunction2(params) {
    const { types: types2, rawAbiFunction } = params;
    return new Function3({ types: types2, rawAbiFunction });
  }
  function parseFunctions2(params) {
    const { types: types2, rawAbiFunctions } = params;
    const functions = rawAbiFunctions.map(
      (rawAbiFunction) => makeFunction2({ types: types2, rawAbiFunction })
    );
    return functions;
  }
  var AType3 = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _ArrayType3 = class extends AType3 {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType3.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType3({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType3 = _ArrayType3;
  __publicField9(ArrayType3, "swayType", "[_; 2]");
  __publicField9(ArrayType3, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType3 = class extends AType3 {
    name = "str";
    static isSuitableFor(params) {
      return _StrType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType3 = _StrType3;
  __publicField9(StrType3, "swayType", "str[3]");
  __publicField9(StrType3, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type3 = class extends StrType3 {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type3.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type3 = _B256Type3;
  __publicField9(B256Type3, "swayType", "b256");
  __publicField9(B256Type3, "MATCH_REGEX", /^b256$/m);
  var _B512Type3 = class extends B256Type3 {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type3.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type3 = _B512Type3;
  __publicField9(B512Type3, "swayType", "struct B512");
  __publicField9(B512Type3, "MATCH_REGEX", /^struct B512$/m);
  var _BoolType3 = class extends AType3 {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType3 = _BoolType3;
  __publicField9(BoolType3, "swayType", "bool");
  __publicField9(BoolType3, "MATCH_REGEX", /^bool$/m);
  var _BytesType3 = class extends ArrayType3 {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType3 = _BytesType3;
  __publicField9(BytesType3, "swayType", "struct Bytes");
  __publicField9(BytesType3, "MATCH_REGEX", /^struct Bytes/m);
  function extractStructName3(params) {
    const { rawAbiType, regex } = params;
    const match3 = rawAbiType.type.match(params.regex)?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _EnumType3 = class extends AType3 {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType3.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _EnumType3.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash4, row) => ({
          ...hash4,
          [row.rawAbiType.typeId]: row
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => !typeHash[type3])) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const { attributes } = findType3({ types: types2, typeId });
        return `${name}: ${attributes[attributeKey]}`;
      });
      return contents.join(", ");
    }
  };
  var EnumType3 = _EnumType3;
  __publicField9(EnumType3, "swayType", "enum MyEnumName");
  __publicField9(EnumType3, "MATCH_REGEX", /^enum (.+)$/m);
  __publicField9(EnumType3, "IGNORE_REGEX", /^enum Option$/m);
  var _EvmAddressType3 = class extends AType3 {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType3 = _EvmAddressType3;
  __publicField9(EvmAddressType3, "swayType", "struct EvmAddress");
  __publicField9(EvmAddressType3, "MATCH_REGEX", /^struct EvmAddress$/m);
  var _GenericType3 = class extends AType3 {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType3.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _GenericType3.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType3 = _GenericType3;
  __publicField9(GenericType3, "swayType", "generic T");
  __publicField9(GenericType3, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _OptionType3 = class extends AType3 {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType3 = _OptionType3;
  __publicField9(OptionType3, "swayType", "enum Option");
  __publicField9(OptionType3, "MATCH_REGEX", /^enum Option$/m);
  var _U8Type3 = class extends AType3 {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type3 = _U8Type3;
  __publicField9(U8Type3, "swayType", "u8");
  __publicField9(U8Type3, "MATCH_REGEX", /^u8$/m);
  var _U64Type3 = class extends U8Type3 {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type3 = _U64Type3;
  __publicField9(U64Type3, "swayType", "u64");
  __publicField9(U64Type3, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr3 = class extends U64Type3 {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr3.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr3 = _RawUntypedPtr3;
  __publicField9(RawUntypedPtr3, "swayType", "raw untyped ptr");
  __publicField9(RawUntypedPtr3, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice3 = class extends ArrayType3 {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice3 = _RawUntypedSlice3;
  __publicField9(RawUntypedSlice3, "swayType", "raw untyped slice");
  __publicField9(RawUntypedSlice3, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType3 = class extends AType3 {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType3 = _StdStringType3;
  __publicField9(StdStringType3, "swayType", "struct String");
  __publicField9(StdStringType3, "MATCH_REGEX", /^struct String/m);
  var _StrSliceType3 = class extends AType3 {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "StrSlice",
        outputLabel: "StrSlice"
      };
      return this.attributes;
    }
  };
  var StrSliceType3 = _StrSliceType3;
  __publicField9(StrSliceType3, "swayType", "str");
  __publicField9(StrSliceType3, "MATCH_REGEX", /^str$/m);
  var _StructType3 = class extends AType3 {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType3.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _StructType3.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType3({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments3({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType3({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType3 = _StructType3;
  __publicField9(StructType3, "swayType", "struct MyStruct");
  __publicField9(StructType3, "MATCH_REGEX", /^struct (.+)$/m);
  __publicField9(StructType3, "IGNORE_REGEX", /^struct (Vec|RawVec|EvmAddress|Bytes|String)$/m);
  var _TupleType3 = class extends AType3 {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType3({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType3 = _TupleType3;
  __publicField9(TupleType3, "swayType", "(_, _, _)");
  __publicField9(TupleType3, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type3 = class extends U8Type3 {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type3 = _U16Type3;
  __publicField9(U16Type3, "swayType", "u16");
  __publicField9(U16Type3, "MATCH_REGEX", /^u16$/m);
  var _U256Type3 = class extends U64Type3 {
    name = "u256";
    static isSuitableFor(params) {
      return _U256Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U256Type3 = _U256Type3;
  __publicField9(U256Type3, "swayType", "u256");
  __publicField9(U256Type3, "MATCH_REGEX", /^u256$/m);
  var _U32Type3 = class extends U8Type3 {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type3 = _U32Type3;
  __publicField9(U32Type3, "swayType", "u32");
  __publicField9(U32Type3, "MATCH_REGEX", /^u32$/m);
  var _VectorType3 = class extends ArrayType3 {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType3.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType3 = _VectorType3;
  __publicField9(VectorType3, "swayType", "struct Vec");
  __publicField9(VectorType3, "MATCH_REGEX", /^struct Vec/m);
  __publicField9(VectorType3, "IGNORE_REGEX", /^struct RawVec$/m);
  var supportedTypes2 = [
    ArrayType3,
    B256Type3,
    B512Type3,
    BoolType3,
    BytesType3,
    EnumType3,
    GenericType3,
    OptionType3,
    RawUntypedPtr3,
    RawUntypedSlice3,
    StdStringType3,
    StrType3,
    StrSliceType3,
    StructType3,
    TupleType3,
    U16Type3,
    U32Type3,
    U64Type3,
    U256Type3,
    U8Type3,
    VectorType3,
    EvmAddressType3
  ];
  function makeType2(params) {
    const { rawAbiType } = params;
    const { type: type3 } = rawAbiType;
    const TypeClass = supportedTypes2.find((tc) => tc.isSuitableFor({ type: type3 }));
    if (!TypeClass) {
      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Type not supported: ${type3}`);
    }
    return new TypeClass(params);
  }
  function shouldSkipAbiType2(params) {
    const ignoreList = ["()", "struct RawVec"];
    const shouldSkip = ignoreList.indexOf(params.type) >= 0;
    return shouldSkip;
  }
  function parseTypes2(params) {
    const types2 = [];
    params.rawAbiTypes.forEach((rawAbiType) => {
      const { type: type3 } = rawAbiType;
      const skip = shouldSkipAbiType2({ type: type3 });
      if (!skip) {
        const parsedType = makeType2({ rawAbiType });
        types2.push(parsedType);
      }
    });
    types2.forEach((type3) => {
      type3.parseComponentsAttributes({ types: types2 });
    });
    return types2;
  }
  var Abi2 = class {
    name;
    programType;
    filepath;
    outputDir;
    commonTypesInUse = [];
    rawContents;
    hexlifiedBinContents;
    storageSlotsContents;
    types;
    functions;
    configurables;
    constructor(params) {
      const {
        filepath,
        outputDir,
        rawContents,
        hexlifiedBinContents,
        programType,
        storageSlotsContents
      } = params;
      const abiNameRegex = /([^/]+)-abi\.json$/m;
      const abiName = filepath.match(abiNameRegex);
      const couldNotParseName = !abiName || abiName.length === 0;
      if (couldNotParseName) {
        throw new FuelError(
          ErrorCode.PARSE_FAILED,
          `Could not parse name from ABI file: ${filepath}.`
        );
      }
      const name = `${normalizeString(abiName[1])}Abi`;
      this.name = name;
      this.programType = programType;
      this.filepath = filepath;
      this.rawContents = rawContents;
      this.hexlifiedBinContents = hexlifiedBinContents;
      this.storageSlotsContents = storageSlotsContents;
      this.outputDir = outputDir;
      const { types: types2, functions, configurables } = this.parse();
      this.types = types2;
      this.functions = functions;
      this.configurables = configurables;
      this.computeCommonTypesInUse();
    }
    parse() {
      const {
        types: rawAbiTypes,
        functions: rawAbiFunctions,
        configurables: rawAbiConfigurables
      } = this.rawContents;
      const types2 = parseTypes2({ rawAbiTypes });
      const functions = parseFunctions2({ rawAbiFunctions, types: types2 });
      const configurables = parseConfigurables2({ rawAbiConfigurables, types: types2 });
      return {
        types: types2,
        functions,
        configurables
      };
    }
    computeCommonTypesInUse() {
      const customTypesTable = {
        option: "Option",
        enum: "Enum",
        vector: "Vec"
      };
      this.commonTypesInUse = [];
      Object.keys(customTypesTable).forEach((typeName) => {
        const isInUse = !!this.types.find((t) => t.name === typeName);
        if (isInUse) {
          const commonTypeLabel = customTypesTable[typeName];
          this.commonTypesInUse.push(commonTypeLabel);
        }
      });
    }
  };
  var ProgramTypeEnum3 = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum3 || {});
  var header_default2 = "/* Autogenerated file. Do not edit manually. */\n\n/* tslint:disable */\n/* eslint-disable */\n\n/*\n  Fuels version: {{FUELS}}\n  Forc version: {{FORC}}\n  Fuel-Core version: {{FUEL_CORE}}\n*/\n";
  function renderHbsTemplate2(params) {
    const { data, template } = params;
    const options = {
      strict: true,
      noEscape: true
    };
    const renderTemplate = (0, import_handlebars3.compile)(template, options);
    const renderHeaderTemplate = (0, import_handlebars3.compile)(header_default2, options);
    const text = renderTemplate({
      ...data,
      header: renderHeaderTemplate(versions)
    });
    return text.replace(/[\n]{3,}/gm, "\n\n");
  }
  var common_default3 = "{{header}}\n\n/*\n  Mimics Sway Enum, requires at least one Key-Value but\n  does not raise error on multiple pairs.\n  This is done in the abi-coder\n*/\nexport type Enum<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n  U[keyof U];\n\n/*\n  Mimics Sway Option and Vectors.\n  Vectors are treated like arrays in Typescript.\n*/\nexport type Option<T> = T | undefined;\n\nexport type Vec<T> = T[];\n";
  function renderCommonTemplate2() {
    const text = renderHbsTemplate2({ template: common_default3 });
    return text;
  }
  var common_default22 = "{{header}}\n\n{{#if isGeneratingContracts}}\n{{#each abis}}\nexport type { {{name}} } from './{{name}}';\n{{/each}}\n{{/if}}\n\n{{#if isGeneratingPredicates}}\n{{#each abis}}\nexport type { {{name}}Inputs } from './factories/{{name}}__factory';\n{{/each}}\n{{/if}}\n\n{{#each abis}}\nexport { {{name}}__factory } from './factories/{{name}}__factory';\n{{/each}}\n";
  function renderIndexTemplate2(params) {
    const { abis } = params;
    const isGeneratingContracts = abis[0].programType === "contract";
    const isGeneratingPredicates = abis[0].programType === "predicate";
    const text = renderHbsTemplate2({
      template: common_default22,
      data: { abis, isGeneratingContracts, isGeneratingPredicates }
    });
    return text;
  }
  var bytecode_default2 = "{{header}}\n\nexport default '{{hexlifiedBytecode}}'";
  function renderBytecodeTemplate2(params) {
    const text = renderHbsTemplate2({
      template: bytecode_default2,
      data: {
        hexlifiedBytecode: params.hexlifiedBytecode
      }
    });
    return text;
  }
  function formatConfigurables2(params) {
    const { configurables } = params;
    const formattedConfigurables = configurables.map((c) => {
      const {
        name,
        type: {
          attributes: { inputLabel }
        }
      } = c;
      return {
        configurableName: name,
        configurableType: inputLabel
      };
    });
    return { formattedConfigurables };
  }
  function formatEnums2(params) {
    const { types: types2 } = params;
    const enums = types2.filter((t) => t.name === "enum").map((t) => {
      const et = t;
      const structName = et.getStructName();
      const inputValues = et.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = et.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const inputNativeValues = et.getNativeEnum({ types: types2 });
      const outputNativeValues = et.getNativeEnum({ types: types2 });
      return {
        structName,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues,
        // reduces duplication
        inputNativeValues,
        outputNativeValues
      };
    });
    return { enums };
  }
  var caseInsensitiveSort2 = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
  function formatImports2(params) {
    const { types: types2, baseMembers = [] } = params;
    const members = types2.flatMap((t) => t.requiredFuelsMembersImports);
    const imports = uniq_default(baseMembers.concat(members).sort(caseInsensitiveSort2));
    return {
      imports: imports.length ? imports : void 0
    };
  }
  function formatStructs2(params) {
    const { types: types2 } = params;
    const structs = types2.filter((t) => t.name === "struct").map((t) => {
      const st = t;
      const structName = st.getStructName();
      const inputValues = st.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = st.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const typeAnnotations = st.getStructDeclaration({ types: types2 });
      return {
        structName,
        typeAnnotations,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues
        // reduces duplication
      };
    });
    return { structs };
  }
  var dts_default2 = `{{header}}

{{#if imports}}
import type {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if formattedConfigurables}}
export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};
{{/if}}

interface {{capitalizedName}}Interface extends Interface {
  functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };

  {{#each encoders}}
  encodeFunctionData(functionFragment: '{{functionName}}', values: [{{input}}]): Uint8Array;
  {{/each}}

  {{#each decoders}}
  decodeFunctionData(functionFragment: '{{functionName}}', data: BytesLike): DecodedValue;
  {{/each}}
}


export class {{capitalizedName}} extends Contract {
  interface: {{capitalizedName}}Interface;
  functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };
}
`;
  function renderDtsTemplate2(params) {
    const { name: capitalizedName, types: types2, functions, commonTypesInUse, configurables } = params.abi;
    const functionsTypedefs = functions.map((f2) => f2.getDeclaration());
    const functionsFragments = functions.map((f2) => f2.name);
    const encoders = functions.map((f2) => ({
      functionName: f2.name,
      input: f2.attributes.inputs
    }));
    const decoders = functions.map((f2) => ({
      functionName: f2.name
    }));
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({
      types: types2,
      baseMembers: [
        "Interface",
        "FunctionFragment",
        "DecodedValue",
        "Contract",
        "BytesLike",
        "InvokeFunction"
      ]
    });
    const { formattedConfigurables } = formatConfigurables2({ configurables });
    const text = renderHbsTemplate2({
      template: dts_default2,
      data: {
        capitalizedName,
        commonTypesInUse: commonTypesInUse.join(", "),
        functionsTypedefs,
        functionsFragments,
        encoders,
        decoders,
        structs,
        enums,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  var factory_default4 = '{{header}}\n\nimport { Interface, Contract, ContractFactory } from "fuels";\nimport type { Provider, Account, AbstractAddress, BytesLike, DeployContractOptions, StorageSlot } from "fuels";\nimport type { {{capitalizedName}}, {{capitalizedName}}Interface } from "../{{capitalizedName}}";\n\nconst _abi = {{abiJsonString}};\n\nconst _storageSlots: StorageSlot[] = {{storageSlotsJsonString}};\n\nexport class {{capitalizedName}}__factory {\n  static readonly abi = _abi;\n\n  static readonly storageSlots = _storageSlots;\n\n  static createInterface(): {{capitalizedName}}Interface {\n    return new Interface(_abi) as unknown as {{capitalizedName}}Interface\n  }\n\n  static connect(\n    id: string | AbstractAddress,\n    accountOrProvider: Account | Provider\n  ): {{capitalizedName}} {\n    return new Contract(id, _abi, accountOrProvider) as unknown as {{capitalizedName}}\n  }\n\n  static async deployContract(\n    bytecode: BytesLike,\n    wallet: Account,\n    options: DeployContractOptions = {}\n  ): Promise<{{capitalizedName}}> {\n    const factory = new ContractFactory(bytecode, _abi, wallet);\n\n    const { storageSlots } = {{capitalizedName}}__factory;\n\n    const contract = await factory.deployContract({\n      storageSlots,\n      ...options,\n    });\n\n    return contract as unknown as {{capitalizedName}};\n  }\n}\n';
  function renderFactoryTemplate4(params) {
    const { name: capitalizedName, rawContents, storageSlotsContents } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate2({
      template: factory_default4,
      data: { capitalizedName, abiJsonString, storageSlotsJsonString }
    });
    return text;
  }
  function assembleContracts2(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const dtsFilepath = `${outputDir}/${name}.d.ts`;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const hexBinFilePath = `${outputDir}/${name}.hex.ts`;
      const dts = {
        path: dtsFilepath,
        contents: renderDtsTemplate2({ abi })
      };
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate4({ abi })
      };
      const hexBinFile = {
        path: hexBinFilePath,
        contents: renderBytecodeTemplate2({
          hexlifiedBytecode: abi.hexlifiedBinContents
        })
      };
      files.push(dts);
      files.push(factory);
      files.push(hexBinFile);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path17.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2()
      };
      files.push(file);
    }
    return files;
  }
  var factory_default22 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};

export type {{capitalizedName}}Inputs = [{{inputs}}];

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin;

  static createInstance(provider: Provider, predicateData?: {{capitalizedName}}Inputs, configurables?: {{capitalizedName}}Configurables) {

    const { abi, bin } = {{capitalizedName}}__factory

    const predicate = new Predicate<{{capitalizedName}}Inputs>({
      bytecode: bin,
      abi,
      provider,
      inputData: predicateData,
      configurableConstants: configurables,
    })

    return predicate;

  }

}
`;
  function renderFactoryTemplate22(params) {
    const { abi } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      name: capitalizedName,
      hexlifiedBinContents: hexlifiedBinString
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({
      types: types2,
      baseMembers: ["Predicate", "Provider", "InputValue"]
    });
    const { formattedConfigurables } = formatConfigurables2({ configurables });
    const { prefixedInputs: inputs, output: output3 } = func.attributes;
    const text = renderHbsTemplate2({
      template: factory_default22,
      data: {
        inputs,
        output: output3,
        structs,
        enums,
        abiJsonString,
        hexlifiedBinString,
        capitalizedName,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  function assemblePredicates2(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate22({ abi })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path18.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2()
      };
      files.push(file);
    }
    return files;
  }
  var factory_default32 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

type {{capitalizedName}}Inputs = [{{inputs}}];
type {{capitalizedName}}Output = {{output}};

{{#if formattedConfigurables}}
export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};
{{/if}}

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin

  static createInstance(wallet: Account) {

    const { abi, bin } = {{capitalizedName}}__factory

    const script = new Script<
      {{capitalizedName}}Inputs,
      {{capitalizedName}}Output
    >(bin, abi, wallet);

    return script;

  }

}
`;
  function renderFactoryTemplate32(params) {
    const { abi } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      name: capitalizedName,
      hexlifiedBinContents: hexlifiedBinString
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({ types: types2, baseMembers: ["Script", "Account"] });
    const { formattedConfigurables } = formatConfigurables2({ configurables });
    const { prefixedInputs: inputs, output: output3 } = func.attributes;
    const text = renderHbsTemplate2({
      template: factory_default32,
      data: {
        inputs,
        output: output3,
        structs,
        enums,
        abiJsonString,
        hexlifiedBinString,
        capitalizedName,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  function assembleScripts2(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate32({ abi })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path19.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2()
      };
      files.push(file);
    }
    return files;
  }
  var upperFirst2 = (s) => s[0].toUpperCase() + s.slice(1);
  function validateBinFile2(params) {
    const { abiFilepath, binFilepath, binExists, programType } = params;
    const isScript = programType === "script";
    if (!binExists && isScript) {
      throw new FuelError(
        ErrorCode.BIN_FILE_NOT_FOUND,
        [
          `Could not find BIN file for counterpart ${upperFirst2(programType)} ABI.`,
          `  - ABI: ${abiFilepath}`,
          `  - BIN: ${binFilepath}`,
          programType
        ].join("\n")
      );
    }
  }
  var AbiTypeGen2 = class {
    abis;
    abiFiles;
    binFiles;
    storageSlotsFiles;
    outputDir;
    files;
    constructor(params) {
      const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles } = params;
      this.outputDir = outputDir;
      this.abiFiles = abiFiles;
      this.binFiles = binFiles;
      this.storageSlotsFiles = storageSlotsFiles;
      this.abis = this.abiFiles.map((abiFile) => {
        const binFilepath = abiFile.path.replace("-abi.json", ".bin");
        const relatedBinFile = this.binFiles.find(({ path: path5 }) => path5 === binFilepath);
        const storageSlotFilepath = abiFile.path.replace("-abi.json", "-storage_slots.json");
        const relatedStorageSlotsFile = this.storageSlotsFiles.find(
          ({ path: path5 }) => path5 === storageSlotFilepath
        );
        if (!relatedBinFile) {
          validateBinFile2({
            abiFilepath: abiFile.path,
            binExists: !!relatedBinFile,
            binFilepath,
            programType
          });
        }
        const abi = new Abi2({
          filepath: abiFile.path,
          rawContents: JSON.parse(abiFile.contents),
          hexlifiedBinContents: relatedBinFile?.contents,
          storageSlotsContents: relatedStorageSlotsFile?.contents,
          outputDir,
          programType
        });
        return abi;
      });
      this.files = this.getAssembledFiles({ programType });
    }
    getAssembledFiles(params) {
      const { abis, outputDir } = this;
      const { programType } = params;
      switch (programType) {
        case "contract":
          return assembleContracts2({ abis, outputDir });
        case "script":
          return assembleScripts2({ abis, outputDir });
        case "predicate":
          return assemblePredicates2({ abis, outputDir });
        default:
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(
              ProgramTypeEnum3
            )}`
          );
      }
    }
  };
  var collectBinFilepaths2 = (params) => {
    const { filepaths, programType } = params;
    const binFiles = filepaths.map((abiFilepath) => {
      const binFilepath = abiFilepath.replace("-abi.json", ".bin");
      const binExists = (0, import_fs10.existsSync)(binFilepath);
      validateBinFile2({ abiFilepath, binFilepath, binExists, programType });
      const bin = {
        path: binFilepath,
        contents: hexlify((0, import_fs10.readFileSync)(binFilepath))
      };
      return bin;
    });
    return binFiles;
  };
  var collectStorageSlotsFilepaths2 = (params) => {
    const { filepaths, programType } = params;
    const storageSlotsFiles = [];
    if (programType !== "contract") {
      return storageSlotsFiles;
    }
    filepaths.forEach((abiFilepath) => {
      const storageSlotsFilepath = abiFilepath.replace("-abi.json", "-storage_slots.json");
      const storageSlotsExists = (0, import_fs11.existsSync)(storageSlotsFilepath);
      if (storageSlotsExists) {
        const storageSlots = {
          path: storageSlotsFilepath,
          contents: (0, import_fs11.readFileSync)(storageSlotsFilepath, "utf-8")
        };
        storageSlotsFiles.push(storageSlots);
      }
    });
    return storageSlotsFiles;
  };
  function runTypegen2(params) {
    const { cwd, inputs, output: output3, silent, programType, filepaths: inputFilepaths } = params;
    const cwdBasename = (0, import_path16.basename)(cwd);
    function log2(...args) {
      if (!silent) {
        process.stdout.write(`${args.join(" ")}
`);
      }
    }
    let filepaths = [];
    if (!inputFilepaths?.length && inputs?.length) {
      filepaths = inputs.flatMap((i) => globSync(i, { cwd }));
    } else if (inputFilepaths?.length) {
      filepaths = inputFilepaths;
    } else {
      throw new FuelError(
        ErrorCode.MISSING_REQUIRED_PARAMETER,
        `At least one parameter should be supplied: 'input' or 'filepaths'.`
      );
    }
    const abiFiles = filepaths.map((filepath) => {
      const abi = {
        path: filepath,
        contents: (0, import_fs9.readFileSync)(filepath, "utf-8")
      };
      return abi;
    });
    if (!abiFiles.length) {
      throw new FuelError(ErrorCode.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);
    }
    const binFiles = collectBinFilepaths2({ filepaths, programType });
    const storageSlotsFiles = collectStorageSlotsFilepaths2({ filepaths, programType });
    const abiTypeGen = new AbiTypeGen2({
      outputDir: output3,
      abiFiles,
      binFiles,
      storageSlotsFiles,
      programType
    });
    log2("Generating files..\n");
    import_mkdirp2.default.sync(`${output3}/factories`);
    abiTypeGen.files.forEach((file) => {
      import_rimraf2.default.sync(file.path);
      (0, import_fs9.writeFileSync)(file.path, file.contents);
      const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, "m");
      log2(` - ${file.path.replace(trimPathRegex, "")}`);
    });
    log2("\nDone.\u26A1");
  }

  // src/cli/commands/build/generateTypes.ts
  var import_fs12 = __require2("fs");
  var import_path20 = __require2("path");

  // src/cli/templates/index.ts
  var import_handlebars4 = __toESM(require_lib());

  // src/cli/templates/index.hbs
  var templates_default = "{{#each paths}}\nexport * from './{{this}}';\n{{/each}}\n";

  // src/cli/templates/index.ts
  function renderIndexTemplate3(paths) {
    const renderTemplate = (0, import_handlebars4.compile)(templates_default, {
      strict: true,
      noEscape: true
    });
    return renderTemplate({
      paths
    });
  }

  // src/cli/commands/build/generateTypes.ts
  async function generateTypesForProgramType(config, paths, programType) {
    debug("Generating types..");
    const filepaths = await getABIPaths(paths, config);
    const pluralizedDirName = `${String(programType).toLocaleLowerCase()}s`;
    runTypegen2({
      programType,
      cwd: config.basePath,
      filepaths,
      output: (0, import_path20.join)(config.output, pluralizedDirName),
      silent: !loggingConfig.isDebugEnabled
    });
    return pluralizedDirName;
  }
  async function generateTypes(config) {
    log("Generating types..");
    const { contracts, scripts, predicates, output: output3 } = config;
    (0, import_fs12.mkdirSync)(output3, { recursive: true });
    const members = [
      { type: ProgramTypeEnum2.CONTRACT, programs: contracts },
      { type: ProgramTypeEnum2.SCRIPT, programs: scripts },
      { type: ProgramTypeEnum2.PREDICATE, programs: predicates }
    ];
    const pluralizedDirNames = await Promise.all(
      members.filter(({ programs }) => !!programs.length).map(({ programs, type: type3 }) => generateTypesForProgramType(config, programs, type3))
    );
    const indexFile = await renderIndexTemplate3(pluralizedDirNames);
    (0, import_fs12.writeFileSync)((0, import_path20.join)(config.output, "index.ts"), indexFile);
  }

  // src/cli/commands/build/index.ts
  async function build(config, program2) {
    log("Building..");
    await buildSwayPrograms(config);
    await generateTypes(config);
    const options = program2?.opts();
    if (options?.deploy) {
      const fuelCore = await autoStartFuelCore(config);
      await deploy(config);
      fuelCore?.killChildProcess();
    }
  }

  // src/cli/commands/dev/index.ts
  var import_chokidar = __toESM(require_chokidar());

  // ../account/dist/configs.mjs
  var FUEL_NETWORK_URL = typeof process !== "undefined" ? process?.env?.FUEL_NETWORK_URL || "http://127.0.0.1:4000/graphql" : "http://127.0.0.1:4000/graphql";

  // ../../node_modules/.pnpm/bundle-require@4.0.1_esbuild@0.19.3/node_modules/bundle-require/dist/index.js
  var import_fs14 = __toESM(__require2("fs"), 1);
  var import_path22 = __toESM(__require2("path"), 1);
  var import_url4 = __require2("url");
  var import_esbuild = __toESM(require_main(), 1);

  // ../../node_modules/.pnpm/load-tsconfig@0.2.5/node_modules/load-tsconfig/dist/index.js
  var import_path21 = __toESM(__require2("path"), 1);
  var import_fs13 = __toESM(__require2("fs"), 1);
  var import_module = __require2("module");
  var import_meta = {};
  var singleComment = Symbol("singleComment");
  var multiComment = Symbol("multiComment");
  var stripWithoutWhitespace = () => "";
  var stripWithWhitespace = (string2, start, end) => string2.slice(start, end).replace(/\S/g, " ");
  var isEscaped = (jsonString, quotePosition) => {
    let index = quotePosition - 1;
    let backslashCount = 0;
    while (jsonString[index] === "\\") {
      index -= 1;
      backslashCount += 1;
    }
    return Boolean(backslashCount % 2);
  };
  function stripJsonComments(jsonString, { whitespace = true, trailingCommas = false } = {}) {
    if (typeof jsonString !== "string") {
      throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
    }
    const strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;
    let isInsideString = false;
    let isInsideComment = false;
    let offset = 0;
    let buffer = "";
    let result = "";
    let commaIndex = -1;
    for (let index = 0; index < jsonString.length; index++) {
      const currentCharacter = jsonString[index];
      const nextCharacter = jsonString[index + 1];
      if (!isInsideComment && currentCharacter === '"') {
        const escaped = isEscaped(jsonString, index);
        if (!escaped) {
          isInsideString = !isInsideString;
        }
      }
      if (isInsideString) {
        continue;
      }
      if (!isInsideComment && currentCharacter + nextCharacter === "//") {
        buffer += jsonString.slice(offset, index);
        offset = index;
        isInsideComment = singleComment;
        index++;
      } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
        index++;
        isInsideComment = false;
        buffer += strip(jsonString, offset, index);
        offset = index;
        continue;
      } else if (isInsideComment === singleComment && currentCharacter === "\n") {
        isInsideComment = false;
        buffer += strip(jsonString, offset, index);
        offset = index;
      } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
        buffer += jsonString.slice(offset, index);
        offset = index;
        isInsideComment = multiComment;
        index++;
        continue;
      } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
        index++;
        isInsideComment = false;
        buffer += strip(jsonString, offset, index + 1);
        offset = index + 1;
        continue;
      } else if (trailingCommas && !isInsideComment) {
        if (commaIndex !== -1) {
          if (currentCharacter === "}" || currentCharacter === "]") {
            buffer += jsonString.slice(offset, index);
            result += strip(buffer, 0, 1) + buffer.slice(1);
            buffer = "";
            offset = index;
            commaIndex = -1;
          } else if (currentCharacter !== " " && currentCharacter !== "	" && currentCharacter !== "\r" && currentCharacter !== "\n") {
            buffer += jsonString.slice(offset, index);
            offset = index;
            commaIndex = -1;
          }
        } else if (currentCharacter === ",") {
          result += buffer + jsonString.slice(offset, index);
          buffer = "";
          offset = index;
          commaIndex = index;
        }
      }
    }
    return result + buffer + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
  }
  function jsoncParse(data) {
    try {
      return new Function("return " + stripJsonComments(data).trim())();
    } catch (_) {
      return {};
    }
  }
  var req = true ? (0, import_module.createRequire)(import_meta.url) : __require;
  var findUp = (name, startDir, stopDir = import_path21.default.parse(startDir).root) => {
    let dir = startDir;
    while (dir !== stopDir) {
      const file = import_path21.default.join(dir, name);
      if (import_fs13.default.existsSync(file))
        return file;
      if (!file.endsWith(".json")) {
        const fileWithExt = file + ".json";
        if (import_fs13.default.existsSync(fileWithExt))
          return fileWithExt;
      }
      dir = import_path21.default.dirname(dir);
    }
    return null;
  };
  var resolveTsConfigFromFile = (cwd, filename) => {
    if (import_path21.default.isAbsolute(filename))
      return import_fs13.default.existsSync(filename) ? filename : null;
    return findUp(filename, cwd);
  };
  var resolveTsConfigFromExtends = (cwd, name) => {
    if (import_path21.default.isAbsolute(name))
      return import_fs13.default.existsSync(name) ? name : null;
    if (name.startsWith("."))
      return findUp(name, cwd);
    const id = req.resolve(name, { paths: [cwd] });
    return id;
  };
  var loadTsConfigInternal = (dir = process.cwd(), name = "tsconfig.json", isExtends = false) => {
    var _a, _b;
    dir = import_path21.default.resolve(dir);
    const id = isExtends ? resolveTsConfigFromExtends(dir, name) : resolveTsConfigFromFile(dir, name);
    if (!id)
      return null;
    const data = jsoncParse(import_fs13.default.readFileSync(id, "utf-8"));
    const configDir = import_path21.default.dirname(id);
    if ((_a = data.compilerOptions) == null ? void 0 : _a.baseUrl) {
      data.compilerOptions.baseUrl = import_path21.default.join(
        configDir,
        data.compilerOptions.baseUrl
      );
    }
    let extendsFiles = [];
    if (data.extends) {
      const extendsList = Array.isArray(data.extends) ? data.extends : [data.extends];
      const extendsData = {};
      for (const name2 of extendsList) {
        const parentConfig = loadTsConfigInternal(configDir, name2, true);
        if (parentConfig) {
          Object.assign(extendsData, {
            ...parentConfig == null ? void 0 : parentConfig.data,
            compilerOptions: {
              ...extendsData.compilerOptions,
              ...(_b = parentConfig == null ? void 0 : parentConfig.data) == null ? void 0 : _b.compilerOptions
            }
          });
          extendsFiles.push(...parentConfig.files);
        }
      }
      Object.assign(data, {
        ...extendsData,
        ...data,
        compilerOptions: {
          ...extendsData.compilerOptions,
          ...data.compilerOptions
        }
      });
    }
    delete data.extends;
    return { path: id, data, files: [...extendsFiles, id] };
  };
  var loadTsConfig = (dir, name) => loadTsConfigInternal(dir, name);

  // ../../node_modules/.pnpm/bundle-require@4.0.1_esbuild@0.19.3/node_modules/bundle-require/dist/index.js
  var import_fs15 = __toESM(__require2("fs"), 1);
  var import_path23 = __toESM(__require2("path"), 1);
  var import_module2 = __require2("module");
  var import_meta2 = {};
  var getPkgType = () => {
    try {
      const pkg = JSON.parse(
        import_fs15.default.readFileSync(import_path23.default.resolve("package.json"), "utf-8")
      );
      return pkg.type;
    } catch (error2) {
    }
  };
  function guessFormat(inputFile) {
    if (!usingDynamicImport)
      return "cjs";
    const ext2 = import_path23.default.extname(inputFile);
    const type3 = getPkgType();
    if (ext2 === ".js") {
      return type3 === "module" ? "esm" : "cjs";
    } else if (ext2 === ".ts") {
      return "esm";
    } else if (ext2 === ".mjs") {
      return "esm";
    }
    return "cjs";
  }
  var usingDynamicImport = typeof jest === "undefined";
  var dynamicImport = async (id, { format }) => {
    const fn = format === "esm" ? (file) => import(file) : true ? (0, import_module2.createRequire)(import_meta2.url) : __require;
    return fn(id);
  };
  var getRandomId = () => {
    return Math.random().toString(36).substring(2, 15);
  };
  var DIRNAME_VAR_NAME = "__injected_dirname__";
  var FILENAME_VAR_NAME = "__injected_filename__";
  var IMPORT_META_URL_VAR_NAME = "__injected_import_meta_url__";
  var JS_EXT_RE = /\.(mjs|cjs|ts|js|tsx|jsx)$/;
  function inferLoader(ext2) {
    if (ext2 === ".mjs" || ext2 === ".cjs")
      return "js";
    return ext2.slice(1);
  }
  var defaultGetOutputFile = (filepath, format) => filepath.replace(
    JS_EXT_RE,
    `.bundled_${getRandomId()}.${format === "esm" ? "mjs" : "cjs"}`
  );
  var tsconfigPathsToRegExp = (paths) => {
    return Object.keys(paths || {}).map((key) => {
      return new RegExp(`^${key.replace(/\*/, ".*")}$`);
    });
  };
  var match2 = (id, patterns) => {
    if (!patterns)
      return false;
    return patterns.some((p) => {
      if (p instanceof RegExp) {
        return p.test(id);
      }
      return id === p || id.startsWith(p + "/");
    });
  };
  var externalPlugin = ({
    external,
    notExternal
  } = {}) => {
    return {
      name: "bundle-require:external",
      setup(ctx) {
        ctx.onResolve({ filter: /.*/ }, async (args) => {
          if (args.path[0] === "." || import_path22.default.isAbsolute(args.path)) {
            return;
          }
          if (match2(args.path, external)) {
            return {
              external: true
            };
          }
          if (match2(args.path, notExternal)) {
            return;
          }
          return {
            external: true
          };
        });
      }
    };
  };
  var injectFileScopePlugin = () => {
    return {
      name: "bundle-require:inject-file-scope",
      setup(ctx) {
        ctx.initialOptions.define = {
          ...ctx.initialOptions.define,
          __dirname: DIRNAME_VAR_NAME,
          __filename: FILENAME_VAR_NAME,
          "import.meta.url": IMPORT_META_URL_VAR_NAME
        };
        ctx.onLoad({ filter: JS_EXT_RE }, async (args) => {
          const contents = await import_fs14.default.promises.readFile(args.path, "utf-8");
          const injectLines = [
            `const ${FILENAME_VAR_NAME} = ${JSON.stringify(args.path)};`,
            `const ${DIRNAME_VAR_NAME} = ${JSON.stringify(
              import_path22.default.dirname(args.path)
            )};`,
            `const ${IMPORT_META_URL_VAR_NAME} = ${JSON.stringify(
              (0, import_url4.pathToFileURL)(args.path).href
            )};`
          ];
          return {
            contents: injectLines.join("") + contents,
            loader: inferLoader(import_path22.default.extname(args.path))
          };
        });
      }
    };
  };
  function bundleRequire(options) {
    return new Promise((resolve4, reject) => {
      var _a, _b, _c, _d;
      if (!JS_EXT_RE.test(options.filepath)) {
        throw new Error(`${options.filepath} is not a valid JS file`);
      }
      const preserveTemporaryFile = (_a = options.preserveTemporaryFile) != null ? _a : !!process.env.BUNDLE_REQUIRE_PRESERVE;
      const cwd = options.cwd || process.cwd();
      const format = (_b = options.format) != null ? _b : guessFormat(options.filepath);
      const tsconfig = loadTsConfig(cwd, options.tsconfig);
      const resolvePaths = tsconfigPathsToRegExp(
        ((_c = tsconfig == null ? void 0 : tsconfig.data.compilerOptions) == null ? void 0 : _c.paths) || {}
      );
      const extractResult = async (result) => {
        if (!result.outputFiles) {
          throw new Error(`[bundle-require] no output files`);
        }
        const { text } = result.outputFiles[0];
        const getOutputFile = options.getOutputFile || defaultGetOutputFile;
        const outfile = getOutputFile(options.filepath, format);
        await import_fs14.default.promises.writeFile(outfile, text, "utf8");
        let mod2;
        const req2 = options.require || dynamicImport;
        try {
          mod2 = await req2(
            format === "esm" ? (0, import_url4.pathToFileURL)(outfile).href : outfile,
            { format }
          );
        } finally {
          if (!preserveTemporaryFile) {
            await import_fs14.default.promises.unlink(outfile);
          }
        }
        return {
          mod: mod2,
          dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
        };
      };
      const { watch: watchMode, ...restEsbuildOptions } = options.esbuildOptions || {};
      const esbuildOptions = {
        ...restEsbuildOptions,
        entryPoints: [options.filepath],
        absWorkingDir: cwd,
        outfile: "out.js",
        format,
        platform: "node",
        sourcemap: "inline",
        bundle: true,
        metafile: true,
        write: false,
        plugins: [
          ...((_d = options.esbuildOptions) == null ? void 0 : _d.plugins) || [],
          externalPlugin({
            external: options.external,
            notExternal: resolvePaths
          }),
          injectFileScopePlugin()
        ]
      };
      const run2 = async () => {
        if (!(watchMode || options.onRebuild)) {
          const result = await (0, import_esbuild.build)(esbuildOptions);
          resolve4(await extractResult(result));
        } else {
          const rebuildCallback = typeof watchMode === "object" && typeof watchMode.onRebuild === "function" ? watchMode.onRebuild : async (error2, result) => {
            var _a2, _b2;
            if (error2) {
              (_a2 = options.onRebuild) == null ? void 0 : _a2.call(options, { err: error2 });
            }
            if (result) {
              (_b2 = options.onRebuild) == null ? void 0 : _b2.call(options, await extractResult(result));
            }
          };
          const onRebuildPlugin = () => {
            return {
              name: "bundle-require:on-rebuild",
              setup(ctx2) {
                let count = 0;
                ctx2.onEnd(async (result) => {
                  if (count++ === 0) {
                    if (result.errors.length === 0)
                      resolve4(await extractResult(result));
                  } else {
                    if (result.errors.length > 0) {
                      return rebuildCallback(
                        { errors: result.errors, warnings: result.warnings },
                        null
                      );
                    }
                    if (result) {
                      rebuildCallback(null, result);
                    }
                  }
                });
              }
            };
          };
          esbuildOptions.plugins.push(onRebuildPlugin());
          const ctx = await (0, import_esbuild.context)(esbuildOptions);
          await ctx.watch();
        }
      };
      run2().catch(reject);
    });
  }

  // src/cli/config/loadConfig.ts
  var import_joycon = __toESM(require_lib4());
  var import_path24 = __require2("path");

  // src/cli/commands/init/shouldUseBuiltinForc.ts
  var shouldUseBuiltinForc = () => {
    const { systemForcVersion } = getSystemForc();
    if (systemForcVersion !== null) {
      return false;
    }
    return true;
  };

  // src/cli/commands/init/shouldUseBuiltinFuelCore.ts
  var shouldUseBuiltinFuelCore = () => {
    const { systemFuelCoreVersion } = getSystemFuelCore();
    if (systemFuelCoreVersion !== null) {
      return false;
    }
    return true;
  };

  // ../../node_modules/.pnpm/nanoclone@0.2.1/node_modules/nanoclone/src/index.js
  var map;
  try {
    map = Map;
  } catch (_) {
  }
  var set;
  try {
    set = Set;
  } catch (_) {
  }
  function baseClone(src, circulars, clones) {
    if (!src || typeof src !== "object" || typeof src === "function") {
      return src;
    }
    if (src.nodeType && "cloneNode" in src) {
      return src.cloneNode(true);
    }
    if (src instanceof Date) {
      return new Date(src.getTime());
    }
    if (src instanceof RegExp) {
      return new RegExp(src);
    }
    if (Array.isArray(src)) {
      return src.map(clone4);
    }
    if (map && src instanceof map) {
      return new Map(Array.from(src.entries()));
    }
    if (set && src instanceof set) {
      return new Set(Array.from(src.values()));
    }
    if (src instanceof Object) {
      circulars.push(src);
      var obj = Object.create(src);
      clones.push(obj);
      for (var key in src) {
        var idx = circulars.findIndex(function(i) {
          return i === src[key];
        });
        obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);
      }
      return obj;
    }
    return src;
  }
  function clone4(src) {
    return baseClone(src, [], []);
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/printValue.js
  var toString2 = Object.prototype.toString;
  var errorToString = Error.prototype.toString;
  var regExpToString = RegExp.prototype.toString;
  var symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  function printNumber(val) {
    if (val != +val)
      return "NaN";
    const isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? "-0" : "" + val;
  }
  function printSimpleValue(val, quoteStrings = false) {
    if (val == null || val === true || val === false)
      return "" + val;
    const typeOf = typeof val;
    if (typeOf === "number")
      return printNumber(val);
    if (typeOf === "string")
      return quoteStrings ? `"${val}"` : val;
    if (typeOf === "function")
      return "[Function " + (val.name || "anonymous") + "]";
    if (typeOf === "symbol")
      return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    const tag = toString2.call(val).slice(8, -1);
    if (tag === "Date")
      return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
    if (tag === "Error" || val instanceof Error)
      return "[" + errorToString.call(val) + "]";
    if (tag === "RegExp")
      return regExpToString.call(val);
    return null;
  }
  function printValue(value, quoteStrings) {
    let result = printSimpleValue(value, quoteStrings);
    if (result !== null)
      return result;
    return JSON.stringify(value, function(key, value2) {
      let result2 = printSimpleValue(this[key], quoteStrings);
      if (result2 !== null)
        return result2;
      return value2;
    }, 2);
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/locale.js
  var mixed = {
    default: "${path} is invalid",
    required: "${path} is a required field",
    oneOf: "${path} must be one of the following values: ${values}",
    notOneOf: "${path} must not be one of the following values: ${values}",
    notType: ({
      path: path5,
      type: type3,
      value,
      originalValue
    }) => {
      let isCast = originalValue != null && originalValue !== value;
      let msg = `${path5} must be a \`${type3}\` type, but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".");
      if (value === null) {
        msg += `
 If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
      }
      return msg;
    },
    defined: "${path} must be defined"
  };
  var string = {
    length: "${path} must be exactly ${length} characters",
    min: "${path} must be at least ${min} characters",
    max: "${path} must be at most ${max} characters",
    matches: '${path} must match the following: "${regex}"',
    email: "${path} must be a valid email",
    url: "${path} must be a valid URL",
    uuid: "${path} must be a valid UUID",
    trim: "${path} must be a trimmed string",
    lowercase: "${path} must be a lowercase string",
    uppercase: "${path} must be a upper case string"
  };
  var number3 = {
    min: "${path} must be greater than or equal to ${min}",
    max: "${path} must be less than or equal to ${max}",
    lessThan: "${path} must be less than ${less}",
    moreThan: "${path} must be greater than ${more}",
    positive: "${path} must be a positive number",
    negative: "${path} must be a negative number",
    integer: "${path} must be an integer"
  };
  var date = {
    min: "${path} field must be later than ${min}",
    max: "${path} field must be at earlier than ${max}"
  };
  var boolean = {
    isValue: "${path} field must be ${value}"
  };
  var object = {
    noUnknown: "${path} field has unspecified keys: ${unknown}"
  };
  var array = {
    min: "${path} field must have at least ${min} items",
    max: "${path} field must have less than or equal to ${max} items",
    length: "${path} must have ${length} items"
  };
  var locale_default = Object.assign(/* @__PURE__ */ Object.create(null), {
    mixed,
    string,
    number: number3,
    date,
    object,
    array,
    boolean
  });

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/Condition.js
  var import_has17 = __toESM(require_has());

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/isSchema.js
  var isSchema = (obj) => obj && obj.__isYupSchema__;
  var isSchema_default = isSchema;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/Condition.js
  var Condition = class {
    constructor(refs, options) {
      this.fn = void 0;
      this.refs = refs;
      this.refs = refs;
      if (typeof options === "function") {
        this.fn = options;
        return;
      }
      if (!(0, import_has17.default)(options, "is"))
        throw new TypeError("`is:` is required for `when()` conditions");
      if (!options.then && !options.otherwise)
        throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
      let {
        is,
        then,
        otherwise
      } = options;
      let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
      this.fn = function(...args) {
        let options2 = args.pop();
        let schema2 = args.pop();
        let branch = check(...args) ? then : otherwise;
        if (!branch)
          return void 0;
        if (typeof branch === "function")
          return branch(schema2);
        return schema2.concat(branch.resolve(options2));
      };
    }
    resolve(base, options) {
      let values = this.refs.map((ref) => ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
      let schema2 = this.fn.apply(base, values.concat(base, options));
      if (schema2 === void 0 || schema2 === base)
        return base;
      if (!isSchema_default(schema2))
        throw new TypeError("conditions must return a schema object");
      return schema2.resolve(options);
    }
  };
  var Condition_default = Condition;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/toArray.js
  function toArray(value) {
    return value == null ? [] : [].concat(value);
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/ValidationError.js
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var strReg = /\$\{\s*(\w+)\s*\}/g;
  var ValidationError = class extends Error {
    static formatError(message, params) {
      const path5 = params.label || params.path || "this";
      if (path5 !== params.path)
        params = _extends({}, params, {
          path: path5
        });
      if (typeof message === "string")
        return message.replace(strReg, (_, key) => printValue(params[key]));
      if (typeof message === "function")
        return message(params);
      return message;
    }
    static isError(err) {
      return err && err.name === "ValidationError";
    }
    constructor(errorOrErrors, value, field, type3) {
      super();
      this.value = void 0;
      this.path = void 0;
      this.type = void 0;
      this.errors = void 0;
      this.params = void 0;
      this.inner = void 0;
      this.name = "ValidationError";
      this.value = value;
      this.path = field;
      this.type = type3;
      this.errors = [];
      this.inner = [];
      toArray(errorOrErrors).forEach((err) => {
        if (ValidationError.isError(err)) {
          this.errors.push(...err.errors);
          this.inner = this.inner.concat(err.inner.length ? err.inner : err);
        } else {
          this.errors.push(err);
        }
      });
      this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ValidationError);
    }
  };

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/runTests.js
  var once = (cb) => {
    let fired = false;
    return (...args) => {
      if (fired)
        return;
      fired = true;
      cb(...args);
    };
  };
  function runTests(options, cb) {
    let {
      endEarly,
      tests,
      args,
      value,
      errors,
      sort,
      path: path5
    } = options;
    let callback = once(cb);
    let count = tests.length;
    const nestedErrors = [];
    errors = errors ? errors : [];
    if (!count)
      return errors.length ? callback(new ValidationError(errors, value, path5)) : callback(null, value);
    for (let i = 0; i < tests.length; i++) {
      const test = tests[i];
      test(args, function finishTestRun(err) {
        if (err) {
          if (!ValidationError.isError(err)) {
            return callback(err, value);
          }
          if (endEarly) {
            err.value = value;
            return callback(err, value);
          }
          nestedErrors.push(err);
        }
        if (--count <= 0) {
          if (nestedErrors.length) {
            if (sort)
              nestedErrors.sort(sort);
            if (errors.length)
              nestedErrors.push(...errors);
            errors = nestedErrors;
          }
          if (errors.length) {
            callback(new ValidationError(errors, value, path5), value);
            return;
          }
          callback(null, value);
        }
      });
    }
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/createValidation.js
  var import_mapValues = __toESM(require_mapValues());

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/Reference.js
  var import_property_expr = __toESM(require_property_expr());
  var prefixes = {
    context: "$",
    value: "."
  };
  var Reference = class {
    constructor(key, options = {}) {
      this.key = void 0;
      this.isContext = void 0;
      this.isValue = void 0;
      this.isSibling = void 0;
      this.path = void 0;
      this.getter = void 0;
      this.map = void 0;
      if (typeof key !== "string")
        throw new TypeError("ref must be a string, got: " + key);
      this.key = key.trim();
      if (key === "")
        throw new TypeError("ref must be a non-empty string");
      this.isContext = this.key[0] === prefixes.context;
      this.isValue = this.key[0] === prefixes.value;
      this.isSibling = !this.isContext && !this.isValue;
      let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
      this.path = this.key.slice(prefix.length);
      this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
      this.map = options.map;
    }
    getValue(value, parent, context2) {
      let result = this.isContext ? context2 : this.isValue ? value : parent;
      if (this.getter)
        result = this.getter(result || {});
      if (this.map)
        result = this.map(result);
      return result;
    }
    /**
     *
     * @param {*} value
     * @param {Object} options
     * @param {Object=} options.context
     * @param {Object=} options.parent
     */
    cast(value, options) {
      return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
    }
    resolve() {
      return this;
    }
    describe() {
      return {
        type: "ref",
        key: this.key
      };
    }
    toString() {
      return `Ref(${this.key})`;
    }
    static isRef(value) {
      return value && value.__isYupRef;
    }
  };
  Reference.prototype.__isYupRef = true;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/createValidation.js
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function createValidation(config) {
    function validate(_ref, cb) {
      let {
        value,
        path: path5 = "",
        label,
        options,
        originalValue,
        sync: sync2
      } = _ref, rest = _objectWithoutPropertiesLoose(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);
      const {
        name,
        test,
        params,
        message
      } = config;
      let {
        parent,
        context: context2
      } = options;
      function resolve4(item) {
        return Reference.isRef(item) ? item.getValue(value, parent, context2) : item;
      }
      function createError(overrides = {}) {
        const nextParams = (0, import_mapValues.default)(_extends2({
          value,
          originalValue,
          label,
          path: overrides.path || path5
        }, params, overrides.params), resolve4);
        const error2 = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name);
        error2.params = nextParams;
        return error2;
      }
      let ctx = _extends2({
        path: path5,
        parent,
        type: name,
        createError,
        resolve: resolve4,
        options,
        originalValue
      }, rest);
      if (!sync2) {
        try {
          Promise.resolve(test.call(ctx, value, ctx)).then((validOrError) => {
            if (ValidationError.isError(validOrError))
              cb(validOrError);
            else if (!validOrError)
              cb(createError());
            else
              cb(null, validOrError);
          }).catch(cb);
        } catch (err) {
          cb(err);
        }
        return;
      }
      let result;
      try {
        var _ref2;
        result = test.call(ctx, value, ctx);
        if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === "function") {
          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
        }
      } catch (err) {
        cb(err);
        return;
      }
      if (ValidationError.isError(result))
        cb(result);
      else if (!result)
        cb(createError());
      else
        cb(null, result);
    }
    validate.OPTIONS = config;
    return validate;
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/reach.js
  var import_property_expr2 = __toESM(require_property_expr());
  var trim = (part) => part.substr(0, part.length - 1).substr(1);
  function getIn(schema2, path5, value, context2 = value) {
    let parent, lastPart, lastPartDebug;
    if (!path5)
      return {
        parent,
        parentPath: path5,
        schema: schema2
      };
    (0, import_property_expr2.forEach)(path5, (_part, isBracket, isArray) => {
      let part = isBracket ? trim(_part) : _part;
      schema2 = schema2.resolve({
        context: context2,
        parent,
        value
      });
      if (schema2.innerType) {
        let idx = isArray ? parseInt(part, 10) : 0;
        if (value && idx >= value.length) {
          throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path5}. because there is no value at that index. `);
        }
        parent = value;
        value = value && value[idx];
        schema2 = schema2.innerType;
      }
      if (!isArray) {
        if (!schema2.fields || !schema2.fields[part])
          throw new Error(`The schema does not contain the path: ${path5}. (failed at: ${lastPartDebug} which is a type: "${schema2._type}")`);
        parent = value;
        value = value && value[part];
        schema2 = schema2.fields[part];
      }
      lastPart = part;
      lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
    });
    return {
      schema: schema2,
      parent,
      parentPath: lastPart
    };
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/ReferenceSet.js
  var ReferenceSet = class {
    constructor() {
      this.list = void 0;
      this.refs = void 0;
      this.list = /* @__PURE__ */ new Set();
      this.refs = /* @__PURE__ */ new Map();
    }
    get size() {
      return this.list.size + this.refs.size;
    }
    describe() {
      const description = [];
      for (const item of this.list)
        description.push(item);
      for (const [, ref] of this.refs)
        description.push(ref.describe());
      return description;
    }
    toArray() {
      return Array.from(this.list).concat(Array.from(this.refs.values()));
    }
    resolveAll(resolve4) {
      return this.toArray().reduce((acc, e) => acc.concat(Reference.isRef(e) ? resolve4(e) : e), []);
    }
    add(value) {
      Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
    }
    delete(value) {
      Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
    }
    clone() {
      const next = new ReferenceSet();
      next.list = new Set(this.list);
      next.refs = new Map(this.refs);
      return next;
    }
    merge(newItems, removeItems) {
      const next = this.clone();
      newItems.list.forEach((value) => next.add(value));
      newItems.refs.forEach((value) => next.add(value));
      removeItems.list.forEach((value) => next.delete(value));
      removeItems.refs.forEach((value) => next.delete(value));
      return next;
    }
  };

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/schema.js
  function _extends3() {
    _extends3 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  var BaseSchema = class {
    constructor(options) {
      this.deps = [];
      this.tests = void 0;
      this.transforms = void 0;
      this.conditions = [];
      this._mutate = void 0;
      this._typeError = void 0;
      this._whitelist = new ReferenceSet();
      this._blacklist = new ReferenceSet();
      this.exclusiveTests = /* @__PURE__ */ Object.create(null);
      this.spec = void 0;
      this.tests = [];
      this.transforms = [];
      this.withMutation(() => {
        this.typeError(mixed.notType);
      });
      this.type = (options == null ? void 0 : options.type) || "mixed";
      this.spec = _extends3({
        strip: false,
        strict: false,
        abortEarly: true,
        recursive: true,
        nullable: false,
        presence: "optional"
      }, options == null ? void 0 : options.spec);
    }
    // TODO: remove
    get _type() {
      return this.type;
    }
    _typeCheck(_value) {
      return true;
    }
    clone(spec) {
      if (this._mutate) {
        if (spec)
          Object.assign(this.spec, spec);
        return this;
      }
      const next = Object.create(Object.getPrototypeOf(this));
      next.type = this.type;
      next._typeError = this._typeError;
      next._whitelistError = this._whitelistError;
      next._blacklistError = this._blacklistError;
      next._whitelist = this._whitelist.clone();
      next._blacklist = this._blacklist.clone();
      next.exclusiveTests = _extends3({}, this.exclusiveTests);
      next.deps = [...this.deps];
      next.conditions = [...this.conditions];
      next.tests = [...this.tests];
      next.transforms = [...this.transforms];
      next.spec = clone4(_extends3({}, this.spec, spec));
      return next;
    }
    label(label) {
      let next = this.clone();
      next.spec.label = label;
      return next;
    }
    meta(...args) {
      if (args.length === 0)
        return this.spec.meta;
      let next = this.clone();
      next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
      return next;
    }
    // withContext<TContext extends AnyObject>(): BaseSchema<
    //   TCast,
    //   TContext,
    //   TOutput
    // > {
    //   return this as any;
    // }
    withMutation(fn) {
      let before = this._mutate;
      this._mutate = true;
      let result = fn(this);
      this._mutate = before;
      return result;
    }
    concat(schema2) {
      if (!schema2 || schema2 === this)
        return this;
      if (schema2.type !== this.type && this.type !== "mixed")
        throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema2.type}`);
      let base = this;
      let combined = schema2.clone();
      const mergedSpec = _extends3({}, base.spec, combined.spec);
      combined.spec = mergedSpec;
      combined._typeError || (combined._typeError = base._typeError);
      combined._whitelistError || (combined._whitelistError = base._whitelistError);
      combined._blacklistError || (combined._blacklistError = base._blacklistError);
      combined._whitelist = base._whitelist.merge(schema2._whitelist, schema2._blacklist);
      combined._blacklist = base._blacklist.merge(schema2._blacklist, schema2._whitelist);
      combined.tests = base.tests;
      combined.exclusiveTests = base.exclusiveTests;
      combined.withMutation((next) => {
        schema2.tests.forEach((fn) => {
          next.test(fn.OPTIONS);
        });
      });
      combined.transforms = [...base.transforms, ...combined.transforms];
      return combined;
    }
    isType(v) {
      if (this.spec.nullable && v === null)
        return true;
      return this._typeCheck(v);
    }
    resolve(options) {
      let schema2 = this;
      if (schema2.conditions.length) {
        let conditions = schema2.conditions;
        schema2 = schema2.clone();
        schema2.conditions = [];
        schema2 = conditions.reduce((schema3, condition) => condition.resolve(schema3, options), schema2);
        schema2 = schema2.resolve(options);
      }
      return schema2;
    }
    /**
     *
     * @param {*} value
     * @param {Object} options
     * @param {*=} options.parent
     * @param {*=} options.context
     */
    cast(value, options = {}) {
      let resolvedSchema = this.resolve(_extends3({
        value
      }, options));
      let result = resolvedSchema._cast(value, options);
      if (value !== void 0 && options.assert !== false && resolvedSchema.isType(result) !== true) {
        let formattedValue = printValue(value);
        let formattedResult = printValue(result);
        throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema._type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
      }
      return result;
    }
    _cast(rawValue, _options2) {
      let value = rawValue === void 0 ? rawValue : this.transforms.reduce((value2, fn) => fn.call(this, value2, rawValue, this), rawValue);
      if (value === void 0) {
        value = this.getDefault();
      }
      return value;
    }
    _validate(_value, options = {}, cb) {
      let {
        sync: sync2,
        path: path5,
        from = [],
        originalValue = _value,
        strict = this.spec.strict,
        abortEarly = this.spec.abortEarly
      } = options;
      let value = _value;
      if (!strict) {
        value = this._cast(value, _extends3({
          assert: false
        }, options));
      }
      let args = {
        value,
        path: path5,
        options,
        originalValue,
        schema: this,
        label: this.spec.label,
        sync: sync2,
        from
      };
      let initialTests = [];
      if (this._typeError)
        initialTests.push(this._typeError);
      let finalTests = [];
      if (this._whitelistError)
        finalTests.push(this._whitelistError);
      if (this._blacklistError)
        finalTests.push(this._blacklistError);
      runTests({
        args,
        value,
        path: path5,
        sync: sync2,
        tests: initialTests,
        endEarly: abortEarly
      }, (err) => {
        if (err)
          return void cb(err, value);
        runTests({
          tests: this.tests.concat(finalTests),
          args,
          path: path5,
          sync: sync2,
          value,
          endEarly: abortEarly
        }, cb);
      });
    }
    validate(value, options, maybeCb) {
      let schema2 = this.resolve(_extends3({}, options, {
        value
      }));
      return typeof maybeCb === "function" ? schema2._validate(value, options, maybeCb) : new Promise((resolve4, reject) => schema2._validate(value, options, (err, value2) => {
        if (err)
          reject(err);
        else
          resolve4(value2);
      }));
    }
    validateSync(value, options) {
      let schema2 = this.resolve(_extends3({}, options, {
        value
      }));
      let result;
      schema2._validate(value, _extends3({}, options, {
        sync: true
      }), (err, value2) => {
        if (err)
          throw err;
        result = value2;
      });
      return result;
    }
    isValid(value, options) {
      return this.validate(value, options).then(() => true, (err) => {
        if (ValidationError.isError(err))
          return false;
        throw err;
      });
    }
    isValidSync(value, options) {
      try {
        this.validateSync(value, options);
        return true;
      } catch (err) {
        if (ValidationError.isError(err))
          return false;
        throw err;
      }
    }
    _getDefault() {
      let defaultValue = this.spec.default;
      if (defaultValue == null) {
        return defaultValue;
      }
      return typeof defaultValue === "function" ? defaultValue.call(this) : clone4(defaultValue);
    }
    getDefault(options) {
      let schema2 = this.resolve(options || {});
      return schema2._getDefault();
    }
    default(def) {
      if (arguments.length === 0) {
        return this._getDefault();
      }
      let next = this.clone({
        default: def
      });
      return next;
    }
    strict(isStrict = true) {
      let next = this.clone();
      next.spec.strict = isStrict;
      return next;
    }
    _isPresent(value) {
      return value != null;
    }
    defined(message = mixed.defined) {
      return this.test({
        message,
        name: "defined",
        exclusive: true,
        test(value) {
          return value !== void 0;
        }
      });
    }
    required(message = mixed.required) {
      return this.clone({
        presence: "required"
      }).withMutation((s) => s.test({
        message,
        name: "required",
        exclusive: true,
        test(value) {
          return this.schema._isPresent(value);
        }
      }));
    }
    notRequired() {
      let next = this.clone({
        presence: "optional"
      });
      next.tests = next.tests.filter((test) => test.OPTIONS.name !== "required");
      return next;
    }
    nullable(isNullable = true) {
      let next = this.clone({
        nullable: isNullable !== false
      });
      return next;
    }
    transform(fn) {
      let next = this.clone();
      next.transforms.push(fn);
      return next;
    }
    /**
     * Adds a test function to the schema's queue of tests.
     * tests can be exclusive or non-exclusive.
     *
     * - exclusive tests, will replace any existing tests of the same name.
     * - non-exclusive: can be stacked
     *
     * If a non-exclusive test is added to a schema with an exclusive test of the same name
     * the exclusive test is removed and further tests of the same name will be stacked.
     *
     * If an exclusive test is added to a schema with non-exclusive tests of the same name
     * the previous tests are removed and further tests of the same name will replace each other.
     */
    test(...args) {
      let opts;
      if (args.length === 1) {
        if (typeof args[0] === "function") {
          opts = {
            test: args[0]
          };
        } else {
          opts = args[0];
        }
      } else if (args.length === 2) {
        opts = {
          name: args[0],
          test: args[1]
        };
      } else {
        opts = {
          name: args[0],
          message: args[1],
          test: args[2]
        };
      }
      if (opts.message === void 0)
        opts.message = mixed.default;
      if (typeof opts.test !== "function")
        throw new TypeError("`test` is a required parameters");
      let next = this.clone();
      let validate = createValidation(opts);
      let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
      if (opts.exclusive) {
        if (!opts.name)
          throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
      }
      if (opts.name)
        next.exclusiveTests[opts.name] = !!opts.exclusive;
      next.tests = next.tests.filter((fn) => {
        if (fn.OPTIONS.name === opts.name) {
          if (isExclusive)
            return false;
          if (fn.OPTIONS.test === validate.OPTIONS.test)
            return false;
        }
        return true;
      });
      next.tests.push(validate);
      return next;
    }
    when(keys4, options) {
      if (!Array.isArray(keys4) && typeof keys4 !== "string") {
        options = keys4;
        keys4 = ".";
      }
      let next = this.clone();
      let deps = toArray(keys4).map((key) => new Reference(key));
      deps.forEach((dep) => {
        if (dep.isSibling)
          next.deps.push(dep.key);
      });
      next.conditions.push(new Condition_default(deps, options));
      return next;
    }
    typeError(message) {
      let next = this.clone();
      next._typeError = createValidation({
        message,
        name: "typeError",
        test(value) {
          if (value !== void 0 && !this.schema.isType(value))
            return this.createError({
              params: {
                type: this.schema._type
              }
            });
          return true;
        }
      });
      return next;
    }
    oneOf(enums, message = mixed.oneOf) {
      let next = this.clone();
      enums.forEach((val) => {
        next._whitelist.add(val);
        next._blacklist.delete(val);
      });
      next._whitelistError = createValidation({
        message,
        name: "oneOf",
        test(value) {
          if (value === void 0)
            return true;
          let valids = this.schema._whitelist;
          let resolved = valids.resolveAll(this.resolve);
          return resolved.includes(value) ? true : this.createError({
            params: {
              values: valids.toArray().join(", "),
              resolved
            }
          });
        }
      });
      return next;
    }
    notOneOf(enums, message = mixed.notOneOf) {
      let next = this.clone();
      enums.forEach((val) => {
        next._blacklist.add(val);
        next._whitelist.delete(val);
      });
      next._blacklistError = createValidation({
        message,
        name: "notOneOf",
        test(value) {
          let invalids = this.schema._blacklist;
          let resolved = invalids.resolveAll(this.resolve);
          if (resolved.includes(value))
            return this.createError({
              params: {
                values: invalids.toArray().join(", "),
                resolved
              }
            });
          return true;
        }
      });
      return next;
    }
    strip(strip = true) {
      let next = this.clone();
      next.spec.strip = strip;
      return next;
    }
    describe() {
      const next = this.clone();
      const {
        label,
        meta
      } = next.spec;
      const description = {
        meta,
        label,
        type: next.type,
        oneOf: next._whitelist.describe(),
        notOneOf: next._blacklist.describe(),
        tests: next.tests.map((fn) => ({
          name: fn.OPTIONS.name,
          params: fn.OPTIONS.params
        })).filter((n, idx, list) => list.findIndex((c) => c.name === n.name) === idx)
      };
      return description;
    }
  };
  BaseSchema.prototype.__isYupSchema__ = true;
  for (const method of ["validate", "validateSync"])
    BaseSchema.prototype[`${method}At`] = function(path5, value, options = {}) {
      const {
        parent,
        parentPath,
        schema: schema2
      } = getIn(this, path5, value, options.context);
      return schema2[method](parent && parent[parentPath], _extends3({}, options, {
        parent,
        path: path5
      }));
    };
  for (const alias of ["equals", "is"])
    BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;
  for (const alias of ["not", "nope"])
    BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;
  BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/mixed.js
  var Mixed = BaseSchema;
  function create() {
    return new Mixed();
  }
  create.prototype = Mixed.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/isAbsent.js
  var isAbsent = (value) => value == null;
  var isAbsent_default = isAbsent;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/boolean.js
  function create2() {
    return new BooleanSchema();
  }
  var BooleanSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "boolean"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (!this.isType(value)) {
            if (/^(true|1)$/i.test(String(value)))
              return true;
            if (/^(false|0)$/i.test(String(value)))
              return false;
          }
          return value;
        });
      });
    }
    _typeCheck(v) {
      if (v instanceof Boolean)
        v = v.valueOf();
      return typeof v === "boolean";
    }
    isTrue(message = boolean.isValue) {
      return this.test({
        message,
        name: "is-value",
        exclusive: true,
        params: {
          value: "true"
        },
        test(value) {
          return isAbsent_default(value) || value === true;
        }
      });
    }
    isFalse(message = boolean.isValue) {
      return this.test({
        message,
        name: "is-value",
        exclusive: true,
        params: {
          value: "false"
        },
        test(value) {
          return isAbsent_default(value) || value === false;
        }
      });
    }
  };
  create2.prototype = BooleanSchema.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/string.js
  var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
  var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
  var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  var isTrimmed = (value) => isAbsent_default(value) || value === value.trim();
  var objStringTag = {}.toString();
  function create3() {
    return new StringSchema();
  }
  var StringSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "string"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (this.isType(value))
            return value;
          if (Array.isArray(value))
            return value;
          const strValue = value != null && value.toString ? value.toString() : value;
          if (strValue === objStringTag)
            return value;
          return strValue;
        });
      });
    }
    _typeCheck(value) {
      if (value instanceof String)
        value = value.valueOf();
      return typeof value === "string";
    }
    _isPresent(value) {
      return super._isPresent(value) && !!value.length;
    }
    length(length, message = string.length) {
      return this.test({
        message,
        name: "length",
        exclusive: true,
        params: {
          length
        },
        test(value) {
          return isAbsent_default(value) || value.length === this.resolve(length);
        }
      });
    }
    min(min, message = string.min) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value.length >= this.resolve(min);
        }
      });
    }
    max(max2, message = string.max) {
      return this.test({
        name: "max",
        exclusive: true,
        message,
        params: {
          max: max2
        },
        test(value) {
          return isAbsent_default(value) || value.length <= this.resolve(max2);
        }
      });
    }
    matches(regex, options) {
      let excludeEmptyString = false;
      let message;
      let name;
      if (options) {
        if (typeof options === "object") {
          ({
            excludeEmptyString = false,
            message,
            name
          } = options);
        } else {
          message = options;
        }
      }
      return this.test({
        name: name || "matches",
        message: message || string.matches,
        params: {
          regex
        },
        test: (value) => isAbsent_default(value) || value === "" && excludeEmptyString || value.search(regex) !== -1
      });
    }
    email(message = string.email) {
      return this.matches(rEmail, {
        name: "email",
        message,
        excludeEmptyString: true
      });
    }
    url(message = string.url) {
      return this.matches(rUrl, {
        name: "url",
        message,
        excludeEmptyString: true
      });
    }
    uuid(message = string.uuid) {
      return this.matches(rUUID, {
        name: "uuid",
        message,
        excludeEmptyString: false
      });
    }
    //-- transforms --
    ensure() {
      return this.default("").transform((val) => val === null ? "" : val);
    }
    trim(message = string.trim) {
      return this.transform((val) => val != null ? val.trim() : val).test({
        message,
        name: "trim",
        test: isTrimmed
      });
    }
    lowercase(message = string.lowercase) {
      return this.transform((value) => !isAbsent_default(value) ? value.toLowerCase() : value).test({
        message,
        name: "string_case",
        exclusive: true,
        test: (value) => isAbsent_default(value) || value === value.toLowerCase()
      });
    }
    uppercase(message = string.uppercase) {
      return this.transform((value) => !isAbsent_default(value) ? value.toUpperCase() : value).test({
        message,
        name: "string_case",
        exclusive: true,
        test: (value) => isAbsent_default(value) || value === value.toUpperCase()
      });
    }
  };
  create3.prototype = StringSchema.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/number.js
  var isNaN2 = (value) => value != +value;
  function create4() {
    return new NumberSchema();
  }
  var NumberSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "number"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          let parsed = value;
          if (typeof parsed === "string") {
            parsed = parsed.replace(/\s/g, "");
            if (parsed === "")
              return NaN;
            parsed = +parsed;
          }
          if (this.isType(parsed))
            return parsed;
          return parseFloat(parsed);
        });
      });
    }
    _typeCheck(value) {
      if (value instanceof Number)
        value = value.valueOf();
      return typeof value === "number" && !isNaN2(value);
    }
    min(min, message = number3.min) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value >= this.resolve(min);
        }
      });
    }
    max(max2, message = number3.max) {
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        test(value) {
          return isAbsent_default(value) || value <= this.resolve(max2);
        }
      });
    }
    lessThan(less, message = number3.lessThan) {
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          less
        },
        test(value) {
          return isAbsent_default(value) || value < this.resolve(less);
        }
      });
    }
    moreThan(more, message = number3.moreThan) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          more
        },
        test(value) {
          return isAbsent_default(value) || value > this.resolve(more);
        }
      });
    }
    positive(msg = number3.positive) {
      return this.moreThan(0, msg);
    }
    negative(msg = number3.negative) {
      return this.lessThan(0, msg);
    }
    integer(message = number3.integer) {
      return this.test({
        name: "integer",
        message,
        test: (val) => isAbsent_default(val) || Number.isInteger(val)
      });
    }
    truncate() {
      return this.transform((value) => !isAbsent_default(value) ? value | 0 : value);
    }
    round(method) {
      var _method;
      let avail = ["ceil", "floor", "round", "trunc"];
      method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
      if (method === "trunc")
        return this.truncate();
      if (avail.indexOf(method.toLowerCase()) === -1)
        throw new TypeError("Only valid options for round() are: " + avail.join(", "));
      return this.transform((value) => !isAbsent_default(value) ? Math[method](value) : value);
    }
  };
  create4.prototype = NumberSchema.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/isodate.js
  var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
  function parseIsoDate(date2) {
    var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
    if (struct = isoReg.exec(date2)) {
      for (var i = 0, k; k = numericKeys[i]; ++i)
        struct[k] = +struct[k] || 0;
      struct[2] = (+struct[2] || 1) - 1;
      struct[3] = +struct[3] || 1;
      struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
      if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === ""))
        timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
      else {
        if (struct[8] !== "Z" && struct[9] !== void 0) {
          minutesOffset = struct[10] * 60 + struct[11];
          if (struct[9] === "+")
            minutesOffset = 0 - minutesOffset;
        }
        timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
      }
    } else
      timestamp = Date.parse ? Date.parse(date2) : NaN;
    return timestamp;
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/date.js
  var invalidDate = /* @__PURE__ */ new Date("");
  var isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
  function create5() {
    return new DateSchema();
  }
  var DateSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "date"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (this.isType(value))
            return value;
          value = parseIsoDate(value);
          return !isNaN(value) ? new Date(value) : invalidDate;
        });
      });
    }
    _typeCheck(v) {
      return isDate(v) && !isNaN(v.getTime());
    }
    prepareParam(ref, name) {
      let param;
      if (!Reference.isRef(ref)) {
        let cast = this.cast(ref);
        if (!this._typeCheck(cast))
          throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
        param = cast;
      } else {
        param = ref;
      }
      return param;
    }
    min(min, message = date.min) {
      let limit = this.prepareParam(min, "min");
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value >= this.resolve(limit);
        }
      });
    }
    max(max2, message = date.max) {
      let limit = this.prepareParam(max2, "max");
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        test(value) {
          return isAbsent_default(value) || value <= this.resolve(limit);
        }
      });
    }
  };
  DateSchema.INVALID_DATE = invalidDate;
  create5.prototype = DateSchema.prototype;
  create5.INVALID_DATE = invalidDate;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/object.js
  var import_has19 = __toESM(require_has());
  var import_snakeCase = __toESM(require_snakeCase());
  var import_camelCase = __toESM(require_camelCase());
  var import_mapKeys = __toESM(require_mapKeys());
  var import_mapValues2 = __toESM(require_mapValues());
  var import_property_expr4 = __toESM(require_property_expr());

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/sortFields.js
  var import_has18 = __toESM(require_has());
  var import_toposort = __toESM(require_toposort());
  var import_property_expr3 = __toESM(require_property_expr());
  function sortFields(fields, excludedEdges = []) {
    let edges = [];
    let nodes = /* @__PURE__ */ new Set();
    let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
    function addNode(depPath, key) {
      let node = (0, import_property_expr3.split)(depPath)[0];
      nodes.add(node);
      if (!excludes.has(`${key}-${node}`))
        edges.push([key, node]);
    }
    for (const key in fields)
      if ((0, import_has18.default)(fields, key)) {
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling)
          addNode(value.path, key);
        else if (isSchema_default(value) && "deps" in value)
          value.deps.forEach((path5) => addNode(path5, key));
      }
    return import_toposort.default.array(Array.from(nodes), edges).reverse();
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/sortByKeyOrder.js
  function findIndex(arr, err) {
    let idx = Infinity;
    arr.some((key, ii) => {
      var _err$path;
      if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
        idx = ii;
        return true;
      }
    });
    return idx;
  }
  function sortByKeyOrder(keys4) {
    return (a, b) => {
      return findIndex(keys4, a) - findIndex(keys4, b);
    };
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/object.js
  function _extends4() {
    _extends4 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends4.apply(this, arguments);
  }
  var isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
  function unknown(ctx, value) {
    let known = Object.keys(ctx.fields);
    return Object.keys(value).filter((key) => known.indexOf(key) === -1);
  }
  var defaultSort = sortByKeyOrder([]);
  var ObjectSchema = class extends BaseSchema {
    constructor(spec) {
      super({
        type: "object"
      });
      this.fields = /* @__PURE__ */ Object.create(null);
      this._sortErrors = defaultSort;
      this._nodes = [];
      this._excludedEdges = [];
      this.withMutation(() => {
        this.transform(function coerce(value) {
          if (typeof value === "string") {
            try {
              value = JSON.parse(value);
            } catch (err) {
              value = null;
            }
          }
          if (this.isType(value))
            return value;
          return null;
        });
        if (spec) {
          this.shape(spec);
        }
      });
    }
    _typeCheck(value) {
      return isObject(value) || typeof value === "function";
    }
    _cast(_value, options = {}) {
      var _options$stripUnknown;
      let value = super._cast(_value, options);
      if (value === void 0)
        return this.getDefault();
      if (!this._typeCheck(value))
        return value;
      let fields = this.fields;
      let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
      let props = this._nodes.concat(Object.keys(value).filter((v) => this._nodes.indexOf(v) === -1));
      let intermediateValue = {};
      let innerOptions = _extends4({}, options, {
        parent: intermediateValue,
        __validating: options.__validating || false
      });
      let isChanged = false;
      for (const prop of props) {
        let field = fields[prop];
        let exists3 = (0, import_has19.default)(value, prop);
        if (field) {
          let fieldValue;
          let inputValue = value[prop];
          innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
          field = field.resolve({
            value: inputValue,
            context: options.context,
            parent: intermediateValue
          });
          let fieldSpec = "spec" in field ? field.spec : void 0;
          let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
          if (fieldSpec == null ? void 0 : fieldSpec.strip) {
            isChanged = isChanged || prop in value;
            continue;
          }
          fieldValue = !options.__validating || !strict ? (
            // TODO: use _cast, this is double resolving
            field.cast(value[prop], innerOptions)
          ) : value[prop];
          if (fieldValue !== void 0) {
            intermediateValue[prop] = fieldValue;
          }
        } else if (exists3 && !strip) {
          intermediateValue[prop] = value[prop];
        }
        if (intermediateValue[prop] !== value[prop]) {
          isChanged = true;
        }
      }
      return isChanged ? intermediateValue : value;
    }
    _validate(_value, opts = {}, callback) {
      let errors = [];
      let {
        sync: sync2,
        from = [],
        originalValue = _value,
        abortEarly = this.spec.abortEarly,
        recursive = this.spec.recursive
      } = opts;
      from = [{
        schema: this,
        value: originalValue
      }, ...from];
      opts.__validating = true;
      opts.originalValue = originalValue;
      opts.from = from;
      super._validate(_value, opts, (err, value) => {
        if (err) {
          if (!ValidationError.isError(err) || abortEarly) {
            return void callback(err, value);
          }
          errors.push(err);
        }
        if (!recursive || !isObject(value)) {
          callback(errors[0] || null, value);
          return;
        }
        originalValue = originalValue || value;
        let tests = this._nodes.map((key) => (_, cb) => {
          let path5 = key.indexOf(".") === -1 ? (opts.path ? `${opts.path}.` : "") + key : `${opts.path || ""}["${key}"]`;
          let field = this.fields[key];
          if (field && "validate" in field) {
            field.validate(value[key], _extends4({}, opts, {
              // @ts-ignore
              path: path5,
              from,
              // inner fields are always strict:
              // 1. this isn't strict so the casting will also have cast inner values
              // 2. this is strict in which case the nested values weren't cast either
              strict: true,
              parent: value,
              originalValue: originalValue[key]
            }), cb);
            return;
          }
          cb(null);
        });
        runTests({
          sync: sync2,
          tests,
          value,
          errors,
          endEarly: abortEarly,
          sort: this._sortErrors,
          path: opts.path
        }, callback);
      });
    }
    clone(spec) {
      const next = super.clone(spec);
      next.fields = _extends4({}, this.fields);
      next._nodes = this._nodes;
      next._excludedEdges = this._excludedEdges;
      next._sortErrors = this._sortErrors;
      return next;
    }
    concat(schema2) {
      let next = super.concat(schema2);
      let nextFields = next.fields;
      for (let [field, schemaOrRef] of Object.entries(this.fields)) {
        const target = nextFields[field];
        if (target === void 0) {
          nextFields[field] = schemaOrRef;
        } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
          nextFields[field] = schemaOrRef.concat(target);
        }
      }
      return next.withMutation(() => next.shape(nextFields, this._excludedEdges));
    }
    getDefaultFromShape() {
      let dft = {};
      this._nodes.forEach((key) => {
        const field = this.fields[key];
        dft[key] = "default" in field ? field.getDefault() : void 0;
      });
      return dft;
    }
    _getDefault() {
      if ("default" in this.spec) {
        return super._getDefault();
      }
      if (!this._nodes.length) {
        return void 0;
      }
      return this.getDefaultFromShape();
    }
    shape(additions, excludes = []) {
      let next = this.clone();
      let fields = Object.assign(next.fields, additions);
      next.fields = fields;
      next._sortErrors = sortByKeyOrder(Object.keys(fields));
      if (excludes.length) {
        if (!Array.isArray(excludes[0]))
          excludes = [excludes];
        next._excludedEdges = [...next._excludedEdges, ...excludes];
      }
      next._nodes = sortFields(fields, next._excludedEdges);
      return next;
    }
    pick(keys4) {
      const picked = {};
      for (const key of keys4) {
        if (this.fields[key])
          picked[key] = this.fields[key];
      }
      return this.clone().withMutation((next) => {
        next.fields = {};
        return next.shape(picked);
      });
    }
    omit(keys4) {
      const next = this.clone();
      const fields = next.fields;
      next.fields = {};
      for (const key of keys4) {
        delete fields[key];
      }
      return next.withMutation(() => next.shape(fields));
    }
    from(from, to, alias) {
      let fromGetter = (0, import_property_expr4.getter)(from, true);
      return this.transform((obj) => {
        if (obj == null)
          return obj;
        let newObj = obj;
        if ((0, import_has19.default)(obj, from)) {
          newObj = _extends4({}, obj);
          if (!alias)
            delete newObj[from];
          newObj[to] = fromGetter(obj);
        }
        return newObj;
      });
    }
    noUnknown(noAllow = true, message = object.noUnknown) {
      if (typeof noAllow === "string") {
        message = noAllow;
        noAllow = true;
      }
      let next = this.test({
        name: "noUnknown",
        exclusive: true,
        message,
        test(value) {
          if (value == null)
            return true;
          const unknownKeys = unknown(this.schema, value);
          return !noAllow || unknownKeys.length === 0 || this.createError({
            params: {
              unknown: unknownKeys.join(", ")
            }
          });
        }
      });
      next.spec.noUnknown = noAllow;
      return next;
    }
    unknown(allow = true, message = object.noUnknown) {
      return this.noUnknown(!allow, message);
    }
    transformKeys(fn) {
      return this.transform((obj) => obj && (0, import_mapKeys.default)(obj, (_, key) => fn(key)));
    }
    camelCase() {
      return this.transformKeys(import_camelCase.default);
    }
    snakeCase() {
      return this.transformKeys(import_snakeCase.default);
    }
    constantCase() {
      return this.transformKeys((key) => (0, import_snakeCase.default)(key).toUpperCase());
    }
    describe() {
      let base = super.describe();
      base.fields = (0, import_mapValues2.default)(this.fields, (value) => value.describe());
      return base;
    }
  };
  function create6(spec) {
    return new ObjectSchema(spec);
  }
  create6.prototype = ObjectSchema.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/array.js
  function _extends5() {
    _extends5 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends5.apply(this, arguments);
  }
  function create7(type3) {
    return new ArraySchema(type3);
  }
  var ArraySchema = class extends BaseSchema {
    constructor(type3) {
      super({
        type: "array"
      });
      this.innerType = void 0;
      this.innerType = type3;
      this.withMutation(() => {
        this.transform(function(values) {
          if (typeof values === "string")
            try {
              values = JSON.parse(values);
            } catch (err) {
              values = null;
            }
          return this.isType(values) ? values : null;
        });
      });
    }
    _typeCheck(v) {
      return Array.isArray(v);
    }
    get _subType() {
      return this.innerType;
    }
    _cast(_value, _opts) {
      const value = super._cast(_value, _opts);
      if (!this._typeCheck(value) || !this.innerType)
        return value;
      let isChanged = false;
      const castArray = value.map((v, idx) => {
        const castElement = this.innerType.cast(v, _extends5({}, _opts, {
          path: `${_opts.path || ""}[${idx}]`
        }));
        if (castElement !== v) {
          isChanged = true;
        }
        return castElement;
      });
      return isChanged ? castArray : value;
    }
    _validate(_value, options = {}, callback) {
      var _options$abortEarly, _options$recursive;
      let errors = [];
      let sync2 = options.sync;
      let path5 = options.path;
      let innerType = this.innerType;
      let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
      let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
      let originalValue = options.originalValue != null ? options.originalValue : _value;
      super._validate(_value, options, (err, value) => {
        if (err) {
          if (!ValidationError.isError(err) || endEarly) {
            return void callback(err, value);
          }
          errors.push(err);
        }
        if (!recursive || !innerType || !this._typeCheck(value)) {
          callback(errors[0] || null, value);
          return;
        }
        originalValue = originalValue || value;
        let tests = new Array(value.length);
        for (let idx = 0; idx < value.length; idx++) {
          let item = value[idx];
          let path6 = `${options.path || ""}[${idx}]`;
          let innerOptions = _extends5({}, options, {
            path: path6,
            strict: true,
            parent: value,
            index: idx,
            originalValue: originalValue[idx]
          });
          tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);
        }
        runTests({
          sync: sync2,
          path: path5,
          value,
          errors,
          endEarly,
          tests
        }, callback);
      });
    }
    clone(spec) {
      const next = super.clone(spec);
      next.innerType = this.innerType;
      return next;
    }
    concat(schema2) {
      let next = super.concat(schema2);
      next.innerType = this.innerType;
      if (schema2.innerType)
        next.innerType = next.innerType ? (
          // @ts-expect-error Lazy doesn't have concat()
          next.innerType.concat(schema2.innerType)
        ) : schema2.innerType;
      return next;
    }
    of(schema2) {
      let next = this.clone();
      if (!isSchema_default(schema2))
        throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema2));
      next.innerType = schema2;
      return next;
    }
    length(length, message = array.length) {
      return this.test({
        message,
        name: "length",
        exclusive: true,
        params: {
          length
        },
        test(value) {
          return isAbsent_default(value) || value.length === this.resolve(length);
        }
      });
    }
    min(min, message) {
      message = message || array.min;
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        // FIXME(ts): Array<typeof T>
        test(value) {
          return isAbsent_default(value) || value.length >= this.resolve(min);
        }
      });
    }
    max(max2, message) {
      message = message || array.max;
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        test(value) {
          return isAbsent_default(value) || value.length <= this.resolve(max2);
        }
      });
    }
    ensure() {
      return this.default(() => []).transform((val, original) => {
        if (this._typeCheck(val))
          return val;
        return original == null ? [] : [].concat(original);
      });
    }
    compact(rejector) {
      let reject = !rejector ? (v) => !!v : (v, i, a) => !rejector(v, i, a);
      return this.transform((values) => values != null ? values.filter(reject) : values);
    }
    describe() {
      let base = super.describe();
      if (this.innerType)
        base.innerType = this.innerType.describe();
      return base;
    }
    nullable(isNullable = true) {
      return super.nullable(isNullable);
    }
    defined() {
      return super.defined();
    }
    required(msg) {
      return super.required(msg);
    }
  };
  create7.prototype = ArraySchema.prototype;

  // src/cli/config/validateConfig.ts
  var schema = create6({
    workspace: create3(),
    contracts: create7(create3()),
    scripts: create7(create3()),
    predicates: create7(create3()),
    output: create3().required("config.output should be a valid string")
  }).required();
  async function validateConfig(config) {
    return schema.validate(config);
  }

  // src/cli/config/loadConfig.ts
  async function loadConfig(cwd) {
    const configJoycon = new import_joycon.default();
    const configPath = await configJoycon.resolve({
      files: ["ts", "js", "cjs", "mjs"].map((e) => `fuels.config.${e}`),
      cwd,
      stopDir: (0, import_path24.parse)(cwd).root
    });
    if (!configPath) {
      throw new Error("Config file not found!");
    }
    const esbuildOptions = {
      target: "ES2021",
      platform: "node",
      format: "esm"
    };
    const result = await bundleRequire({
      filepath: configPath,
      esbuildOptions,
      cwd
    });
    const userConfig = result.mod.default;
    await validateConfig(userConfig);
    const useBuiltinForc = userConfig.useBuiltinForc ?? shouldUseBuiltinForc();
    const useBuiltinFuelCore = userConfig.useBuiltinFuelCore ?? shouldUseBuiltinFuelCore();
    const { forcBuildFlags = [] } = userConfig;
    const releaseFlag = forcBuildFlags.find((f2) => f2 === "--release");
    const buildMode = releaseFlag ? "release" : "debug";
    const config = {
      contracts: [],
      scripts: [],
      predicates: [],
      deployConfig: {},
      autoStartFuelCore: true,
      fuelCorePort: 4e3,
      providerUrl: FUEL_NETWORK_URL,
      privateKey: defaultConsensusKey,
      ...userConfig,
      basePath: cwd,
      useBuiltinForc,
      useBuiltinFuelCore,
      configPath,
      forcBuildFlags,
      buildMode
    };
    config.output = (0, import_path24.resolve)(cwd, config.output);
    config.autoStartFuelCore = userConfig.autoStartFuelCore ?? true;
    if (!userConfig.workspace) {
      const { contracts, predicates, scripts } = userConfig;
      config.contracts = (contracts || []).map((c) => (0, import_path24.resolve)(cwd, c));
      config.scripts = (scripts || []).map((s) => (0, import_path24.resolve)(cwd, s));
      config.predicates = (predicates || []).map((p) => (0, import_path24.resolve)(cwd, p));
    } else {
      const workspace = (0, import_path24.resolve)(cwd, userConfig.workspace);
      const forcToml = readForcToml(workspace);
      if (!forcToml.workspace) {
        const workspaceMsg = `Forc workspace not detected in:
  ${workspace}/Forc.toml`;
        const swayProgramType = readSwayType(workspace);
        const exampleMsg = `Try using '${swayProgramType}s' instead of 'workspace' in:
  ${configPath}`;
        throw new Error([workspaceMsg, exampleMsg].join("\n\n"));
      }
      const swayMembers = forcToml.workspace.members.map((member) => (0, import_path24.resolve)(workspace, member));
      swayMembers.forEach((path5) => {
        const type3 = readSwayType(path5);
        config[`${type3}s`].push(path5);
      });
      config.workspace = workspace;
    }
    return config;
  }

  // src/cli/commands/withConfig.ts
  var withConfigErrorHandler = async (err, config) => {
    error(err);
    if (config) {
      await config.onFailure?.(err, config);
    }
  };
  function withConfig(program2, command, fn) {
    return async () => {
      const options = program2.opts();
      let config;
      try {
        config = await loadConfig(options.path);
      } catch (err) {
        await withConfigErrorHandler(err);
        return;
      }
      try {
        const eventData = await fn(config, program2);
        config.onSuccess?.(
          {
            type: command,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: eventData
          },
          config
        );
        log(`\u{1F389}  ${capitalizeString(command)} completed successfully!`);
      } catch (err) {
        await withConfigErrorHandler(err, config);
      }
    };
  }

  // src/cli/commands/dev/index.ts
  var closeAllFileHandlers = (handlers) => {
    handlers.forEach((h) => h.close());
  };
  var buildAndDeploy = async (config) => {
    await build(config);
    return deploy(config);
  };
  var getConfigFilepathsToWatch = (config) => {
    const configFilePathsToWatch = [config.configPath];
    if (config.chainConfig) {
      configFilePathsToWatch.push(config.chainConfig);
    }
    return configFilePathsToWatch;
  };
  var workspaceFileChanged = (state) => async (_event, path5) => {
    log(`
File changed: ${path5}`);
    await buildAndDeploy(state.config);
  };
  var configFileChanged = (state) => async (_event, path5) => {
    log(`
File changed: ${path5}`);
    closeAllFileHandlers(state.watchHandlers);
    state.fuelCore?.killChildProcess();
    try {
      await dev(await loadConfig(state.config.basePath));
    } catch (err) {
      await withConfigErrorHandler(err, state.config);
    }
  };
  var dev = async (config) => {
    const fuelCore = await autoStartFuelCore(config);
    const configFilePaths = getConfigFilepathsToWatch(config);
    const { contracts, scripts, predicates, basePath: cwd } = config;
    const workspaceFilePaths = [contracts, predicates, scripts].flat().flatMap((dir) => [
      dir,
      globSync(`${dir}/**/*.toml`, { cwd }),
      globSync(`${dir}/**/*.sw`, { cwd })
    ]).flat();
    try {
      await buildAndDeploy(config);
      const watchHandlers = [];
      const options = { persistent: true, ignoreInitial: true, ignored: "**/out/**" };
      const state = { config, watchHandlers, fuelCore };
      watchHandlers.push((0, import_chokidar.watch)(configFilePaths, options).on("all", configFileChanged(state)));
      watchHandlers.push((0, import_chokidar.watch)(workspaceFilePaths, options).on("all", workspaceFileChanged(state)));
    } catch (err) {
      error(err);
      throw err;
    }
  };

  // src/cli/commands/init/index.ts
  var import_fs16 = __require2("fs");
  var import_path25 = __require2("path");

  // src/cli/templates/fuels.config.ts
  var import_handlebars5 = __toESM(require_lib());

  // src/cli/templates/fuels.config.hbs
  var fuels_config_default = "import { createConfig } from 'fuels';\n\nexport default createConfig({\n  {{#if (isDefined workspace)}}\n  workspace: '{{workspace}}',\n  {{else}}\n    {{#if (isDefined contracts)}}\n  contracts: [\n      {{#each contracts}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n    {{#if (isDefined predicates)}}\n  predicates: [\n      {{#each predicates}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n    {{#if (isDefined scripts)}}\n  scripts: [\n      {{#each scripts}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n  {{/if}}\n  output: '{{output}}',\n  {{#if (isDefined useBuiltinForc)}}\n  useBuiltinForc: {{useBuiltinForc}},\n  {{/if}}\n  {{#if (isDefined useBuiltinFuelCore)}}\n  useBuiltinFuelCore: {{useBuiltinFuelCore}},\n  {{/if}}\n  {{#if (isDefined autoStartFuelCore)}}\n  autoStartFuelCore: {{autoStartFuelCore}},\n  {{/if}}\n});\n\n/**\n * Check the docs:\n * https://fuellabs.github.io/fuels-ts/tooling/cli/fuels/config-file\n */\n";

  // src/cli/templates/fuels.config.ts
  import_handlebars5.default.registerHelper("isDefined", (v) => v !== void 0);
  function renderFuelsConfigTemplate(props) {
    const renderTemplate = (0, import_handlebars5.compile)(fuels_config_default, {
      strict: true,
      noEscape: true
    });
    return renderTemplate(props);
  }

  // src/cli/commands/init/index.ts
  function init(program2) {
    const options = program2.opts();
    const { path: path5, autoStartFuelCore: autoStartFuelCore2, useBuiltinForc, useBuiltinFuelCore } = options;
    let workspace;
    let absoluteWorkspace;
    if (options.workspace) {
      absoluteWorkspace = (0, import_path25.resolve)(path5, options.workspace);
      workspace = `./${(0, import_path25.relative)(path5, absoluteWorkspace)}`;
    }
    const absoluteOutput = (0, import_path25.resolve)(path5, options.output);
    const output3 = `./${(0, import_path25.relative)(path5, absoluteOutput)}`;
    const [contracts, scripts, predicates] = ["contracts", "scripts", "predicates"].map(
      (optionName) => {
        const pathOrGlob = options[optionName];
        if (!pathOrGlob) {
          return void 0;
        }
        const expanded = globSync(pathOrGlob, { cwd: path5 });
        const relatives = expanded.map((e) => (0, import_path25.relative)(path5, e));
        return relatives;
      }
    );
    const noneIsInformed = ![workspace, contracts, scripts, predicates].find((v) => v !== void 0);
    if (noneIsInformed) {
      process.stdout.write(`error: required option '-w, --workspace <path>' not specified\r`);
      process.exit(1);
    } else {
      const fuelsConfigPath = (0, import_path25.join)(path5, "fuels.config.ts");
      if ((0, import_fs16.existsSync)(fuelsConfigPath)) {
        throw new Error(`Config file exists, aborting.
  ${fuelsConfigPath}`);
      }
      const renderedConfig = renderFuelsConfigTemplate({
        workspace,
        contracts,
        scripts,
        predicates,
        output: output3,
        useBuiltinForc,
        useBuiltinFuelCore,
        autoStartFuelCore: autoStartFuelCore2
      });
      (0, import_fs16.writeFileSync)(fuelsConfigPath, renderedConfig);
      log(`Config file created at:

 ${fuelsConfigPath}
`);
    }
  }

  // src/cli/commands/withProgram.ts
  function withProgram(program2, _command, fn) {
    return async () => {
      try {
        await fn(program2);
      } catch (err) {
        error(err);
      }
    };
  }

  // src/cli.ts
  var onPreAction = (command) => {
    const opts = command.opts();
    configureLogging({
      isDebugEnabled: opts.debug,
      isLoggingEnabled: !opts.silent
    });
  };
  var configureCli = () => {
    const program2 = new Command();
    program2.name("fuels");
    program2.option("-D, --debug", "Enables verbose logging", false);
    program2.option("-S, --silent", "Omit output messages", false);
    program2.version(versions.FUELS, "-v, --version", "Output the version number");
    program2.helpOption("-h, --help", "Display help");
    program2.addHelpCommand("help [command]", "Display help for command");
    program2.enablePositionalOptions(true);
    program2.hook("preAction", onPreAction);
    const pathOption = new Option("-p, --path <path>", "Path to project root").default(process.cwd());
    let command;
    const desc = `Relative path/globals to `;
    const arg = `<path|global>`;
    (command = program2.command("init" /* init */)).description("Create a sample `fuel.config.ts` file").addOption(pathOption).option("-w, --workspace <path>", "Relative dir path to Forc workspace").addOption(new Option(`-c, --contracts ${arg}`, `${desc} Contracts`).conflicts("workspace")).addOption(new Option(`-s, --scripts ${arg}`, `${desc} Scripts`).conflicts("workspace")).addOption(new Option(`-p, --predicates ${arg}`, `${desc} Predicates`).conflicts("workspace")).requiredOption("-o, --output <path>", "Relative dir path for Typescript generation output").option("--use-builtin-forc", "Use buit-in `forc` to build Sway programs").option("--use-builtin-fuel-core", "Use buit-in `fuel-core` when starting a Fuel node").option("--auto-start-fuel-core", "Auto-starts a `fuel-core` node during `dev` command").action(withProgram(command, "init" /* init */, init));
    (command = program2.command("dev" /* dev */)).description("Start a Fuel node and run build + deploy on every file change").addOption(pathOption).action(withConfig(command, "dev" /* dev */, dev));
    (command = program2.command("build" /* build */)).description("Build Sway programs and generate Typescript for them").addOption(pathOption).option(
      "-d, --deploy",
      "Deploy contracts after build (auto-starts a `fuel-core` node if needed)"
    ).action(withConfig(command, "build" /* build */, build));
    (command = program2.command("deploy" /* deploy */)).description("Deploy contracts to the Fuel network").addOption(pathOption).action(withConfig(command, "deploy" /* deploy */, deploy));
    configureCliOptions(
      program2.command("typegen").description(`Generate Typescript from Sway ABI JSON files`)
    );
    program2.command("versions").description("Check for version incompatibilities").action(runVersions);
    program2.command("core", "Wrapper around Fuel Core binary", {
      executableFile: findBinPath("fuels-core", __dirname)
    });
    program2.command("forc", "Wrapper around Forc binary", {
      executableFile: findBinPath("fuels-forc", __dirname)
    });
    return program2;
  };

  // src/run.ts
  var run = async (argv) => {
    const program2 = configureCli();
    return program2.parseAsync(argv);
  };

  // src/bin.ts
  try {
    run(process.argv).catch(process.stderr.write);
  } catch (err) {
    error(err?.message || err);
    process.exit(1);
  }
})();
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=bin.global.js.map