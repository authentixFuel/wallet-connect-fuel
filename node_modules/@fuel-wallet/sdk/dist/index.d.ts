import { Asset, AssetData } from '@fuel-wallet/types';
export * from '@fuel-wallet/types';
import { TransactionRequestLike, JsonAbi, Provider, ProviderOptions, TransactionResponse, WalletLocked, AbstractAddress } from 'fuels';
import EventEmitter from 'events';
import { JSONRPCClient } from 'json-rpc-2.0';

declare enum FuelConnectorMethods {
    ping = "ping",
    version = "version",
    connect = "connect",
    disconnect = "disconnect",
    isConnected = "isConnected",
    accounts = "accounts",
    currentAccount = "currentAccount",
    signMessage = "signMessage",
    sendTransaction = "sendTransaction",
    assets = "assets",
    addAsset = "addAsset",
    addAssets = "addAssets",
    networks = "networks",
    currentNetwork = "currentNetwork",
    addNetwork = "addNetwork",
    selectNetwork = "selectNetwork",
    addABI = "addABI",
    getABI = "getABI",
    hasABI = "hasABI"
}
declare enum FuelConnectorEventTypes {
    connectors = "connectors",
    currentConnector = "currentConnector",
    connection = "connection",
    accounts = "accounts",
    currentAccount = "currentAccount",
    networks = "networks",
    currentNetwork = "currentNetwork",
    assets = "assets",
    abis = "abis"
}
declare const FuelConnectorEventType = "FuelConnector";

/**
 * @name FuelConnector
 *
 * Wallet Connector is a interface that represents a Wallet Connector and all the methods
 * that should be implemented to be compatible with the Fuel SDK.
 */
declare abstract class FuelConnector extends EventEmitter {
    name: string;
    metadata: ConnectorMetadata;
    connected: boolean;
    installed: boolean;
    events: typeof FuelConnectorEventTypes;
    /**
     * Should return true if the connector is loaded
     * in less then one second.
     *
     * @returns {true} - always true.
     */
    ping(): Promise<boolean>;
    /**
     * Should return the current version of the connector
     * and the network version that is compatible.
     *
     * @returns {boolean} - connection status.
     */
    version(): Promise<Version>;
    /**
     * Should return true if the connector is connected
     * to any of the accounts available.
     *
     * @returns {boolean} - connection status.
     */
    isConnected(): Promise<boolean>;
    /**
     * Should return all the accounts authorized for the
     * current connection.
     *
     * @returns {string[]} - Accounts addresses
     */
    accounts(): Promise<Array<string>>;
    /**
     * Should start the connection process and return
     * true if the account authorize the connection.
     *
     * and return false if the user reject the connection.
     *
     * @emits accounts
     * @returns {boolean} - connection status.
     */
    connect(): Promise<boolean>;
    /**
     * Should disconnect the current connection and
     * return false if the disconnection was successful.
     *
     * @emits assets connection
     * @returns {boolean} - connection status.
     */
    disconnect(): Promise<boolean>;
    /**
     * Should start the sign message process and return
     * the signed message.
     *
     * @param {string} address - The address to sign the message
     * @param {string} message - The message to sign all text will be treated as text utf-8
     *
     * @returns {string} - Message signature
     */
    signMessage(address: string, message: string): Promise<string>;
    /**
     * Should start the send transaction process and return
     * the transaction id submitted to the network.
     *
     * If the network is not available for the connection
     * it should throw an error to avoid the transaction
     * to be sent to the wrong network and lost.
     *
     * @param {string} address - The address to sign the transaction
     * @param {Transaction} transaction - The transaction to send
     *
     * @returns {string} - The transaction id
     */
    sendTransaction(address: string, transaction: TransactionRequestLike): Promise<string>;
    /**
     * Should return the current account selected inside the connector, if the account
     * is authorized for the connection.
     *
     * If the account is not authorized it should return null.
     *
     * @returns {string | null} - The current account selected or null.
     */
    currentAccount(): Promise<string | null>;
    /**
     * Should add the the assets metadata to the connector and return true if the asset
     * was added successfully.
     *
     * If the asset already exists it should throw an error.
     *
     * @emits assets
     * @param {Asset[]} assets - The assets to add the metadata to the connection.
     * @returns True if the asset was added successfully
     * @throws Error if the asset already exists
     */
    addAssets(assets: Array<Asset>): Promise<boolean>;
    /**
     * Should add the the asset metadata to the connector and return true if the asset
     * was added successfully.
     *
     * If the asset already exists it should throw an error.
     *
     * @emits assets
     * @param {Asset} asset - The asset to add the metadata to the connection.
     * @returns True if the asset was added successfully
     * @throws Error if the asset already exists
     */
    addAsset(asset: Asset): Promise<boolean>;
    /**
     * Should return all the assets added to the connector. If a connection is already established.
     *
     * @returns {Asset} assets - The assets metadata from the connector vinculated to the all accounts from a specific Wallet.
     */
    assets(): Promise<Array<Asset>>;
    /**
     * Should start the add network process and return true if the network was added successfully.
     *
     * @emits networks
     * @throws {Error} if the network already exists
     * @returns {boolean} boolean - Return true if the network was added successfully
     */
    addNetwork(networkUrl: string): Promise<boolean>;
    /**
     * Should start the select network process and return true if the network has change successfully.
     *
     * @emits networks
     * @throws {Error} if the network already exists
     * @returns {boolean} boolean - Return true if the network was added successfully
     */
    selectNetwork(network: Network): Promise<boolean>;
    /**
     * Should return all the networks available from the connector. If the connection is already established.
     *
     * @returns {Network[]} networks - Return all the networks added to the connector.
     */
    networks(): Promise<Array<Network>>;
    /**
     * Should return the current network selected inside the connector. Even if the connection is not established.
     *
     * @returns {Network} network - Return all the networks added to the connector.
     */
    currentNetwork(): Promise<Network>;
    /**
     * Should add the abi to the connector and return true if the abi was added successfully.
     *
     * @param {FuelABI} abi - The fuel abi that represents a contract.
     * @throws {Error} if the abi already exists
     * @returns {boolean} - Return true if the abi was added successfully
     */
    addABI(contractId: string, abi: FuelABI): Promise<boolean>;
    /**
     * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.
     *
     * @param {string} contractId - The contract id to get the abi
     * @returns {FuelABI | null} abi - The fuel abi that represents a contract or script.
     */
    getABI(id: string): Promise<FuelABI | null>;
    /**
     * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.
     *
     * @param {string} contractId - The contract id to get the abi
     * @return {boolean} - Return true if the abi exists or false if not.
     */
    hasABI(id: string): Promise<boolean>;
    /**
     * Event listener for the connector.
     *
     * @param {string} eventName - The event name to listen
     * @param {function} listener - The listener function
     */
    on<E extends FuelConnectorEvents['type'], D extends FuelEventArg<E>>(eventName: E, listener: (data: D) => void): this;
}

/****
 * ========================================================================================
 * Helpers
 * ========================================================================================
 */
/**
 * Extract the event argument type from the event type.
 */
type FuelEventArg<T extends FuelConnectorEvents['type']> = Extract<FuelConnectorEventTypes, {
    type: T;
}>['data'];
/****
 * ========================================================================================
 * Events
 * ========================================================================================
 */
/**
 * Event trigger when the accounts available to the
 * connection changes.
 *
 * @property {string} type - The event type.
 * @property {string[]} accounts - The accounts addresses
 */
type AccountsEvent = {
    type: FuelConnectorEventTypes.accounts;
    data: Array<string>;
};
/**
 * Event trigger when the current account on the connector is changed
 * if the account is not authorized for the connection it should trigger with value null.
 *
 * @property {string} type - The event type.
 * @property {string | null} data - The current account selected or null.
 */
type AccountEvent = {
    type: FuelConnectorEventTypes.currentAccount;
    data: string | null;
};
/**
 * Event trigger when connection status changes. With the new connection status.
 *
 * @event ConnectionEvent
 * @type {object}
 * @property {string} type - The event type.
 * @property {boolean} data - The new connection status.
 */
type ConnectionEvent = {
    type: FuelConnectorEventTypes.connection;
    data: boolean;
};
/**
 * Event trigger when the network selected on the connector is changed.
 * It should trigger even if the network is not available for the connection.
 *
 * @event NetworkEvent
 * @type {object}
 * @property {string} type - The event type.
 * @property {Network} data - The network information
 */
type NetworkEvent = {
    type: FuelConnectorEventTypes.currentNetwork;
    data: Network;
};
/**
 * Event trigger when the network selected on the connector is changed.
 * It should trigger even if the network is not available for the connection.
 *
 * @event NetworksEvent
 * @type {object}
 * @property {string} type - The event type.
 * @property {Network[]} data - The network information
 */
type NetworksEvent = {
    type: FuelConnectorEventTypes.networks;
    data: Network;
};
/**
 * Event trigger when the list of connectors has changed.
 *
 * @event ConnectorsEvent
 * @type {object}
 * @property {string} type - The event type.
 * @property {FuelConnector[]} data - The list of connectors
 */
type ConnectorsEvent = {
    type: FuelConnectorEventTypes.connectors;
    data: Array<FuelConnector>;
};
/**
 * Event trigger when the current connector has changed.
 *
 * @event ConnectorEvent
 * @type {object}
 * @property {string} type - The event type.
 * @property {FuelConnector} data - The list of connectors
 */
type ConnectorEvent = {
    type: FuelConnectorEventTypes.currentConnector;
    data: FuelConnector;
};
/**
 * Event trigger when the assets list of metadata changed.
 *
 * @event AssetsEvent
 * @type {object}
 * @property {string} type - The event type.
 * @property {Array<Asset>} data - The list of assets
 */
type AssetsEvent = {
    type: FuelConnectorEventTypes.assets;
    data: Array<Asset>;
};
/**
 * All the events available to the connector.
 */
type FuelConnectorEvents = ConnectionEvent | NetworkEvent | NetworksEvent | AccountEvent | AccountsEvent | ConnectorsEvent | ConnectorEvent | AssetsEvent;
type FuelConnectorEventsType = FuelConnectorEvents['type'];
/****
 * ========================================================================================
 * Data Types
 * ========================================================================================
 */
/**
 * @name Version
 */
type Version = {
    app: string;
    /**
     * Version selection this allow
     * Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4
     * Tilde Ranges ~1.2.3 ~1.2 ~1
     * And Exact Versions 1.0.0
     */
    network: string;
};
/**
 * @name Network
 */
type Network = {
    /**
     * The name of the network.
     */
    url: string;
    /**
     * The chain id of the network.
     */
    chainId: number;
};
/**
 * ABI that represents a binary code interface from Sway.
 *
 * Read more at: https://docs.fuel.network/docs/specs/abi/json-abi-format/
 */
type FuelABI = JsonAbi;
/****
 * ========================================================================================
 * Wallet Connector Metadata
 * ========================================================================================
 */
type ConnectorMetadata = {
    image?: string | {
        light: string;
        dark: string;
    };
    install: {
        action: string;
        link: string;
        description: string;
    };
};
/****
 * ========================================================================================
 *  Others
 * ========================================================================================
 */
/**
 * Target Object that represents the global event bus used by Fuel Connector Manager.
 * On browser the default target is the window or document. For other environments
 * the event bus should be provided.
 */
interface TargetObject {
    on?: (event: string, callback: any) => void;
    off?: (event: string, callback: any) => void;
    emit?: (event: string, data: any) => void;
    addEventListener?: (event: string, callback: any) => void;
    removeEventListener?: (event: string, callback: any) => void;
    postMessage?: (message: string) => void;
}
/**
 * Fuel Storage represent the storage interface used by Fuel Connector Manager.
 * On browser the default storage is the localStorage. For other environments
 * the storage should be provided.
 */
interface FuelStorage {
    setItem: (key: string, value: string) => void;
    getItem: (key: string) => string | null;
    removeItem: (key: string) => void;
}

type CacheFor = {
    [key: string]: {
        timeout: number;
        value: unknown;
    } | null;
};
type CacheForOptions = {
    key: string;
    cache: CacheFor;
    cacheTime: number;
};
declare function cacheFor<F extends (...args: unknown[]) => Promise<unknown>>(fn: F, { cache, cacheTime, key }: CacheForOptions): F;

type DeferPromise<R = unknown> = {
    promise: Promise<R>;
    resolve: (value: R) => void;
    reject: (error: unknown) => void;
};
declare function deferPromise<R = unknown>(): DeferPromise<R>;
declare function withTimeout<F extends Promise<unknown>, RT = Awaited<F>>(promise: F, timeout?: number): Promise<RT>;

declare function getAssetByChain(asset: Asset, chainId: number, network?: string): AssetData;

/**
 * Fuel Connector Event is a custom event that can be used by the connector to
 * inform the Fuel Connector Manager that a new connector is available.
 */
declare function dispatchFuelConnectorEvent(connector: FuelConnector): void;

/**
 * @todo: We should add getTransactionResponse to TS-SDK in this way
 * a provider becomes self contained enabling connectors to implement
 * their on providers for customized responses.
 *
 * With the change we can remove the entire FuelWalletProvider.
 */
declare class FuelWalletProvider extends Provider {
    constructor(url: string, options?: ProviderOptions);
    static create(url: string, options?: ProviderOptions | undefined): Promise<FuelWalletProvider>;
    getTransactionResponse(transactionId: string): Promise<TransactionResponse>;
}

declare class FuelWalletLocked extends WalletLocked {
    connector: FuelConnector;
    _provider: FuelWalletProvider;
    constructor(address: string | AbstractAddress, connector: FuelConnector, provider: FuelWalletProvider);
    signMessage(message: string): Promise<string>;
    sendTransaction(transaction: TransactionRequestLike): Promise<TransactionResponse>;
    get provider(): FuelWalletProvider;
}

type FuelConfig = {
    connectors?: Array<FuelConnector>;
    storage?: FuelStorage | null;
    targetObject?: TargetObject;
    devMode?: boolean;
};
type FuelConnectorSelectOptions = {
    emitEvents?: boolean;
};
declare class Fuel extends FuelConnector {
    static STORAGE_KEY: string;
    static defaultConfig: FuelConfig;
    private _storage?;
    private _connectors;
    private _targetObject;
    private _unsubscribes;
    private _targetUnsubscribe;
    private _pingCache;
    private _currentConnector?;
    constructor(config?: FuelConfig);
    /**
     * Return the target object to listen for global events.
     */
    private getTargetObject;
    /**
     * Return the storage used.
     */
    private getStorage;
    /**
     * Setup the default connector from the storage.
     */
    private setDefaultConnector;
    /**
     * Start listener for all the events of the current
     * connector and emit them to the Fuel instance
     */
    private setupConnectorEvents;
    /**
     * Call method from the current connector.
     */
    private callMethod;
    /**
     * Create a method for each method proxy that is available on the Common interface
     * and call the method from the current connector.
     */
    private setupMethods;
    /**
     * Fetch the status of a connector and set the installed and connected
     * status.
     */
    private fetchConnectorStatus;
    /**
     * Fetch the status of all connectors and set the installed and connected
     * status.
     */
    private fetchConnectorsStatus;
    /**
     * Fetch the status of a connector and set the installed and connected
     * status. If no connector is provided it will ping the current connector.
     */
    private pingConnector;
    /**
     * Setup a listener for the FuelConnector event and add the connector
     * to the list of new connectors.
     */
    private setupConnectorListener;
    /**
     * Add a new connector to the list of connectors.
     */
    private addConnector;
    private triggerConnectorEvents;
    /**
     * Get a connector from the list of connectors.
     */
    getConnector: (connector: FuelConnector | string) => FuelConnector | null;
    /**
     * Return the list of connectors with the status of installed and connected.
     */
    connectors(): Promise<Array<FuelConnector>>;
    /**
     * Set the current connector to be used.
     */
    selectConnector(connectorName: string, options?: FuelConnectorSelectOptions): Promise<boolean>;
    /**
     * Return the current selected connector.
     */
    currentConnector(): FuelConnector | null | undefined;
    /**
     * Return true if any connector is available.
     */
    hasConnector(): Promise<boolean>;
    hasWallet(): Promise<boolean>;
    /**
     * Return a Fuel Provider instance with extends features to work with
     * connectors.
     *
     * @deprecated Provider is going to be deprecated in the future.
     */
    getProvider(providerOrNetwork?: FuelWalletProvider | Network): Promise<FuelWalletProvider>;
    /**
     * Return a Fuel Provider instance with extends features to work with
     * connectors.
     */
    private _getProvider;
    /**
     * Return a Fuel Wallet Locked instance with extends features to work with
     * connectors.
     */
    getWallet(address: string | AbstractAddress, providerOrNetwork?: FuelWalletProvider | Network): Promise<FuelWalletLocked>;
    /**
     * Remove all open listeners this is useful when you want to
     * remove the Fuel instance and avoid memory leaks.
     */
    unsubscribe(): void;
    /**
     * Clean all the data from the storage.
     */
    clean(): void;
    /**
     * Removes all listeners and cleans the storage.
     */
    destroy(): void;
}

declare class FuelWalletConnector extends FuelConnector {
    name: string;
    connected: boolean;
    installed: boolean;
    events: typeof FuelConnectorEventTypes;
    metadata: ConnectorMetadata;
    readonly client: JSONRPCClient;
    constructor(name?: string);
    /**
     * ============================================================
     * Application communication methods
     * ============================================================
     */
    private setupConnector;
    private acceptMessage;
    private setupListener;
    private createRequestId;
    private postMessage;
    private sendRequest;
    private onResponse;
    private onEvent;
    private onMessage;
    private onCommunicationMessage;
    /**
     * ============================================================
     * Connector methods
     * ============================================================
     */
    ping(): Promise<boolean>;
    isConnected(): Promise<boolean>;
    connect(): Promise<boolean>;
    disconnect(): Promise<boolean>;
    accounts(): Promise<Array<string>>;
    currentAccount(): Promise<string | null>;
    signMessage(address: string, message: string): Promise<string>;
    sendTransaction(address: string, transaction: TransactionRequestLike): Promise<string>;
    assets(): Promise<Array<Asset>>;
    addAsset(asset: Asset): Promise<boolean>;
    addAssets(assets: Asset[]): Promise<boolean>;
    addABI(contractId: string, abi: FuelABI): Promise<boolean>;
    getABI(contractId: string): Promise<FuelABI>;
    hasABI(contractId: string): Promise<boolean>;
    currentNetwork(): Promise<Network>;
    selectNetwork(_network: Network): Promise<boolean>;
    networks(): Promise<Network[]>;
    addNetwork(networkUrl: string): Promise<boolean>;
    version(): Promise<Version>;
}

declare class FuelWalletDevelopmentConnector extends FuelWalletConnector {
    metadata: ConnectorMetadata;
    constructor();
}

declare class FueletWalletConnector extends FuelWalletConnector {
    name: string;
    metadata: ConnectorMetadata;
    constructor();
}

type DefaultConnectors = {
    devMode?: boolean;
};
declare function defaultConnectors({ devMode }?: DefaultConnectors): FuelWalletConnector[];

export { AccountEvent, AccountsEvent, AssetsEvent, CacheFor, ConnectionEvent, ConnectorEvent, ConnectorMetadata, ConnectorsEvent, DeferPromise, Fuel, FuelABI, FuelConfig, FuelConnector, FuelConnectorEventType, FuelConnectorEventTypes, FuelConnectorEvents, FuelConnectorEventsType, FuelConnectorMethods, FuelConnectorSelectOptions, FuelEventArg, FuelStorage, FuelWalletConnector, FuelWalletDevelopmentConnector, FuelWalletLocked, FuelWalletProvider, FueletWalletConnector, Network, NetworkEvent, NetworksEvent, TargetObject, Version, cacheFor, defaultConnectors, deferPromise, dispatchFuelConnectorEvent, getAssetByChain, withTimeout };
