import x from 'events';
import { WalletLocked, Provider, TransactionResponse, transactionRequestify } from 'fuels';
import { MessageTypes, CONNECTOR_SCRIPT, EVENT_MESSAGE, CONTENT_SCRIPT_NAME } from '@fuel-wallet/types';
export * from '@fuel-wallet/types';
import { JSONRPCClient } from 'json-rpc-2.0';

var A=(i=>(i.ping="ping",i.version="version",i.connect="connect",i.disconnect="disconnect",i.isConnected="isConnected",i.accounts="accounts",i.currentAccount="currentAccount",i.signMessage="signMessage",i.sendTransaction="sendTransaction",i.assets="assets",i.addAsset="addAsset",i.addAssets="addAssets",i.networks="networks",i.currentNetwork="currentNetwork",i.addNetwork="addNetwork",i.selectNetwork="selectNetwork",i.addABI="addABI",i.getABI="getABI",i.hasABI="hasABI",i))(A||{}),m=(l=>(l.connectors="connectors",l.currentConnector="currentConnector",l.connection="connection",l.accounts="accounts",l.currentAccount="currentAccount",l.networks="networks",l.currentNetwork="currentNetwork",l.assets="assets",l.abis="abis",l))(m||{}),f="FuelConnector";function b(o,{cache:r,cacheTime:e,key:t}){return async(...n)=>{if(r[t]&&r[t]?.value)return r[t].value;clearTimeout(r[t]?.timeout);let s=await o(...n);return r[t]={timeout:Number(setTimeout(()=>{r[t]=null;},e)),value:s},s}}function k(){let o={};return o.promise=new Promise((r,e)=>{o.reject=e,o.resolve=r;}),o}async function g(o,r=1050){let e=new Promise((t,n)=>{setTimeout(()=>{n(new Error("Promise timed out"));},r);});return Promise.race([e,o])}function K(o,r,e="fuel"){let t=o.networks.find(n=>n.chainId===r&&n.type===e);if(!t)throw new Error("Asset not found for the given chain and network.");return {...o,assetId:t.assetId,decimals:t.decimals,chainId:t.chainId,network:t.type}}function $(o){window.dispatchEvent(new CustomEvent(f,{detail:o}));}var h=class extends x{constructor(){super(...arguments);this.name="";this.metadata={};this.connected=!1;this.installed=!1;this.events=m;}async ping(){throw new Error("Method not implemented.")}async version(){throw new Error("Method not implemented.")}async isConnected(){throw new Error("Method not implemented.")}async accounts(){throw new Error("Method not implemented.")}async connect(){throw new Error("Method not implemented.")}async disconnect(){throw new Error("Method not implemented.")}async signMessage(e,t){throw new Error("Method not implemented.")}async sendTransaction(e,t){throw new Error("Method not implemented.")}async currentAccount(){throw new Error("Method not implemented.")}async addAssets(e){throw new Error("Method not implemented.")}async addAsset(e){throw new Error("Method not implemented.")}async assets(){throw new Error("Method not implemented.")}async addNetwork(e){throw new Error("Method not implemented.")}async selectNetwork(e){throw new Error("Method not implemented.")}async networks(){throw new Error("Method not implemented.")}async currentNetwork(){throw new Error("Method not implemented.")}async addABI(e,t){throw new Error("Method not implemented.")}async getABI(e){throw new Error("Method not implemented.")}async hasABI(e){throw new Error("Method not implemented.")}on(e,t){return super.on(e,t),this}};var v=class extends WalletLocked{constructor(e,t,n){super(e,n);this.connector=t,this._provider=n;}async signMessage(e){return this.connector.signMessage(this.address.toString(),e)}async sendTransaction(e){let t=await this.connector.sendTransaction(this.address.toString(),e);return this.provider.getTransactionResponse(t)}get provider(){return this._provider}};var w=class o extends Provider{constructor(r,e){super(r,e);}static async create(r,e){let t=new o(r,e);return await t.fetchChainAndNodeInfo(),t}async getTransactionResponse(r){return new TransactionResponse(r,this)}};var p=class extends h{constructor(e="Fuel Wallet"){super();this.name="";this.connected=!1;this.installed=!1;this.events=m;this.metadata={image:"/connectors/fuel-wallet.svg",install:{action:"Install",description:"To connect your Fuel Wallet, install the browser extension.",link:"https://chrome.google.com/webstore/detail/fuel-wallet/dldjpboieedgcmpkchcjcbijingjcgok"}};this.onMessage=e=>{let t=Object.freeze(e);if(!this.acceptMessage(t))return;let{data:n}=t;this.onCommunicationMessage(n);};this.onCommunicationMessage=e=>{switch(e.type){case MessageTypes.response:this.onResponse(e);break;case MessageTypes.event:this.onEvent(e);break;}};this.name=e,this.setMaxListeners(100),this.client=new JSONRPCClient(this.sendRequest.bind(this),this.createRequestId),this.setupListener(),this.setupConnector();}async setupConnector(){typeof window<"u"&&this.ping().then(()=>{window.dispatchEvent(new CustomEvent("FuelConnector",{detail:this}));}).catch(()=>{});}acceptMessage(e){let{data:t}=e;return e.origin===window.origin&&t.type!==MessageTypes.request&&t.connectorName===this.name&&t.target===CONNECTOR_SCRIPT}setupListener(){typeof window>"u"||window.addEventListener(EVENT_MESSAGE,this.onMessage.bind(this));}createRequestId(){return crypto.randomUUID()}postMessage(e,t){window.postMessage(e,t||window.origin);}async sendRequest(e){e&&this.postMessage({type:MessageTypes.request,target:CONTENT_SCRIPT_NAME,connectorName:this.name,request:e});}onResponse(e){this.client.receive(e.response);}onEvent(e){e.events.forEach(t=>{t.event==="start"?this.setupConnector():this.emit(t.event,...t.params);});}async ping(){return this.client.timeout(800).request("ping",{})}async isConnected(){try{return await this.client.request("isConnected",{})}catch{return !1}}async connect(){return this.client.request("connect",{})}async disconnect(){return this.client.request("disconnect",{})}async accounts(){return this.client.request("accounts",{})}async currentAccount(){return this.client.request("currentAccount",{})}async signMessage(e,t){if(!t.trim())throw new Error("Message is required");return this.client.request("signMessage",{address:e,message:t})}async sendTransaction(e,t){if(!t)throw new Error("Transaction is required");let n=transactionRequestify(t),u={url:(await this.currentNetwork()).url};return this.client.request("sendTransaction",{address:e,transaction:JSON.stringify(n),provider:u})}async assets(){return this.client.request("assets",{})}async addAsset(e){return this.addAssets([e])}async addAssets(e){let t=e.map(n=>{let s=n.networks.find(u=>u.type==="fuel");if(!s)throw new Error("Asset for Fuel Network not found!");return {...n,imageUrl:n.icon,decimals:s.decimals,assetId:s.assetId}});return this.client.request("addAssets",{assets:t})}async addABI(e,t){return this.client.request("addAbi",{abiMap:{[e]:t}})}async getABI(e){return this.client.request("getAbi",{contractId:e})}async hasABI(e){return !!await this.getABI(e)}async currentNetwork(){return this.client.request("network",{})}async selectNetwork(e){throw new Error("Method not implemented.")}async networks(){return this.client.request("networks",{})}async addNetwork(e){let t=await Provider.create(e);return this.client.request("addNetwork",{network:{url:t.url,name:t.getChain().name}})}async version(){return this.client.request("version",{app:"0.0.0",network:"0.0.0"})}};var C=class extends p{constructor(){super("Fuel Wallet Development");this.metadata={image:"/connectors/fuel-wallet-dev.svg",install:{action:"Install",description:"To connect your Fuel Wallet, you need to install the browser extension first.",link:"https://chrome.google.com/webstore/detail/fuel-wallet-development/hcgmehahnlbhpilepakbdinkhhaackmc"}};}};var E=class extends p{constructor(){super("Fuelet Wallet");this.name="Fuelet Wallet";this.metadata={image:{light:"/connectors/fuelet-light.svg",dark:"/connectors/fuelet-dark.svg"},install:{action:"Install",description:"Install Fuelet Wallet in order to connect it.",link:"https://fuelet.app/download/"}};}};function P({devMode:o}={}){let r=[new p,new E];return o&&r.push(new C),r}var W=2e3,j=5e3,d=class d extends h{constructor(e=d.defaultConfig){super();this._storage=null;this._connectors=[];this._targetObject=null;this._unsubscribes=[];this._pingCache={};this.setupConnectorListener=()=>{let{_targetObject:e}=this,t=f;if(e?.on)return e.on(t,this.addConnector),()=>{e.off?.(t,this.addConnector);};if(e?.addEventListener){let n=s=>{this.addConnector(s.detail);};return e.addEventListener(t,n),()=>{e.removeEventListener?.(t,n);}}return ()=>{}};this.addConnector=async e=>{this.getConnector(e)||this._connectors.push(e),await this.fetchConnectorStatus(e),this.emit(this.events.connectors,this._connectors),this._currentConnector||await this.selectConnector(e.name,{emitEvents:!1});};this.triggerConnectorEvents=async()=>{let[e,t,n]=await Promise.all([this.isConnected(),this.networks(),this.currentNetwork()]);if(this.emit(this.events.connection,e),this.emit(this.events.networks,t),this.emit(this.events.currentNetwork,n),e){let[s,u]=await Promise.all([this.accounts(),this.currentAccount()]);this.emit(this.events.accounts,s),this.emit(this.events.currentAccount,u);}};this.getConnector=e=>this._connectors.find(t=>{let n=typeof e=="string"?e:e.name;return t.name===n||t===e})||null;this.setMaxListeners(1e3),this._connectors=e.connectors??P({devMode:e.devMode}),this._targetObject=this.getTargetObject(e.targetObject),this._storage=e.storage===void 0?this.getStorage():e.storage,this.setupMethods(),this.setDefaultConnector(),this._targetUnsubscribe=this.setupConnectorListener();}getTargetObject(e){return e||(typeof window<"u"?window:typeof document<"u"?document:null)}getStorage(){if(typeof window<"u")return window.localStorage}setDefaultConnector(){let e=this._storage?.getItem(d.STORAGE_KEY)||this._connectors[0]?.name;if(e)return this.selectConnector(e,{emitEvents:!1})}setupConnectorEvents(e){if(!this._currentConnector)return;let t=this._currentConnector;this._unsubscribes.map(n=>n()),this._unsubscribes=e.map(n=>{let s=(...u)=>this.emit(n,...u);return t.on(n,s),()=>t.off(n,s)});}async callMethod(e,...t){let n=await this.hasConnector();if(await this.pingConnector(),!this._currentConnector||!n)throw new Error(`No connector selected for calling ${e}. Use hasConnector before executing other methods.`);if(typeof this._currentConnector[e]=="function")return this._currentConnector[e](...t);}setupMethods(){Object.values(A).map(e=>{this[e]=async(...t)=>this.callMethod(e,...t);});}async fetchConnectorStatus(e){let t=Date.now(),[n,s]=await Promise.allSettled([g(e.isConnected()),g(this.pingConnector(e))]);return t<(e._latestUpdate||0)||(e._latestUpdate=Date.now(),e.installed=s.status==="fulfilled"&&s.value,e.connected=n.status==="fulfilled"&&n.value),{installed:e.installed,connected:e.connected}}async fetchConnectorsStatus(){return Promise.all(this._connectors.map(async e=>this.fetchConnectorStatus(e)))}async pingConnector(e){let{_currentConnector:t}=this,n=e??t;if(!n)return !1;try{return await b(async()=>g(n.ping()),{key:n.name,cache:this._pingCache,cacheTime:j})()}catch{throw new Error("Current connector is not available.")}}async connectors(){return await this.fetchConnectorsStatus(),this._connectors}async selectConnector(e,t={emitEvents:!0}){let n=this.getConnector(e);if(!n)return !1;if(this._currentConnector?.name===e)return !0;let{installed:s}=await this.fetchConnectorStatus(n);return s?(this._currentConnector=n,this.emit(this.events.currentConnector,n),this.setupConnectorEvents(Object.values(m)),this._storage?.setItem(d.STORAGE_KEY,n.name),t.emitEvents&&this.triggerConnectorEvents(),!0):!1}currentConnector(){return this._currentConnector}async hasConnector(){if(this._currentConnector)return !0;let e=k();return this.once(this.events.currentConnector,()=>{e.resolve(!0);}),g(e.promise,W).then(()=>!0).catch(()=>!1)}async hasWallet(){return this.hasConnector()}async getProvider(e){return process.env.NODE_ENV!=="production"&&console.warn("Get provider is deprecated, use getWallet instead. Provider is going to be removed in the future."),this._getProvider(e)}async _getProvider(e){let t;if(e&&"getTransactionResponse"in e)t=e;else if(e&&"chainId"in e&&"url"in e)t=await w.create(e.url);else {if(e)throw new Error("Provider is not valid.");{let n=await this.currentNetwork();t=await w.create(n.url);}}return t}async getWallet(e,t){let n=await this._getProvider(t);return new v(e,this,n)}unsubscribe(){this._unsubscribes.map(e=>e()),this._targetUnsubscribe(),this.removeAllListeners();}clean(){this._storage?.removeItem(d.STORAGE_KEY);}destroy(){this.unsubscribe(),this.clean();}};d.STORAGE_KEY="fuel-current-connector",d.defaultConfig={};var F=d;

export { F as Fuel, h as FuelConnector, f as FuelConnectorEventType, m as FuelConnectorEventTypes, A as FuelConnectorMethods, p as FuelWalletConnector, C as FuelWalletDevelopmentConnector, v as FuelWalletLocked, w as FuelWalletProvider, E as FueletWalletConnector, b as cacheFor, P as defaultConnectors, k as deferPromise, $ as dispatchFuelConnectorEvent, K as getAssetByChain, g as withTimeout };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map