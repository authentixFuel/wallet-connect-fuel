{"version":3,"sources":["../src/api.ts","../src/utils/cache.ts","../src/utils/promise.ts","../src/utils/getAssetByChain.ts","../src/utils/dispatchFuelConnectorEvent.ts","../src/FuelConnector.ts","../src/FuelWalletLocked.ts","../src/FuelWalletProvider.ts","../src/connectors/FuelWallet.ts","../src/connectors/FuelWalletDevelopment.ts","../src/connectors/FueletWallet.ts","../src/connectors/defaultConnectors.ts","../src/Fuel.ts","../src/index.ts"],"names":["FuelConnectorMethods","FuelConnectorEventTypes","FuelConnectorEventType","cacheFor","fn","cache","cacheTime","key","args","result","deferPromise","defer","resolve","reject","withTimeout","promise","timeout","timeoutPromise","_","getAssetByChain","asset","chainId","network","assetFuelNetwork","item","dispatchFuelConnectorEvent","connector","EventEmitter","FuelConnector","address","message","transaction","assets","networkUrl","contractId","abi","id","eventName","listener","WalletLocked","FuelWalletLocked","provider","transactionId","TransactionResponse","Provider","FuelWalletProvider","_FuelWalletProvider","url","options","MessageTypes","EVENT_MESSAGE","CONTENT_SCRIPT_NAME","CONNECTOR_SCRIPT","transactionRequestify","JSONRPCClient","FuelWalletConnector","name","messageFroze","event","origin","request","eventData","txRequest","assetsData","fuelNetworkAsset","n","_network","FuelWalletDevelopmentConnector","FueletWalletConnector","defaultConnectors","devMode","connectors","HAS_CONNECTOR_TIMEOUT","PING_CACHE_TIME","_Fuel","config","targetObject","handler","e","isConnected","networks","currentNetwork","accounts","currentAccount","c","connectorName","events","currentConnector","unSub","method","hasConnector","requestTimestamp","ping","_connector","installed","providerOrNetwork","Fuel"],"mappings":"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","sourcesContent":["export enum FuelConnectorMethods {\n  // General methods\n  ping = 'ping',\n  version = 'version',\n  // Connection methods\n  connect = 'connect',\n  disconnect = 'disconnect',\n  isConnected = 'isConnected',\n  // Account methods\n  accounts = 'accounts',\n  currentAccount = 'currentAccount',\n  // Signature methods\n  signMessage = 'signMessage',\n  sendTransaction = 'sendTransaction',\n  // Assets metadata methods\n  assets = 'assets',\n  addAsset = 'addAsset',\n  addAssets = 'addAssets',\n  // Network methods\n  networks = 'networks',\n  currentNetwork = 'currentNetwork',\n  addNetwork = 'addNetwork',\n  selectNetwork = 'selectNetwork',\n  // ABI methods\n  addABI = 'addABI',\n  getABI = 'getABI',\n  hasABI = 'hasABI',\n}\nexport enum FuelConnectorEventTypes {\n  connectors = 'connectors',\n  currentConnector = 'currentConnector',\n  connection = 'connection',\n  accounts = 'accounts',\n  currentAccount = 'currentAccount',\n  networks = 'networks',\n  currentNetwork = 'currentNetwork',\n  assets = 'assets',\n  abis = 'abis',\n}\nexport const FuelConnectorEventType = 'FuelConnector';\n","export type CacheFor = {\n  [key: string]: {\n    timeout: number;\n    value: unknown;\n  } | null;\n};\n\ntype CacheForOptions = {\n  key: string;\n  cache: CacheFor;\n  cacheTime: number;\n};\n\nexport function cacheFor<F extends (...args: unknown[]) => Promise<unknown>>(\n  fn: F,\n  { cache, cacheTime, key }: CacheForOptions\n): F {\n  return (async (...args: unknown[]) => {\n    if (cache[key] && cache[key]?.value) {\n      return cache[key]!.value as ReturnType<F>;\n    }\n    clearTimeout(cache[key]?.timeout);\n    const result = await fn(...args);\n\n    // Create cache auto clean\n    cache[key] = {\n      timeout: Number(\n        setTimeout(() => {\n          cache[key] = null;\n        }, cacheTime)\n      ),\n      value: result,\n    };\n\n    return result;\n  }) as F;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport type DeferPromise<R = unknown> = {\n  promise: Promise<R>;\n  resolve: (value: R) => void;\n  reject: (error: unknown) => void;\n};\n\nexport function deferPromise<R = unknown>() {\n  const defer: DeferPromise<R> = {} as any;\n\n  defer.promise = new Promise((resolve, reject) => {\n    defer.reject = reject;\n    defer.resolve = resolve;\n  });\n\n  return defer;\n}\n\nexport async function withTimeout<F extends Promise<unknown>, RT = Awaited<F>>(\n  promise: F,\n  timeout: number = 1050\n): Promise<RT> {\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new Error('Promise timed out'));\n    }, timeout);\n  });\n  return Promise.race([timeoutPromise, promise]) as any;\n}\n","import type { Asset, AssetData, AssetFuel } from '@fuel-wallet/types';\n\nexport function getAssetByChain(\n  asset: Asset,\n  chainId: number,\n  network: string = 'fuel'\n): AssetData {\n  const assetFuelNetwork = asset.networks.find(\n    (item) => item.chainId === chainId && item.type === network\n  ) as AssetFuel;\n\n  if (!assetFuelNetwork) {\n    throw new Error('Asset not found for the given chain and network.');\n  }\n\n  return {\n    ...asset,\n    assetId: assetFuelNetwork.assetId,\n    decimals: assetFuelNetwork.decimals,\n    chainId: assetFuelNetwork.chainId,\n    network: assetFuelNetwork.type,\n  };\n}\n","import type { FuelConnector } from '../FuelConnector';\nimport { FuelConnectorEventType } from '../api';\n\n/**\n * Fuel Connector Event is a custom event that can be used by the connector to\n * inform the Fuel Connector Manager that a new connector is available.\n */\nexport function dispatchFuelConnectorEvent(connector: FuelConnector) {\n  window.dispatchEvent(\n    new CustomEvent(FuelConnectorEventType, {\n      detail: connector,\n    })\n  );\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type { Asset } from '@fuel-wallet/types';\nimport EventEmitter from 'events';\nimport type { TransactionRequestLike } from 'fuels';\n\nimport { FuelConnectorEventTypes } from './api';\nimport type {\n  FuelABI,\n  FuelConnectorEvents,\n  FuelEventArg,\n  Network,\n  Version,\n  ConnectorMetadata,\n} from './types';\n\n/**\n * @name FuelConnector\n *\n * Wallet Connector is a interface that represents a Wallet Connector and all the methods\n * that should be implemented to be compatible with the Fuel SDK.\n */\nexport abstract class FuelConnector extends EventEmitter {\n  name: string = '';\n  metadata: ConnectorMetadata = {} as ConnectorMetadata;\n  connected: boolean = false;\n  installed: boolean = false;\n  events = FuelConnectorEventTypes;\n\n  /**\n   * Should return true if the connector is loaded\n   * in less then one second.\n   *\n   * @returns {true} - always true.\n   */\n  async ping(): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return the current version of the connector\n   * and the network version that is compatible.\n   *\n   * @returns {boolean} - connection status.\n   */\n  async version(): Promise<Version> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return true if the connector is connected\n   * to any of the accounts available.\n   *\n   * @returns {boolean} - connection status.\n   */\n  async isConnected(): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return all the accounts authorized for the\n   * current connection.\n   *\n   * @returns {string[]} - Accounts addresses\n   */\n  async accounts(): Promise<Array<string>> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should start the connection process and return\n   * true if the account authorize the connection.\n   *\n   * and return false if the user reject the connection.\n   *\n   * @emits accounts\n   * @returns {boolean} - connection status.\n   */\n  async connect(): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should disconnect the current connection and\n   * return false if the disconnection was successful.\n   *\n   * @emits assets connection\n   * @returns {boolean} - connection status.\n   */\n  async disconnect(): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should start the sign message process and return\n   * the signed message.\n   *\n   * @param {string} address - The address to sign the message\n   * @param {string} message - The message to sign all text will be treated as text utf-8\n   *\n   * @returns {string} - Message signature\n   */\n  async signMessage(address: string, message: string): Promise<string> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should start the send transaction process and return\n   * the transaction id submitted to the network.\n   *\n   * If the network is not available for the connection\n   * it should throw an error to avoid the transaction\n   * to be sent to the wrong network and lost.\n   *\n   * @param {string} address - The address to sign the transaction\n   * @param {Transaction} transaction - The transaction to send\n   *\n   * @returns {string} - The transaction id\n   */\n  async sendTransaction(\n    address: string,\n    transaction: TransactionRequestLike\n  ): Promise<string> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return the current account selected inside the connector, if the account\n   * is authorized for the connection.\n   *\n   * If the account is not authorized it should return null.\n   *\n   * @returns {string | null} - The current account selected or null.\n   */\n  async currentAccount(): Promise<string | null> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should add the the assets metadata to the connector and return true if the asset\n   * was added successfully.\n   *\n   * If the asset already exists it should throw an error.\n   *\n   * @emits assets\n   * @param {Asset[]} assets - The assets to add the metadata to the connection.\n   * @returns True if the asset was added successfully\n   * @throws Error if the asset already exists\n   */\n  async addAssets(assets: Array<Asset>): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should add the the asset metadata to the connector and return true if the asset\n   * was added successfully.\n   *\n   * If the asset already exists it should throw an error.\n   *\n   * @emits assets\n   * @param {Asset} asset - The asset to add the metadata to the connection.\n   * @returns True if the asset was added successfully\n   * @throws Error if the asset already exists\n   */\n  async addAsset(asset: Asset): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return all the assets added to the connector. If a connection is already established.\n   *\n   * @returns {Asset} assets - The assets metadata from the connector vinculated to the all accounts from a specific Wallet.\n   */\n  async assets(): Promise<Array<Asset>> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should start the add network process and return true if the network was added successfully.\n   *\n   * @emits networks\n   * @throws {Error} if the network already exists\n   * @returns {boolean} boolean - Return true if the network was added successfully\n   */\n  async addNetwork(networkUrl: string): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should start the select network process and return true if the network has change successfully.\n   *\n   * @emits networks\n   * @throws {Error} if the network already exists\n   * @returns {boolean} boolean - Return true if the network was added successfully\n   */\n  async selectNetwork(network: Network): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return all the networks available from the connector. If the connection is already established.\n   *\n   * @returns {Network[]} networks - Return all the networks added to the connector.\n   */\n  async networks(): Promise<Array<Network>> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return the current network selected inside the connector. Even if the connection is not established.\n   *\n   * @returns {Network} network - Return all the networks added to the connector.\n   */\n  async currentNetwork(): Promise<Network> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should add the abi to the connector and return true if the abi was added successfully.\n   *\n   * @param {FuelABI} abi - The fuel abi that represents a contract.\n   * @throws {Error} if the abi already exists\n   * @returns {boolean} - Return true if the abi was added successfully\n   */\n  async addABI(contractId: string, abi: FuelABI): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.\n   *\n   * @param {string} contractId - The contract id to get the abi\n   * @returns {FuelABI | null} abi - The fuel abi that represents a contract or script.\n   */\n  async getABI(id: string): Promise<FuelABI | null> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.\n   *\n   * @param {string} contractId - The contract id to get the abi\n   * @return {boolean} - Return true if the abi exists or false if not.\n   */\n  async hasABI(id: string): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  /**\n   * Event listener for the connector.\n   *\n   * @param {string} eventName - The event name to listen\n   * @param {function} listener - The listener function\n   */\n  on<E extends FuelConnectorEvents['type'], D extends FuelEventArg<E>>(\n    eventName: E,\n    listener: (data: D) => void\n  ): this {\n    super.on(eventName, listener);\n    return this;\n  }\n}\n","import type {\n  AbstractAddress,\n  TransactionRequestLike,\n  TransactionResponse,\n} from 'fuels';\nimport { WalletLocked } from 'fuels';\n\nimport type { FuelConnector } from './FuelConnector';\nimport type { FuelWalletProvider } from './FuelWalletProvider';\n\nexport class FuelWalletLocked extends WalletLocked {\n  connector: FuelConnector;\n  _provider: FuelWalletProvider;\n\n  constructor(\n    address: string | AbstractAddress,\n    connector: FuelConnector,\n    provider: FuelWalletProvider\n  ) {\n    super(address, provider);\n    this.connector = connector;\n    this._provider = provider;\n  }\n\n  async signMessage(message: string): Promise<string> {\n    return this.connector.signMessage(this.address.toString(), message);\n  }\n\n  async sendTransaction(\n    transaction: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionId = await this.connector.sendTransaction(\n      this.address.toString(),\n      transaction\n    );\n    return this.provider.getTransactionResponse(transactionId);\n  }\n\n  get provider(): FuelWalletProvider {\n    return this._provider;\n  }\n}\n","import type { ProviderOptions } from 'fuels';\nimport { TransactionResponse, Provider } from 'fuels';\n\n/**\n * @todo: We should add getTransactionResponse to TS-SDK in this way\n * a provider becomes self contained enabling connectors to implement\n * their on providers for customized responses.\n *\n * With the change we can remove the entire FuelWalletProvider.\n */\nexport class FuelWalletProvider extends Provider {\n  constructor(url: string, options?: ProviderOptions) {\n    super(url, options);\n  }\n\n  static async create(\n    url: string,\n    options?: ProviderOptions | undefined\n  ): Promise<FuelWalletProvider> {\n    const provider = new FuelWalletProvider(url, options);\n    await provider.fetchChainAndNodeInfo();\n    return provider;\n  }\n\n  async getTransactionResponse(\n    transactionId: string\n  ): Promise<TransactionResponse> {\n    return new TransactionResponse(transactionId, this);\n  }\n}\n","import {\n  MessageTypes,\n  EVENT_MESSAGE,\n  CONTENT_SCRIPT_NAME,\n  CONNECTOR_SCRIPT,\n} from '@fuel-wallet/types';\nimport type {\n  Asset,\n  ResponseMessage,\n  EventMessage,\n  CommunicationMessage,\n  AssetData,\n  AssetFuel,\n} from '@fuel-wallet/types';\nimport {\n  Provider,\n  transactionRequestify,\n  type TransactionRequestLike,\n} from 'fuels';\nimport type { JSONRPCRequest } from 'json-rpc-2.0';\nimport { JSONRPCClient } from 'json-rpc-2.0';\n\nimport { FuelConnector } from '../FuelConnector';\nimport { FuelConnectorEventTypes } from '../api';\nimport {\n  type ConnectorMetadata,\n  type FuelABI,\n  type Network,\n  type Version,\n} from '../types';\n\nexport class FuelWalletConnector extends FuelConnector {\n  name: string = '';\n  connected: boolean = false;\n  installed: boolean = false;\n  events = FuelConnectorEventTypes;\n  metadata: ConnectorMetadata = {\n    image: '/connectors/fuel-wallet.svg',\n    install: {\n      action: 'Install',\n      description:\n        'To connect your Fuel Wallet, install the browser extension.',\n      link: 'https://chrome.google.com/webstore/detail/fuel-wallet/dldjpboieedgcmpkchcjcbijingjcgok',\n    },\n  };\n\n  readonly client: JSONRPCClient;\n\n  constructor(name: string = 'Fuel Wallet') {\n    super();\n    this.name = name;\n    this.setMaxListeners(100);\n    this.client = new JSONRPCClient(\n      this.sendRequest.bind(this),\n      this.createRequestId\n    );\n    this.setupListener();\n    this.setupConnector();\n  }\n\n  /**\n   * ============================================================\n   * Application communication methods\n   * ============================================================\n   */\n  private async setupConnector() {\n    if (typeof window !== 'undefined') {\n      this.ping()\n        .then(() => {\n          window.dispatchEvent(\n            new CustomEvent('FuelConnector', { detail: this })\n          );\n        })\n        .catch(() => {});\n    }\n  }\n\n  private acceptMessage(message: MessageEvent<CommunicationMessage>): boolean {\n    const { data: event } = message;\n    return (\n      message.origin === window.origin &&\n      event.type !== MessageTypes.request &&\n      event.connectorName === this.name &&\n      event.target === CONNECTOR_SCRIPT\n    );\n  }\n\n  private setupListener() {\n    if (typeof window === 'undefined') return;\n    window.addEventListener(EVENT_MESSAGE, this.onMessage.bind(this));\n  }\n\n  private createRequestId(): string {\n    return crypto.randomUUID();\n  }\n\n  private postMessage(message: CommunicationMessage, origin?: string) {\n    window.postMessage(message, origin || window.origin);\n  }\n\n  private async sendRequest(request: JSONRPCRequest | null) {\n    if (!request) return;\n    this.postMessage({\n      type: MessageTypes.request,\n      target: CONTENT_SCRIPT_NAME,\n      connectorName: this.name,\n      request,\n    });\n  }\n\n  private onResponse(message: ResponseMessage): void {\n    this.client.receive(message.response);\n  }\n\n  private onEvent(message: EventMessage): void {\n    message.events.forEach((eventData) => {\n      if (eventData.event === 'start') {\n        this.setupConnector();\n      } else {\n        this.emit(eventData.event, ...eventData.params);\n      }\n    });\n  }\n\n  private onMessage = (message: MessageEvent<CommunicationMessage>) => {\n    const messageFroze = Object.freeze(message);\n    if (!this.acceptMessage(messageFroze)) return;\n    const { data: event } = messageFroze;\n    this.onCommunicationMessage(event);\n  };\n\n  private onCommunicationMessage = (message: CommunicationMessage) => {\n    switch (message.type) {\n      case MessageTypes.response:\n        this.onResponse(message);\n        break;\n      case MessageTypes.event:\n        this.onEvent(message);\n        break;\n      default:\n    }\n  };\n\n  /**\n   * ============================================================\n   * Connector methods\n   * ============================================================\n   */\n  async ping(): Promise<boolean> {\n    return this.client.timeout(800).request('ping', {});\n  }\n\n  async isConnected(): Promise<boolean> {\n    // If the wallet not exists or not connected, return false\n    try {\n      return await this.client.request('isConnected', {});\n    } catch {\n      return false;\n    }\n  }\n\n  async connect(): Promise<boolean> {\n    return this.client.request('connect', {});\n  }\n\n  async disconnect(): Promise<boolean> {\n    return this.client.request('disconnect', {});\n  }\n\n  async accounts(): Promise<Array<string>> {\n    return this.client.request('accounts', {});\n  }\n\n  async currentAccount(): Promise<string | null> {\n    return this.client.request('currentAccount', {});\n  }\n\n  async signMessage(address: string, message: string): Promise<string> {\n    if (!message.trim()) {\n      throw new Error('Message is required');\n    }\n    return this.client.request('signMessage', {\n      address,\n      message,\n    });\n  }\n\n  async sendTransaction(\n    address: string,\n    transaction: TransactionRequestLike\n  ): Promise<string> {\n    if (!transaction) {\n      throw new Error('Transaction is required');\n    }\n    // Transform transaction object to a transaction request\n    const txRequest = transactionRequestify(transaction);\n\n    /**\n     * @todo We should remove this once the chainId standard start to be used and chainId is required\n     * to be correct according to the network the transaction wants to target.\n     */\n    const network = await this.currentNetwork();\n    const provider = {\n      url: network.url,\n    };\n\n    return this.client.request('sendTransaction', {\n      address,\n      transaction: JSON.stringify(txRequest),\n      provider,\n    });\n  }\n\n  async assets(): Promise<Array<Asset>> {\n    return this.client.request('assets', {});\n  }\n\n  async addAsset(asset: Asset): Promise<boolean> {\n    return this.addAssets([asset]);\n  }\n\n  async addAssets(assets: Asset[]): Promise<boolean> {\n    /**\n     * @todo: Remove this once Fuel Wallet supports assets with multiple networks\n     */\n    const assetsData: Array<AssetData> = assets.map((asset) => {\n      const fuelNetworkAsset = asset.networks.find(\n        (n) => n.type === 'fuel'\n      ) as AssetFuel;\n      if (!fuelNetworkAsset) {\n        throw new Error('Asset for Fuel Network not found!');\n      }\n      return {\n        ...asset,\n        imageUrl: asset.icon,\n        decimals: fuelNetworkAsset.decimals,\n        assetId: fuelNetworkAsset.assetId,\n      };\n    });\n    return this.client.request('addAssets', {\n      assets: assetsData,\n    });\n  }\n\n  async addABI(contractId: string, abi: FuelABI): Promise<boolean> {\n    return this.client.request('addAbi', {\n      abiMap: {\n        [contractId]: abi,\n      },\n    });\n  }\n\n  async getABI(contractId: string): Promise<FuelABI> {\n    return this.client.request('getAbi', {\n      contractId,\n    });\n  }\n\n  async hasABI(contractId: string): Promise<boolean> {\n    const abi = await this.getABI(contractId);\n    return !!abi;\n  }\n\n  async currentNetwork(): Promise<Network> {\n    return this.client.request('network', {});\n  }\n\n  async selectNetwork(_network: Network): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  async networks(): Promise<Network[]> {\n    return this.client.request('networks', {});\n  }\n\n  async addNetwork(networkUrl: string): Promise<boolean> {\n    /**\n     * @todo: Remove fetch provider once Fuel Wallet supports adding networks\n     * by URL\n     */\n    const provider = await Provider.create(networkUrl);\n    return this.client.request('addNetwork', {\n      network: {\n        url: provider.url,\n        name: provider.getChain().name,\n      },\n    });\n  }\n\n  async version(): Promise<Version> {\n    return this.client.request('version', {\n      app: '0.0.0',\n      network: '0.0.0',\n    });\n  }\n}\n","import type { ConnectorMetadata } from '../types';\n\nimport { FuelWalletConnector } from './FuelWallet';\n\nexport class FuelWalletDevelopmentConnector extends FuelWalletConnector {\n  metadata: ConnectorMetadata = {\n    image: '/connectors/fuel-wallet-dev.svg',\n    install: {\n      action: 'Install',\n      description:\n        'To connect your Fuel Wallet, you need to install the browser extension first.',\n      link: 'https://chrome.google.com/webstore/detail/fuel-wallet-development/hcgmehahnlbhpilepakbdinkhhaackmc',\n    },\n  };\n\n  constructor() {\n    super('Fuel Wallet Development');\n  }\n}\n","import type { ConnectorMetadata } from '../types';\n\nimport { FuelWalletConnector } from './FuelWallet';\n\nexport class FueletWalletConnector extends FuelWalletConnector {\n  name = 'Fuelet Wallet';\n  metadata: ConnectorMetadata = {\n    image: {\n      light: '/connectors/fuelet-light.svg',\n      dark: '/connectors/fuelet-dark.svg',\n    },\n    install: {\n      action: 'Install',\n      description: 'Install Fuelet Wallet in order to connect it.',\n      link: 'https://fuelet.app/download/',\n    },\n  };\n\n  constructor() {\n    super('Fuelet Wallet');\n  }\n}\n","import { FuelWalletConnector } from './FuelWallet';\nimport { FuelWalletDevelopmentConnector } from './FuelWalletDevelopment';\nimport { FueletWalletConnector } from './FueletWallet';\n\ntype DefaultConnectors = {\n  devMode?: boolean;\n};\n\nexport function defaultConnectors({ devMode }: DefaultConnectors = {}) {\n  const connectors = [new FuelWalletConnector(), new FueletWalletConnector()];\n  if (devMode) {\n    connectors.push(new FuelWalletDevelopmentConnector());\n  }\n  return connectors;\n}\n","import type { AbstractAddress } from 'fuels';\n\nimport { FuelConnector } from './FuelConnector';\nimport { FuelWalletLocked } from './FuelWalletLocked';\nimport { FuelWalletProvider } from './FuelWalletProvider';\nimport {\n  FuelConnectorEventType,\n  FuelConnectorEventTypes,\n  FuelConnectorMethods,\n} from './api';\nimport { defaultConnectors } from './connectors';\nimport type {\n  FuelConnectorEventsType,\n  FuelStorage,\n  Network,\n  TargetObject,\n} from './types';\nimport type { CacheFor } from './utils';\nimport { cacheFor, deferPromise, withTimeout } from './utils';\n\n// This is the time to wait for the connector\n// to be available before returning false for hasConnector.\nconst HAS_CONNECTOR_TIMEOUT = 2_000;\n// The time to cache the ping result, as is not\n// expected to change the availability of the connector to\n// change too often we can safely cache the result for 5 seconds\n// at minimum.\nconst PING_CACHE_TIME = 5_000;\n\nexport type FuelConfig = {\n  connectors?: Array<FuelConnector>;\n  storage?: FuelStorage | null;\n  targetObject?: TargetObject;\n  devMode?: boolean;\n};\n\nexport type FuelConnectorSelectOptions = {\n  emitEvents?: boolean;\n};\n\nexport class Fuel extends FuelConnector {\n  static STORAGE_KEY = 'fuel-current-connector';\n  static defaultConfig: FuelConfig = {};\n  private _storage?: FuelStorage | null = null;\n  private _connectors: Array<FuelConnector> = [];\n  private _targetObject: TargetObject | null = null;\n  private _unsubscribes: Array<() => void> = [];\n  private _targetUnsubscribe: () => void;\n  private _pingCache: CacheFor = {};\n  private _currentConnector?: FuelConnector | null;\n\n  constructor(config: FuelConfig = Fuel.defaultConfig) {\n    super();\n    // Increase the limit of listeners\n    this.setMaxListeners(1_000);\n    // Set all connectors\n    this._connectors =\n      config.connectors ??\n      defaultConnectors({\n        devMode: config.devMode,\n      });\n    // Set the target object to listen for global events\n    this._targetObject = this.getTargetObject(config.targetObject);\n    // Set default storage\n    this._storage =\n      config.storage === undefined ? this.getStorage() : config.storage;\n    // Setup all methods\n    this.setupMethods();\n    // Get the current connector from the storage\n    this.setDefaultConnector();\n    // Setup new connector listener for global events\n    this._targetUnsubscribe = this.setupConnectorListener();\n  }\n\n  /**\n   * Return the target object to listen for global events.\n   */\n  private getTargetObject(targetObject?: TargetObject) {\n    if (targetObject) return targetObject;\n    if (typeof window !== 'undefined') return window;\n    if (typeof document !== 'undefined') return document;\n    return null;\n  }\n\n  /**\n   * Return the storage used.\n   */\n  private getStorage() {\n    if (typeof window !== 'undefined') return window.localStorage;\n    return undefined;\n  }\n\n  /**\n   * Setup the default connector from the storage.\n   */\n  private setDefaultConnector() {\n    const connectorName =\n      this._storage?.getItem(Fuel.STORAGE_KEY) || this._connectors[0]?.name;\n    if (connectorName) {\n      // Setup all events for the current connector\n      return this.selectConnector(connectorName, {\n        emitEvents: false,\n      });\n    }\n  }\n\n  /**\n   * Start listener for all the events of the current\n   * connector and emit them to the Fuel instance\n   */\n  private setupConnectorEvents(events: string[]) {\n    if (!this._currentConnector) return;\n    const currentConnector = this._currentConnector;\n    this._unsubscribes.map((unSub) => unSub());\n    this._unsubscribes = events.map((event) => {\n      const handler = (...args: unknown[]) => this.emit(event, ...args);\n      currentConnector.on(event as FuelConnectorEventsType, handler);\n      return () => currentConnector.off(event, handler);\n    });\n  }\n\n  /**\n   * Call method from the current connector.\n   */\n  private async callMethod(method: string, ...args: unknown[]) {\n    const hasConnector = await this.hasConnector();\n    await this.pingConnector();\n    if (!this._currentConnector || !hasConnector) {\n      throw new Error(\n        `No connector selected for calling ${method}. Use hasConnector before executing other methods.`\n      );\n    }\n    if (typeof this._currentConnector[method] === 'function') {\n      return this._currentConnector[method](...args);\n    } else {\n      new Error(`Method ${method} is not available for the connector.`);\n    }\n  }\n\n  /**\n   * Create a method for each method proxy that is available on the Common interface\n   * and call the method from the current connector.\n   */\n  private setupMethods() {\n    Object.values(FuelConnectorMethods).map((method) => {\n      this[method] = async (...args: unknown[]) =>\n        this.callMethod(method, ...args);\n    });\n  }\n\n  /**\n   * Fetch the status of a connector and set the installed and connected\n   * status.\n   */\n  private async fetchConnectorStatus(\n    connector: FuelConnector & { _latestUpdate?: number }\n  ) {\n    // Control fetch status to avoid rewriting the status\n    // on late responses in this way even if a response is\n    // late we can avoid rewriting the status of the connector\n    const requestTimestamp = Date.now();\n    const [isConnected, ping] = await Promise.allSettled([\n      withTimeout(connector.isConnected()),\n      withTimeout(this.pingConnector(connector)),\n    ]);\n    // If the requestTimestamp is greater than the latest update\n    // we can ignore the response as is treated as stale.\n    const isStale = requestTimestamp < (connector._latestUpdate || 0);\n    if (!isStale) {\n      connector._latestUpdate = Date.now();\n      connector.installed = ping.status === 'fulfilled' && ping.value;\n      connector.connected =\n        isConnected.status === 'fulfilled' && isConnected.value;\n    }\n    return {\n      installed: connector.installed,\n      connected: connector.connected,\n    };\n  }\n\n  /**\n   * Fetch the status of all connectors and set the installed and connected\n   * status.\n   */\n  private async fetchConnectorsStatus() {\n    return Promise.all(\n      this._connectors.map(async (connector) => {\n        return this.fetchConnectorStatus(connector);\n      })\n    );\n  }\n\n  /**\n   * Fetch the status of a connector and set the installed and connected\n   * status. If no connector is provided it will ping the current connector.\n   */\n  private async pingConnector(connector?: FuelConnector) {\n    const { _currentConnector: currentConnector } = this;\n    const _connector = connector ?? currentConnector;\n    if (!_connector) return false;\n    // If finds a ping in the cache and the value is true\n    // return from cache\n    try {\n      return await cacheFor(\n        async () => {\n          return withTimeout(_connector.ping());\n        },\n        {\n          key: _connector.name,\n          cache: this._pingCache,\n          cacheTime: PING_CACHE_TIME,\n        }\n      )();\n    } catch {\n      throw new Error('Current connector is not available.');\n    }\n  }\n\n  /**\n   * Setup a listener for the FuelConnector event and add the connector\n   * to the list of new connectors.\n   */\n  private setupConnectorListener = () => {\n    const { _targetObject: targetObject } = this;\n    const eventName = FuelConnectorEventType;\n    if (targetObject?.on) {\n      targetObject.on(eventName, this.addConnector);\n      return () => {\n        targetObject.off?.(eventName, this.addConnector);\n      };\n    }\n    if (targetObject?.addEventListener) {\n      const handler = (e: CustomEvent<FuelConnector>) => {\n        this.addConnector(e.detail);\n      };\n      targetObject.addEventListener(eventName, handler);\n      return () => {\n        targetObject.removeEventListener?.(eventName, handler);\n      };\n    }\n    return () => {};\n  };\n\n  /**\n   * Add a new connector to the list of connectors.\n   */\n  private addConnector = async (connector: FuelConnector) => {\n    if (!this.getConnector(connector)) {\n      this._connectors.push(connector);\n    }\n    // Fetch the status of the new connector\n    await this.fetchConnectorStatus(connector);\n    // Emit connectors events once the connector list changes\n    this.emit(this.events.connectors, this._connectors);\n    // If the current connector is not set\n    if (!this._currentConnector) {\n      // set the new connector as currentConnector\n      await this.selectConnector(connector.name, {\n        emitEvents: false,\n      });\n    }\n  };\n\n  private triggerConnectorEvents = async () => {\n    const [isConnected, networks, currentNetwork] = await Promise.all([\n      this.isConnected(),\n      this.networks(),\n      this.currentNetwork(),\n    ]);\n    this.emit(this.events.connection, isConnected);\n    this.emit(this.events.networks, networks);\n    this.emit(this.events.currentNetwork, currentNetwork);\n    if (isConnected) {\n      const [accounts, currentAccount] = await Promise.all([\n        this.accounts(),\n        this.currentAccount(),\n      ]);\n      this.emit(this.events.accounts, accounts);\n      this.emit(this.events.currentAccount, currentAccount);\n    }\n  };\n\n  /**\n   * Get a connector from the list of connectors.\n   */\n  getConnector = (connector: FuelConnector | string): FuelConnector | null => {\n    return (\n      this._connectors.find((c) => {\n        const connectorName =\n          typeof connector === 'string' ? connector : connector.name;\n        return c.name === connectorName || c === connector;\n      }) || null\n    );\n  };\n\n  /**\n   * Return the list of connectors with the status of installed and connected.\n   */\n  async connectors(): Promise<Array<FuelConnector>> {\n    await this.fetchConnectorsStatus();\n    return this._connectors;\n  }\n\n  /**\n   * Set the current connector to be used.\n   */\n  async selectConnector(\n    connectorName: string,\n    options: FuelConnectorSelectOptions = {\n      emitEvents: true,\n    }\n  ): Promise<boolean> {\n    const connector = this.getConnector(connectorName);\n    if (!connector) return false;\n    if (this._currentConnector?.name === connectorName) return true;\n    const { installed } = await this.fetchConnectorStatus(connector);\n    if (installed) {\n      this._currentConnector = connector;\n      this.emit(this.events.currentConnector, connector);\n      this.setupConnectorEvents(Object.values(FuelConnectorEventTypes));\n      this._storage?.setItem(Fuel.STORAGE_KEY, connector.name);\n      // If emitEvents is true we query all the data from the connector\n      // and emit the events to the Fuel instance allowing the application to\n      // react to changes in the connector state.\n      if (options.emitEvents) {\n        this.triggerConnectorEvents();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Return the current selected connector.\n   */\n  currentConnector() {\n    return this._currentConnector;\n  }\n\n  /**\n   * Return true if any connector is available.\n   */\n  async hasConnector(): Promise<boolean> {\n    // If there is a current connector return true\n    // as the connector is ready\n    if (this._currentConnector) return true;\n    // If there is no current connector\n    // wait for the current connector to be set\n    // for 1 second and return false if is not set\n    const defer = deferPromise<boolean>();\n    this.once(this.events.currentConnector, () => {\n      defer.resolve(true);\n    });\n    // As the max ping time is 1 second we wait for 2 seconds\n    // to allow applications to react to the current connector\n    return withTimeout(defer.promise, HAS_CONNECTOR_TIMEOUT)\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  async hasWallet(): Promise<boolean> {\n    return this.hasConnector();\n  }\n\n  /**\n   * Return a Fuel Provider instance with extends features to work with\n   * connectors.\n   *\n   * @deprecated Provider is going to be deprecated in the future.\n   */\n  async getProvider(\n    providerOrNetwork?: FuelWalletProvider | Network\n  ): Promise<FuelWalletProvider> {\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Get provider is deprecated, use getWallet instead. Provider is going to be removed in the future.'\n      );\n    }\n    return this._getProvider(providerOrNetwork);\n  }\n\n  /**\n   * Return a Fuel Provider instance with extends features to work with\n   * connectors.\n   */\n  private async _getProvider(\n    providerOrNetwork?: FuelWalletProvider | Network\n  ): Promise<FuelWalletProvider> {\n    // Decide which provider to use based on the providerOrNetwork\n    let provider: FuelWalletProvider;\n    // If provider is a valid instance of a Provider use it\n    if (providerOrNetwork && 'getTransactionResponse' in providerOrNetwork) {\n      provider = providerOrNetwork;\n      // If the provided param is a valid network use it\n    } else if (\n      providerOrNetwork &&\n      'chainId' in providerOrNetwork &&\n      'url' in providerOrNetwork\n    ) {\n      provider = await FuelWalletProvider.create(providerOrNetwork.url);\n      // If nor provider or network is provided use the current network\n    } else if (!providerOrNetwork) {\n      const currentNetwork = await this.currentNetwork();\n      provider = await FuelWalletProvider.create(currentNetwork.url);\n      // If a provider or network was informed but is not valid\n      // throw an error\n    } else {\n      throw new Error('Provider is not valid.');\n    }\n    return provider;\n  }\n\n  /**\n   * Return a Fuel Wallet Locked instance with extends features to work with\n   * connectors.\n   */\n  async getWallet(\n    address: string | AbstractAddress,\n    providerOrNetwork?: FuelWalletProvider | Network\n  ): Promise<FuelWalletLocked> {\n    const provider = await this._getProvider(providerOrNetwork);\n    return new FuelWalletLocked(address, this, provider);\n  }\n\n  /**\n   * Remove all open listeners this is useful when you want to\n   * remove the Fuel instance and avoid memory leaks.\n   */\n  unsubscribe() {\n    // Unsubscribe from all events\n    this._unsubscribes.map((unSub) => unSub());\n    this._targetUnsubscribe();\n    // Remove all listeners from fuel instance\n    this.removeAllListeners();\n  }\n\n  /**\n   * Clean all the data from the storage.\n   */\n  clean() {\n    this._storage?.removeItem(Fuel.STORAGE_KEY);\n  }\n\n  /**\n   * Removes all listeners and cleans the storage.\n   */\n  destroy() {\n    this.unsubscribe();\n    this.clean();\n  }\n}\n","export * from './api';\nexport * from './types';\nexport * from './utils';\nexport * from './Fuel';\nexport * from './FuelConnector';\nexport * from './FuelWalletProvider';\nexport * from './FuelWalletLocked';\nexport * from './connectors';\nexport * from '@fuel-wallet/types';\n"]}