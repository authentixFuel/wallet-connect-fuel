import type { BytesLike } from '@fuel-ts/interfaces';
export type DynamicData = {
    [pointerIndex: number]: Uint8ArrayWithDynamicData;
};
export type Uint8ArrayWithDynamicData = Uint8Array & {
    dynamicData?: DynamicData;
};
export declare const BASE_VECTOR_OFFSET: number;
export declare const BASE_RAW_SLICE_OFFSET: number;
export declare function concatWithDynamicData(items: ReadonlyArray<BytesLike>): Uint8ArrayWithDynamicData;
export declare function unpackDynamicData(results: Uint8ArrayWithDynamicData, baseOffset: number, dataOffset: number): Uint8Array;
/**
 * Turns:
  Uint8Array(24) [
    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 24
  ]

  Into:
  Array [
    Uint8Array(8) [
      0, 0, 0, 0, 0, 0, 0, 1
    ],
    Uint8Array(8) [
      0, 0, 0, 0, 0, 0, 0, 2
    ],
    Uint8Array(8) [
      0, 0, 0, 0, 0, 0, 0, 24
    ]
  ]
 *
 */
export declare const chunkByLength: (data: Uint8Array, length?: number) => Uint8Array[];
/**
 * Checks if a given type is a pointer type
 * See: https://github.com/FuelLabs/sway/issues/1368
 */
export declare const isPointerType: (type: string) => boolean;
export declare const isHeapType: (type: string) => boolean;
export declare function findOrThrow<T>(arr: readonly T[], predicate: (val: T) => boolean, throwFn?: () => never): T;
/**
 * Because some properties can be single-bytes, we need to pad them
 * with zeros until they are aligned to a word-sized increment.
 * This is the case for `tuple` and `struct` properties.
 * Please refer to packages/abi-coder/src/coders/abstract-coder.ts for more details
 */
export declare const isMultipleOfWordSize: (length: number) => boolean;
export declare const getWordSizePadding: (length: number) => number;
export declare const rightPadToWordSize: (encoded: Uint8Array) => Uint8Array;
//# sourceMappingURL=utilities.d.ts.map