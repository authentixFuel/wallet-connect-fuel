import { AbstractAddress } from '@fuel-ts/interfaces';
import type { Bech32Address, B256Address, EvmAddress, AssetId } from '@fuel-ts/interfaces';
/**
 * `Address` provides a type safe wrapper for converting between different address formats
 * ands comparing them for equality.
 */
export default class Address extends AbstractAddress {
    readonly bech32Address: Bech32Address;
    /**
     * @param address - A Bech32 address
     */
    constructor(address: Bech32Address);
    /**
     * Returns the `bech32Address` property
     *
     * @returns The `bech32Address` property
     */
    toAddress(): Bech32Address;
    /**
     * Converts and returns the `bech32Address` property to a 256 bit hash string
     *
     * @returns The `bech32Address` property as a 256 bit hash string
     */
    toB256(): B256Address;
    /**
     * Converts and returns the `bech32Address` property to a byte array
     *
     * @returns The `bech32Address` property as a byte array
     */
    toBytes(): Uint8Array;
    /**
     * Converts
     *
     * @returns The `bech32Address` property as a 256 bit hash string
     */
    toHexString(): B256Address;
    /**
     * Converts and returns the `bech32Address` property as a string
     *
     * @returns The `bech32Address` property as a string
     */
    toString(): string;
    /**
     * Converts and returns the `bech32Address` property as a string
     *
     * @returns The `bech32Address` property as a string
     */
    toJSON(): string;
    /**
     * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`
     *
     * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}
     */
    toEvmAddress(): EvmAddress;
    /**
     * Wraps the `bech32Address` property and returns as an `AssetId`.
     *
     * @returns The `bech32Address` property as an {@link AssetId | `AssetId`}
     */
    toAssetId(): AssetId;
    /**
     * Returns the value of the `bech32Address` property
     *
     * @returns The value of `bech32Address` property
     */
    valueOf(): string;
    /**
     * Compares this the `bech32Address` property to another for direct equality
     *
     * @param other - Another address to compare against
     * @returns The equality of the comparison
     */
    equals(other: Address): boolean;
    /**
     * Takes a Public Key, hashes it, and creates an `Address`
     *
     * @param publicKey - A wallets public key
     * @returns A new `Address` instance
     */
    static fromPublicKey(publicKey: string): Address;
    /**
     * Takes a B256 Address and creates an `Address`
     *
     * @param b256Address - A b256 hash
     * @returns A new `Address` instance
     */
    static fromB256(b256Address: string): Address;
    /**
     * Creates an `Address` with a randomized `bech32Address` property
     *
     * @returns A new `Address` instance
     */
    static fromRandom(): Address;
    /**
     * Takes an ambiguous string and attempts to create an `Address`
     *
     * @param address - An ambiguous string
     * @returns A new `Address` instance
     */
    static fromString(address: string): Address;
    /**
     * Takes an ambiguous string or address and creates an `Address`
     *
     * @returns a new `Address` instance
     */
    static fromAddressOrString(address: string | AbstractAddress): AbstractAddress;
    /**
     * Takes a dynamic string or `AbstractAddress` and creates an `Address`
     *
     * @param addressId - A string containing Bech32, B256, or Public Key
     * @throws Error - Unknown address if the format is not recognised
     * @returns A new `Address` instance
     */
    static fromDynamicInput(address: string | AbstractAddress): Address;
    /**
     * Takes an Evm Address and returns back an `Address`
     *
     * @returns A new `Address` instance
     */
    static fromEvmAddress(evmAddress: string): Address;
}
//# sourceMappingURL=address.d.ts.map