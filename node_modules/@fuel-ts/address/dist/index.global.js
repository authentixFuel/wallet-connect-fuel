"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js
  var require_dist = __commonJS({
    "../../node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bech32m = exports.bech32 = void 0;
      var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      var ALPHABET_MAP = {};
      for (let z = 0; z < ALPHABET.length; z++) {
        const x = ALPHABET.charAt(z);
        ALPHABET_MAP[x] = z;
      }
      function polymodStep(pre) {
        const b = pre >> 25;
        return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
      }
      function prefixChk(prefix) {
        let chk = 1;
        for (let i = 0; i < prefix.length; ++i) {
          const c = prefix.charCodeAt(i);
          if (c < 33 || c > 126)
            return "Invalid prefix (" + prefix + ")";
          chk = polymodStep(chk) ^ c >> 5;
        }
        chk = polymodStep(chk);
        for (let i = 0; i < prefix.length; ++i) {
          const v = prefix.charCodeAt(i);
          chk = polymodStep(chk) ^ v & 31;
        }
        return chk;
      }
      function convert(data, inBits, outBits, pad) {
        let value = 0;
        let bits = 0;
        const maxV = (1 << outBits) - 1;
        const result = [];
        for (let i = 0; i < data.length; ++i) {
          value = value << inBits | data[i];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push(value >> bits & maxV);
          }
        }
        if (pad) {
          if (bits > 0) {
            result.push(value << outBits - bits & maxV);
          }
        } else {
          if (bits >= inBits)
            return "Excess padding";
          if (value << outBits - bits & maxV)
            return "Non-zero padding";
        }
        return result;
      }
      function toWords(bytes2) {
        return convert(bytes2, 8, 5, true);
      }
      function fromWordsUnsafe(words) {
        const res = convert(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
      }
      function fromWords(words) {
        const res = convert(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      function getLibraryFromEncoding(encoding) {
        let ENCODING_CONST;
        if (encoding === "bech32") {
          ENCODING_CONST = 1;
        } else {
          ENCODING_CONST = 734539939;
        }
        function encode(prefix, words, LIMIT) {
          LIMIT = LIMIT || 90;
          if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError("Exceeds length limit");
          prefix = prefix.toLowerCase();
          let chk = prefixChk(prefix);
          if (typeof chk === "string")
            throw new Error(chk);
          let result = prefix + "1";
          for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
              throw new Error("Non 5-bit word");
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
          }
          for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
          }
          chk ^= ENCODING_CONST;
          for (let i = 0; i < 6; ++i) {
            const v = chk >> (5 - i) * 5 & 31;
            result += ALPHABET.charAt(v);
          }
          return result;
        }
        function __decode(str, LIMIT) {
          LIMIT = LIMIT || 90;
          if (str.length < 8)
            return str + " too short";
          if (str.length > LIMIT)
            return "Exceeds length limit";
          const lowered = str.toLowerCase();
          const uppered = str.toUpperCase();
          if (str !== lowered && str !== uppered)
            return "Mixed-case string " + str;
          str = lowered;
          const split2 = str.lastIndexOf("1");
          if (split2 === -1)
            return "No separator character for " + str;
          if (split2 === 0)
            return "Missing prefix for " + str;
          const prefix = str.slice(0, split2);
          const wordChars = str.slice(split2 + 1);
          if (wordChars.length < 6)
            return "Data too short";
          let chk = prefixChk(prefix);
          if (typeof chk === "string")
            return chk;
          const words = [];
          for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === void 0)
              return "Unknown character " + c;
            chk = polymodStep(chk) ^ v;
            if (i + 6 >= wordChars.length)
              continue;
            words.push(v);
          }
          if (chk !== ENCODING_CONST)
            return "Invalid checksum for " + str;
          return { prefix, words };
        }
        function decodeUnsafe(str, LIMIT) {
          const res = __decode(str, LIMIT);
          if (typeof res === "object")
            return res;
        }
        function decode(str, LIMIT) {
          const res = __decode(str, LIMIT);
          if (typeof res === "object")
            return res;
          throw new Error(res);
        }
        return {
          decodeUnsafe,
          decode,
          encode,
          toWords,
          fromWordsUnsafe,
          fromWords
        };
      }
      exports.bech32 = getLibraryFromEncoding("bech32");
      exports.bech32m = getLibraryFromEncoding("bech32m");
    }
  });

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  function bytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/utils.js
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  function isBytes2(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!isBytes2(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var toStr = {}.toString;
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  var SHA2 = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha256.js
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash(hash2);
      const key = toBytes(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists(this);
      bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
  hmac.create = (hash2, key) => new HMAC(hash2, key);

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/pbkdf2.js
  function pbkdf2Init(hash2, _password, _salt, _opts) {
    hash(hash2);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    number(c);
    number(dkLen);
    number(asyncTick);
    if (c < 1)
      throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = toBytes(_password);
    const salt = toBytes(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash2, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    u.fill(0);
    return DK;
  }
  function pbkdf2(hash2, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/scrypt.js
  var rotl = (a, b) => a << b | a >>> 32 - b;
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i = 0; i < 8; i += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
      out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
      XorAndSalsa(out, tail, input, ii, out, head);
      if (i > 0)
        tail += 16;
      XorAndSalsa(out, head, input, ii += 16, out, tail);
    }
  }
  function scryptInit(password, salt, _opts) {
    const opts = checkOpts({
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    number(N);
    number(r);
    number(p);
    number(dkLen);
    number(asyncTick);
    number(maxmem);
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error("progressCb should be function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
      throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
    }
    if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
      throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    }
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
      throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    }
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
      throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    }
    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    const V = u32(new Uint8Array(blockSize * N));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => {
    };
    if (onProgress) {
      const totalBlockMix = 2 * N * p;
      const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
      let blockMixCnt = 0;
      blockMixCb = () => {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
          onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
  }
  function scrypt(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
      const Pi = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi + i];
      for (let i = 0, pos = 0; i < N - 1; i++) {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      }
      BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
      blockMixCb();
      for (let i = 0; i < N; i++) {
        const j = B32[Pi + blockSize32 - 16] % N;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi, r);
        blockMixCb();
      }
    }
    return scryptOutput(password, dkLen, B, V, tmp);
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;

  // ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha3.js
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _256n = /* @__PURE__ */ BigInt(256);
  var _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var Keccak = class extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists(this);
      const { blockLen, state } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
  var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

  // ../versions/dist/index.mjs
  function getBuiltinVersions() {
    return {
      FORC: "0.49.3",
      FUEL_CORE: "0.22.1",
      FUELS: "0.79.0"
    };
  }
  var versions = getBuiltinVersions();

  // ../errors/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
    ErrorCode2["NO_ABIS_FOUND"] = "no-abis-found";
    ErrorCode2["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
    ErrorCode2["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
    ErrorCode2["INVALID_COMPONENT"] = "invalid-component";
    ErrorCode2["FRAGMENT_NOT_FOUND"] = "fragment-not-found";
    ErrorCode2["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
    ErrorCode2["TYPE_NOT_FOUND"] = "type-not-found";
    ErrorCode2["TYPE_NOT_SUPPORTED"] = "type-not-supported";
    ErrorCode2["INVALID_DECODE_VALUE"] = "invalid-decode-value";
    ErrorCode2["JSON_ABI_ERROR"] = "json-abi-error";
    ErrorCode2["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
    ErrorCode2["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
    ErrorCode2["CODER_NOT_FOUND"] = "coder-not-found";
    ErrorCode2["INVALID_DATA"] = "invalid-data";
    ErrorCode2["FUNCTION_NOT_FOUND"] = "function-not-found";
    ErrorCode2["UNSUPPORTED_ENCODING_VERSION"] = "unsupported-encoding-version";
    ErrorCode2["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
    ErrorCode2["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
    ErrorCode2["INVALID_B256_ADDRESS"] = "invalid-b256-address";
    ErrorCode2["INVALID_URL"] = "invalid-url";
    ErrorCode2["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
    ErrorCode2["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
    ErrorCode2["MISSING_PROVIDER"] = "missing-provider";
    ErrorCode2["INVALID_PROVIDER"] = "invalid-provider";
    ErrorCode2["CONNECTION_REFUSED"] = "connection-refused";
    ErrorCode2["INVALID_PUBLIC_KEY"] = "invalid-public-key";
    ErrorCode2["INSUFFICIENT_BALANCE"] = "insufficient-balance";
    ErrorCode2["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
    ErrorCode2["HD_WALLET_ERROR"] = "hd-wallet-error";
    ErrorCode2["MISSING_CONNECTOR"] = "missing-connector";
    ErrorCode2["PARSE_FAILED"] = "parse-failed";
    ErrorCode2["ENCODE_ERROR"] = "encode-error";
    ErrorCode2["DECODE_ERROR"] = "decode-error";
    ErrorCode2["INVALID_CREDENTIALS"] = "invalid-credentials";
    ErrorCode2["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
    ErrorCode2["INVALID_TTL"] = "invalid-ttl";
    ErrorCode2["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
    ErrorCode2["NOT_IMPLEMENTED"] = "not-implemented";
    ErrorCode2["NOT_SUPPORTED"] = "not-supported";
    ErrorCode2["CONVERTING_FAILED"] = "converting-error";
    ErrorCode2["ELEMENT_NOT_FOUND"] = "element-not-found";
    ErrorCode2["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
    ErrorCode2["INVALID_REQUEST"] = "invalid-request";
    ErrorCode2["UNEXPECTED_HEX_VALUE"] = "unexpected-hex-value";
    ErrorCode2["INVALID_TRANSFER_AMOUNT"] = "invalid-transfer-amount";
    ErrorCode2["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
    ErrorCode2["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
    ErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
    ErrorCode2["TRANSACTION_FAILED"] = "transaction-failed";
    ErrorCode2["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
    ErrorCode2["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
    ErrorCode2["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
    ErrorCode2["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
    ErrorCode2["INVALID_TRANSACTION_TYPE"] = "invalid-transaction-type";
    ErrorCode2["TRANSACTION_ERROR"] = "transaction-error";
    ErrorCode2["INVALID_POLICY_TYPE"] = "invalid-policy-type";
    ErrorCode2["DUPLICATED_POLICY"] = "duplicated-policy";
    ErrorCode2["TRANSACTION_SQUEEZED_OUT"] = "transaction-squeezed-out";
    ErrorCode2["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
    ErrorCode2["INVALID_WORD_LIST"] = "invalid-word-list";
    ErrorCode2["INVALID_MNEMONIC"] = "invalid-mnemonic";
    ErrorCode2["INVALID_ENTROPY"] = "invalid-entropy";
    ErrorCode2["INVALID_SEED"] = "invalid-seed";
    ErrorCode2["INVALID_CHECKSUM"] = "invalid-checksum";
    ErrorCode2["INVALID_PASSWORD"] = "invalid-password";
    ErrorCode2["ACCOUNT_REQUIRED"] = "account-required";
    ErrorCode2["UNLOCKED_WALLET_REQUIRED"] = "unlocked-wallet-required";
    ErrorCode2["LATEST_BLOCK_UNAVAILABLE"] = "latest-block-unavailable";
    ErrorCode2["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
    ErrorCode2["UNSUPPORTED_FUEL_CLIENT_VERSION"] = "unsupported-fuel-client-version";
    ErrorCode2["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
    ErrorCode2["INVALID_MULTICALL"] = "invalid-multicall";
    ErrorCode2["SCRIPT_REVERTED"] = "script-reverted";
    ErrorCode2["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
    ErrorCode2["STREAM_PARSING_ERROR"] = "stream-parsing-error";
    return ErrorCode2;
  })(ErrorCode || {});
  var _FuelError = class extends Error {
    VERSIONS = versions;
    static parse(e) {
      const error = e;
      if (error.code === void 0) {
        throw new _FuelError(
          "parse-failed",
          "Failed to parse the error object. The required 'code' property is missing."
        );
      }
      const enumValues = Object.values(ErrorCode);
      const codeIsKnown = enumValues.includes(error.code);
      if (!codeIsKnown) {
        throw new _FuelError(
          "parse-failed",
          `Unknown error code: ${error.code}. Accepted codes: ${enumValues.join(", ")}.`
        );
      }
      return new _FuelError(error.code, error.message);
    }
    code;
    constructor(code, message) {
      super(message);
      this.code = code;
      this.name = "FuelError";
    }
    toObject() {
      const { code, name, message, VERSIONS } = this;
      return { code, name, message, VERSIONS };
    }
  };
  var FuelError = _FuelError;
  __publicField(FuelError, "CODES", ErrorCode);

  // ../utils/dist/index.mjs
  var __defProp3 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var arrayify = (value) => {
    if (value instanceof Uint8Array) {
      return new Uint8Array(value);
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    throw new FuelError(ErrorCode.PARSE_FAILED, "invalid BytesLike value");
  };
  var HexCharacters = "0123456789abcdef";
  function hexlify(data) {
    const bytes2 = arrayify(data);
    let result = "0x";
    for (let i = 0; i < bytes2.length; i++) {
      const v = bytes2[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  var TAI64_LEAP_SECONDS = 37;
  var TAI64_UNIX_OFFSET = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);
  var msToSeconds = (ms) => Math.floor(ms / 1e3);
  var secondsToMs = (seconds) => seconds * 1e3;
  var tai64ToUnixSeconds = (tai64) => Number(BigInt(tai64) - TAI64_UNIX_OFFSET);
  var unixSecondsToTai64 = (unixSeconds) => String(BigInt(unixSeconds) + TAI64_UNIX_OFFSET);
  var tai64ToUnixMilliseconds = (tai64) => secondsToMs(tai64ToUnixSeconds(tai64));
  var _DateTime = class extends Date {
    /**
     * Generates a new DateTime instance from a Tai64 timestamp.
     *
     * @param tai64 - Tai64 timestamp
     * @returns a new DateTime instance
     */
    static fromTai64(tai64) {
      return new _DateTime(tai64ToUnixMilliseconds(tai64));
    }
    /**
     * @param unixMilliseconds - unix milliseconds timestamp
     * @returns a new DateTime instance
     */
    static fromUnixMilliseconds(unixMilliseconds) {
      return new _DateTime(unixMilliseconds);
    }
    /**
     * @param unixSeconds - unix seconds timestamp
     * @returns a new DateTime instance
     */
    static fromUnixSeconds(unixSeconds) {
      return new _DateTime(secondsToMs(unixSeconds));
    }
    /**
     * Hide the constructor to prevent direct instantiation.
     */
    constructor(date) {
      super(date);
    }
    /**
     * Returns the Tai64 timestamp.
     *
     * @returns the Tai64 timestamp
     */
    toTai64() {
      return unixSecondsToTai64(this.toUnixSeconds());
    }
    /**
     * @returns the unix milliseconds timestamp
     */
    toUnixMilliseconds() {
      return this.getTime();
    }
    /**
     * @returns the unix seconds timestamp
     */
    toUnixSeconds() {
      return msToSeconds(this.getTime());
    }
  };
  var DateTime = _DateTime;
  __publicField2(DateTime, "TAI64_NULL", "");

  // ../crypto/dist/index.mjs
  var import_crypto4 = __toESM(__require("crypto"), 1);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/_version.js
  var version = "6.7.1";

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/properties.js
  function checkType(value, type, name) {
    const types = type.split("|").map((t) => t.trim());
    for (let i = 0; i < types.length; i++) {
      switch (type) {
        case "any":
          return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          if (typeof value === type) {
            return;
          }
      }
    }
    const error = new Error(`invalid value for type ${type}`);
    error.code = "INVALID_ARGUMENT";
    error.argument = `value.${name}`;
    error.value = value;
    throw error;
  }
  function defineProperties(target, values, types) {
    for (let key in values) {
      let value = values[key];
      const type = types ? types[key] : null;
      if (type) {
        checkType(value, type, key);
      }
      Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/errors.js
  function stringify(value) {
    if (value == null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return "[ " + value.map(stringify).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
      const HEX = "0123456789abcdef";
      let result = "0x";
      for (let i = 0; i < value.length; i++) {
        result += HEX[value[i] >> 4];
        result += HEX[value[i] & 15];
      }
      return result;
    }
    if (typeof value === "object" && typeof value.toJSON === "function") {
      return stringify(value.toJSON());
    }
    switch (typeof value) {
      case "boolean":
      case "symbol":
        return value.toString();
      case "bigint":
        return BigInt(value).toString();
      case "number":
        return value.toString();
      case "string":
        return JSON.stringify(value);
      case "object": {
        const keys = Object.keys(value);
        keys.sort();
        return "{ " + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
      }
    }
    return `[ COULD NOT SERIALIZE ]`;
  }
  function makeError(message, code, info) {
    {
      const details = [];
      if (info) {
        if ("message" in info || "code" in info || "name" in info) {
          throw new Error(`value will overwrite populated values: ${stringify(info)}`);
        }
        for (const key in info) {
          const value = info[key];
          details.push(key + "=" + stringify(value));
        }
      }
      details.push(`code=${code}`);
      details.push(`version=${version}`);
      if (details.length) {
        message += " (" + details.join(", ") + ")";
      }
    }
    let error;
    switch (code) {
      case "INVALID_ARGUMENT":
        error = new TypeError(message);
        break;
      case "NUMERIC_FAULT":
      case "BUFFER_OVERRUN":
        error = new RangeError(message);
        break;
      default:
        error = new Error(message);
    }
    defineProperties(error, { code });
    if (info) {
      Object.assign(error, info);
    }
    return error;
  }
  function assert(check, message, code, info) {
    if (!check) {
      throw makeError(message, code, info);
    }
  }
  function assertArgument(check, message, name, value) {
    assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
  }
  var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
    try {
      if ("test".normalize(form) !== "test") {
        throw new Error("bad");
      }
      ;
      if (form === "NFD") {
        const check = String.fromCharCode(233).normalize("NFD");
        const expected = String.fromCharCode(101, 769);
        if (check !== expected) {
          throw new Error("broken");
        }
      }
      accum.push(form);
    } catch (error) {
    }
    return accum;
  }, []);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/data.js
  function _getBytes(value, name, copy) {
    if (value instanceof Uint8Array) {
      if (copy) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    assertArgument(false, "invalid BytesLike value", name || "value", value);
  }
  function getBytes(value, name) {
    return _getBytes(value, name, false);
  }
  var HexCharacters2 = "0123456789abcdef";
  function hexlify2(data) {
    const bytes2 = getBytes(data);
    let result = "0x";
    for (let i = 0; i < bytes2.length; i++) {
      const v = bytes2[i];
      result += HexCharacters2[(v & 240) >> 4] + HexCharacters2[v & 15];
    }
    return result;
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/crypto.js
  var import_crypto = __require("crypto");

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/pbkdf2.js
  var locked = false;
  var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
    return (0, import_crypto.pbkdf2Sync)(password, salt, iterations, keylen, algo);
  };
  var __pbkdf2 = _pbkdf2;
  function pbkdf22(_password, _salt, iterations, keylen, algo) {
    const password = getBytes(_password, "password");
    const salt = getBytes(_salt, "salt");
    return hexlify2(__pbkdf2(password, salt, iterations, keylen, algo));
  }
  pbkdf22._ = _pbkdf2;
  pbkdf22.lock = function() {
    locked = true;
  };
  pbkdf22.register = function(func) {
    if (locked) {
      throw new Error("pbkdf2 is locked");
    }
    __pbkdf2 = func;
  };
  Object.freeze(pbkdf22);

  // ../crypto/dist/index.mjs
  var import_crypto5 = __toESM(__require("crypto"), 1);
  var import_crypto6 = __toESM(__require("crypto"), 1);
  var scrypt3 = (params) => {
    const { password, salt, n, p, r, dklen } = params;
    const derivedKey = scrypt(password, salt, { N: n, r, p, dkLen: dklen });
    return derivedKey;
  };
  var keccak2562 = (data) => keccak_256(data);
  var bufferFromString = (string, encoding = "base64") => Uint8Array.from(Buffer.from(string, encoding));
  var randomBytes3 = (length) => {
    const randomValues = Uint8Array.from(import_crypto5.default.randomBytes(length));
    return randomValues;
  };
  var stringFromBuffer = (buffer, encoding = "base64") => Buffer.from(buffer).toString(encoding);
  var ALGORITHM = "aes-256-ctr";
  var keyFromPassword = (password, saltBuffer) => {
    const passBuffer = bufferFromString(String(password).normalize("NFKC"), "utf-8");
    const key = pbkdf22(passBuffer, saltBuffer, 1e5, 32, "sha256");
    return arrayify(key);
  };
  var encrypt = async (password, data) => {
    const iv = randomBytes3(16);
    const salt = randomBytes3(32);
    const secret = keyFromPassword(password, salt);
    const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), "utf-8"));
    const cipher = await import_crypto4.default.createCipheriv(ALGORITHM, secret, iv);
    let cipherData = cipher.update(dataBuffer);
    cipherData = Buffer.concat([cipherData, cipher.final()]);
    return {
      data: stringFromBuffer(cipherData),
      iv: stringFromBuffer(iv),
      salt: stringFromBuffer(salt)
    };
  };
  var decrypt = async (password, keystore) => {
    const iv = bufferFromString(keystore.iv);
    const salt = bufferFromString(keystore.salt);
    const secret = keyFromPassword(password, salt);
    const encryptedText = bufferFromString(keystore.data);
    const decipher = await import_crypto4.default.createDecipheriv(ALGORITHM, secret, iv);
    const decrypted = decipher.update(encryptedText);
    const deBuff = Buffer.concat([decrypted, decipher.final()]);
    const decryptedData = Buffer.from(deBuff).toString("utf-8");
    try {
      return JSON.parse(decryptedData);
    } catch {
      throw new FuelError(ErrorCode.INVALID_CREDENTIALS, "Invalid credentials.");
    }
  };
  async function encryptJsonWalletData(data, key, iv) {
    const cipher = await import_crypto6.default.createCipheriv("aes-128-ctr", key.subarray(0, 16), iv);
    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
    return new Uint8Array(encrypted);
  }
  async function decryptJsonWalletData(data, key, iv) {
    const decipher = import_crypto6.default.createDecipheriv("aes-128-ctr", key.subarray(0, 16), iv);
    const decrypted = await Buffer.concat([decipher.update(data), decipher.final()]);
    return new Uint8Array(decrypted);
  }
  var api = {
    bufferFromString,
    stringFromBuffer,
    decrypt,
    encrypt,
    keyFromPassword,
    randomBytes: randomBytes3,
    scrypt: scrypt3,
    keccak256: keccak2562,
    decryptJsonWalletData,
    encryptJsonWalletData
  };
  var node_default = api;
  var {
    bufferFromString: bufferFromString2,
    decrypt: decrypt2,
    encrypt: encrypt2,
    keyFromPassword: keyFromPassword2,
    randomBytes: randomBytes22,
    stringFromBuffer: stringFromBuffer2,
    scrypt: scrypt22,
    keccak256: keccak25622,
    decryptJsonWalletData: decryptJsonWalletData2,
    encryptJsonWalletData: encryptJsonWalletData2
  } = node_default;

  // ../interfaces/dist/index.mjs
  var AbstractAddress = class {
  };
  var AbstractAccount = class {
  };
  var AbstractProgram = class {
  };
  var AbstractContract = class extends AbstractProgram {
  };

  // src/utils.ts
  var import_bech32 = __toESM(require_dist());
  var FUEL_BECH32_HRP_PREFIX = "fuel";
  function fromBech32(address) {
    return import_bech32.bech32m.decode(address);
  }
  function toBech32(address) {
    return import_bech32.bech32m.encode(
      FUEL_BECH32_HRP_PREFIX,
      import_bech32.bech32m.toWords(arrayify(hexlify(address)))
    );
  }
  function isBech32(address) {
    return typeof address === "string" && address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 && fromBech32(address).prefix === FUEL_BECH32_HRP_PREFIX;
  }
  function isB256(address) {
    return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);
  }
  function isPublicKey(address) {
    return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);
  }
  function isEvmAddress(address) {
    return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);
  }
  function getBytesFromBech32(address) {
    return new Uint8Array(import_bech32.bech32m.fromWords(fromBech32(address).words));
  }
  function toB256(address) {
    if (!isBech32(address)) {
      throw new FuelError(
        FuelError.CODES.INVALID_BECH32_ADDRESS,
        `Invalid Bech32 Address: ${address}.`
      );
    }
    return hexlify(getBytesFromBech32(address));
  }
  function normalizeBech32(address) {
    const { words } = fromBech32(address);
    return import_bech32.bech32m.encode(FUEL_BECH32_HRP_PREFIX, words);
  }
  var addressify = (addressLike) => {
    if (addressLike instanceof AbstractAccount) {
      return addressLike.address;
    }
    if (addressLike instanceof AbstractContract) {
      return addressLike.id;
    }
    return addressLike;
  };
  var getRandomB256 = () => hexlify(randomBytes22(32));
  var clearFirst12BytesFromB256 = (b256) => {
    let bytes2;
    try {
      if (!isB256(b256)) {
        throw new FuelError(
          FuelError.CODES.INVALID_BECH32_ADDRESS,
          `Invalid Bech32 Address: ${b256}.`
        );
      }
      bytes2 = getBytesFromBech32(toBech32(b256));
      bytes2 = hexlify(bytes2.fill(0, 0, 12));
    } catch (error) {
      throw new FuelError(
        FuelError.CODES.PARSE_FAILED,
        `Cannot generate EVM Address B256 from: ${b256}.`
      );
    }
    return bytes2;
  };
  var padFirst12BytesOfEvmAddress = (address) => {
    if (!isEvmAddress(address)) {
      throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
    }
    return address.replace("0x", "0x000000000000000000000000");
  };

  // src/address.ts
  var Address = class extends AbstractAddress {
    // #region address-2
    bech32Address;
    // #endregion address-2
    /**
     * @param address - A Bech32 address
     */
    constructor(address) {
      super();
      this.bech32Address = normalizeBech32(address);
      if (!isBech32(this.bech32Address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_BECH32_ADDRESS,
          `Invalid Bech32 Address: ${address}.`
        );
      }
    }
    /**
     * Returns the `bech32Address` property
     *
     * @returns The `bech32Address` property
     */
    toAddress() {
      return this.bech32Address;
    }
    /**
     * Converts and returns the `bech32Address` property to a 256 bit hash string
     *
     * @returns The `bech32Address` property as a 256 bit hash string
     */
    toB256() {
      return toB256(this.bech32Address);
    }
    /**
     * Converts and returns the `bech32Address` property to a byte array
     *
     * @returns The `bech32Address` property as a byte array
     */
    toBytes() {
      return getBytesFromBech32(this.bech32Address);
    }
    /**
     * Converts
     *
     * @returns The `bech32Address` property as a 256 bit hash string
     */
    toHexString() {
      return this.toB256();
    }
    /**
     * Converts and returns the `bech32Address` property as a string
     *
     * @returns The `bech32Address` property as a string
     */
    toString() {
      return this.bech32Address;
    }
    /**
     * Converts and returns the `bech32Address` property as a string
     *
     * @returns The `bech32Address` property as a string
     */
    toJSON() {
      return this.bech32Address;
    }
    /**
     * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`
     *
     * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}
     */
    toEvmAddress() {
      const b256Address = toB256(this.bech32Address);
      return {
        value: clearFirst12BytesFromB256(b256Address)
      };
    }
    /**
     * Wraps the `bech32Address` property and returns as an `AssetId`.
     *
     * @returns The `bech32Address` property as an {@link AssetId | `AssetId`}
     */
    toAssetId() {
      return {
        value: this.toB256()
      };
    }
    /**
     * Returns the value of the `bech32Address` property
     *
     * @returns The value of `bech32Address` property
     */
    valueOf() {
      return this.bech32Address;
    }
    /**
     * Compares this the `bech32Address` property to another for direct equality
     *
     * @param other - Another address to compare against
     * @returns The equality of the comparison
     */
    equals(other) {
      return this.bech32Address === other.bech32Address;
    }
    /**
     * Takes a Public Key, hashes it, and creates an `Address`
     *
     * @param publicKey - A wallets public key
     * @returns A new `Address` instance
     */
    static fromPublicKey(publicKey) {
      if (!isPublicKey(publicKey)) {
        throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);
      }
      const b256Address = hexlify(sha256(arrayify(publicKey)));
      return new Address(toBech32(b256Address));
    }
    /**
     * Takes a B256 Address and creates an `Address`
     *
     * @param b256Address - A b256 hash
     * @returns A new `Address` instance
     */
    static fromB256(b256Address) {
      if (!isB256(b256Address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_B256_ADDRESS,
          `Invalid B256 Address: ${b256Address}.`
        );
      }
      return new Address(toBech32(b256Address));
    }
    /**
     * Creates an `Address` with a randomized `bech32Address` property
     *
     * @returns A new `Address` instance
     */
    static fromRandom() {
      return this.fromB256(getRandomB256());
    }
    /**
     * Takes an ambiguous string and attempts to create an `Address`
     *
     * @param address - An ambiguous string
     * @returns A new `Address` instance
     */
    static fromString(address) {
      return isBech32(address) ? new Address(address) : this.fromB256(address);
    }
    /**
     * Takes an ambiguous string or address and creates an `Address`
     *
     * @returns a new `Address` instance
     */
    static fromAddressOrString(address) {
      return typeof address === "string" ? this.fromString(address) : address;
    }
    /**
     * Takes a dynamic string or `AbstractAddress` and creates an `Address`
     *
     * @param addressId - A string containing Bech32, B256, or Public Key
     * @throws Error - Unknown address if the format is not recognised
     * @returns A new `Address` instance
     */
    static fromDynamicInput(address) {
      if (typeof address !== "string" && "toB256" in address) {
        return Address.fromB256(address.toB256());
      }
      if (isPublicKey(address)) {
        return Address.fromPublicKey(address);
      }
      if (isBech32(address)) {
        return new Address(address);
      }
      if (isB256(address)) {
        return Address.fromB256(address);
      }
      if (isEvmAddress(address)) {
        return Address.fromEvmAddress(address);
      }
      throw new FuelError(
        FuelError.CODES.PARSE_FAILED,
        `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`
      );
    }
    /**
     * Takes an Evm Address and returns back an `Address`
     *
     * @returns A new `Address` instance
     */
    static fromEvmAddress(evmAddress) {
      if (!isEvmAddress(evmAddress)) {
        throw new FuelError(
          FuelError.CODES.INVALID_EVM_ADDRESS,
          `Invalid Evm Address: ${evmAddress}.`
        );
      }
      const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);
      return new Address(toBech32(paddedAddress));
    }
  };
})();
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.global.js.map