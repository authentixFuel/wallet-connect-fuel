{"version":3,"sources":["../src/utils.ts","../src/address.ts"],"sourcesContent":["import { randomBytes } from '@fuel-ts/crypto';\nimport { FuelError } from '@fuel-ts/errors';\nimport { AbstractContract, AbstractAccount } from '@fuel-ts/interfaces';\nimport type {\n  Bech32Address,\n  B256Address,\n  AddressLike,\n  ContractIdLike,\n  AbstractAddress,\n  B256AddressEvm,\n  BytesLike,\n} from '@fuel-ts/interfaces';\nimport { arrayify, hexlify } from '@fuel-ts/utils';\nimport type { Decoded } from 'bech32';\nimport { bech32m } from 'bech32';\n\n/**\n * Fuel Network HRP (human-readable part) for bech32 encoding\n *\n * @hidden\n */\nexport const FUEL_BECH32_HRP_PREFIX = 'fuel';\n\n/**\n * Decodes a Bech32 address string into Decoded\n *\n * @hidden\n */\nexport function fromBech32(address: Bech32Address): Decoded {\n  return bech32m.decode(address);\n}\n\n/**\n * Converts a B256 address string into Bech32\n *\n * @hidden\n */\nexport function toBech32(address: B256Address): Bech32Address {\n  return bech32m.encode(\n    FUEL_BECH32_HRP_PREFIX,\n    bech32m.toWords(arrayify(hexlify(address)))\n  ) as Bech32Address;\n}\n\n/**\n * Determines if a given string is Bech32 format\n *\n * @hidden\n */\nexport function isBech32(address: BytesLike): boolean {\n  return (\n    typeof address === 'string' &&\n    address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 &&\n    fromBech32(address as Bech32Address).prefix === FUEL_BECH32_HRP_PREFIX\n  );\n}\n\n/**\n * Determines if a given string is B256 format\n *\n * @hidden\n */\nexport function isB256(address: string): boolean {\n  return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);\n}\n\n/**\n * Determines if a given string is in Public Key format (512 bits)\n *\n * @hidden\n */\nexport function isPublicKey(address: string): boolean {\n  return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);\n}\n\n/**\n * Determines if a given string is in EVM Address format\n *\n * @hidden\n */\nexport function isEvmAddress(address: string): boolean {\n  return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);\n}\n\n/**\n * Takes a Bech32 address and returns the byte data\n *\n * @hidden\n */\nexport function getBytesFromBech32(address: Bech32Address): Uint8Array {\n  return new Uint8Array(bech32m.fromWords(fromBech32(address).words));\n}\n\n/**\n * Converts a Bech32 address string into B256\n *\n * @hidden\n */\nexport function toB256(address: Bech32Address): B256Address {\n  if (!isBech32(address)) {\n    throw new FuelError(\n      FuelError.CODES.INVALID_BECH32_ADDRESS,\n      `Invalid Bech32 Address: ${address}.`\n    );\n  }\n\n  return hexlify(getBytesFromBech32(address));\n}\n\n/**\n * Takes a Bech32 address and returns a normalized (i.e. lower case) representation of it.\n *\n * The input is validated along the way, which makes this significantly safer than\n * using `address.toLowerCase()`.\n *\n * @hidden\n */\nexport function normalizeBech32(address: Bech32Address): Bech32Address {\n  const { words } = fromBech32(address);\n  return bech32m.encode(FUEL_BECH32_HRP_PREFIX, words) as Bech32Address;\n}\n\n/**\n * Takes an indeterminate address type and returns an address\n *\n * @hidden\n */\nexport const addressify = (addressLike: AddressLike | ContractIdLike): AbstractAddress => {\n  if (addressLike instanceof AbstractAccount) {\n    return addressLike.address;\n  }\n\n  if (addressLike instanceof AbstractContract) {\n    return addressLike.id;\n  }\n\n  return addressLike;\n};\n\n/**\n * @hidden\n */\nexport const getRandomB256 = () => hexlify(randomBytes(32));\n\n/**\n * Takes a B256 address and clears the first 12 bytes, this is required for an EVM Address\n *\n * @param b256 - the address to clear\n * @returns b256 with first 12 bytes cleared\n *\n * @hidden\n */\nexport const clearFirst12BytesFromB256 = (b256: B256Address): B256AddressEvm => {\n  let bytes;\n\n  try {\n    if (!isB256(b256)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_BECH32_ADDRESS,\n        `Invalid Bech32 Address: ${b256}.`\n      );\n    }\n\n    bytes = getBytesFromBech32(toBech32(b256));\n    bytes = hexlify(bytes.fill(0, 0, 12)) as B256AddressEvm;\n  } catch (error) {\n    throw new FuelError(\n      FuelError.CODES.PARSE_FAILED,\n      `Cannot generate EVM Address B256 from: ${b256}.`\n    );\n  }\n\n  return bytes;\n};\n\n/**\n * Pads the first 12 bytes of an Evm address. This is useful for padding addresses returned from\n * the EVM to interact with the Sway EVM Address Type.\n *\n * @param address - Evm address to be padded\n * @returns Evm address padded to a b256 address\n *\n * @hidden\n */\nexport const padFirst12BytesOfEvmAddress = (address: string): B256AddressEvm => {\n  if (!isEvmAddress(address)) {\n    throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, 'Invalid EVM address format.');\n  }\n\n  return address.replace('0x', '0x000000000000000000000000') as B256AddressEvm;\n};\n","import { FuelError } from '@fuel-ts/errors';\nimport { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Bech32Address, B256Address, EvmAddress, AssetId } from '@fuel-ts/interfaces';\nimport { arrayify, hexlify } from '@fuel-ts/utils';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport {\n  normalizeBech32,\n  isBech32,\n  toB256,\n  getBytesFromBech32,\n  toBech32,\n  getRandomB256,\n  isPublicKey,\n  isB256,\n  clearFirst12BytesFromB256,\n  isEvmAddress,\n  padFirst12BytesOfEvmAddress,\n} from './utils';\n\n/**\n * `Address` provides a type safe wrapper for converting between different address formats\n * ands comparing them for equality.\n */\nexport default class Address extends AbstractAddress {\n  // #region address-2\n  readonly bech32Address: Bech32Address;\n  // #endregion address-2\n\n  /**\n   * @param address - A Bech32 address\n   */\n  constructor(address: Bech32Address) {\n    super();\n    this.bech32Address = normalizeBech32(address);\n\n    if (!isBech32(this.bech32Address)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_BECH32_ADDRESS,\n        `Invalid Bech32 Address: ${address}.`\n      );\n    }\n  }\n\n  /**\n   * Returns the `bech32Address` property\n   *\n   * @returns The `bech32Address` property\n   */\n  toAddress(): Bech32Address {\n    return this.bech32Address;\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property to a 256 bit hash string\n   *\n   * @returns The `bech32Address` property as a 256 bit hash string\n   */\n  toB256(): B256Address {\n    return toB256(this.bech32Address);\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property to a byte array\n   *\n   * @returns The `bech32Address` property as a byte array\n   */\n  toBytes(): Uint8Array {\n    return getBytesFromBech32(this.bech32Address);\n  }\n\n  /**\n   * Converts\n   *\n   * @returns The `bech32Address` property as a 256 bit hash string\n   */\n  toHexString(): B256Address {\n    return this.toB256();\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property as a string\n   *\n   * @returns The `bech32Address` property as a string\n   */\n  toString(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property as a string\n   *\n   * @returns The `bech32Address` property as a string\n   */\n  toJSON(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`\n   *\n   * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}\n   */\n  toEvmAddress(): EvmAddress {\n    const b256Address = toB256(this.bech32Address);\n\n    return {\n      value: clearFirst12BytesFromB256(b256Address),\n    } as EvmAddress;\n  }\n\n  /**\n   * Wraps the `bech32Address` property and returns as an `AssetId`.\n   *\n   * @returns The `bech32Address` property as an {@link AssetId | `AssetId`}\n   */\n  toAssetId(): AssetId {\n    return {\n      value: this.toB256(),\n    } as AssetId;\n  }\n\n  /**\n   * Returns the value of the `bech32Address` property\n   *\n   * @returns The value of `bech32Address` property\n   */\n  valueOf(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Compares this the `bech32Address` property to another for direct equality\n   *\n   * @param other - Another address to compare against\n   * @returns The equality of the comparison\n   */\n  equals(other: Address): boolean {\n    return this.bech32Address === other.bech32Address;\n  }\n\n  /**\n   * Takes a Public Key, hashes it, and creates an `Address`\n   *\n   * @param publicKey - A wallets public key\n   * @returns A new `Address` instance\n   */\n  static fromPublicKey(publicKey: string): Address {\n    if (!isPublicKey(publicKey)) {\n      throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);\n    }\n\n    const b256Address = hexlify(sha256(arrayify(publicKey)));\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Takes a B256 Address and creates an `Address`\n   *\n   * @param b256Address - A b256 hash\n   * @returns A new `Address` instance\n   */\n  static fromB256(b256Address: string): Address {\n    if (!isB256(b256Address)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_B256_ADDRESS,\n        `Invalid B256 Address: ${b256Address}.`\n      );\n    }\n\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Creates an `Address` with a randomized `bech32Address` property\n   *\n   * @returns A new `Address` instance\n   */\n  static fromRandom(): Address {\n    return this.fromB256(getRandomB256());\n  }\n\n  /**\n   * Takes an ambiguous string and attempts to create an `Address`\n   *\n   * @param address - An ambiguous string\n   * @returns A new `Address` instance\n   */\n  static fromString(address: string): Address {\n    return isBech32(address) ? new Address(address as Bech32Address) : this.fromB256(address);\n  }\n\n  /**\n   * Takes an ambiguous string or address and creates an `Address`\n   *\n   * @returns a new `Address` instance\n   */\n  static fromAddressOrString(address: string | AbstractAddress): AbstractAddress {\n    return typeof address === 'string' ? this.fromString(address) : address;\n  }\n\n  /**\n   * Takes a dynamic string or `AbstractAddress` and creates an `Address`\n   *\n   * @param addressId - A string containing Bech32, B256, or Public Key\n   * @throws Error - Unknown address if the format is not recognised\n   * @returns A new `Address` instance\n   */\n  static fromDynamicInput(address: string | AbstractAddress): Address {\n    // If address is a object than we assume it's a AbstractAddress\n    // we don't check by instanceof because it's possible to\n    // the host app to have a different reference to this same class type\n    if (typeof address !== 'string' && 'toB256' in address) {\n      return Address.fromB256(address.toB256());\n    }\n    if (isPublicKey(address)) {\n      return Address.fromPublicKey(address);\n    }\n\n    if (isBech32(address)) {\n      return new Address(address as Bech32Address);\n    }\n\n    if (isB256(address)) {\n      return Address.fromB256(address);\n    }\n\n    if (isEvmAddress(address)) {\n      return Address.fromEvmAddress(address);\n    }\n\n    throw new FuelError(\n      FuelError.CODES.PARSE_FAILED,\n      `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`\n    );\n  }\n\n  /**\n   * Takes an Evm Address and returns back an `Address`\n   *\n   * @returns A new `Address` instance\n   */\n  static fromEvmAddress(evmAddress: string): Address {\n    if (!isEvmAddress(evmAddress)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_EVM_ADDRESS,\n        `Invalid Evm Address: ${evmAddress}.`\n      );\n    }\n\n    const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);\n\n    return new Address(toBech32(paddedAddress));\n  }\n}\n"],"mappings":"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","names":["FuelError","arrayify","hexlify","FuelError","hexlify","arrayify"]}