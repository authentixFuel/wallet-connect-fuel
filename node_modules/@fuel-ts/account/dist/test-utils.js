"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/test-utils/index.ts
var test_utils_exports = {};
__export(test_utils_exports, {
  generateTestWallet: () => generateTestWallet,
  killNode: () => killNode,
  launchNode: () => launchNode,
  launchNodeAndGetWallets: () => launchNodeAndGetWallets,
  seedTestWallet: () => seedTestWallet
});
module.exports = __toCommonJS(test_utils_exports);

// src/wallet/base-wallet-unlocked.ts
var import_hasher3 = require("@fuel-ts/hasher");
var import_utils30 = require("@fuel-ts/utils");

// src/account.ts
var import_address4 = require("@fuel-ts/address");
var import_configs11 = require("@fuel-ts/address/configs");
var import_errors15 = require("@fuel-ts/errors");
var import_interfaces = require("@fuel-ts/interfaces");
var import_math17 = require("@fuel-ts/math");
var import_utils27 = require("@fuel-ts/utils");

// src/providers/coin-quantity.ts
var import_configs = require("@fuel-ts/address/configs");
var import_math = require("@fuel-ts/math");
var import_utils = require("@fuel-ts/utils");
var coinQuantityfy = (coinQuantityLike) => {
  let assetId;
  let amount;
  let max2;
  if (Array.isArray(coinQuantityLike)) {
    amount = coinQuantityLike[0];
    assetId = coinQuantityLike[1] ?? import_configs.BaseAssetId;
    max2 = coinQuantityLike[2] ?? void 0;
  } else {
    amount = coinQuantityLike.amount;
    assetId = coinQuantityLike.assetId ?? import_configs.BaseAssetId;
    max2 = coinQuantityLike.max ?? void 0;
  }
  const bnAmount = (0, import_math.bn)(amount);
  return {
    assetId: (0, import_utils.hexlify)(assetId),
    amount: bnAmount.lt(1) ? (0, import_math.bn)(1) : bnAmount,
    max: max2 ? (0, import_math.bn)(max2) : void 0
  };
};
var addAmountToAsset = (params) => {
  const { amount, assetId } = params;
  const coinQuantities = [...params.coinQuantities];
  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
  if (assetIdx !== -1) {
    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
  } else {
    coinQuantities.push({ assetId, amount });
  }
  return coinQuantities;
};

// src/providers/provider.ts
var import_address3 = require("@fuel-ts/address");
var import_errors13 = require("@fuel-ts/errors");
var import_math14 = require("@fuel-ts/math");
var import_transactions17 = require("@fuel-ts/transactions");
var import_utils22 = require("@fuel-ts/utils");
var import_versions = require("@fuel-ts/versions");
var import_utils23 = require("@noble/curves/abstract/utils");
var import_ethers = require("ethers");
var import_graphql_request = require("graphql-request");
var import_ramda3 = require("ramda");

// src/providers/__generated__/operations.ts
var import_graphql_tag = __toESM(require("graphql-tag"));
var ReceiptFragmentFragmentDoc = import_graphql_tag.default`
    fragment receiptFragment on Receipt {
  contract {
    id
  }
  pc
  is
  to {
    id
  }
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
var TransactionStatusFragmentFragmentDoc = import_graphql_tag.default`
    fragment transactionStatusFragment on TransactionStatus {
  type: __typename
  ... on SubmittedStatus {
    time
  }
  ... on SuccessStatus {
    block {
      id
    }
    time
    programState {
      returnType
      data
    }
  }
  ... on FailureStatus {
    block {
      id
    }
    time
    reason
  }
  ... on SqueezedOutStatus {
    reason
  }
}
    `;
var TransactionFragmentFragmentDoc = import_graphql_tag.default`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  gasPrice
  receipts {
    ...receiptFragment
  }
  status {
    ...transactionStatusFragment
  }
}
    ${ReceiptFragmentFragmentDoc}
${TransactionStatusFragmentFragmentDoc}`;
var InputEstimatePredicatesFragmentFragmentDoc = import_graphql_tag.default`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
var TransactionEstimatePredicatesFragmentFragmentDoc = import_graphql_tag.default`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentFragmentDoc}`;
var CoinFragmentFragmentDoc = import_graphql_tag.default`
    fragment coinFragment on Coin {
  __typename
  utxoId
  owner
  amount
  assetId
  maturity
  blockCreated
  txCreatedIdx
}
    `;
var MessageCoinFragmentFragmentDoc = import_graphql_tag.default`
    fragment messageCoinFragment on MessageCoin {
  __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
var MessageFragmentFragmentDoc = import_graphql_tag.default`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  nonce
  daHeight
}
    `;
var MessageProofFragmentFragmentDoc = import_graphql_tag.default`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  commitBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  sender
  recipient
  nonce
  amount
  data
}
    `;
var BalanceFragmentFragmentDoc = import_graphql_tag.default`
    fragment balanceFragment on Balance {
  owner
  amount
  assetId
}
    `;
var BlockFragmentFragmentDoc = import_graphql_tag.default`
    fragment blockFragment on Block {
  id
  header {
    height
    time
  }
  transactions {
    id
  }
}
    `;
var TxParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment TxParametersFragment on TxParameters {
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
}
    `;
var PredicateParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment PredicateParametersFragment on PredicateParameters {
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
var ScriptParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment ScriptParametersFragment on ScriptParameters {
  maxScriptLength
  maxScriptDataLength
}
    `;
var ContractParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment ContractParametersFragment on ContractParameters {
  contractMaxSize
  maxStorageSlots
}
    `;
var FeeParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment FeeParametersFragment on FeeParameters {
  gasPriceFactor
  gasPerByte
}
    `;
var DependentCostFragmentFragmentDoc = import_graphql_tag.default`
    fragment DependentCostFragment on DependentCost {
  __typename
  ... on LightOperation {
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    base
    gasPerUnit
  }
}
    `;
var GasCostsFragmentFragmentDoc = import_graphql_tag.default`
    fragment GasCostsFragment on GasCosts {
  add
  addi
  aloc
  and
  andi
  bal
  bhei
  bhsh
  burn
  cb
  cfei
  cfsi
  croo
  div
  divi
  ecr1
  eck1
  ed19
  eq
  exp
  expi
  flag
  gm
  gt
  gtf
  ji
  jmp
  jne
  jnei
  jnzi
  jmpf
  jmpb
  jnzf
  jnzb
  jnef
  jneb
  lb
  log
  lt
  lw
  mint
  mlog
  modOp
  modi
  moveOp
  movi
  mroo
  mul
  muli
  mldv
  noop
  not
  or
  ori
  poph
  popl
  pshh
  pshl
  ret
  rvrt
  sb
  sll
  slli
  srl
  srli
  srw
  sub
  subi
  sw
  sww
  time
  tr
  tro
  wdcm
  wqcm
  wdop
  wqop
  wdml
  wqml
  wddv
  wqdv
  wdmd
  wqmd
  wdam
  wqam
  wdmm
  wqmm
  xor
  xori
  call {
    ...DependentCostFragment
  }
  ccp {
    ...DependentCostFragment
  }
  csiz {
    ...DependentCostFragment
  }
  k256 {
    ...DependentCostFragment
  }
  ldc {
    ...DependentCostFragment
  }
  logd {
    ...DependentCostFragment
  }
  mcl {
    ...DependentCostFragment
  }
  mcli {
    ...DependentCostFragment
  }
  mcp {
    ...DependentCostFragment
  }
  mcpi {
    ...DependentCostFragment
  }
  meq {
    ...DependentCostFragment
  }
  retd {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  scwq {
    ...DependentCostFragment
  }
  smo {
    ...DependentCostFragment
  }
  srwq {
    ...DependentCostFragment
  }
  swwq {
    ...DependentCostFragment
  }
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  newStoragePerByte
}
    ${DependentCostFragmentFragmentDoc}`;
var ConsensusParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment consensusParametersFragment on ConsensusParameters {
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentFragmentDoc}
${PredicateParametersFragmentFragmentDoc}
${ScriptParametersFragmentFragmentDoc}
${ContractParametersFragmentFragmentDoc}
${FeeParametersFragmentFragmentDoc}
${GasCostsFragmentFragmentDoc}`;
var ChainInfoFragmentFragmentDoc = import_graphql_tag.default`
    fragment chainInfoFragment on ChainInfo {
  name
  latestBlock {
    ...blockFragment
  }
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${BlockFragmentFragmentDoc}
${ConsensusParametersFragmentFragmentDoc}`;
var ContractBalanceFragmentFragmentDoc = import_graphql_tag.default`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
var PageInfoFragmentFragmentDoc = import_graphql_tag.default`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
var NodeInfoFragmentFragmentDoc = import_graphql_tag.default`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  minGasPrice
  maxTx
  maxDepth
  nodeVersion
  peers {
    id
    addresses
    clientVersion
    blockHeight
    lastHeartbeatMs
    appScore
  }
}
    `;
var GetVersionDocument = import_graphql_tag.default`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
var GetNodeInfoDocument = import_graphql_tag.default`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentFragmentDoc}`;
var GetChainDocument = import_graphql_tag.default`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentFragmentDoc}`;
var GetTransactionDocument = import_graphql_tag.default`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetTransactionWithReceiptsDocument = import_graphql_tag.default`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
    receipts {
      ...receiptFragment
    }
  }
}
    ${TransactionFragmentFragmentDoc}
${ReceiptFragmentFragmentDoc}`;
var GetTransactionsDocument = import_graphql_tag.default`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetTransactionsByOwnerDocument = import_graphql_tag.default`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
var EstimatePredicatesDocument = import_graphql_tag.default`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentFragmentDoc}`;
var GetBlockDocument = import_graphql_tag.default`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentFragmentDoc}`;
var GetBlockWithTransactionsDocument = import_graphql_tag.default`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionFragment
    }
  }
}
    ${BlockFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
var GetBlocksDocument = import_graphql_tag.default`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${BlockFragmentFragmentDoc}`;
var GetCoinDocument = import_graphql_tag.default`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
  }
}
    ${CoinFragmentFragmentDoc}`;
var GetCoinsDocument = import_graphql_tag.default`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${CoinFragmentFragmentDoc}`;
var GetCoinsToSpendDocument = import_graphql_tag.default`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentFragmentDoc}
${MessageCoinFragmentFragmentDoc}`;
var GetContractDocument = import_graphql_tag.default`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
var GetContractBalanceDocument = import_graphql_tag.default`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentFragmentDoc}`;
var GetBalanceDocument = import_graphql_tag.default`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    ...balanceFragment
  }
}
    ${BalanceFragmentFragmentDoc}`;
var GetBalancesDocument = import_graphql_tag.default`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...balanceFragment
      }
    }
  }
}
    ${BalanceFragmentFragmentDoc}`;
var GetMessagesDocument = import_graphql_tag.default`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...messageFragment
      }
    }
  }
}
    ${MessageFragmentFragmentDoc}`;
var GetMessageProofDocument = import_graphql_tag.default`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentFragmentDoc}`;
var GetMessageStatusDocument = import_graphql_tag.default`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
var DryRunDocument = import_graphql_tag.default`
    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {
  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {
    ...receiptFragment
  }
}
    ${ReceiptFragmentFragmentDoc}`;
var SubmitDocument = import_graphql_tag.default`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
var ProduceBlocksDocument = import_graphql_tag.default`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
var SubmitAndAwaitDocument = import_graphql_tag.default`
    subscription submitAndAwait($encodedTransaction: HexString!) {
  submitAndAwait(tx: $encodedTransaction) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc}`;
var StatusChangeDocument = import_graphql_tag.default`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc}`;
function getSdk(requester) {
  return {
    getVersion(variables, options) {
      return requester(GetVersionDocument, variables, options);
    },
    getNodeInfo(variables, options) {
      return requester(GetNodeInfoDocument, variables, options);
    },
    getChain(variables, options) {
      return requester(GetChainDocument, variables, options);
    },
    getTransaction(variables, options) {
      return requester(GetTransactionDocument, variables, options);
    },
    getTransactionWithReceipts(variables, options) {
      return requester(GetTransactionWithReceiptsDocument, variables, options);
    },
    getTransactions(variables, options) {
      return requester(GetTransactionsDocument, variables, options);
    },
    getTransactionsByOwner(variables, options) {
      return requester(GetTransactionsByOwnerDocument, variables, options);
    },
    estimatePredicates(variables, options) {
      return requester(EstimatePredicatesDocument, variables, options);
    },
    getBlock(variables, options) {
      return requester(GetBlockDocument, variables, options);
    },
    getBlockWithTransactions(variables, options) {
      return requester(GetBlockWithTransactionsDocument, variables, options);
    },
    getBlocks(variables, options) {
      return requester(GetBlocksDocument, variables, options);
    },
    getCoin(variables, options) {
      return requester(GetCoinDocument, variables, options);
    },
    getCoins(variables, options) {
      return requester(GetCoinsDocument, variables, options);
    },
    getCoinsToSpend(variables, options) {
      return requester(GetCoinsToSpendDocument, variables, options);
    },
    getContract(variables, options) {
      return requester(GetContractDocument, variables, options);
    },
    getContractBalance(variables, options) {
      return requester(GetContractBalanceDocument, variables, options);
    },
    getBalance(variables, options) {
      return requester(GetBalanceDocument, variables, options);
    },
    getBalances(variables, options) {
      return requester(GetBalancesDocument, variables, options);
    },
    getMessages(variables, options) {
      return requester(GetMessagesDocument, variables, options);
    },
    getMessageProof(variables, options) {
      return requester(GetMessageProofDocument, variables, options);
    },
    getMessageStatus(variables, options) {
      return requester(GetMessageStatusDocument, variables, options);
    },
    dryRun(variables, options) {
      return requester(DryRunDocument, variables, options);
    },
    submit(variables, options) {
      return requester(SubmitDocument, variables, options);
    },
    produceBlocks(variables, options) {
      return requester(ProduceBlocksDocument, variables, options);
    },
    submitAndAwait(variables, options) {
      return requester(SubmitAndAwaitDocument, variables, options);
    },
    statusChange(variables, options) {
      return requester(StatusChangeDocument, variables, options);
    }
  };
}

// src/providers/fuel-graphql-subscriber.ts
var import_errors = require("@fuel-ts/errors");
var import_graphql = require("graphql");
var _FuelGraphqlSubscriber = class {
  constructor(options) {
    this.options = options;
  }
  stream;
  async setStream() {
    const { url, query, variables, fetchFn } = this.options;
    const response = await fetchFn(`${url}-sub`, {
      method: "POST",
      body: JSON.stringify({
        query: (0, import_graphql.print)(query),
        variables
      }),
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }
    });
    this.stream = response.body.getReader();
  }
  async next() {
    if (!this.stream) {
      await this.setStream();
    }
    while (true) {
      const { value, done } = await this.stream.read();
      if (done) {
        return { value, done };
      }
      const text = _FuelGraphqlSubscriber.textDecoder.decode(value);
      if (!text.startsWith("data:")) {
        continue;
      }
      let data;
      let errors;
      try {
        ({ data, errors } = JSON.parse(text.replace(/^data:/, "")));
      } catch (e) {
        throw new import_errors.FuelError(
          import_errors.ErrorCode.STREAM_PARSING_ERROR,
          `Error while parsing stream data response: ${text}`
        );
      }
      if (Array.isArray(errors)) {
        throw new import_errors.FuelError(
          import_errors.FuelError.CODES.INVALID_REQUEST,
          errors.map((err) => err.message).join("\n\n")
        );
      }
      return { value: data, done: false };
    }
  }
  /**
   * Gets called when `break` is called in a `for-await-of` loop.
   */
  async return() {
    await this.stream.cancel();
    this.stream.releaseLock();
    return { done: true, value: void 0 };
  }
  [Symbol.asyncIterator]() {
    return this;
  }
};
var FuelGraphqlSubscriber = _FuelGraphqlSubscriber;
__publicField(FuelGraphqlSubscriber, "textDecoder", new TextDecoder());

// src/providers/memory-cache.ts
var import_errors2 = require("@fuel-ts/errors");
var import_utils2 = require("@fuel-ts/utils");
var cache = {};
var DEFAULT_TTL_IN_MS = 30 * 1e3;
var MemoryCache = class {
  ttl;
  constructor(ttlInMs = DEFAULT_TTL_IN_MS) {
    this.ttl = ttlInMs;
    if (typeof ttlInMs !== "number" || this.ttl <= 0) {
      throw new import_errors2.FuelError(
        import_errors2.ErrorCode.INVALID_TTL,
        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
      );
    }
  }
  get(value, isAutoExpiring = true) {
    const key = (0, import_utils2.hexlify)(value);
    if (cache[key]) {
      if (!isAutoExpiring || cache[key].expires > Date.now()) {
        return cache[key].value;
      }
      this.del(value);
    }
    return void 0;
  }
  set(value) {
    const expiresAt = Date.now() + this.ttl;
    const key = (0, import_utils2.hexlify)(value);
    cache[key] = {
      expires: expiresAt,
      value
    };
    return expiresAt;
  }
  getAllData() {
    return Object.keys(cache).reduce((list, key) => {
      const data = this.get(key, false);
      if (data) {
        list.push(data);
      }
      return list;
    }, []);
  }
  getActiveData() {
    return Object.keys(cache).reduce((list, key) => {
      const data = this.get(key);
      if (data) {
        list.push(data);
      }
      return list;
    }, []);
  }
  del(value) {
    const key = (0, import_utils2.hexlify)(value);
    delete cache[key];
  }
};

// src/providers/transaction-request/input.ts
var import_configs2 = require("@fuel-ts/address/configs");
var import_errors3 = require("@fuel-ts/errors");
var import_math2 = require("@fuel-ts/math");
var import_transactions = require("@fuel-ts/transactions");
var import_utils3 = require("@fuel-ts/utils");
var inputify = (value) => {
  const { type } = value;
  switch (value.type) {
    case import_transactions.InputType.Coin: {
      const predicate = (0, import_utils3.arrayify)(value.predicate ?? "0x");
      const predicateData = (0, import_utils3.arrayify)(value.predicateData ?? "0x");
      return {
        type: import_transactions.InputType.Coin,
        txID: (0, import_utils3.hexlify)((0, import_utils3.arrayify)(value.id).slice(0, 32)),
        outputIndex: (0, import_utils3.arrayify)(value.id)[32],
        owner: (0, import_utils3.hexlify)(value.owner),
        amount: (0, import_math2.bn)(value.amount),
        assetId: (0, import_utils3.hexlify)(value.assetId),
        txPointer: {
          blockHeight: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.txPointer).slice(0, 8)),
          txIndex: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.txPointer).slice(8, 16))
        },
        witnessIndex: value.witnessIndex,
        maturity: value.maturity ?? 0,
        predicateGasUsed: (0, import_math2.bn)(value.predicateGasUsed),
        predicateLength: predicate.length,
        predicateDataLength: predicateData.length,
        predicate: (0, import_utils3.hexlify)(predicate),
        predicateData: (0, import_utils3.hexlify)(predicateData)
      };
    }
    case import_transactions.InputType.Contract: {
      return {
        type: import_transactions.InputType.Contract,
        txID: import_configs2.ZeroBytes32,
        outputIndex: 0,
        balanceRoot: import_configs2.ZeroBytes32,
        stateRoot: import_configs2.ZeroBytes32,
        txPointer: {
          blockHeight: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.txPointer).slice(0, 8)),
          txIndex: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.txPointer).slice(8, 16))
        },
        contractID: (0, import_utils3.hexlify)(value.contractId)
      };
    }
    case import_transactions.InputType.Message: {
      const predicate = (0, import_utils3.arrayify)(value.predicate ?? "0x");
      const predicateData = (0, import_utils3.arrayify)(value.predicateData ?? "0x");
      const data = (0, import_utils3.arrayify)(value.data ?? "0x");
      return {
        type: import_transactions.InputType.Message,
        sender: (0, import_utils3.hexlify)(value.sender),
        recipient: (0, import_utils3.hexlify)(value.recipient),
        amount: (0, import_math2.bn)(value.amount),
        nonce: (0, import_utils3.hexlify)(value.nonce),
        witnessIndex: value.witnessIndex,
        predicateGasUsed: (0, import_math2.bn)(value.predicateGasUsed),
        predicateLength: predicate.length,
        predicateDataLength: predicateData.length,
        predicate: (0, import_utils3.hexlify)(predicate),
        predicateData: (0, import_utils3.hexlify)(predicateData),
        data: (0, import_utils3.hexlify)(data),
        dataLength: data.length
      };
    }
    default: {
      throw new import_errors3.FuelError(
        import_errors3.ErrorCode.INVALID_TRANSACTION_INPUT,
        `Invalid transaction input type: ${type}.`
      );
    }
  }
};

// src/providers/transaction-request/output.ts
var import_configs3 = require("@fuel-ts/address/configs");
var import_errors4 = require("@fuel-ts/errors");
var import_math3 = require("@fuel-ts/math");
var import_transactions2 = require("@fuel-ts/transactions");
var import_utils4 = require("@fuel-ts/utils");
var outputify = (value) => {
  const { type } = value;
  switch (type) {
    case import_transactions2.OutputType.Coin: {
      return {
        type: import_transactions2.OutputType.Coin,
        to: (0, import_utils4.hexlify)(value.to),
        amount: (0, import_math3.bn)(value.amount),
        assetId: (0, import_utils4.hexlify)(value.assetId)
      };
    }
    case import_transactions2.OutputType.Contract: {
      return {
        type: import_transactions2.OutputType.Contract,
        inputIndex: value.inputIndex,
        balanceRoot: import_configs3.ZeroBytes32,
        stateRoot: import_configs3.ZeroBytes32
      };
    }
    case import_transactions2.OutputType.Change: {
      return {
        type: import_transactions2.OutputType.Change,
        to: (0, import_utils4.hexlify)(value.to),
        amount: (0, import_math3.bn)(0),
        assetId: (0, import_utils4.hexlify)(value.assetId)
      };
    }
    case import_transactions2.OutputType.Variable: {
      return {
        type: import_transactions2.OutputType.Variable,
        to: import_configs3.ZeroBytes32,
        amount: (0, import_math3.bn)(0),
        assetId: import_configs3.ZeroBytes32
      };
    }
    case import_transactions2.OutputType.ContractCreated: {
      return {
        type: import_transactions2.OutputType.ContractCreated,
        contractId: (0, import_utils4.hexlify)(value.contractId),
        stateRoot: (0, import_utils4.hexlify)(value.stateRoot)
      };
    }
    default: {
      throw new import_errors4.FuelError(
        import_errors4.ErrorCode.INVALID_TRANSACTION_INPUT,
        `Invalid transaction output type: ${type}.`
      );
    }
  }
};

// src/providers/transaction-request/transaction-request.ts
var import_address = require("@fuel-ts/address");
var import_configs6 = require("@fuel-ts/address/configs");
var import_math6 = require("@fuel-ts/math");
var import_transactions5 = require("@fuel-ts/transactions");
var import_utils9 = require("@fuel-ts/utils");

// src/providers/resource.ts
var isCoin = (resource) => "id" in resource;

// src/providers/utils/receipts.ts
var import_configs4 = require("@fuel-ts/address/configs");
var import_errors5 = require("@fuel-ts/errors");
var import_math4 = require("@fuel-ts/math");
var import_transactions3 = require("@fuel-ts/transactions");
var import_configs5 = require("@fuel-ts/transactions/configs");
var import_utils5 = require("@fuel-ts/utils");
var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === import_transactions3.ReceiptType.Revert && receipt.val.toString("hex") === import_configs5.FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
var doesReceiptHaveMissingContractId = (receipt) => receipt.type === import_transactions3.ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
var getReceiptsWithMissingData = (receipts) => receipts.reduce(
  (memo, receipt) => {
    if (doesReceiptHaveMissingOutputVariables(receipt)) {
      memo.missingOutputVariables.push(receipt);
    }
    if (doesReceiptHaveMissingContractId(receipt)) {
      memo.missingOutputContractIds.push(receipt);
    }
    return memo;
  },
  {
    missingOutputVariables: [],
    missingOutputContractIds: []
  }
);
var hexOrZero = (hex) => hex || import_configs4.ZeroBytes32;
function assembleReceiptByType(receipt) {
  const { receiptType } = receipt;
  switch (receiptType) {
    case "CALL" /* Call */: {
      const callReceipt = {
        type: import_transactions3.ReceiptType.Call,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt?.to?.id),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        gas: (0, import_math4.bn)(receipt.gas),
        param1: (0, import_math4.bn)(receipt.param1),
        param2: (0, import_math4.bn)(receipt.param2),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return callReceipt;
    }
    case "RETURN" /* Return */: {
      const returnReceipt = {
        type: import_transactions3.ReceiptType.Return,
        id: hexOrZero(receipt.contract?.id),
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return returnReceipt;
    }
    case "RETURN_DATA" /* ReturnData */: {
      const returnDataReceipt = {
        type: import_transactions3.ReceiptType.ReturnData,
        id: hexOrZero(receipt.contract?.id),
        ptr: (0, import_math4.bn)(receipt.ptr),
        len: (0, import_math4.bn)(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return returnDataReceipt;
    }
    case "PANIC" /* Panic */: {
      const panicReceipt = {
        type: import_transactions3.ReceiptType.Panic,
        id: hexOrZero(receipt.contract?.id),
        reason: (0, import_math4.bn)(receipt.reason),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is),
        contractId: hexOrZero(receipt.contractId)
      };
      return panicReceipt;
    }
    case "REVERT" /* Revert */: {
      const revertReceipt = {
        type: import_transactions3.ReceiptType.Revert,
        id: hexOrZero(receipt.contract?.id),
        val: (0, import_math4.bn)(receipt.ra),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return revertReceipt;
    }
    case "LOG" /* Log */: {
      const logReceipt = {
        type: import_transactions3.ReceiptType.Log,
        id: hexOrZero(receipt.contract?.id),
        val0: (0, import_math4.bn)(receipt.ra),
        val1: (0, import_math4.bn)(receipt.rb),
        val2: (0, import_math4.bn)(receipt.rc),
        val3: (0, import_math4.bn)(receipt.rd),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return logReceipt;
    }
    case "LOG_DATA" /* LogData */: {
      const logDataReceipt = {
        type: import_transactions3.ReceiptType.LogData,
        id: hexOrZero(receipt.contract?.id),
        val0: (0, import_math4.bn)(receipt.ra),
        val1: (0, import_math4.bn)(receipt.rb),
        ptr: (0, import_math4.bn)(receipt.ptr),
        len: (0, import_math4.bn)(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return logDataReceipt;
    }
    case "TRANSFER" /* Transfer */: {
      const transferReceipt = {
        type: import_transactions3.ReceiptType.Transfer,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt.toAddress || receipt?.to?.id),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return transferReceipt;
    }
    case "TRANSFER_OUT" /* TransferOut */: {
      const transferOutReceipt = {
        type: import_transactions3.ReceiptType.TransferOut,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt.toAddress || receipt.to?.id),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return transferOutReceipt;
    }
    case "SCRIPT_RESULT" /* ScriptResult */: {
      const scriptResultReceipt = {
        type: import_transactions3.ReceiptType.ScriptResult,
        result: (0, import_math4.bn)(receipt.result),
        gasUsed: (0, import_math4.bn)(receipt.gasUsed)
      };
      return scriptResultReceipt;
    }
    case "MESSAGE_OUT" /* MessageOut */: {
      const sender = hexOrZero(receipt.sender);
      const recipient = hexOrZero(receipt.recipient);
      const nonce = hexOrZero(receipt.nonce);
      const amount = (0, import_math4.bn)(receipt.amount);
      const data = receipt.data ? (0, import_utils5.arrayify)(receipt.data) : Uint8Array.from([]);
      const digest = hexOrZero(receipt.digest);
      const messageId = import_transactions3.ReceiptMessageOutCoder.getMessageId({
        sender,
        recipient,
        nonce,
        amount,
        data
      });
      const receiptMessageOut = {
        type: import_transactions3.ReceiptType.MessageOut,
        sender,
        recipient,
        amount,
        nonce,
        data,
        digest,
        messageId
      };
      return receiptMessageOut;
    }
    case "MINT" /* Mint */: {
      const contractId = hexOrZero(receipt.contract?.id);
      const subId = hexOrZero(receipt.subId);
      const assetId = import_transactions3.ReceiptMintCoder.getAssetId(contractId, subId);
      const mintReceipt = {
        type: import_transactions3.ReceiptType.Mint,
        subId,
        contractId,
        assetId,
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return mintReceipt;
    }
    case "BURN" /* Burn */: {
      const contractId = hexOrZero(receipt.contract?.id);
      const subId = hexOrZero(receipt.subId);
      const assetId = import_transactions3.ReceiptBurnCoder.getAssetId(contractId, subId);
      const burnReceipt = {
        type: import_transactions3.ReceiptType.Burn,
        subId,
        contractId,
        assetId,
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return burnReceipt;
    }
    default:
      throw new import_errors5.FuelError(import_errors5.ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
  }
}

// src/providers/utils/block-explorer.ts
var import_errors6 = require("@fuel-ts/errors");

// src/providers/utils/gas.ts
var import_math5 = require("@fuel-ts/math");
var import_transactions4 = require("@fuel-ts/transactions");
var import_utils6 = require("@fuel-ts/utils");
var calculatePriceWithFactor = (gas, gasPrice, priceFactor) => (0, import_math5.bn)(Math.ceil(gas.mul(gasPrice).toNumber() / priceFactor.toNumber()));
var getGasUsedFromReceipts = (receipts) => {
  const scriptResult = receipts.filter(
    (receipt) => receipt.type === import_transactions4.ReceiptType.ScriptResult
  );
  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), (0, import_math5.bn)(0));
  return gasUsed;
};
function resolveGasDependentCosts(byteSize, gasDependentCost) {
  const base = (0, import_math5.bn)(gasDependentCost.base);
  let dependentValue = (0, import_math5.bn)(0);
  if (gasDependentCost.__typename === "LightOperation") {
    dependentValue = (0, import_math5.bn)(byteSize).div((0, import_math5.bn)(gasDependentCost.unitsPerGas));
  }
  if (gasDependentCost.__typename === "HeavyOperation") {
    dependentValue = (0, import_math5.bn)(byteSize).mul((0, import_math5.bn)(gasDependentCost.gasPerUnit));
  }
  return base.add(dependentValue);
}
function gasUsedByInputs(inputs, txBytesSize, gasCosts) {
  const witnessCache = [];
  const totalGas = inputs.reduce((total, input) => {
    if ("predicate" in input && input.predicate && input.predicate !== "0x") {
      return total.add(
        resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization).add(resolveGasDependentCosts((0, import_utils6.arrayify)(input.predicate).length, gasCosts.contractRoot)).add((0, import_math5.bn)(input.predicateGasUsed))
      );
    }
    if ("witnessIndex" in input && !witnessCache.includes(input.witnessIndex)) {
      witnessCache.push(input.witnessIndex);
      return total.add(gasCosts.ecr1);
    }
    return total;
  }, (0, import_math5.bn)());
  return totalGas;
}
function getMinGas(params) {
  const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
  const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const bytesGas = (0, import_math5.bn)(txBytesSize).mul(gasPerByte);
  const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);
  const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
  return minGas;
}
function getMaxGas(params) {
  const { gasPerByte, witnessesLength, witnessLimit, minGas, gasLimit = (0, import_math5.bn)(0) } = params;
  let remainingAllowedWitnessGas = (0, import_math5.bn)(0);
  if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
    remainingAllowedWitnessGas = (0, import_math5.bn)(witnessLimit).sub(witnessesLength).mul(gasPerByte);
  }
  return remainingAllowedWitnessGas.add(minGas).add(gasLimit);
}
function calculateMetadataGasForTxCreate({
  gasCosts,
  stateRootSize,
  txBytesSize,
  contractBytesSize
}) {
  const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);
  const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);
  const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const contractIdInputSize = (0, import_math5.bn)(4 + 32 + 32 + 32);
  const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);
  const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
  return metadataGas.maxU64();
}
function calculateMetadataGasForTxScript({
  gasCosts,
  txBytesSize
}) {
  return resolveGasDependentCosts(txBytesSize, gasCosts.s256);
}

// src/providers/utils/json.ts
var import_utils7 = require("@fuel-ts/utils");
var import_ramda = require("ramda");
function normalize(object) {
  Object.keys(object).forEach((key) => {
    switch (object[key]?.constructor.name) {
      case "Uint8Array":
        object[key] = (0, import_utils7.hexlify)(object[key]);
        break;
      case "Array":
        object[key] = normalize(object[key]);
        break;
      case "BN":
        object[key] = object[key].toHex();
        break;
      case "Address":
        object[key] = object[key].toB256();
        break;
      case "Object":
        object[key] = normalize(object[key]);
        break;
      default:
        break;
    }
  });
  return object;
}
function normalizeJSON(root) {
  return normalize((0, import_ramda.clone)(root));
}

// src/providers/utils/sleep.ts
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(true);
    }, time);
  });
}

// src/providers/transaction-request/errors.ts
var NoWitnessAtIndexError = class extends Error {
  constructor(index) {
    super();
    this.index = index;
    this.message = `Witness at index "${index}" was not found`;
  }
  name = "NoWitnessAtIndexError";
};

// src/providers/transaction-request/witness.ts
var import_utils8 = require("@fuel-ts/utils");
var witnessify = (value) => {
  const data = (0, import_utils8.arrayify)(value);
  return {
    data: (0, import_utils8.hexlify)(data),
    dataLength: data.length
  };
};

// src/providers/transaction-request/transaction-request.ts
var BaseTransactionRequest = class {
  /** Gas price for transaction */
  gasPrice;
  /** Block until which tx cannot be included */
  maturity;
  /** The maximum fee payable by this transaction using BASE_ASSET. */
  maxFee;
  /** The maximum amount of witness data allowed for the transaction */
  witnessLimit;
  /** List of inputs */
  inputs = [];
  /** List of outputs */
  outputs = [];
  /** List of witnesses */
  witnesses = [];
  /**
   * Constructor for initializing a base transaction request.
   *
   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
   */
  constructor({
    gasPrice,
    maturity,
    maxFee,
    witnessLimit,
    inputs,
    outputs,
    witnesses
  } = {}) {
    this.gasPrice = (0, import_math6.bn)(gasPrice);
    this.maturity = maturity ?? 0;
    this.witnessLimit = witnessLimit ? (0, import_math6.bn)(witnessLimit) : void 0;
    this.maxFee = maxFee ? (0, import_math6.bn)(maxFee) : void 0;
    this.inputs = inputs ?? [];
    this.outputs = outputs ?? [];
    this.witnesses = witnesses ?? [];
  }
  static getPolicyMeta(req) {
    let policyTypes = 0;
    const policies = [];
    if (req.gasPrice) {
      policyTypes += import_transactions5.PolicyType.GasPrice;
      policies.push({ data: req.gasPrice, type: import_transactions5.PolicyType.GasPrice });
    }
    if (req.witnessLimit) {
      policyTypes += import_transactions5.PolicyType.WitnessLimit;
      policies.push({ data: req.witnessLimit, type: import_transactions5.PolicyType.WitnessLimit });
    }
    if (req.maturity > 0) {
      policyTypes += import_transactions5.PolicyType.Maturity;
      policies.push({ data: req.maturity, type: import_transactions5.PolicyType.Maturity });
    }
    if (req.maxFee) {
      policyTypes += import_transactions5.PolicyType.MaxFee;
      policies.push({ data: req.maxFee, type: import_transactions5.PolicyType.MaxFee });
    }
    return {
      policyTypes,
      policies
    };
  }
  /**
   * Method to obtain the base transaction details.
   *
   * @returns The base transaction details.
   */
  getBaseTransaction() {
    const inputs = this.inputs?.map(inputify) ?? [];
    const outputs = this.outputs?.map(outputify) ?? [];
    const witnesses = this.witnesses?.map(witnessify) ?? [];
    const { policyTypes, policies } = BaseTransactionRequest.getPolicyMeta(this);
    return {
      policyTypes,
      inputs,
      outputs,
      policies,
      witnesses,
      inputsCount: inputs.length,
      outputsCount: outputs.length,
      witnessesCount: witnesses.length
    };
  }
  /**
   * Converts the transaction request to a byte array.
   *
   * @returns The transaction bytes.
   */
  toTransactionBytes() {
    return new import_transactions5.TransactionCoder().encode(this.toTransaction());
  }
  /**
   * @hidden
   *
   * Pushes an input to the list without any side effects and returns the index
   */
  pushInput(input) {
    this.inputs.push(input);
    return this.inputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes an output to the list without any side effects and returns the index
   */
  pushOutput(output) {
    this.outputs.push(output);
    return this.outputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes a witness to the list and returns the index
   *
   * @param signature - The signature to add to the witness.
   * @returns The index of the created witness.
   */
  addWitness(signature) {
    this.witnesses.push(signature);
    return this.witnesses.length - 1;
  }
  /**
   * @hidden
   *
   * Creates an empty witness without any side effects and returns the index
   *
   * @returns The index of the created witness.
   */
  addEmptyWitness() {
    this.addWitness((0, import_utils9.concat)([import_configs6.ZeroBytes32, import_configs6.ZeroBytes32]));
    return this.witnesses.length - 1;
  }
  /**
   * Updates the witness for a given owner and signature.
   *
   * @param address - The address to get the coin input witness index for.
   * @param signature - The signature to update the witness with.
   */
  updateWitnessByOwner(address, signature) {
    const ownerAddress = import_address.Address.fromAddressOrString(address);
    const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
    if (typeof witnessIndex === "number") {
      this.updateWitness(witnessIndex, signature);
    }
  }
  /**
   * Updates an existing witness without any side effects.
   *
   * @param index - The index of the witness to update.
   * @param witness - The new witness.
   * @throws If the witness does not exist.
   */
  updateWitness(index, witness) {
    if (!this.witnesses[index]) {
      throw new NoWitnessAtIndexError(index);
    }
    this.witnesses[index] = witness;
  }
  /**
   * Helper function to add an external signature to the transaction.
   *
   * @param account - The account/s to sign to the transaction.
   * @returns The transaction with the signature witness added.
   */
  async addAccountWitnesses(account) {
    const accounts = Array.isArray(account) ? account : [account];
    await Promise.all(
      accounts.map(async (acc) => {
        this.addWitness(await acc.signTransaction(this));
      })
    );
    return this;
  }
  /**
   * Gets the coin inputs for a transaction.
   *
   * @returns The coin inputs.
   */
  getCoinInputs() {
    return this.inputs.filter(
      (input) => input.type === import_transactions5.InputType.Coin
    );
  }
  /**
   * Gets the coin outputs for a transaction.
   *
   * @returns The coin outputs.
   */
  getCoinOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions5.OutputType.Coin
    );
  }
  /**
   * Gets the change outputs for a transaction.
   *
   * @returns The change outputs.
   */
  getChangeOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions5.OutputType.Change
    );
  }
  /**
   * @hidden
   *
   * Returns the witnessIndex of the found CoinInput.
   */
  getCoinInputWitnessIndexByOwner(owner) {
    const ownerAddress = (0, import_address.addressify)(owner);
    const found = this.inputs.find((input) => {
      switch (input.type) {
        case import_transactions5.InputType.Coin:
          return (0, import_utils9.hexlify)(input.owner) === ownerAddress.toB256();
        case import_transactions5.InputType.Message:
          return (0, import_utils9.hexlify)(input.recipient) === ownerAddress.toB256();
        default:
          return false;
      }
    });
    return found?.witnessIndex;
  }
  /**
   * Adds a single coin input to the transaction and a change output for the related
   * assetId, if one it was not added yet.
   *
   * @param coin - Coin resource.
   * @param predicate - Predicate bytes.
   * @param predicateData - Predicate data bytes.
   */
  addCoinInput(coin, predicate) {
    const { assetId, owner, amount } = coin;
    let witnessIndex;
    if (predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.addEmptyWitness();
      }
    }
    const input = {
      ...coin,
      type: import_transactions5.InputType.Coin,
      owner: owner.toB256(),
      amount,
      assetId,
      txPointer: "0x00000000000000000000000000000000",
      witnessIndex,
      predicate: predicate?.bytes,
      predicateData: predicate?.predicateDataBytes
    };
    this.pushInput(input);
    this.addChangeOutput(owner, assetId);
  }
  /**
   * Adds a single message input to the transaction and a change output for the
   * baseAssetId, if one it was not added yet.
   *
   * @param message - Message resource.
   * @param predicate - Predicate bytes.
   * @param predicateData - Predicate data bytes.
   */
  addMessageInput(message, predicate) {
    const { recipient, sender, amount } = message;
    const assetId = import_configs6.BaseAssetId;
    let witnessIndex;
    if (predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.addEmptyWitness();
      }
    }
    const input = {
      ...message,
      type: import_transactions5.InputType.Message,
      sender: sender.toB256(),
      recipient: recipient.toB256(),
      amount,
      witnessIndex,
      predicate: predicate?.bytes,
      predicateData: predicate?.predicateDataBytes
    };
    this.pushInput(input);
    this.addChangeOutput(recipient, assetId);
  }
  /**
   * Adds a single resource to the transaction by adding a coin/message input and a
   * change output for the related assetId, if one it was not added yet.
   *
   * @param resource - The resource to add.
   * @returns This transaction.
   */
  addResource(resource) {
    if (isCoin(resource)) {
      this.addCoinInput(resource);
    } else {
      this.addMessageInput(resource);
    }
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addResources(resources) {
    resources.forEach((resource) => this.addResource(resource));
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addPredicateResource(resource, predicate) {
    if (isCoin(resource)) {
      this.addCoinInput(resource, predicate);
    } else {
      this.addMessageInput(resource, predicate);
    }
    return this;
  }
  /**
   * Adds multiple predicate coin/message inputs to the transaction and change outputs
   * from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addPredicateResources(resources, predicate) {
    resources.forEach((resource) => this.addPredicateResource(resource, predicate));
    return this;
  }
  /**
   * Adds a coin output to the transaction.
   *
   * @param to - Address of the owner.
   * @param amount - Amount of coin.
   * @param assetId - Asset ID of coin.
   */
  addCoinOutput(to, amount, assetId = import_configs6.BaseAssetId) {
    this.pushOutput({
      type: import_transactions5.OutputType.Coin,
      to: (0, import_address.addressify)(to).toB256(),
      amount,
      assetId
    });
    return this;
  }
  /**
   * Adds multiple coin outputs to the transaction.
   *
   * @param to - Address of the destination.
   * @param quantities - Quantities of coins.
   */
  addCoinOutputs(to, quantities) {
    quantities.map(coinQuantityfy).forEach((quantity) => {
      this.pushOutput({
        type: import_transactions5.OutputType.Coin,
        to: (0, import_address.addressify)(to).toB256(),
        amount: quantity.amount,
        assetId: quantity.assetId
      });
    });
    return this;
  }
  /**
   * Adds a change output to the transaction.
   *
   * @param to - Address of the owner.
   * @param assetId - Asset ID of coin.
   */
  addChangeOutput(to, assetId = import_configs6.BaseAssetId) {
    const changeOutput = this.getChangeOutputs().find(
      (output) => (0, import_utils9.hexlify)(output.assetId) === assetId
    );
    if (!changeOutput) {
      this.pushOutput({
        type: import_transactions5.OutputType.Change,
        to: (0, import_address.addressify)(to).toB256(),
        assetId
      });
    }
  }
  /**
   * @hidden
   */
  byteSize() {
    return this.toTransactionBytes().length;
  }
  /**
   * @hidden
   */
  metadataGas(_gasCosts) {
    throw new Error("Not implemented");
  }
  /**
   * @hidden
   */
  calculateMinGas(chainInfo) {
    const { gasCosts, consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    return getMinGas({
      gasPerByte,
      gasCosts,
      inputs: this.inputs,
      txBytesSize: this.byteSize(),
      metadataGas: this.metadataGas(gasCosts)
    });
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit
    });
  }
  /**
   * Funds the transaction with fake UTXOs for each assetId and amount in the
   * quantities array.
   *
   * @param quantities - CoinQuantity Array.
   */
  fundWithFakeUtxos(quantities, resourcesOwner) {
    let idCounter = 0;
    const generateId = () => {
      const counterString = String(idCounter++);
      const id = import_configs6.ZeroBytes32.slice(0, -counterString.length).concat(counterString);
      return id;
    };
    const findAssetInput = (assetId) => this.inputs.find((input) => {
      if ("assetId" in input) {
        return input.assetId === assetId;
      }
      return false;
    });
    const updateAssetInput = (assetId, quantity) => {
      const assetInput = findAssetInput(assetId);
      if (assetInput && "assetId" in assetInput) {
        assetInput.id = generateId();
        assetInput.amount = quantity;
      } else {
        this.addResources([
          {
            id: generateId(),
            amount: quantity,
            assetId,
            owner: resourcesOwner || import_address.Address.fromRandom(),
            maturity: 0,
            blockCreated: (0, import_math6.bn)(1),
            txCreatedIdx: (0, import_math6.bn)(1)
          }
        ]);
      }
    };
    updateAssetInput(import_configs6.BaseAssetId, (0, import_math6.bn)(1e11));
    quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
  }
  /**
   * Retrieves an array of CoinQuantity for each coin output present in the transaction.
   * a transaction.
   *
   * @returns  CoinQuantity array.
   */
  getCoinOutputsQuantities() {
    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
      amount: (0, import_math6.bn)(amount),
      assetId: assetId.toString()
    }));
    return coinsQuantities;
  }
  /**
   * Return the minimum amount in native coins required to create
   * a transaction.
   *
   * @returns The transaction as a JSON object.
   */
  toJSON() {
    return normalizeJSON(this);
  }
  updatePredicateInputs(inputs) {
    this.inputs.forEach((i) => {
      let correspondingInput;
      switch (i.type) {
        case import_transactions5.InputType.Coin:
          correspondingInput = inputs.find((x) => x.type === import_transactions5.InputType.Coin && x.owner === i.owner);
          break;
        case import_transactions5.InputType.Message:
          correspondingInput = inputs.find(
            (x) => x.type === import_transactions5.InputType.Message && x.sender === i.sender
          );
          break;
        default:
          return;
      }
      if (correspondingInput && "predicateGasUsed" in correspondingInput && (0, import_math6.bn)(correspondingInput.predicateGasUsed).gt(0)) {
        i.predicate = correspondingInput.predicate;
        i.predicateData = correspondingInput.predicateData;
        i.predicateGasUsed = correspondingInput.predicateGasUsed;
      }
    });
  }
};

// src/providers/transaction-request/create-transaction-request.ts
var import_configs8 = require("@fuel-ts/address/configs");
var import_math8 = require("@fuel-ts/math");
var import_transactions7 = require("@fuel-ts/transactions");
var import_utils13 = require("@fuel-ts/utils");

// src/providers/transaction-request/hash-transaction.ts
var import_configs7 = require("@fuel-ts/address/configs");
var import_hasher = require("@fuel-ts/hasher");
var import_math7 = require("@fuel-ts/math");
var import_transactions6 = require("@fuel-ts/transactions");
var import_utils11 = require("@fuel-ts/utils");
var import_ramda2 = require("ramda");
function hashTransaction(transactionRequest, chainId) {
  const transaction = transactionRequest.toTransaction();
  if (transaction.type === import_transactions6.TransactionType.Script) {
    transaction.receiptsRoot = import_configs7.ZeroBytes32;
  }
  transaction.inputs = transaction.inputs.map((input) => {
    const inputClone = (0, import_ramda2.clone)(input);
    switch (inputClone.type) {
      case import_transactions6.InputType.Coin: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.predicateGasUsed = (0, import_math7.bn)(0);
        return inputClone;
      }
      case import_transactions6.InputType.Message: {
        inputClone.predicateGasUsed = (0, import_math7.bn)(0);
        return inputClone;
      }
      case import_transactions6.InputType.Contract: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.txID = import_configs7.ZeroBytes32;
        inputClone.outputIndex = 0;
        inputClone.balanceRoot = import_configs7.ZeroBytes32;
        inputClone.stateRoot = import_configs7.ZeroBytes32;
        return inputClone;
      }
      default:
        return inputClone;
    }
  });
  transaction.outputs = transaction.outputs.map((output) => {
    const outputClone = (0, import_ramda2.clone)(output);
    switch (outputClone.type) {
      case import_transactions6.OutputType.Contract: {
        outputClone.balanceRoot = import_configs7.ZeroBytes32;
        outputClone.stateRoot = import_configs7.ZeroBytes32;
        return outputClone;
      }
      case import_transactions6.OutputType.Change: {
        outputClone.amount = (0, import_math7.bn)(0);
        return outputClone;
      }
      case import_transactions6.OutputType.Variable: {
        outputClone.to = import_configs7.ZeroBytes32;
        outputClone.amount = (0, import_math7.bn)(0);
        outputClone.assetId = import_configs7.ZeroBytes32;
        return outputClone;
      }
      default:
        return outputClone;
    }
  });
  transaction.witnessesCount = 0;
  transaction.witnesses = [];
  const chainIdBytes = (0, import_hasher.uint64ToBytesBE)(chainId);
  const concatenatedData = (0, import_utils11.concat)([chainIdBytes, new import_transactions6.TransactionCoder().encode(transaction)]);
  return (0, import_hasher.sha256)(concatenatedData);
}

// src/providers/transaction-request/storage-slot.ts
var import_utils12 = require("@fuel-ts/utils");
var getStorageValue = (value) => {
  const v = new Uint8Array(32);
  v.set((0, import_utils12.arrayify)(value));
  return v;
};
var storageSlotify = (storageSlot) => {
  let key;
  let value;
  if (Array.isArray(storageSlot)) {
    key = storageSlot[0];
    value = storageSlot[1];
  } else {
    key = storageSlot.key;
    value = storageSlot.value;
  }
  return {
    key: (0, import_utils12.hexlify)(key),
    value: (0, import_utils12.hexlify)(getStorageValue(value))
  };
};

// src/providers/transaction-request/create-transaction-request.ts
var CreateTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  /** Type of the transaction */
  type = import_transactions7.TransactionType.Create;
  /** Witness index of contract bytecode to create */
  bytecodeWitnessIndex;
  /** Salt */
  salt;
  /** List of storage slots to initialize */
  storageSlots;
  /**
   * Creates an instance `CreateTransactionRequest`.
   *
   * @param createTransactionRequestLike - The initial values for the instance
   */
  constructor({
    bytecodeWitnessIndex,
    salt,
    storageSlots,
    ...rest
  } = {}) {
    super(rest);
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.salt = (0, import_utils13.hexlify)(salt ?? import_configs8.ZeroBytes32);
    this.storageSlots = [...storageSlots ?? []];
  }
  /**
   * Converts the transaction request to a `TransactionCreate`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];
    return {
      type: import_transactions7.TransactionType.Create,
      ...baseTransaction,
      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,
      bytecodeWitnessIndex,
      storageSlotsCount: storageSlots.length,
      salt: this.salt ? (0, import_utils13.hexlify)(this.salt) : import_configs8.ZeroBytes32,
      storageSlots
    };
  }
  /**
   * Get contract created outputs for the transaction.
   *
   * @returns An array of contract created transaction request outputs.
   */
  getContractCreatedOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions7.OutputType.ContractCreated
    );
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Adds a contract created output to the transaction request.
   *
   * @param contractId - The contract ID.
   * @param stateRoot - The state root.
   */
  addContractCreatedOutput(contractId, stateRoot) {
    this.pushOutput({
      type: import_transactions7.OutputType.ContractCreated,
      contractId,
      stateRoot
    });
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxCreate({
      contractBytesSize: (0, import_math8.bn)((0, import_utils13.arrayify)(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
      gasCosts,
      stateRootSize: this.storageSlots.length,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/script-transaction-request.ts
var import_abi_coder = require("@fuel-ts/abi-coder");
var import_address2 = require("@fuel-ts/address");
var import_configs9 = require("@fuel-ts/address/configs");
var import_math9 = require("@fuel-ts/math");
var import_transactions8 = require("@fuel-ts/transactions");
var import_utils15 = require("@fuel-ts/utils");

// src/providers/transaction-request/scripts.ts
var import_utils14 = require("@fuel-ts/utils");
var returnZeroScript = {
  /*
      Opcode::RET(REG_ZERO)
      Opcode::NOOP
    */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: (0, import_utils14.arrayify)("0x24000000"),
  encodeScriptData: () => new Uint8Array(0)
};
var withdrawScript = {
  /*
          The following code loads some basic values into registers and calls SMO to create an output message
          5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
          5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
          4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
          24000000	- RET                [return 0]
          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
          00000000 00000000 [amount value]
      */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: (0, import_utils14.arrayify)("0x5040C0105D44C0064C40001124000000"),
  encodeScriptData: () => new Uint8Array(0)
};

// src/providers/transaction-request/script-transaction-request.ts
var ScriptTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  /** Type of the transaction */
  type = import_transactions8.TransactionType.Script;
  /** Gas limit for transaction */
  gasLimit;
  /** Script to execute */
  script;
  /** Script input data (parameters) */
  scriptData;
  abis;
  /**
   * Constructor for `ScriptTransactionRequest`.
   *
   * @param scriptTransactionRequestLike - The initial values for the instance.
   */
  constructor({ script, scriptData, gasLimit, ...rest } = {}) {
    super(rest);
    this.gasLimit = (0, import_math9.bn)(gasLimit);
    this.script = (0, import_utils15.arrayify)(script ?? returnZeroScript.bytes);
    this.scriptData = (0, import_utils15.arrayify)(scriptData ?? returnZeroScript.encodeScriptData());
    this.abis = rest.abis;
  }
  /**
   * Converts the transaction request to a `TransactionScript`.
   *
   * @returns The transaction script object.
   */
  toTransaction() {
    const script = (0, import_utils15.arrayify)(this.script ?? "0x");
    const scriptData = (0, import_utils15.arrayify)(this.scriptData ?? "0x");
    return {
      type: import_transactions8.TransactionType.Script,
      scriptGasLimit: this.gasLimit,
      ...super.getBaseTransaction(),
      scriptLength: script.length,
      scriptDataLength: scriptData.length,
      receiptsRoot: import_configs9.ZeroBytes32,
      script: (0, import_utils15.hexlify)(script),
      scriptData: (0, import_utils15.hexlify)(scriptData)
    };
  }
  /**
   * Get contract inputs for the transaction.
   *
   * @returns An array of contract transaction request inputs.
   */
  getContractInputs() {
    return this.inputs.filter(
      (input) => input.type === import_transactions8.InputType.Contract
    );
  }
  /**
   * Get contract outputs for the transaction.
   *
   * @returns An array of contract transaction request outputs.
   */
  getContractOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions8.OutputType.Contract
    );
  }
  /**
   * Get variable outputs for the transaction.
   *
   * @returns An array of variable transaction request outputs.
   */
  getVariableOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions8.OutputType.Variable
    );
  }
  /**
   * Set the script and its data.
   *
   * @param script - The abstract script request.
   * @param data - The script data.
   */
  setScript(script, data) {
    this.scriptData = script.encodeScriptData(data);
    this.script = script.bytes;
  }
  /**
   * Adds variable outputs to the transaction request.
   *
   * @param numberOfVariables - The number of variables to add.
   * @returns The new length of the outputs array.
   */
  addVariableOutputs(numberOfVariables = 1) {
    let outputsNumber = numberOfVariables;
    while (outputsNumber) {
      this.pushOutput({
        type: import_transactions8.OutputType.Variable
      });
      outputsNumber -= 1;
    }
    return this.outputs.length - 1;
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      gasLimit: this.gasLimit
    });
  }
  /**
   * Adds a contract input and output to the transaction request.
   *
   * @param contract - The contract ID.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  addContractInputAndOutput(contract) {
    const contractAddress = (0, import_address2.addressify)(contract);
    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
      return this;
    }
    const inputIndex = super.pushInput({
      type: import_transactions8.InputType.Contract,
      contractId: contractAddress.toB256(),
      txPointer: "0x00000000000000000000000000000000"
    });
    this.pushOutput({
      type: import_transactions8.OutputType.Contract,
      inputIndex
    });
    return this;
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Sets the data for the transaction request.
   *
   * @param abi - Script JSON ABI.
   * @param args - The input arguments.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  setData(abi, args) {
    const abiInterface = new import_abi_coder.Interface(abi);
    this.scriptData = abiInterface.functions.main.encodeArguments(args);
    return this;
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/utils.ts
var import_errors8 = require("@fuel-ts/errors");
var import_transactions9 = require("@fuel-ts/transactions");
var transactionRequestify = (obj) => {
  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {
    return obj;
  }
  const { type } = obj;
  switch (obj.type) {
    case import_transactions9.TransactionType.Script: {
      return ScriptTransactionRequest.from(obj);
    }
    case import_transactions9.TransactionType.Create: {
      return CreateTransactionRequest.from(obj);
    }
    default: {
      throw new import_errors8.FuelError(import_errors8.ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type}.`);
    }
  }
};

// src/providers/transaction-response/transaction-response.ts
var import_errors12 = require("@fuel-ts/errors");
var import_math13 = require("@fuel-ts/math");
var import_transactions16 = require("@fuel-ts/transactions");
var import_utils21 = require("@fuel-ts/utils");

// src/providers/transaction-summary/assemble-transaction-summary.ts
var import_utils19 = require("@fuel-ts/utils");

// src/providers/transaction-summary/calculate-transaction-fee.ts
var import_math10 = require("@fuel-ts/math");
var import_transactions10 = require("@fuel-ts/transactions");
var import_utils16 = require("@fuel-ts/utils");
var calculateTransactionFee = (params) => {
  const {
    gasUsed,
    rawPayload,
    consensusParameters: { gasCosts, feeParams }
  } = params;
  const gasPerByte = (0, import_math10.bn)(feeParams.gasPerByte);
  const gasPriceFactor = (0, import_math10.bn)(feeParams.gasPriceFactor);
  const transactionBytes = (0, import_utils16.arrayify)(rawPayload);
  const [transaction] = new import_transactions10.TransactionCoder().decode(transactionBytes, 0);
  if (transaction.type === import_transactions10.TransactionType.Mint) {
    return {
      fee: (0, import_math10.bn)(0),
      minFee: (0, import_math10.bn)(0),
      maxFee: (0, import_math10.bn)(0),
      feeFromGasUsed: (0, import_math10.bn)(0)
    };
  }
  const { type, witnesses, inputs, policies } = transaction;
  let metadataGas = (0, import_math10.bn)(0);
  let gasLimit = (0, import_math10.bn)(0);
  if (type === import_transactions10.TransactionType.Create) {
    const { bytecodeWitnessIndex, storageSlots } = transaction;
    const contractBytesSize = (0, import_math10.bn)((0, import_utils16.arrayify)(witnesses[bytecodeWitnessIndex].data).length);
    metadataGas = calculateMetadataGasForTxCreate({
      contractBytesSize,
      gasCosts,
      stateRootSize: storageSlots.length || 0,
      txBytesSize: transactionBytes.length
    });
  } else {
    const { scriptGasLimit } = transaction;
    if (scriptGasLimit) {
      gasLimit = scriptGasLimit;
    }
    metadataGas = calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: transactionBytes.length
    });
  }
  const minGas = getMinGas({
    gasCosts,
    gasPerByte: (0, import_math10.bn)(gasPerByte),
    inputs,
    metadataGas,
    txBytesSize: transactionBytes.length
  });
  const gasPrice = (0, import_math10.bn)(policies.find((policy) => policy.type === import_transactions10.PolicyType.GasPrice)?.data);
  const witnessLimit = policies.find((policy) => policy.type === import_transactions10.PolicyType.WitnessLimit)?.data;
  const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
  const maxGas = getMaxGas({
    gasPerByte,
    minGas,
    witnessesLength,
    gasLimit,
    witnessLimit
  });
  const feeFromGasUsed = calculatePriceWithFactor(gasUsed, gasPrice, gasPriceFactor);
  const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor);
  const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor);
  const fee = minFee.add(feeFromGasUsed);
  return {
    fee,
    minFee,
    maxFee,
    feeFromGasUsed
  };
};

// src/providers/transaction-summary/operations.ts
var import_configs10 = require("@fuel-ts/address/configs");
var import_errors10 = require("@fuel-ts/errors");
var import_math12 = require("@fuel-ts/math");
var import_transactions13 = require("@fuel-ts/transactions");

// src/providers/transaction-summary/call.ts
var import_abi_coder2 = require("@fuel-ts/abi-coder");
var import_math11 = require("@fuel-ts/math");
var getFunctionCall = ({ abi, receipt, rawPayload, maxInputs }) => {
  const abiInterface = new import_abi_coder2.Interface(abi);
  const callFunctionSelector = receipt.param1.toHex(8);
  const functionFragment = abiInterface.getFunction(callFunctionSelector);
  const inputs = functionFragment.jsonFn.inputs;
  let encodedArgs;
  if (functionFragment.isInputDataPointer) {
    if (rawPayload) {
      const argsOffset = (0, import_math11.bn)(receipt.param2).sub((0, import_abi_coder2.calculateVmTxMemory)({ maxInputs: maxInputs.toNumber() })).toNumber();
      encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;
    }
  } else {
    encodedArgs = receipt.param2.toHex();
  }
  let argumentsProvided;
  if (encodedArgs) {
    const data = functionFragment.decodeArguments(encodedArgs);
    if (data) {
      argumentsProvided = inputs.reduce((prev, input, index) => {
        const value = data[index];
        const name = input.name;
        if (name) {
          return {
            ...prev,
            // reparse to remove bn
            [name]: JSON.parse(JSON.stringify(value))
          };
        }
        return prev;
      }, {});
    }
  }
  const call = {
    functionSignature: functionFragment.signature,
    functionName: functionFragment.name,
    argumentsProvided,
    ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
  };
  return call;
};

// src/providers/transaction-summary/input.ts
var import_errors9 = require("@fuel-ts/errors");
var import_transactions11 = require("@fuel-ts/transactions");
function getInputsByTypes(inputs, types) {
  return inputs.filter((i) => types.includes(i.type));
}
function getInputsByType(inputs, type) {
  return inputs.filter((i) => i.type === type);
}
function getInputsCoin(inputs) {
  return getInputsByType(inputs, import_transactions11.InputType.Coin);
}
function getInputsMessage(inputs) {
  return getInputsByType(inputs, import_transactions11.InputType.Message);
}
function getInputsCoinAndMessage(inputs) {
  return getInputsByTypes(inputs, [import_transactions11.InputType.Coin, import_transactions11.InputType.Message]);
}
function getInputsContract(inputs) {
  return getInputsByType(inputs, import_transactions11.InputType.Contract);
}
function getInputFromAssetId(inputs, assetId) {
  const coinInputs = getInputsCoin(inputs);
  const messageInputs = getInputsMessage(inputs);
  const coinInput = coinInputs.find((i) => i.assetId === assetId);
  const messageInput = messageInputs.find(
    (_) => assetId === "0x0000000000000000000000000000000000000000000000000000000000000000"
  );
  return coinInput || messageInput;
}
function getInputContractFromIndex(inputs, inputIndex) {
  if (inputIndex == null) {
    return void 0;
  }
  const contractInput = inputs?.[inputIndex];
  if (!contractInput) {
    return void 0;
  }
  if (contractInput.type !== import_transactions11.InputType.Contract) {
    throw new import_errors9.FuelError(
      import_errors9.ErrorCode.INVALID_TRANSACTION_INPUT,
      `Contract input should be of type 'contract'.`
    );
  }
  return contractInput;
}
function getInputAccountAddress(input) {
  if (input.type === import_transactions11.InputType.Coin) {
    return input.owner.toString();
  }
  if (input.type === import_transactions11.InputType.Message) {
    return input.recipient.toString();
  }
  return "";
}

// src/providers/transaction-summary/output.ts
var import_transactions12 = require("@fuel-ts/transactions");
function getOutputsByType(outputs, type) {
  return outputs.filter((o) => o.type === type);
}
function getOutputsContractCreated(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.ContractCreated);
}
function getOutputsCoin(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.Coin);
}
function getOutputsChange(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.Change);
}
function getOutputsContract(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.Contract);
}

// src/providers/transaction-summary/operations.ts
function getReceiptsByType(receipts, type) {
  return (receipts ?? []).filter((r) => r.type === type);
}
function getTransactionTypeName(transactionType) {
  switch (transactionType) {
    case import_transactions13.TransactionType.Mint:
      return "Mint" /* Mint */;
    case import_transactions13.TransactionType.Create:
      return "Create" /* Create */;
    case import_transactions13.TransactionType.Script:
      return "Script" /* Script */;
    default:
      throw new import_errors10.FuelError(
        import_errors10.ErrorCode.INVALID_TRANSACTION_TYPE,
        `Invalid transaction type: ${transactionType}.`
      );
  }
}
function isType(transactionType, type) {
  const txType = getTransactionTypeName(transactionType);
  return txType === type;
}
function isTypeMint(transactionType) {
  return isType(transactionType, "Mint" /* Mint */);
}
function isTypeCreate(transactionType) {
  return isType(transactionType, "Create" /* Create */);
}
function isTypeScript(transactionType) {
  return isType(transactionType, "Script" /* Script */);
}
function getReceiptsCall(receipts) {
  return getReceiptsByType(receipts, import_transactions13.ReceiptType.Call);
}
function getReceiptsMessageOut(receipts) {
  return getReceiptsByType(receipts, import_transactions13.ReceiptType.MessageOut);
}
var mergeAssets = (op1, op2) => {
  const assets1 = op1.assetsSent || [];
  const assets2 = op2.assetsSent || [];
  const filteredAssets = assets2.filter(
    (asset2) => !assets1.some((asset1) => asset1.assetId === asset2.assetId)
  );
  const mergedAssets = assets1.map((asset1) => {
    const matchingAsset = assets2.find((asset2) => asset2.assetId === asset1.assetId);
    if (!matchingAsset) {
      return asset1;
    }
    const mergedAmount = (0, import_math12.bn)(asset1.amount).add(matchingAsset.amount);
    return { ...asset1, amount: mergedAmount };
  });
  return mergedAssets.concat(filteredAssets);
};
function isSameOperation(a, b) {
  return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
}
function addOperation(operations, toAdd) {
  const allOperations = [...operations];
  const index = allOperations.findIndex((op) => isSameOperation(op, toAdd));
  if (allOperations[index]) {
    const existentOperation = { ...allOperations[index] };
    if (toAdd.assetsSent?.length) {
      existentOperation.assetsSent = existentOperation.assetsSent?.length ? mergeAssets(existentOperation, toAdd) : toAdd.assetsSent;
    }
    if (toAdd.calls?.length) {
      existentOperation.calls = [...existentOperation.calls || [], ...toAdd.calls];
    }
    allOperations[index] = existentOperation;
  } else {
    allOperations.push(toAdd);
  }
  return allOperations;
}
function getWithdrawFromFuelOperations({
  inputs,
  receipts
}) {
  const messageOutReceipts = getReceiptsMessageOut(receipts);
  const withdrawFromFuelOperations = messageOutReceipts.reduce(
    (prevWithdrawFromFuelOps, receipt) => {
      const assetId = "0x0000000000000000000000000000000000000000000000000000000000000000";
      const input = getInputFromAssetId(inputs, assetId);
      if (input) {
        const inputAddress = getInputAccountAddress(input);
        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
          name: "Withdraw from Fuel" /* withdrawFromFuel */,
          from: {
            type: 1 /* account */,
            address: inputAddress
          },
          to: {
            type: 1 /* account */,
            address: receipt.recipient.toString(),
            chain: "ethereum" /* ethereum */
          },
          assetsSent: [
            {
              amount: receipt.amount,
              assetId
            }
          ]
        });
        return newWithdrawFromFuelOps;
      }
      return prevWithdrawFromFuelOps;
    },
    []
  );
  return withdrawFromFuelOperations;
}
function getContractCallOperations({
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  const contractCallReceipts = getReceiptsCall(receipts);
  const contractOutputs = getOutputsContract(outputs);
  const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output) => {
    const contractInput = getInputContractFromIndex(inputs, output.inputIndex);
    if (contractInput) {
      const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {
        if (receipt.to === contractInput.contractID) {
          const input = getInputFromAssetId(inputs, receipt.assetId);
          if (input) {
            const inputAddress = getInputAccountAddress(input);
            const calls = [];
            const abi = abiMap?.[contractInput.contractID];
            if (abi) {
              calls.push(
                getFunctionCall({
                  abi,
                  receipt,
                  rawPayload,
                  maxInputs
                })
              );
            }
            const newContractCallOps = addOperation(prevContractCallOps, {
              name: "Contract call" /* contractCall */,
              from: {
                type: 1 /* account */,
                address: inputAddress
              },
              to: {
                type: 0 /* contract */,
                address: receipt.to
              },
              // if no amount is forwarded to the contract, skip showing assetsSent
              assetsSent: receipt.amount?.isZero() ? void 0 : [
                {
                  amount: receipt.amount,
                  assetId: receipt.assetId
                }
              ],
              calls
            });
            return newContractCallOps;
          }
        }
        return prevContractCallOps;
      }, prevOutputCallOps);
      return newCallOps;
    }
    return prevOutputCallOps;
  }, []);
  return contractCallOperations;
}
function extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs) {
  const { to: toAddress, assetId, amount } = receipt;
  let { from: fromAddress } = receipt;
  const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 /* contract */ : 1 /* account */;
  if (import_configs10.ZeroBytes32 === fromAddress) {
    const change = changeOutputs.find((output) => output.assetId === assetId);
    fromAddress = change?.to || fromAddress;
  }
  const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 /* contract */ : 1 /* account */;
  return {
    name: "Transfer asset" /* transfer */,
    from: {
      type: fromType,
      address: fromAddress
    },
    to: {
      type: toType,
      address: toAddress
    },
    assetsSent: [
      {
        assetId: assetId.toString(),
        amount
      }
    ]
  };
}
function getTransferOperations({
  inputs,
  outputs,
  receipts
}) {
  let operations = [];
  const coinOutputs = getOutputsCoin(outputs);
  const contractInputs = getInputsContract(inputs);
  const changeOutputs = getOutputsChange(outputs);
  coinOutputs.forEach((output) => {
    const { amount, assetId, to } = output;
    const changeOutput = changeOutputs.find((change) => change.assetId === assetId);
    if (changeOutput) {
      operations = addOperation(operations, {
        name: "Transfer asset" /* transfer */,
        from: {
          type: 1 /* account */,
          address: changeOutput.to
        },
        to: {
          type: 1 /* account */,
          address: to
        },
        assetsSent: [
          {
            assetId,
            amount
          }
        ]
      });
    }
  });
  const transferReceipts = getReceiptsByType(
    receipts,
    import_transactions13.ReceiptType.Transfer
  );
  const transferOutReceipts = getReceiptsByType(
    receipts,
    import_transactions13.ReceiptType.TransferOut
  );
  [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
    const operation = extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs);
    operations = addOperation(operations, operation);
  });
  return operations;
}
function getPayProducerOperations(outputs) {
  const coinOutputs = getOutputsCoin(outputs);
  const payProducerOperations = coinOutputs.reduce((prev, output) => {
    const operations = addOperation(prev, {
      name: "Pay network fee to block producer" /* payBlockProducer */,
      from: {
        type: 1 /* account */,
        address: "Network"
      },
      to: {
        type: 1 /* account */,
        address: output.to.toString()
      },
      assetsSent: [
        {
          assetId: output.assetId.toString(),
          amount: output.amount
        }
      ]
    });
    return operations;
  }, []);
  return payProducerOperations;
}
function getContractCreatedOperations({ inputs, outputs }) {
  const contractCreatedOutputs = getOutputsContractCreated(outputs);
  const input = getInputsCoinAndMessage(inputs)[0];
  const fromAddress = getInputAccountAddress(input);
  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
    const operations = addOperation(prev, {
      name: "Contract created" /* contractCreated */,
      from: {
        type: 1 /* account */,
        address: fromAddress
      },
      to: {
        type: 0 /* contract */,
        address: contractCreatedOutput?.contractId || ""
      }
    });
    return operations;
  }, []);
  return contractCreatedOperations;
}
function getOperations({
  transactionType,
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  if (isTypeCreate(transactionType)) {
    return [
      ...getContractCreatedOperations({ inputs, outputs }),
      ...getTransferOperations({ inputs, outputs, receipts })
    ];
  }
  if (isTypeScript(transactionType)) {
    return [
      ...getTransferOperations({ inputs, outputs, receipts }),
      ...getContractCallOperations({
        inputs,
        outputs,
        receipts,
        abiMap,
        rawPayload,
        maxInputs
      }),
      ...getWithdrawFromFuelOperations({ inputs, receipts })
    ];
  }
  return [...getPayProducerOperations(outputs)];
}

// src/providers/transaction-summary/receipt.ts
var import_transactions14 = require("@fuel-ts/transactions");
var processGqlReceipt = (gqlReceipt) => {
  const receipt = assembleReceiptByType(gqlReceipt);
  switch (receipt.type) {
    case import_transactions14.ReceiptType.ReturnData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    case import_transactions14.ReceiptType.LogData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    default:
      return receipt;
  }
};
var extractMintedAssetsFromReceipts = (receipts) => {
  const mintedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === import_transactions14.ReceiptType.Mint) {
      mintedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return mintedAssets;
};
var extractBurnedAssetsFromReceipts = (receipts) => {
  const burnedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === import_transactions14.ReceiptType.Burn) {
      burnedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return burnedAssets;
};

// src/providers/transaction-summary/status.ts
var import_errors11 = require("@fuel-ts/errors");
var getTransactionStatusName = (gqlStatus) => {
  switch (gqlStatus) {
    case "FailureStatus":
      return "failure" /* failure */;
    case "SuccessStatus":
      return "success" /* success */;
    case "SubmittedStatus":
      return "submitted" /* submitted */;
    case "SqueezedOutStatus":
      return "squeezedout" /* squeezedout */;
    default:
      throw new import_errors11.FuelError(
        import_errors11.ErrorCode.INVALID_TRANSACTION_STATUS,
        `Invalid transaction status: ${gqlStatus}.`
      );
  }
};
var processGraphqlStatus = (gqlTransactionStatus) => {
  let time;
  let blockId;
  let status;
  let isStatusFailure = false;
  let isStatusSuccess = false;
  let isStatusPending = false;
  if (gqlTransactionStatus?.type) {
    status = getTransactionStatusName(gqlTransactionStatus.type);
    switch (gqlTransactionStatus.type) {
      case "SuccessStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusSuccess = true;
        break;
      case "FailureStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusFailure = true;
        break;
      case "SubmittedStatus":
        time = gqlTransactionStatus.time;
        isStatusPending = true;
        break;
      default:
    }
  }
  const processedGraphqlStatus = {
    time,
    blockId,
    status,
    isStatusFailure,
    isStatusSuccess,
    isStatusPending
  };
  return processedGraphqlStatus;
};

// src/providers/transaction-summary/assemble-transaction-summary.ts
function assembleTransactionSummary(params) {
  const {
    id,
    receipts,
    gasPerByte,
    gasPriceFactor,
    transaction,
    transactionBytes,
    gqlTransactionStatus,
    abiMap = {},
    maxInputs,
    gasCosts
  } = params;
  const gasUsed = getGasUsedFromReceipts(receipts);
  const rawPayload = (0, import_utils19.hexlify)(transactionBytes);
  const operations = getOperations({
    transactionType: transaction.type,
    inputs: transaction.inputs || [],
    outputs: transaction.outputs || [],
    receipts,
    rawPayload,
    abiMap,
    maxInputs
  });
  const typeName = getTransactionTypeName(transaction.type);
  const { fee } = calculateTransactionFee({
    gasUsed,
    rawPayload,
    consensusParameters: {
      gasCosts,
      feeParams: {
        gasPerByte,
        gasPriceFactor
      }
    }
  });
  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } = processGraphqlStatus(gqlTransactionStatus);
  const mintedAssets = extractMintedAssetsFromReceipts(receipts);
  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
  let date;
  if (time) {
    date = import_utils19.DateTime.fromTai64(time);
  }
  const transactionSummary = {
    id,
    fee,
    gasUsed,
    operations,
    type: typeName,
    blockId,
    time,
    status,
    receipts,
    mintedAssets,
    burnedAssets,
    isTypeMint: isTypeMint(transaction.type),
    isTypeCreate: isTypeCreate(transaction.type),
    isTypeScript: isTypeScript(transaction.type),
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    date,
    transaction
  };
  return transactionSummary;
}

// src/providers/transaction-response/getDecodedLogs.ts
var import_abi_coder3 = require("@fuel-ts/abi-coder");
var import_transactions15 = require("@fuel-ts/transactions");
function getDecodedLogs(receipts, mainAbi, externalAbis = {}) {
  return receipts.reduce((logs, receipt) => {
    if (receipt.type === import_transactions15.ReceiptType.LogData || receipt.type === import_transactions15.ReceiptType.Log) {
      const interfaceToUse = new import_abi_coder3.Interface(externalAbis[receipt.id] || mainAbi);
      const data = receipt.type === import_transactions15.ReceiptType.Log ? new import_abi_coder3.BigNumberCoder("u64").encode(receipt.val0) : receipt.data;
      const [decodedLog] = interfaceToUse.decodeLog(data, receipt.val1.toNumber());
      logs.push(decodedLog);
    }
    return logs;
  }, []);
}

// src/providers/transaction-response/transaction-response.ts
var TransactionResponse = class {
  /** Transaction ID */
  id;
  /** Current provider */
  provider;
  /** Gas used on the transaction */
  gasUsed = (0, import_math13.bn)(0);
  /** The graphql Transaction with receipts object. */
  gqlTransaction;
  abis;
  /**
   * Constructor for `TransactionResponse`.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  constructor(id, provider, abis) {
    this.id = id;
    this.provider = provider;
    this.abis = abis;
  }
  /**
   * Async constructor for `TransactionResponse`. This method can be used to create
   * an instance of `TransactionResponse` and wait for the transaction to be fetched
   * from the chain, ensuring that the `gqlTransaction` property is set.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  static async create(id, provider, abis) {
    const response = new TransactionResponse(id, provider, abis);
    await response.fetch();
    return response;
  }
  /**
   * Fetch the transaction with receipts from the provider.
   *
   * @returns Transaction with receipts query result.
   */
  async fetch() {
    const response = await this.provider.operations.getTransactionWithReceipts({
      transactionId: this.id
    });
    if (!response.transaction) {
      const subscription = this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange } of subscription) {
        if (statusChange) {
          break;
        }
      }
      return this.fetch();
    }
    this.gqlTransaction = response.transaction;
    return response.transaction;
  }
  /**
   * Decode the raw payload of the transaction.
   *
   * @param transactionWithReceipts - The transaction with receipts object.
   * @returns The decoded transaction.
   */
  decodeTransaction(transactionWithReceipts) {
    return new import_transactions16.TransactionCoder().decode(
      (0, import_utils21.arrayify)(transactionWithReceipts.rawPayload),
      0
    )?.[0];
  }
  /**
   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
   * fetch it from the provider
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns
   */
  async getTransactionSummary(contractsAbiMap) {
    let transaction = this.gqlTransaction;
    if (!transaction) {
      transaction = await this.fetch();
    }
    const decodedTransaction = this.decodeTransaction(
      transaction
    );
    const receipts = transaction.receipts?.map(processGqlReceipt) || [];
    const { gasPerByte, gasPriceFactor, gasCosts } = this.provider.getGasConfig();
    const maxInputs = this.provider.getChain().consensusParameters.maxInputs;
    const transactionSummary = assembleTransactionSummary({
      id: this.id,
      receipts,
      transaction: decodedTransaction,
      transactionBytes: (0, import_utils21.arrayify)(transaction.rawPayload),
      gqlTransactionStatus: transaction.status,
      gasPerByte,
      gasPriceFactor,
      abiMap: contractsAbiMap,
      maxInputs,
      gasCosts
    });
    return transactionSummary;
  }
  async waitForStatusChange() {
    const status = this.gqlTransaction?.status?.type;
    if (status && status !== "SubmittedStatus") {
      return;
    }
    const subscription = this.provider.operations.statusChange({
      transactionId: this.id
    });
    for await (const { statusChange } of subscription) {
      if (statusChange.type === "SqueezedOutStatus") {
        throw new import_errors12.FuelError(
          import_errors12.ErrorCode.TRANSACTION_SQUEEZED_OUT,
          `Transaction Squeezed Out with reason: ${statusChange.reason}`
        );
      }
      if (statusChange.type !== "SubmittedStatus") {
        break;
      }
    }
    await this.fetch();
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @returns The completed transaction result
   */
  async waitForResult(contractsAbiMap) {
    await this.waitForStatusChange();
    const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
    const transactionResult = {
      gqlTransaction: this.gqlTransaction,
      ...transactionSummary
    };
    if (this.abis) {
      const logs = getDecodedLogs(
        transactionSummary.receipts,
        this.abis.main,
        this.abis.otherContractsAbis
      );
      transactionResult.logs = logs;
    }
    return transactionResult;
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   */
  async wait(contractsAbiMap) {
    const result = await this.waitForResult(contractsAbiMap);
    if (result.isStatusFailure) {
      throw new import_errors12.FuelError(
        import_errors12.ErrorCode.TRANSACTION_FAILED,
        `Transaction failed: ${result.gqlTransaction.status.reason}`
      );
    }
    return result;
  }
};

// src/providers/utils/auto-retry-fetch.ts
function getWaitDelay(options, retryAttemptNum) {
  const duration = options.baseDelay ?? 150;
  switch (options.backoff) {
    case "linear":
      return duration * retryAttemptNum;
    case "fixed":
      return duration;
    case "exponential":
    default:
      return 2 ** (retryAttemptNum - 1) * duration;
  }
}
function autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {
  if (options === void 0) {
    return fetchFn;
  }
  return async (...args) => {
    try {
      return await fetchFn(...args);
    } catch (_error) {
      const error = _error;
      if (error.cause?.code !== "ECONNREFUSED") {
        throw error;
      }
      const retryNum = retryAttemptNum + 1;
      if (retryNum > options.maxRetries) {
        throw error;
      }
      const delay = getWaitDelay(options, retryNum);
      await sleep(delay);
      return autoRetryFetch(fetchFn, options, retryNum)(...args);
    }
  };
}

// src/providers/utils/merge-quantities.ts
var mergeQuantities = (arr1, arr2) => {
  const resultMap = {};
  function addToMap({ amount, assetId }) {
    if (resultMap[assetId]) {
      resultMap[assetId] = resultMap[assetId].add(amount);
    } else {
      resultMap[assetId] = amount;
    }
  }
  arr1.forEach(addToMap);
  arr2.forEach(addToMap);
  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
};

// src/providers/provider.ts
var MAX_RETRIES = 10;
var processGqlChain = (chain) => {
  const { name, daHeight, consensusParameters, latestBlock } = chain;
  const { contractParams, feeParams, predicateParams, scriptParams, txParams, gasCosts } = consensusParameters;
  return {
    name,
    baseChainHeight: (0, import_math14.bn)(daHeight),
    consensusParameters: {
      contractMaxSize: (0, import_math14.bn)(contractParams.contractMaxSize),
      maxInputs: (0, import_math14.bn)(txParams.maxInputs),
      maxOutputs: (0, import_math14.bn)(txParams.maxOutputs),
      maxWitnesses: (0, import_math14.bn)(txParams.maxWitnesses),
      maxGasPerTx: (0, import_math14.bn)(txParams.maxGasPerTx),
      maxScriptLength: (0, import_math14.bn)(scriptParams.maxScriptLength),
      maxScriptDataLength: (0, import_math14.bn)(scriptParams.maxScriptDataLength),
      maxStorageSlots: (0, import_math14.bn)(contractParams.maxStorageSlots),
      maxPredicateLength: (0, import_math14.bn)(predicateParams.maxPredicateLength),
      maxPredicateDataLength: (0, import_math14.bn)(predicateParams.maxPredicateDataLength),
      maxGasPerPredicate: (0, import_math14.bn)(predicateParams.maxGasPerPredicate),
      gasPriceFactor: (0, import_math14.bn)(feeParams.gasPriceFactor),
      gasPerByte: (0, import_math14.bn)(feeParams.gasPerByte),
      maxMessageDataLength: (0, import_math14.bn)(predicateParams.maxMessageDataLength),
      chainId: (0, import_math14.bn)(consensusParameters.chainId),
      gasCosts
    },
    gasCosts,
    latestBlock: {
      id: latestBlock.id,
      height: (0, import_math14.bn)(latestBlock.header.height),
      time: latestBlock.header.time,
      transactions: latestBlock.transactions.map((i) => ({
        id: i.id
      }))
    }
  };
};
var _cacheInputs, cacheInputs_fn;
var _Provider = class {
  /**
   * Constructor to initialize a Provider.
   *
   * @param url - GraphQL endpoint of the Fuel node
   * @param chainInfo - Chain info of the Fuel node
   * @param options - Additional options for the provider
   * @hidden
   */
  constructor(url, options = {}) {
    this.url = url;
    /**
     * @hidden
     */
    __privateAdd(this, _cacheInputs);
    __publicField(this, "operations");
    __publicField(this, "cache");
    __publicField(this, "options", {
      timeout: void 0,
      cacheUtxo: void 0,
      fetch: void 0,
      retryOptions: void 0
    });
    this.options = { ...this.options, ...options };
    this.url = url;
    this.operations = this.createOperations();
    this.cache = options.cacheUtxo ? new MemoryCache(options.cacheUtxo) : void 0;
  }
  static clearChainAndNodeCaches() {
    _Provider.nodeInfoCache = {};
    _Provider.chainInfoCache = {};
  }
  static getFetchFn(options) {
    const { retryOptions, timeout } = options;
    return autoRetryFetch(async (...args) => {
      const url = args[0];
      const request = args[1];
      const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
      let fullRequest = { ...request, signal };
      if (options.requestMiddleware) {
        fullRequest = await options.requestMiddleware(fullRequest);
      }
      return options.fetch ? options.fetch(url, fullRequest, options) : fetch(url, fullRequest);
    }, retryOptions);
  }
  /**
   * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.
   * @param url - GraphQL endpoint of the Fuel node
   * @param options - Additional options for the provider
   */
  static async create(url, options = {}) {
    const provider = new _Provider(url, options);
    await provider.fetchChainAndNodeInfo();
    return provider;
  }
  /**
   * Returns the cached chainInfo for the current URL.
   */
  getChain() {
    const chain = _Provider.chainInfoCache[this.url];
    if (!chain) {
      throw new import_errors13.FuelError(
        import_errors13.ErrorCode.CHAIN_INFO_CACHE_EMPTY,
        "Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
      );
    }
    return chain;
  }
  /**
   * Returns the cached nodeInfo for the current URL.
   */
  getNode() {
    const node = _Provider.nodeInfoCache[this.url];
    if (!node) {
      throw new import_errors13.FuelError(
        import_errors13.ErrorCode.NODE_INFO_CACHE_EMPTY,
        "Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
      );
    }
    return node;
  }
  /**
   * Returns some helpful parameters related to gas fees.
   */
  getGasConfig() {
    const { minGasPrice } = this.getNode();
    const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte, gasCosts } = this.getChain().consensusParameters;
    return {
      minGasPrice,
      maxGasPerTx,
      maxGasPerPredicate,
      gasPriceFactor,
      gasPerByte,
      gasCosts
    };
  }
  /**
   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
   */
  async connect(url, options) {
    this.url = url;
    this.options = options ?? this.options;
    this.operations = this.createOperations();
    await this.fetchChainAndNodeInfo();
  }
  /**
   * Fetches both the chain and node information, saves it to the cache, and return it.
   *
   * @returns NodeInfo and Chain
   */
  async fetchChainAndNodeInfo() {
    const chain = await this.fetchChain();
    const nodeInfo = await this.fetchNode();
    _Provider.ensureClientVersionIsSupported(nodeInfo);
    return {
      chain,
      nodeInfo
    };
  }
  static ensureClientVersionIsSupported(nodeInfo) {
    const { isMajorSupported, isMinorSupported, supportedVersion } = (0, import_versions.checkFuelCoreVersionCompatibility)(nodeInfo.nodeVersion);
    if (!isMajorSupported || !isMinorSupported) {
      throw new import_errors13.FuelError(
        import_errors13.FuelError.CODES.UNSUPPORTED_FUEL_CLIENT_VERSION,
        `Fuel client version: ${nodeInfo.nodeVersion}, Supported version: ${supportedVersion}`
      );
    }
  }
  /**
   * Create GraphQL client and set operations.
   *
   * @returns The operation SDK object
   */
  createOperations() {
    const fetchFn = _Provider.getFetchFn(this.options);
    const gqlClient = new import_graphql_request.GraphQLClient(this.url, {
      fetch: (url, requestInit) => fetchFn(url, requestInit, this.options)
    });
    const executeQuery = (query, vars) => {
      const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
      const isSubscription = opDefinition?.operation === "subscription";
      if (isSubscription) {
        return new FuelGraphqlSubscriber({
          url: this.url,
          query,
          fetchFn: (url, requestInit) => fetchFn(url, requestInit, this.options),
          variables: vars
        });
      }
      return gqlClient.request(query, vars);
    };
    return getSdk(executeQuery);
  }
  /**
   * Returns the version of the connected node.
   *
   * @returns A promise that resolves to the version string.
   */
  async getVersion() {
    const {
      nodeInfo: { nodeVersion }
    } = await this.operations.getVersion();
    return nodeVersion;
  }
  /**
   * @hidden
   *
   * Returns the network configuration of the connected Fuel node.
   *
   * @returns A promise that resolves to the network configuration object
   */
  async getNetwork() {
    const {
      name,
      consensusParameters: { chainId }
    } = await this.getChain();
    const network = new import_ethers.Network(name, chainId.toNumber());
    return Promise.resolve(network);
  }
  /**
   * Returns the block number.
   *
   * @returns A promise that resolves to the block number
   */
  async getBlockNumber() {
    const { chain } = await this.operations.getChain();
    return (0, import_math14.bn)(chain.latestBlock.header.height, 10);
  }
  /**
   * Returns the chain information.
   * @param url - The URL of the Fuel node
   * @returns NodeInfo object
   */
  async fetchNode() {
    const { nodeInfo } = await this.operations.getNodeInfo();
    const processedNodeInfo = {
      maxDepth: (0, import_math14.bn)(nodeInfo.maxDepth),
      maxTx: (0, import_math14.bn)(nodeInfo.maxTx),
      minGasPrice: (0, import_math14.bn)(nodeInfo.minGasPrice),
      nodeVersion: nodeInfo.nodeVersion,
      utxoValidation: nodeInfo.utxoValidation,
      vmBacktrace: nodeInfo.vmBacktrace,
      peers: nodeInfo.peers
    };
    _Provider.nodeInfoCache[this.url] = processedNodeInfo;
    return processedNodeInfo;
  }
  /**
   * Fetches the `chainInfo` for the given node URL.
   * @param url - The URL of the Fuel node
   * @returns ChainInfo object
   */
  async fetchChain() {
    const { chain } = await this.operations.getChain();
    const processedChain = processGqlChain(chain);
    _Provider.chainInfoCache[this.url] = processedChain;
    return processedChain;
  }
  /**
   * Returns the chain ID
   * @returns A promise that resolves to the chain ID number
   */
  getChainId() {
    const {
      consensusParameters: { chainId }
    } = this.getChain();
    return chainId.toNumber();
  }
  /**
   * Submits a transaction to the chain to be executed.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @returns A promise that resolves to the transaction response object.
   */
  // #region Provider-sendTransaction
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution = false } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    __privateMethod(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs);
    if (estimateTxDependencies) {
      await this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = (0, import_utils22.hexlify)(transactionRequest.toTransactionBytes());
    let abis;
    if (transactionRequest.type === import_transactions17.TransactionType.Script) {
      abis = transactionRequest.abis;
    }
    if (awaitExecution) {
      const subscription = this.operations.submitAndAwait({ encodedTransaction });
      for await (const { submitAndAwait } of subscription) {
        if (submitAndAwait.type === "SqueezedOutStatus") {
          throw new import_errors13.FuelError(
            import_errors13.ErrorCode.TRANSACTION_SQUEEZED_OUT,
            `Transaction Squeezed Out with reason: ${submitAndAwait.reason}`
          );
        }
        if (submitAndAwait.type !== "SubmittedStatus") {
          break;
        }
      }
      const transactionId2 = transactionRequest.getTransactionId(this.getChainId());
      const response = new TransactionResponse(transactionId2, this, abis);
      await response.fetch();
      return response;
    }
    const {
      submit: { id: transactionId }
    } = await this.operations.submit({ encodedTransaction });
    return new TransactionResponse(transactionId, this, abis);
  }
  /**
   * Executes a transaction without actually submitting it to the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param utxoValidation - Additional provider call parameters.
   * @returns A promise that resolves to the call result object.
   */
  async call(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = (0, import_utils22.hexlify)(transactionRequest.toTransactionBytes());
    const { dryRun: gqlReceipts } = await this.operations.dryRun({
      encodedTransaction,
      utxoValidation: utxoValidation || false
    });
    const receipts = gqlReceipts.map(processGqlReceipt);
    return {
      receipts
    };
  }
  /**
   * Verifies whether enough gas is available to complete transaction.
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise that resolves to the estimated transaction request object.
   */
  async estimatePredicates(transactionRequest) {
    const shouldEstimatePredicates = Boolean(
      transactionRequest.inputs.find(
        (input) => "predicate" in input && input.predicate && !(0, import_utils23.equalBytes)((0, import_utils22.arrayify)(input.predicate), (0, import_utils22.arrayify)("0x")) && new import_math14.BN(input.predicateGasUsed).isZero()
      )
    );
    if (!shouldEstimatePredicates) {
      return transactionRequest;
    }
    const encodedTransaction = (0, import_utils22.hexlify)(transactionRequest.toTransactionBytes());
    const response = await this.operations.estimatePredicates({
      encodedTransaction
    });
    const {
      estimatePredicates: { inputs }
    } = response;
    if (inputs) {
      inputs.forEach((input, index) => {
        if ("predicateGasUsed" in input && (0, import_math14.bn)(input.predicateGasUsed).gt(0)) {
          transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
        }
      });
    }
    return transactionRequest;
  }
  /**
   * Will dryRun a transaction and check for missing dependencies.
   *
   * If there are missing variable outputs,
   * `addVariableOutputs` is called on the transaction.
   *
   * @privateRemarks
   * TODO: Investigate support for missing contract IDs
   * TODO: Add support for missing output messages
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise.
   */
  async estimateTxDependencies(transactionRequest) {
    if (transactionRequest.type === import_transactions17.TransactionType.Create) {
      return {
        receipts: [],
        outputVariables: 0,
        missingContractIds: []
      };
    }
    await this.estimatePredicates(transactionRequest);
    let receipts = [];
    const missingContractIds = [];
    let outputVariables = 0;
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction: (0, import_utils22.hexlify)(transactionRequest.toTransactionBytes()),
        utxoValidation: false
      });
      receipts = gqlReceipts.map(processGqlReceipt);
      const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
      const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
      if (hasMissingOutputs) {
        outputVariables += missingOutputVariables.length;
        transactionRequest.addVariableOutputs(missingOutputVariables.length);
        missingOutputContractIds.forEach(({ contractId }) => {
          transactionRequest.addContractInputAndOutput(import_address3.Address.fromString(contractId));
          missingContractIds.push(contractId);
        });
      } else {
        break;
      }
    }
    return {
      receipts,
      outputVariables,
      missingContractIds
    };
  }
  /**
   * Executes a signed transaction without applying the states changes
   * on the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added
   *
   * @param transactionRequestLike - The transaction request object.
   * @returns A promise that resolves to the call result object.
   */
  async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = (0, import_utils22.hexlify)(transactionRequest.toTransactionBytes());
    const { dryRun: gqlReceipts } = await this.operations.dryRun({
      encodedTransaction,
      utxoValidation: true
    });
    const receipts = gqlReceipts.map(processGqlReceipt);
    return {
      receipts
    };
  }
  /**
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the the transaction.
   *
   * @privateRemarks
   * The tolerance is add on top of the gasUsed calculated
   * from the node, this create a safe margin costs like
   * change states on transfer that don't occur on the dryRun
   * transaction. The default value is 0.2 or 20%
   *
   * @param transactionRequestLike - The transaction request object.
   * @param tolerance - The tolerance to add on top of the gasUsed.
   * @returns A promise that resolves to the transaction cost object.
   */
  async getTransactionCost(transactionRequestLike, forwardingQuantities = [], {
    estimateTxDependencies = true,
    estimatePredicates = true,
    resourcesOwner,
    signatureCallback
  } = {}) {
    const txRequestClone = (0, import_ramda3.clone)(transactionRequestify(transactionRequestLike));
    const chainInfo = this.getChain();
    const { gasPriceFactor, minGasPrice, maxGasPerTx } = this.getGasConfig();
    const gasPrice = (0, import_math14.max)(txRequestClone.gasPrice, minGasPrice);
    const isScriptTransaction = txRequestClone.type === import_transactions17.TransactionType.Script;
    const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
    const allQuantities = mergeQuantities(coinOutputsQuantities, forwardingQuantities);
    txRequestClone.fundWithFakeUtxos(allQuantities, resourcesOwner?.address);
    if (estimatePredicates) {
      if (isScriptTransaction) {
        txRequestClone.gasLimit = (0, import_math14.bn)(0);
      }
      if (resourcesOwner && "populateTransactionPredicateData" in resourcesOwner) {
        resourcesOwner.populateTransactionPredicateData(txRequestClone);
      }
      await this.estimatePredicates(txRequestClone);
    }
    if (signatureCallback && isScriptTransaction) {
      await signatureCallback(txRequestClone);
    }
    const minGas = txRequestClone.calculateMinGas(chainInfo);
    const maxGas = txRequestClone.calculateMaxGas(chainInfo, minGas);
    let receipts = [];
    let missingContractIds = [];
    let outputVariables = 0;
    if (isScriptTransaction && estimateTxDependencies) {
      txRequestClone.gasPrice = (0, import_math14.bn)(0);
      txRequestClone.gasLimit = (0, import_math14.bn)(maxGasPerTx.sub(maxGas).toNumber() * 0.9);
      const result = await this.estimateTxDependencies(txRequestClone);
      receipts = result.receipts;
      outputVariables = result.outputVariables;
      missingContractIds = result.missingContractIds;
    }
    const gasUsed = isScriptTransaction ? getGasUsedFromReceipts(receipts) : minGas;
    const usedFee = calculatePriceWithFactor(
      gasUsed,
      gasPrice,
      gasPriceFactor
    ).normalizeZeroToOne();
    const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
    const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
    return {
      requiredQuantities: allQuantities,
      receipts,
      gasUsed,
      minGasPrice,
      gasPrice,
      minGas,
      maxGas,
      usedFee,
      minFee,
      maxFee,
      estimatedInputs: txRequestClone.inputs,
      outputVariables,
      missingContractIds
    };
  }
  async getResourcesForTransaction(owner, transactionRequestLike, forwardingQuantities = []) {
    const ownerAddress = import_address3.Address.fromAddressOrString(owner);
    const transactionRequest = transactionRequestify((0, import_ramda3.clone)(transactionRequestLike));
    const transactionCost = await this.getTransactionCost(transactionRequest, forwardingQuantities);
    transactionRequest.addResources(
      await this.getResourcesToSpend(ownerAddress, transactionCost.requiredQuantities)
    );
    const { requiredQuantities, ...txCost } = await this.getTransactionCost(
      transactionRequest,
      forwardingQuantities
    );
    const resources = await this.getResourcesToSpend(ownerAddress, requiredQuantities);
    return {
      resources,
      requiredQuantities,
      ...txCost
    };
  }
  /**
   * Returns coins for the given owner.
   */
  async getCoins(owner, assetId, paginationArgs) {
    const ownerAddress = import_address3.Address.fromAddressOrString(owner);
    const result = await this.operations.getCoins({
      first: 10,
      ...paginationArgs,
      filter: { owner: ownerAddress.toB256(), assetId: assetId && (0, import_utils22.hexlify)(assetId) }
    });
    const coins = result.coins.edges.map((edge) => edge.node);
    return coins.map((coin) => ({
      id: coin.utxoId,
      assetId: coin.assetId,
      amount: (0, import_math14.bn)(coin.amount),
      owner: import_address3.Address.fromAddressOrString(coin.owner),
      maturity: (0, import_math14.bn)(coin.maturity).toNumber(),
      blockCreated: (0, import_math14.bn)(coin.blockCreated),
      txCreatedIdx: (0, import_math14.bn)(coin.txCreatedIdx)
    }));
  }
  /**
   * Returns resources for the given owner satisfying the spend query.
   *
   * @param owner - The address to get resources for.
   * @param quantities - The quantities to get.
   * @param excludedIds - IDs of excluded resources from the selection.
   * @returns A promise that resolves to the resources.
   */
  async getResourcesToSpend(owner, quantities, excludedIds) {
    const ownerAddress = import_address3.Address.fromAddressOrString(owner);
    const excludeInput = {
      messages: excludedIds?.messages?.map((nonce) => (0, import_utils22.hexlify)(nonce)) || [],
      utxos: excludedIds?.utxos?.map((id) => (0, import_utils22.hexlify)(id)) || []
    };
    if (this.cache) {
      const uniqueUtxos = new Set(
        excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => (0, import_utils22.hexlify)(id)))
      );
      excludeInput.utxos = Array.from(uniqueUtxos);
    }
    const coinsQuery = {
      owner: ownerAddress.toB256(),
      queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
        assetId: (0, import_utils22.hexlify)(assetId),
        amount: amount.toString(10),
        max: maxPerAsset ? maxPerAsset.toString(10) : void 0
      })),
      excludedIds: excludeInput
    };
    const result = await this.operations.getCoinsToSpend(coinsQuery);
    const coins = result.coinsToSpend.flat().map((coin) => {
      switch (coin.__typename) {
        case "MessageCoin":
          return {
            amount: (0, import_math14.bn)(coin.amount),
            assetId: coin.assetId,
            daHeight: (0, import_math14.bn)(coin.daHeight),
            sender: import_address3.Address.fromAddressOrString(coin.sender),
            recipient: import_address3.Address.fromAddressOrString(coin.recipient),
            nonce: coin.nonce
          };
        case "Coin":
          return {
            id: coin.utxoId,
            amount: (0, import_math14.bn)(coin.amount),
            assetId: coin.assetId,
            owner: import_address3.Address.fromAddressOrString(coin.owner),
            maturity: (0, import_math14.bn)(coin.maturity).toNumber(),
            blockCreated: (0, import_math14.bn)(coin.blockCreated),
            txCreatedIdx: (0, import_math14.bn)(coin.txCreatedIdx)
          };
        default:
          return null;
      }
    }).filter((v) => !!v);
    return coins;
  }
  /**
   * Returns block matching the given ID or height.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlock(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { height: (0, import_math14.bn)(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { height: (await this.getBlockNumber()).toString(10) };
    } else if (idOrHeight.length === 66) {
      variables = { blockId: idOrHeight };
    } else {
      variables = { blockId: (0, import_math14.bn)(idOrHeight).toString(10) };
    }
    const { block } = await this.operations.getBlock(variables);
    if (!block) {
      return null;
    }
    return {
      id: block.id,
      height: (0, import_math14.bn)(block.header.height),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id)
    };
  }
  /**
   * Returns all the blocks matching the given parameters.
   *
   * @param params - The parameters to query blocks.
   * @returns A promise that resolves to the blocks.
   */
  async getBlocks(params) {
    const { blocks: fetchedData } = await this.operations.getBlocks(params);
    const blocks = fetchedData.edges.map(({ node: block }) => ({
      id: block.id,
      height: (0, import_math14.bn)(block.header.height),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id)
    }));
    return blocks;
  }
  /**
   * Returns block matching the given ID or type, including transaction data.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlockWithTransactions(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { blockHeight: (0, import_math14.bn)(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { blockHeight: (await this.getBlockNumber()).toString() };
    } else {
      variables = { blockId: idOrHeight };
    }
    const { block } = await this.operations.getBlockWithTransactions(variables);
    if (!block) {
      return null;
    }
    return {
      id: block.id,
      height: (0, import_math14.bn)(block.header.height, 10),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id),
      transactions: block.transactions.map(
        (tx) => new import_transactions17.TransactionCoder().decode((0, import_utils22.arrayify)(tx.rawPayload), 0)?.[0]
      )
    };
  }
  /**
   * Get transaction with the given ID.
   *
   * @param transactionId - ID of the transaction.
   * @returns A promise that resolves to the transaction.
   */
  async getTransaction(transactionId) {
    const { transaction } = await this.operations.getTransaction({ transactionId });
    if (!transaction) {
      return null;
    }
    return new import_transactions17.TransactionCoder().decode(
      (0, import_utils22.arrayify)(transaction.rawPayload),
      0
    )?.[0];
  }
  /**
   * Get deployed contract with the given ID.
   *
   * @param contractId - ID of the contract.
   * @returns A promise that resolves to the contract.
   */
  async getContract(contractId) {
    const { contract } = await this.operations.getContract({ contractId });
    if (!contract) {
      return null;
    }
    return contract;
  }
  /**
   * Returns the balance for the given contract for the given asset ID.
   *
   * @param contractId - The contract ID to get the balance for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getContractBalance(contractId, assetId) {
    const { contractBalance } = await this.operations.getContractBalance({
      contract: import_address3.Address.fromAddressOrString(contractId).toB256(),
      asset: (0, import_utils22.hexlify)(assetId)
    });
    return (0, import_math14.bn)(contractBalance.amount, 10);
  }
  /**
   * Returns the balance for the given owner for the given asset ID.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getBalance(owner, assetId) {
    const { balance } = await this.operations.getBalance({
      owner: import_address3.Address.fromAddressOrString(owner).toB256(),
      assetId: (0, import_utils22.hexlify)(assetId)
    });
    return (0, import_math14.bn)(balance.amount, 10);
  }
  /**
   * Returns balances for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param paginationArgs - Pagination arguments.
   * @returns A promise that resolves to the balances.
   */
  async getBalances(owner, paginationArgs) {
    const result = await this.operations.getBalances({
      first: 10,
      ...paginationArgs,
      filter: { owner: import_address3.Address.fromAddressOrString(owner).toB256() }
    });
    const balances = result.balances.edges.map((edge) => edge.node);
    return balances.map((balance) => ({
      assetId: balance.assetId,
      amount: (0, import_math14.bn)(balance.amount)
    }));
  }
  /**
   * Returns message for the given address.
   *
   * @param address - The address to get message from.
   * @param paginationArgs - Pagination arguments.
   * @returns A promise that resolves to the messages.
   */
  async getMessages(address, paginationArgs) {
    const result = await this.operations.getMessages({
      first: 10,
      ...paginationArgs,
      owner: import_address3.Address.fromAddressOrString(address).toB256()
    });
    const messages = result.messages.edges.map((edge) => edge.node);
    return messages.map((message) => ({
      messageId: import_transactions17.InputMessageCoder.getMessageId({
        sender: message.sender,
        recipient: message.recipient,
        nonce: message.nonce,
        amount: (0, import_math14.bn)(message.amount),
        data: message.data
      }),
      sender: import_address3.Address.fromAddressOrString(message.sender),
      recipient: import_address3.Address.fromAddressOrString(message.recipient),
      nonce: message.nonce,
      amount: (0, import_math14.bn)(message.amount),
      data: import_transactions17.InputMessageCoder.decodeData(message.data),
      daHeight: (0, import_math14.bn)(message.daHeight)
    }));
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param transactionId - The transaction to get message from.
   * @param messageId - The message id from MessageOut receipt.
   * @param commitBlockId - The commit block id.
   * @param commitBlockHeight - The commit block height.
   * @returns A promise that resolves to the message proof.
   */
  async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
    let inputObject = {
      transactionId,
      nonce
    };
    if (commitBlockId && commitBlockHeight) {
      throw new import_errors13.FuelError(
        import_errors13.ErrorCode.INVALID_INPUT_PARAMETERS,
        "commitBlockId and commitBlockHeight cannot be used together"
      );
    }
    if (commitBlockId) {
      inputObject = {
        ...inputObject,
        commitBlockId
      };
    }
    if (commitBlockHeight) {
      inputObject = {
        ...inputObject,
        // Conver BN into a number string required on the query
        // This should problably be fixed on the fuel client side
        commitBlockHeight: commitBlockHeight.toNumber().toString()
      };
    }
    const result = await this.operations.getMessageProof(inputObject);
    if (!result.messageProof) {
      return null;
    }
    const {
      messageProof,
      messageBlockHeader,
      commitBlockHeader,
      blockProof,
      sender,
      recipient,
      amount,
      data
    } = result.messageProof;
    return {
      messageProof: {
        proofIndex: (0, import_math14.bn)(messageProof.proofIndex),
        proofSet: messageProof.proofSet
      },
      blockProof: {
        proofIndex: (0, import_math14.bn)(blockProof.proofIndex),
        proofSet: blockProof.proofSet
      },
      messageBlockHeader: {
        id: messageBlockHeader.id,
        daHeight: (0, import_math14.bn)(messageBlockHeader.daHeight),
        transactionsCount: (0, import_math14.bn)(messageBlockHeader.transactionsCount),
        transactionsRoot: messageBlockHeader.transactionsRoot,
        height: (0, import_math14.bn)(messageBlockHeader.height),
        prevRoot: messageBlockHeader.prevRoot,
        time: messageBlockHeader.time,
        applicationHash: messageBlockHeader.applicationHash,
        messageReceiptRoot: messageBlockHeader.messageReceiptRoot,
        messageReceiptCount: (0, import_math14.bn)(messageBlockHeader.messageReceiptCount)
      },
      commitBlockHeader: {
        id: commitBlockHeader.id,
        daHeight: (0, import_math14.bn)(commitBlockHeader.daHeight),
        transactionsCount: (0, import_math14.bn)(commitBlockHeader.transactionsCount),
        transactionsRoot: commitBlockHeader.transactionsRoot,
        height: (0, import_math14.bn)(commitBlockHeader.height),
        prevRoot: commitBlockHeader.prevRoot,
        time: commitBlockHeader.time,
        applicationHash: commitBlockHeader.applicationHash,
        messageReceiptRoot: commitBlockHeader.messageReceiptRoot,
        messageReceiptCount: (0, import_math14.bn)(commitBlockHeader.messageReceiptCount)
      },
      sender: import_address3.Address.fromAddressOrString(sender),
      recipient: import_address3.Address.fromAddressOrString(recipient),
      nonce,
      amount: (0, import_math14.bn)(amount),
      data
    };
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param nonce - The nonce of the message to get status from.
   * @returns A promise that resolves to the message status
   */
  async getMessageStatus(nonce) {
    const result = await this.operations.getMessageStatus({ nonce });
    return result.messageStatus;
  }
  /**
   * Lets you produce blocks with custom timestamps and the block number of the last block produced.
   *
   * @param amount - The amount of blocks to produce
   * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block
   * @returns A promise that resolves to the block number of the last produced block.
   */
  async produceBlocks(amount, startTime) {
    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
      blocksToProduce: (0, import_math14.bn)(amount).toString(10),
      startTimestamp: startTime ? import_utils22.DateTime.fromUnixMilliseconds(startTime).toTai64() : void 0
    });
    return (0, import_math14.bn)(latestBlockHeight);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async getTransactionResponse(transactionId) {
    return new TransactionResponse(transactionId, this);
  }
};
var Provider = _Provider;
_cacheInputs = new WeakSet();
cacheInputs_fn = function(inputs) {
  if (!this.cache) {
    return;
  }
  inputs.forEach((input) => {
    if (input.type === import_transactions17.InputType.Coin) {
      this.cache?.set(input.id);
    }
  });
};
__publicField(Provider, "chainInfoCache", {});
__publicField(Provider, "nodeInfoCache", {});

// src/providers/transaction-summary/get-transaction-summary.ts
var import_errors14 = require("@fuel-ts/errors");
var import_math15 = require("@fuel-ts/math");
var import_transactions18 = require("@fuel-ts/transactions");
var import_utils25 = require("@fuel-ts/utils");

// src/providers/chains.ts
var CHAIN_IDS = {
  eth: {
    sepolia: 11155111,
    foundry: 31337
  },
  fuel: {
    beta5: 0,
    devnet: 10
  }
};

// src/providers/assets/index.ts
var assets = [
  {
    name: "Ethereum",
    symbol: "ETH",
    icon: "eth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.sepolia,
        decimals: 18
      },
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.foundry,
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.beta5,
        decimals: 9,
        assetId: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.devnet,
        decimals: 9,
        assetId: "0x0000000000000000000000000000000000000000000000000000000000000000"
      }
    ]
  }
];

// src/utils/formatTransferToContractScriptData.ts
var import_abi_coder4 = require("@fuel-ts/abi-coder");
var import_math16 = require("@fuel-ts/math");
var import_utils26 = require("@fuel-ts/utils");
var asm = __toESM(require("@fuels/vm-asm"));
var formatTransferToContractScriptData = (params) => {
  const { assetId, amountToTransfer, hexlifiedContractId } = params;
  const numberCoder = new import_abi_coder4.BigNumberCoder("u64");
  const encoded = numberCoder.encode(new import_math16.BN(amountToTransfer).toNumber());
  const scriptData = Uint8Array.from([
    ...(0, import_utils26.arrayify)(hexlifiedContractId),
    ...encoded,
    ...(0, import_utils26.arrayify)(assetId)
  ]);
  return scriptData;
};
var assembleTransferToContractScript = async (params) => {
  const scriptData = formatTransferToContractScriptData(params);
  await asm.initWasm();
  const gtf2 = asm.gtf(16, 0, asm.GTFArgs.ScriptData);
  const addi2 = asm.addi(17, 16, 32);
  const lw2 = asm.lw(18, 17, 0);
  const addi22 = asm.addi(19, 17, 8);
  const tr2 = asm.tr(16, 18, 19);
  const ret2 = asm.ret(1);
  const script = Uint8Array.from([
    ...gtf2.to_bytes(),
    ...addi2.to_bytes(),
    ...lw2.to_bytes(),
    ...addi22.to_bytes(),
    ...tr2.to_bytes(),
    ...ret2.to_bytes()
  ]);
  return { script, scriptData };
};

// src/account.ts
var Account = class extends import_interfaces.AbstractAccount {
  /**
   * The address associated with the account.
   */
  address;
  /**
   * The provider used to interact with the network.
   */
  _provider;
  _connector;
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance  (optional).
   */
  constructor(address, provider, connector) {
    super();
    this._provider = provider;
    this._connector = connector;
    this.address = import_address4.Address.fromDynamicInput(address);
  }
  /**
   * The provider used to interact with the network.
   *
   * @returns A Provider instance.
   *
   * @throws `FuelError` if the provider is not set.
   */
  get provider() {
    if (!this._provider) {
      throw new import_errors15.FuelError(import_errors15.ErrorCode.MISSING_PROVIDER, "Provider not set");
    }
    return this._provider;
  }
  /**
   * Sets the provider for the account.
   *
   * @param provider - A Provider instance.
   */
  set provider(provider) {
    this._provider = provider;
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this._provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param excludedIds - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve.
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId) {
    const coins = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageCoins = await this.provider.getCoins(this.address, assetId, {
        first: pageSize,
        after: cursor
      });
      coins.push(...pageCoins);
      const hasNextPage = pageCoins.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
      );
    }
    return coins;
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages() {
    const messages = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageMessages = await this.provider.getMessages(this.address, {
        first: pageSize,
        after: cursor
      });
      messages.push(...pageMessages);
      const hasNextPage = pageMessages.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
      );
    }
    return messages;
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for.
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId = import_configs11.BaseAssetId) {
    const amount = await this.provider.getBalance(this.address, assetId);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    const balances = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageBalances = await this.provider.getBalances(this.address, {
        first: pageSize,
        after: cursor
      });
      balances.push(...pageBalances);
      const hasNextPage = pageBalances.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
      );
    }
    return balances;
  }
  /**
   * Adds resources to the transaction enough to fund it.
   *
   * @param request - The transaction request.
   * @param coinQuantities - The coin quantities required to execute the transaction.
   * @param fee - The estimated transaction fee.
   * @returns A promise that resolves when the resources are added to the transaction.
   */
  async fund(request, coinQuantities, fee) {
    const updatedQuantities = addAmountToAsset({
      amount: (0, import_math17.bn)(fee),
      assetId: import_configs11.BaseAssetId,
      coinQuantities
    });
    const quantitiesDict = {};
    updatedQuantities.forEach(({ amount, assetId }) => {
      quantitiesDict[assetId] = {
        required: amount,
        owned: (0, import_math17.bn)(0)
      };
    });
    const cachedUtxos = [];
    const cachedMessages = [];
    const owner = this.address.toB256();
    request.inputs.forEach((input) => {
      const isResource = "amount" in input;
      if (isResource) {
        const isCoin2 = "owner" in input;
        if (isCoin2) {
          const assetId = String(input.assetId);
          if (input.owner === owner && quantitiesDict[assetId]) {
            const amount = (0, import_math17.bn)(input.amount);
            quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(amount);
            cachedUtxos.push(input.id);
          }
        } else if (input.recipient === owner && input.amount && quantitiesDict[import_configs11.BaseAssetId]) {
          quantitiesDict[import_configs11.BaseAssetId].owned = quantitiesDict[import_configs11.BaseAssetId].owned.add(input.amount);
          cachedMessages.push(input.nonce);
        }
      }
    });
    const missingQuantities = [];
    Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
      if (owned.lt(required)) {
        missingQuantities.push({
          assetId,
          amount: required.sub(owned)
        });
      }
    });
    const needsToBeFunded = missingQuantities.length;
    if (needsToBeFunded) {
      const resources = await this.getResourcesToSpend(missingQuantities, {
        messages: cachedMessages,
        utxos: cachedUtxos
      });
      request.addResources(resources);
    }
  }
  /**
   * A helper that creates a transfer transaction request and returns it.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the prepared transaction request.
   */
  async createTransfer(destination, amount, assetId = import_configs11.BaseAssetId, txParams = {}) {
    const { minGasPrice } = this.provider.getGasConfig();
    const params = { gasPrice: minGasPrice, ...txParams };
    const request = new ScriptTransactionRequest(params);
    request.addCoinOutput(import_address4.Address.fromAddressOrString(destination), amount, assetId);
    const { maxFee, requiredQuantities, gasUsed, estimatedInputs } = await this.provider.getTransactionCost(request, [], {
      estimateTxDependencies: true,
      resourcesOwner: this
    });
    request.gasPrice = (0, import_math17.bn)(txParams.gasPrice ?? minGasPrice);
    request.gasLimit = (0, import_math17.bn)(txParams.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    request.updatePredicateInputs(estimatedInputs);
    return request;
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId = import_configs11.BaseAssetId, txParams = {}) {
    if ((0, import_math17.bn)(amount).lte(0)) {
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.INVALID_TRANSFER_AMOUNT,
        "Transfer amount must be a positive number."
      );
    }
    const request = await this.createTransfer(destination, amount, assetId, txParams);
    return this.sendTransaction(request, { estimateTxDependencies: false });
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId, amount, assetId = import_configs11.BaseAssetId, txParams = {}) {
    if ((0, import_math17.bn)(amount).lte(0)) {
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.INVALID_TRANSFER_AMOUNT,
        "Transfer amount must be a positive number."
      );
    }
    const contractAddress = import_address4.Address.fromAddressOrString(contractId);
    const { minGasPrice } = this.provider.getGasConfig();
    const params = { gasPrice: minGasPrice, ...txParams };
    const { script, scriptData } = await assembleTransferToContractScript({
      hexlifiedContractId: contractAddress.toB256(),
      amountToTransfer: (0, import_math17.bn)(amount),
      assetId
    });
    const request = new ScriptTransactionRequest({
      ...params,
      script,
      scriptData
    });
    request.addContractInputAndOutput(contractAddress);
    const { maxFee, requiredQuantities, gasUsed } = await this.provider.getTransactionCost(
      request,
      [{ amount: (0, import_math17.bn)(amount), assetId: String(assetId) }]
    );
    request.gasLimit = (0, import_math17.bn)(params.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const { minGasPrice } = this.provider.getGasConfig();
    const recipientAddress = import_address4.Address.fromAddressOrString(recipient);
    const recipientDataArray = (0, import_utils27.arrayify)(
      "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = (0, import_utils27.arrayify)(
      "0x".concat((0, import_math17.bn)(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...(0, import_utils27.arrayify)(withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const params = { script, gasPrice: minGasPrice, ...txParams };
    const request = new ScriptTransactionRequest(params);
    const forwardingQuantities = [{ amount: (0, import_math17.bn)(amount), assetId: import_configs11.BaseAssetId }];
    const { requiredQuantities, maxFee, gasUsed } = await this.provider.getTransactionCost(
      request,
      forwardingQuantities
    );
    request.gasLimit = (0, import_math17.bn)(params.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    return this.sendTransaction(request);
  }
  async signMessage(message) {
    if (!this._connector) {
      throw new import_errors15.FuelError(import_errors15.ErrorCode.MISSING_CONNECTOR, "A connector is required to sign messages.");
    }
    return this._connector.signMessage(this.address.toString(), message);
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature of the transaction.
   */
  async signTransaction(transactionRequestLike) {
    if (!this._connector) {
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.MISSING_CONNECTOR,
        "A connector is required to sign transactions."
      );
    }
    return this._connector.signTransaction(this.address.toString(), transactionRequestLike);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution } = {}) {
    if (this._connector) {
      return this.provider.getTransactionResponse(
        await this._connector.sendTransaction(this.address.toString(), transactionRequestLike)
      );
    }
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(transactionRequest, {
      awaitExecution,
      estimateTxDependencies: false
    });
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
  }
  validateGas({
    gasUsed,
    gasPrice,
    gasLimit,
    minGasPrice
  }) {
    if (minGasPrice.gt(gasPrice)) {
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.GAS_PRICE_TOO_LOW,
        `Gas price '${gasPrice}' is lower than the required: '${minGasPrice}'.`
      );
    }
    if (gasUsed.gt(gasLimit)) {
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.GAS_LIMIT_TOO_LOW,
        `Gas limit '${gasLimit}' is lower than the required: '${gasUsed}'.`
      );
    }
  }
};

// src/signer/signer.ts
var import_address5 = require("@fuel-ts/address");
var import_crypto = require("@fuel-ts/crypto");
var import_hasher2 = require("@fuel-ts/hasher");
var import_math18 = require("@fuel-ts/math");
var import_utils28 = require("@fuel-ts/utils");
var import_secp256k1 = require("@noble/curves/secp256k1");
var Signer = class {
  address;
  publicKey;
  compressedPublicKey;
  privateKey;
  /**
   * Create a Signer instance from a given private key
   *
   * @param privateKey - The private key to use for signing
   * @returns A new Signer instance
   */
  constructor(privateKey) {
    if (typeof privateKey === "string") {
      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
        privateKey = `0x${privateKey}`;
      }
    }
    const privateKeyBytes = (0, import_math18.toBytes)(privateKey, 32);
    this.privateKey = (0, import_utils28.hexlify)(privateKeyBytes);
    this.publicKey = (0, import_utils28.hexlify)(import_secp256k1.secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
    this.compressedPublicKey = (0, import_utils28.hexlify)(import_secp256k1.secp256k1.getPublicKey(privateKeyBytes, true));
    this.address = import_address5.Address.fromPublicKey(this.publicKey);
  }
  /**
   * Sign data using the Signer instance
   *
   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
   * @ignore
   * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
   *
   * @param data - The data to be sign
   * @returns hashed signature
   */
  sign(data) {
    const signature = import_secp256k1.secp256k1.sign((0, import_utils28.arrayify)(data), (0, import_utils28.arrayify)(this.privateKey));
    const r = (0, import_math18.toBytes)(`0x${signature.r.toString(16)}`, 32);
    const s = (0, import_math18.toBytes)(`0x${signature.s.toString(16)}`, 32);
    s[0] |= (signature.recovery || 0) << 7;
    return (0, import_utils28.hexlify)((0, import_utils28.concat)([r, s]));
  }
  /**
   * Add point on the current elliptic curve
   *
   * @param point - Point to add on the curve
   * @returns compressed point on the curve
   */
  addPoint(point) {
    const p0 = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_utils28.arrayify)(this.compressedPublicKey));
    const p1 = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_utils28.arrayify)(point));
    const result = p0.add(p1);
    return `0x${result.toHex(true)}`;
  }
  /**
   * Recover the public key from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - hashed signature
   * @returns public key from signature from the
   */
  static recoverPublicKey(data, signature) {
    const signedMessageBytes = (0, import_utils28.arrayify)(signature);
    const r = signedMessageBytes.slice(0, 32);
    const s = signedMessageBytes.slice(32, 64);
    const recoveryParam = (s[0] & 128) >> 7;
    s[0] &= 127;
    const sig = new import_secp256k1.secp256k1.Signature(BigInt((0, import_utils28.hexlify)(r)), BigInt((0, import_utils28.hexlify)(s))).addRecoveryBit(
      recoveryParam
    );
    const publicKey = sig.recoverPublicKey((0, import_utils28.arrayify)(data)).toRawBytes(false).slice(1);
    return (0, import_utils28.hexlify)(publicKey);
  }
  /**
   * Recover the address from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - Signature
   * @returns Address from signature
   */
  static recoverAddress(data, signature) {
    return import_address5.Address.fromPublicKey(Signer.recoverPublicKey(data, signature));
  }
  /**
   * Generate a random privateKey
   *
   * @param entropy - Adds extra entropy to generate the privateKey
   * @returns random 32-byte hashed
   */
  static generatePrivateKey(entropy) {
    return entropy ? (0, import_hasher2.hash)((0, import_utils28.concat)([(0, import_crypto.randomBytes)(32), (0, import_utils28.arrayify)(entropy)])) : (0, import_crypto.randomBytes)(32);
  }
  /**
   * Extended publicKey from a compact publicKey
   *
   * @param publicKey - Compact publicKey
   * @returns extended publicKey
   */
  static extendPublicKey(publicKey) {
    const point = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_utils28.arrayify)(publicKey));
    return (0, import_utils28.hexlify)(point.toRawBytes(false).slice(1));
  }
};

// src/wallet/keystore-wallet.ts
var import_address6 = require("@fuel-ts/address");
var import_crypto2 = require("@fuel-ts/crypto");
var import_errors16 = require("@fuel-ts/errors");
var import_utils29 = require("@fuel-ts/utils");
var import_uuid = require("uuid");
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = (0, import_crypto2.bufferFromString)(removeHexPrefix(privateKey), "hex");
  const ownerAddress = import_address6.Address.fromAddressOrString(address);
  const salt = (0, import_crypto2.randomBytes)(DEFAULT_KEY_SIZE);
  const key = (0, import_crypto2.scrypt)({
    password: (0, import_crypto2.bufferFromString)(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = (0, import_crypto2.randomBytes)(DEFAULT_IV_SIZE);
  const ciphertext = await (0, import_crypto2.encryptJsonWalletData)(privateKeyBuffer, key, iv);
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = (0, import_crypto2.keccak256)(data);
  const mac = (0, import_crypto2.stringFromBuffer)(macHashUint8Array, "hex");
  const keystore = {
    id: (0, import_uuid.v4)(),
    version: 3,
    address: removeHexPrefix(ownerAddress.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: (0, import_crypto2.stringFromBuffer)(iv, "hex") },
      ciphertext: (0, import_crypto2.stringFromBuffer)(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: (0, import_crypto2.stringFromBuffer)(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = (0, import_crypto2.bufferFromString)(ciphertext, "hex");
  const ivBuffer = (0, import_crypto2.bufferFromString)(iv, "hex");
  const saltBuffer = (0, import_crypto2.bufferFromString)(salt, "hex");
  const passwordBuffer = (0, import_crypto2.bufferFromString)(password);
  const key = (0, import_crypto2.scrypt)({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = (0, import_crypto2.keccak256)(data);
  const macHash = (0, import_crypto2.stringFromBuffer)(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new import_errors16.FuelError(
      import_errors16.ErrorCode.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer = await (0, import_crypto2.decryptJsonWalletData)(ciphertextBuffer, key, ivBuffer);
  const privateKey = (0, import_utils29.hexlify)(buffer);
  return privateKey;
}

// src/wallet/base-wallet-unlocked.ts
var BaseWalletUnlocked = class extends Account {
  /**
   * A function that returns the wallet's signer.
   */
  signer;
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   */
  constructor(privateKey, provider) {
    const signer = new Signer(privateKey);
    super(signer.address, provider);
    this.signer = () => signer;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign((0, import_hasher3.hashMessage)(message));
    return (0, import_utils30.hexlify)(signedMessage);
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const chainId = this.provider.getChainId();
    const hashedTransaction = transactionRequest.getTransactionId(chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return (0, import_utils30.hexlify)(signature);
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      { awaitExecution, estimateTxDependencies: false }
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.call(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true,
        estimateTxDependencies: false
      }
    );
  }
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
/**
 * Default HDWallet path.
 */
__publicField(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");

// src/hdwallet/hdwallet.ts
var import_errors19 = require("@fuel-ts/errors");
var import_hasher6 = require("@fuel-ts/hasher");
var import_math19 = require("@fuel-ts/math");
var import_utils34 = require("@fuel-ts/utils");
var import_ethers3 = require("ethers");

// src/mnemonic/mnemonic.ts
var import_crypto3 = require("@fuel-ts/crypto");
var import_errors18 = require("@fuel-ts/errors");
var import_hasher5 = require("@fuel-ts/hasher");
var import_utils32 = require("@fuel-ts/utils");
var import_ethers2 = require("ethers");

// src/wordlists/words/english.ts
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// src/mnemonic/utils.ts
var import_errors17 = require("@fuel-ts/errors");
var import_hasher4 = require("@fuel-ts/hasher");
var import_utils31 = require("@fuel-ts/utils");
function toUtf8Bytes(stri) {
  const str = stri.normalize("NFKD");
  const result = [];
  for (let i = 0; i < str.length; i += 1) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) === 55296) {
      i += 1;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new import_errors17.FuelError(
          import_errors17.ErrorCode.INVALID_INPUT_PARAMETERS,
          "Invalid UTF-8 in the input string."
        );
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return Uint8Array.from(result);
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getWords(mnemonic) {
  if (!Array.isArray(mnemonic)) {
    return mnemonic.split(/\s+/);
  }
  return mnemonic;
}
function getPhrase(mnemonic) {
  if (Array.isArray(mnemonic)) {
    return mnemonic.join(" ");
  }
  return mnemonic;
}
function entropyToMnemonicIndices(entropy) {
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i += 1) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = (0, import_utils31.arrayify)((0, import_hasher4.sha256)(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return indices;
}
function mnemonicWordsToEntropy(words, wordlist) {
  const size = Math.ceil(11 * words.length / 8);
  const entropy = (0, import_utils31.arrayify)(new Uint8Array(size));
  let offset = 0;
  for (let i = 0; i < words.length; i += 1) {
    const index = wordlist.indexOf(words[i].normalize("NFKD"));
    if (index === -1) {
      throw new import_errors17.FuelError(
        import_errors17.ErrorCode.INVALID_MNEMONIC,
        `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
      );
    }
    for (let bit = 0; bit < 11; bit += 1) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset += 1;
    }
  }
  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = (0, import_utils31.arrayify)((0, import_hasher4.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new import_errors17.FuelError(
      import_errors17.ErrorCode.INVALID_CHECKSUM,
      "Checksum validation failed for the provided mnemonic."
    );
  }
  return entropy.slice(0, entropyBits / 8);
}

// src/mnemonic/mnemonic.ts
var MasterSecret = toUtf8Bytes("Bitcoin seed");
var MainnetPRV = "0x0488ade4";
var TestnetPRV = "0x04358394";
var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
function assertWordList(wordlist) {
  if (wordlist.length !== 2048) {
    throw new import_errors18.FuelError(
      import_errors18.ErrorCode.INVALID_WORD_LIST,
      `Expected word list length of 2048, but got ${wordlist.length}.`
    );
  }
}
function assertEntropy(entropy) {
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new import_errors18.FuelError(
      import_errors18.ErrorCode.INVALID_ENTROPY,
      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
    );
  }
}
function assertMnemonic(words) {
  if (!MNEMONIC_SIZES.includes(words.length)) {
    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
      ", "
    )}] words, but got ${words.length}.`;
    throw new import_errors18.FuelError(import_errors18.ErrorCode.INVALID_MNEMONIC, errorMsg);
  }
}
var Mnemonic = class {
  wordlist;
  /**
   *
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic instance
   */
  constructor(wordlist = english) {
    this.wordlist = wordlist;
    assertWordList(this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns Entropy hash
   */
  mnemonicToEntropy(phrase) {
    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
  }
  /**
   *
   * @param entropy - Entropy source to the mnemonic phrase.
   * @returns Mnemonic phrase
   */
  entropyToMnemonic(entropy) {
    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic phrase
   */
  static mnemonicToEntropy(phrase, wordlist = english) {
    const words = getWords(phrase);
    assertMnemonic(words);
    return (0, import_utils32.hexlify)(mnemonicWordsToEntropy(words, wordlist));
  }
  /**
   * @param entropy - Entropy source to the mnemonic phrase.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static entropyToMnemonic(entropy, wordlist = english) {
    const entropyBytes = (0, import_utils32.arrayify)(entropy);
    assertWordList(wordlist);
    assertEntropy(entropyBytes);
    return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToSeed(phrase, passphrase = "") {
    assertMnemonic(getWords(phrase));
    const phraseBytes = toUtf8Bytes(getPhrase(phrase));
    const salt = toUtf8Bytes(`mnemonic${passphrase}`);
    return (0, import_ethers2.pbkdf2)(phraseBytes, salt, 2048, 64, "sha512");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToMasterKeys(phrase, passphrase = "") {
    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);
    return Mnemonic.masterKeysFromSeed(seed);
  }
  /**
   * Validates if given mnemonic is  valid
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns true if phrase is a valid mnemonic
   */
  static isMnemonicValid(phrase) {
    const words = getWords(phrase);
    let i = 0;
    try {
      assertMnemonic(words);
    } catch {
      return false;
    }
    while (i < words.length) {
      if (Mnemonic.binarySearch(words[i]) === false) {
        return false;
      }
      i += 1;
    }
    return true;
  }
  static binarySearch(target) {
    const words = english;
    let left = 0;
    let right = words.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (words[mid] === target) {
        return true;
      }
      if (target < words[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return false;
  }
  /**
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static masterKeysFromSeed(seed) {
    const seedArray = (0, import_utils32.arrayify)(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new import_errors18.FuelError(
        import_errors18.ErrorCode.INVALID_SEED,
        `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
      );
    }
    return (0, import_utils32.arrayify)((0, import_ethers2.computeHmac)("sha512", MasterSecret, seedArray));
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  static seedToExtendedKey(seed, testnet = false) {
    const masterKey = Mnemonic.masterKeysFromSeed(seed);
    const prefix = (0, import_utils32.arrayify)(testnet ? TestnetPRV : MainnetPRV);
    const depth = "0x00";
    const fingerprint = "0x00000000";
    const index = "0x00000000";
    const chainCode = masterKey.slice(32);
    const privateKey = masterKey.slice(0, 32);
    const extendedKey = (0, import_utils32.concat)([
      prefix,
      depth,
      fingerprint,
      index,
      chainCode,
      (0, import_utils32.concat)(["0x00", privateKey])
    ]);
    const checksum = (0, import_ethers2.dataSlice)((0, import_hasher5.sha256)((0, import_hasher5.sha256)(extendedKey)), 0, 4);
    return (0, import_ethers2.encodeBase58)((0, import_utils32.concat)([extendedKey, checksum]));
  }
  /**
   *  Create a new mnemonic using a randomly generated number as entropy.
   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
   *  If not provided, the default entropy length will be set to 256 bits.
   *  The return is a list of words that encodes the generated entropy.
   *
   *
   * @param size - Number of bytes used as an entropy
   * @param extraEntropy - Optional extra entropy to increase randomness
   * @returns A randomly generated mnemonic
   */
  static generate(size = 32, extraEntropy = "") {
    const entropy = extraEntropy ? (0, import_hasher5.sha256)((0, import_utils32.concat)([(0, import_crypto3.randomBytes)(size), (0, import_utils32.arrayify)(extraEntropy)])) : (0, import_crypto3.randomBytes)(size);
    return Mnemonic.entropyToMnemonic(entropy);
  }
};
var mnemonic_default = Mnemonic;

// src/hdwallet/hdwallet.ts
var HARDENED_INDEX = 2147483648;
var MainnetPRV2 = (0, import_utils34.hexlify)("0x0488ade4");
var MainnetPUB = (0, import_utils34.hexlify)("0x0488b21e");
var TestnetPRV2 = (0, import_utils34.hexlify)("0x04358394");
var TestnetPUB = (0, import_utils34.hexlify)("0x043587cf");
function base58check(data) {
  return (0, import_ethers3.encodeBase58)((0, import_utils34.concat)([data, (0, import_ethers3.dataSlice)((0, import_hasher6.sha256)((0, import_hasher6.sha256)(data)), 0, 4)]));
}
function getExtendedKeyPrefix(isPublic = false, testnet = false) {
  if (isPublic) {
    return testnet ? TestnetPUB : MainnetPUB;
  }
  return testnet ? TestnetPRV2 : MainnetPRV2;
}
function isPublicExtendedKey(extendedKey) {
  return [MainnetPUB, TestnetPUB].includes((0, import_utils34.hexlify)(extendedKey.slice(0, 4)));
}
function isValidExtendedKey(extendedKey) {
  return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
    (0, import_utils34.hexlify)(extendedKey.slice(0, 4))
  );
}
function parsePath(path2, depth = 0) {
  const components = path2.split("/");
  if (components.length === 0 || components[0] === "m" && depth !== 0) {
    throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, `invalid path - ${path2}`);
  }
  if (components[0] === "m") {
    components.shift();
  }
  return components.map(
    (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
  );
}
var HDWallet = class {
  depth = 0;
  index = 0;
  fingerprint = (0, import_utils34.hexlify)("0x00000000");
  parentFingerprint = (0, import_utils34.hexlify)("0x00000000");
  privateKey;
  publicKey;
  chainCode;
  /**
   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
   *
   * @param config - Wallet configurations
   */
  constructor(config) {
    if (config.privateKey) {
      const signer = new Signer(config.privateKey);
      this.publicKey = (0, import_utils34.hexlify)(signer.compressedPublicKey);
      this.privateKey = (0, import_utils34.hexlify)(config.privateKey);
    } else {
      if (!config.publicKey) {
        throw new import_errors19.FuelError(
          import_errors19.ErrorCode.HD_WALLET_ERROR,
          "Both public and private Key cannot be missing. At least one should be provided."
        );
      }
      this.publicKey = (0, import_utils34.hexlify)(config.publicKey);
    }
    this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
    this.fingerprint = (0, import_ethers3.dataSlice)((0, import_ethers3.ripemd160)((0, import_hasher6.sha256)(this.publicKey)), 0, 4);
    this.depth = config.depth || this.depth;
    this.index = config.index || this.index;
    this.chainCode = config.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  /**
   * Derive the current HDWallet instance navigating only on the index.
   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param index - Index of the child HDWallet.
   * @returns A new instance of HDWallet on the derived index
   */
  deriveIndex(index) {
    const privateKey = this.privateKey && (0, import_utils34.arrayify)(this.privateKey);
    const publicKey = (0, import_utils34.arrayify)(this.publicKey);
    const chainCode = (0, import_utils34.arrayify)(this.chainCode);
    const data = new Uint8Array(37);
    if (index & HARDENED_INDEX) {
      if (!privateKey) {
        throw new import_errors19.FuelError(
          import_errors19.ErrorCode.HD_WALLET_ERROR,
          "Cannot derive a hardened index without a private Key."
        );
      }
      data.set(privateKey, 1);
    } else {
      data.set((0, import_utils34.arrayify)(this.publicKey));
    }
    data.set((0, import_math19.toBytes)(index, 4), 33);
    const bytes = (0, import_utils34.arrayify)((0, import_ethers3.computeHmac)("sha512", chainCode, data));
    const IL = bytes.slice(0, 32);
    const IR = bytes.slice(32);
    if (privateKey) {
      const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
      const ki = (0, import_math19.bn)(IL).add(privateKey).mod(N).toBytes(32);
      return new HDWallet({
        privateKey: ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const signer = new Signer((0, import_utils34.hexlify)(IL));
    const Ki = signer.addPoint(publicKey);
    return new HDWallet({
      publicKey: Ki,
      chainCode: IR,
      index,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  /**
   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
   * @returns A new instance of HDWallet on the derived path
   */
  derivePath(path2) {
    const paths = parsePath(path2, this.depth);
    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  toExtendedKey(isPublic = false, testnet = false) {
    if (this.depth >= 256) {
      throw new import_errors19.FuelError(
        import_errors19.ErrorCode.HD_WALLET_ERROR,
        `Exceeded max depth of 255. Current depth: ${this.depth}.`
      );
    }
    const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
    const depth = (0, import_utils34.hexlify)(Uint8Array.from([this.depth]));
    const parentFingerprint = this.parentFingerprint;
    const index = (0, import_math19.toHex)(this.index, 4);
    const chainCode = this.chainCode;
    const key = this.privateKey != null && !isPublic ? (0, import_utils34.concat)(["0x00", this.privateKey]) : this.publicKey;
    const extendedKey = (0, import_utils34.arrayify)((0, import_utils34.concat)([prefix, depth, parentFingerprint, index, chainCode, key]));
    return base58check(extendedKey);
  }
  /**
   * Create HDWallet instance from seed
   *
   * @param seed - Seed
   * @returns A new instance of HDWallet
   */
  static fromSeed(seed) {
    const masterKey = mnemonic_default.masterKeysFromSeed(seed);
    return new HDWallet({
      chainCode: (0, import_utils34.arrayify)(masterKey.slice(32)),
      privateKey: (0, import_utils34.arrayify)(masterKey.slice(0, 32))
    });
  }
  static fromExtendedKey(extendedKey) {
    const decoded = (0, import_ethers3.toBeHex)((0, import_ethers3.decodeBase58)(extendedKey));
    const bytes = (0, import_utils34.arrayify)(decoded);
    const validChecksum = base58check(bytes.slice(0, 78)) === extendedKey;
    if (bytes.length !== 82 || !isValidExtendedKey(bytes)) {
      throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    }
    if (!validChecksum) {
      throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    }
    const depth = bytes[4];
    const parentFingerprint = (0, import_utils34.hexlify)(bytes.slice(5, 9));
    const index = parseInt((0, import_utils34.hexlify)(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = (0, import_utils34.hexlify)(bytes.slice(13, 45));
    const key = bytes.slice(45, 78);
    if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
      throw new import_errors19.FuelError(
        import_errors19.ErrorCode.HD_WALLET_ERROR,
        "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
      );
    }
    if (isPublicExtendedKey(bytes)) {
      if (key[0] !== 3) {
        throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
      }
      return new HDWallet({
        publicKey: key,
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
    if (key[0] !== 0) {
      throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
    }
    return new HDWallet({
      privateKey: key.slice(1),
      chainCode,
      index,
      depth,
      parentFingerprint
    });
  }
};
var hdwallet_default = HDWallet;

// src/wallet/wallets.ts
var WalletLocked = class extends Account {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this._provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new Signer("0x00");
    return new WalletLocked(this.address, this._provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);
    return new WalletUnlocked(privateKey, generateOptions?.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed, path2, provider) {
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path2 || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, path2, passphrase, provider) {
    const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path2 || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an encrypted JSON.
   *
   * @param jsonWallet - The encrypted JSON keystore.
   * @param password - The password to decrypt the JSON.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};

// src/wallet/wallet.ts
var Wallet = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
/**
 * Generate a new Wallet Unlocked with a random key pair.
 *
 * @param generateOptions - Options to customize the generation process (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "generate", WalletUnlocked.generate);
/**
 * Create a Wallet Unlocked from a seed.
 *
 * @param seed - The seed phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromSeed", WalletUnlocked.fromSeed);
/**
 * Create a Wallet Unlocked from a mnemonic phrase.
 *
 * @param mnemonic - The mnemonic phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @param passphrase - The passphrase for the mnemonic (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
/**
 * Create a Wallet Unlocked from an extended key.
 *
 * @param extendedKey - The extended key.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
/**
 * Create a Wallet Unlocked from an encrypted JSON.
 *
 * @param jsonWallet - The encrypted JSON keystore.
 * @param password - The password to decrypt the JSON.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);

// src/test-utils/seedTestWallet.ts
var import_crypto4 = require("@fuel-ts/crypto");
var seedTestWallet = async (wallet, quantities) => {
  const genesisWallet = new WalletUnlocked(
    process.env.GENESIS_SECRET || (0, import_crypto4.randomBytes)(32),
    wallet.provider
  );
  const resources = await genesisWallet.getResourcesToSpend(quantities);
  const { minGasPrice } = genesisWallet.provider.getGasConfig();
  const request = new ScriptTransactionRequest({
    gasLimit: 1e4,
    gasPrice: minGasPrice
  });
  request.addResources(resources);
  quantities.map(coinQuantityfy).forEach(({ amount, assetId }) => request.addCoinOutput(wallet.address, amount, assetId));
  await genesisWallet.sendTransaction(request, { awaitExecution: true });
};

// src/test-utils/generateTestWallet.ts
var generateTestWallet = async (provider, quantities) => {
  const wallet = Wallet.generate({ provider });
  if (quantities) {
    await seedTestWallet(wallet, quantities);
  }
  return wallet;
};

// src/test-utils/launchNode.ts
var import_configs12 = require("@fuel-ts/address/configs");
var import_math20 = require("@fuel-ts/math");
var import_utils35 = require("@fuel-ts/utils");
var import_cli_utils = require("@fuel-ts/utils/cli-utils");
var import_child_process = require("child_process");
var import_crypto5 = require("crypto");
var import_fs = require("fs");
var import_os = __toESM(require("os"));
var import_path = __toESM(require("path"));
var import_portfinder = require("portfinder");
var import_tree_kill = __toESM(require("tree-kill"));
var getFlagValueFromArgs = (args, flag) => {
  const flagIndex = args.indexOf(flag);
  if (flagIndex === -1) {
    return void 0;
  }
  return args[flagIndex + 1];
};
var extractRemainingArgs = (args, flagsToRemove) => {
  const newArgs = [...args];
  flagsToRemove.forEach((flag) => {
    const flagIndex = newArgs.indexOf(flag);
    if (flagIndex !== -1) {
      newArgs.splice(flagIndex, 2);
    }
  });
  return newArgs;
};
var killNode = (params) => {
  const { child, configPath, state, killFn } = params;
  if (!state.isDead) {
    if (child.pid) {
      state.isDead = true;
      killFn(Number(child.pid));
    }
    child.stdout.removeAllListeners();
    child.stderr.removeAllListeners();
    if ((0, import_fs.existsSync)(configPath)) {
      (0, import_fs.rmSync)(configPath, { recursive: true });
    }
  }
};
var launchNode = async ({
  ip,
  port,
  args = [],
  useSystemFuelCore = false,
  loggingEnabled = true,
  debugEnabled = false,
  basePath
}) => (
  // eslint-disable-next-line no-async-promise-executor
  new Promise(async (resolve, reject) => {
    const remainingArgs = extractRemainingArgs(args, [
      "--chain",
      "--consensus-key",
      "--db-type",
      "--poa-instant"
    ]);
    const chainConfigPath = getFlagValueFromArgs(args, "--chain");
    const consensusKey = getFlagValueFromArgs(args, "--consensus-key") || import_utils35.defaultConsensusKey;
    const dbTypeFlagValue = getFlagValueFromArgs(args, "--db-type");
    const useInMemoryDb = dbTypeFlagValue === "in-memory" || dbTypeFlagValue === void 0;
    const poaInstantFlagValue = getFlagValueFromArgs(args, "--poa-instant");
    const poaInstant = poaInstantFlagValue === "true" || poaInstantFlagValue === void 0;
    const graphQLStartSubstring = "Binding GraphQL provider to";
    const binPath = (0, import_cli_utils.findBinPath)("fuels-core", __dirname);
    const command = useSystemFuelCore ? "fuel-core" : binPath;
    const ipToUse = ip || "0.0.0.0";
    const portToUse = port || (await (0, import_portfinder.getPortPromise)({
      port: 4e3,
      // tries 4000 first, then 4001, then 4002, etc.
      stopPort: 5e3
      // don't try ports above 5000
    })).toString();
    let chainConfigPathToUse;
    const prefix = basePath || import_os.default.tmpdir();
    const suffix = basePath ? "" : (0, import_crypto5.randomUUID)();
    const tempDirPath = import_path.default.join(prefix, ".fuels", suffix);
    if (chainConfigPath) {
      chainConfigPathToUse = chainConfigPath;
    } else {
      if (!(0, import_fs.existsSync)(tempDirPath)) {
        (0, import_fs.mkdirSync)(tempDirPath, { recursive: true });
      }
      const tempChainConfigFilePath = import_path.default.join(tempDirPath, "chainConfig.json");
      let chainConfig = import_utils35.defaultChainConfig;
      if (!process.env.GENESIS_SECRET) {
        const pk = Signer.generatePrivateKey();
        const signer = new Signer(pk);
        process.env.GENESIS_SECRET = (0, import_utils35.hexlify)(pk);
        chainConfig = {
          ...import_utils35.defaultChainConfig,
          initial_state: {
            ...import_utils35.defaultChainConfig.initial_state,
            coins: [
              ...import_utils35.defaultChainConfig.initial_state.coins,
              {
                owner: signer.address.toHexString(),
                amount: (0, import_math20.toHex)(1e9),
                asset_id: import_configs12.BaseAssetId
              }
            ]
          }
        };
      }
      (0, import_fs.writeFileSync)(tempChainConfigFilePath, JSON.stringify(chainConfig), "utf8");
      chainConfigPathToUse = tempChainConfigFilePath;
    }
    const child = (0, import_child_process.spawn)(
      command,
      [
        "run",
        ["--ip", ipToUse],
        ["--port", portToUse],
        useInMemoryDb ? ["--db-type", "in-memory"] : ["--db-path", tempDirPath],
        ["--min-gas-price", "0"],
        poaInstant ? ["--poa-instant", "true"] : [],
        ["--consensus-key", consensusKey],
        ["--chain", chainConfigPathToUse],
        "--vm-backtrace",
        "--utxo-validation",
        "--debug",
        ...remainingArgs
      ].flat(),
      {
        stdio: "pipe"
      }
    );
    if (loggingEnabled) {
      child.stderr.pipe(process.stderr);
    }
    if (debugEnabled) {
      child.stdout.pipe(process.stdout);
    }
    const cleanupConfig = {
      child,
      configPath: tempDirPath,
      killFn: import_tree_kill.default,
      state: {
        isDead: false
      }
    };
    child.stderr.on("data", (chunk) => {
      if (chunk.indexOf(graphQLStartSubstring) !== -1) {
        resolve({
          cleanup: () => killNode(cleanupConfig),
          ip: ipToUse,
          port: portToUse,
          chainConfigPath: chainConfigPathToUse
        });
      }
      if (/error/i.test(chunk)) {
        reject(chunk.toString());
      }
    });
    process.on("exit", () => killNode(cleanupConfig));
    process.on("SIGINT", () => killNode(cleanupConfig));
    process.on("SIGUSR1", () => killNode(cleanupConfig));
    process.on("SIGUSR2", () => killNode(cleanupConfig));
    process.on("beforeExit", () => killNode(cleanupConfig));
    process.on("uncaughtException", () => killNode(cleanupConfig));
    child.on("error", reject);
  })
);
var generateWallets = async (count, provider) => {
  const wallets = [];
  for (let i = 0; i < count; i += 1) {
    const wallet = await generateTestWallet(provider, [[1e3, import_configs12.BaseAssetId]]);
    wallets.push(wallet);
  }
  return wallets;
};
var launchNodeAndGetWallets = async ({
  launchNodeOptions,
  walletCount = 10
} = {}) => {
  const { cleanup: closeNode, ip, port } = await launchNode(launchNodeOptions || {});
  const provider = await Provider.create(`http://${ip}:${port}/graphql`);
  const wallets = await generateWallets(walletCount, provider);
  const cleanup = () => {
    closeNode();
  };
  return { wallets, stop: cleanup, provider };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateTestWallet,
  killNode,
  launchNode,
  launchNodeAndGetWallets,
  seedTestWallet
});
//# sourceMappingURL=test-utils.js.map