{"version":3,"sources":["../src/cli.ts","../src/runTypegen.ts","../src/AbiTypeGen.ts","../src/abi/Abi.ts","../src/utils/findType.ts","../src/abi/configurable/Configurable.ts","../src/utils/makeConfigurable.ts","../src/utils/parseConfigurables.ts","../src/utils/parseTypeArguments.ts","../src/abi/functions/Function.ts","../src/utils/makeFunction.ts","../src/utils/parseFunctions.ts","../src/utils/makeType.ts","../src/abi/types/AType.ts","../src/abi/types/ArrayType.ts","../src/abi/types/StrType.ts","../src/abi/types/B256Type.ts","../src/abi/types/B512Type.ts","../src/abi/types/BoolType.ts","../src/abi/types/BytesType.ts","../src/utils/extractStructName.ts","../src/abi/types/EnumType.ts","../src/abi/types/EvmAddressType.ts","../src/abi/types/GenericType.ts","../src/abi/types/OptionType.ts","../src/abi/types/U8Type.ts","../src/abi/types/U64Type.ts","../src/abi/types/RawUntypedPtr.ts","../src/abi/types/RawUntypedSlice.ts","../src/abi/types/StdStringType.ts","../src/abi/types/StrSliceType.ts","../src/abi/types/StructType.ts","../src/abi/types/TupleType.ts","../src/abi/types/U16Type.ts","../src/abi/types/U256Type.ts","../src/abi/types/U32Type.ts","../src/abi/types/VectorType.ts","../src/utils/supportedTypes.ts","../src/utils/shouldSkipAbiType.ts","../src/utils/parseTypes.ts","../src/types/enums/ProgramTypeEnum.ts","../src/utils/assembleContracts.ts","../src/templates/renderHbsTemplate.ts","../src/templates/common/common.ts","../src/templates/common/index.ts","../src/templates/contract/bytecode.ts","../src/templates/utils/formatConfigurables.ts","../src/templates/utils/formatEnums.ts","../src/templates/utils/formatImports.ts","../src/templates/utils/formatStructs.ts","../src/templates/contract/dts.ts","../src/templates/contract/factory.ts","../src/utils/assemblePredicates.ts","../src/templates/predicate/factory.ts","../src/utils/assembleScripts.ts","../src/templates/script/factory.ts","../src/utils/validateBinFile.ts","../src/utils/collectBinFilePaths.ts","../src/utils/collectStorageSlotsFilePaths.ts","../src/bin.ts"],"sourcesContent":["import { versions } from '@fuel-ts/versions';\nimport { Command, Option } from 'commander';\n\nimport { runTypegen } from './runTypegen';\nimport { ProgramTypeEnum } from './types/enums/ProgramTypeEnum';\n\nexport interface ICliParams {\n  inputs: string[];\n  output: string;\n  silent?: boolean;\n  contract?: boolean;\n  script?: boolean;\n  predicate?: boolean;\n}\n\nexport function resolveProgramType(params: {\n  contract?: boolean;\n  script?: boolean;\n  predicate?: boolean;\n}) {\n  const { contract, script, predicate } = params;\n\n  const noneSpecified = !contract && !script && !predicate;\n\n  if (contract || noneSpecified) {\n    return ProgramTypeEnum.CONTRACT;\n  }\n\n  if (predicate) {\n    return ProgramTypeEnum.PREDICATE;\n  }\n\n  return ProgramTypeEnum.SCRIPT;\n}\n\nexport function runCliAction(options: ICliParams) {\n  const { inputs, output, silent, contract, script, predicate } = options;\n\n  const cwd = process.cwd();\n\n  const programType = resolveProgramType({ contract, script, predicate });\n\n  try {\n    runTypegen({\n      cwd,\n      inputs,\n      output,\n      programType,\n      silent: !!silent,\n    });\n  } catch (err) {\n    process.stderr.write(`error: ${(<Error>err).message}\\n`);\n    process.exit(1);\n  }\n}\n\nexport function configureCliOptions(program: Command) {\n  return program\n    .requiredOption('-i, --inputs <path|glob...>', 'Input paths/globals to your ABI JSON files')\n    .requiredOption('-o, --output <dir>', 'Directory path for generated files')\n    .addOption(\n      new Option('-c, --contract', 'Generate types for Contracts [default]')\n        .conflicts(['script', 'predicate'])\n        .implies({ script: undefined, predicate: undefined })\n    )\n    .addOption(\n      new Option('-s, --script', 'Generate types for Scripts')\n        .conflicts(['contract', 'predicate'])\n        .implies({ contract: undefined, predicate: undefined })\n    )\n    .addOption(\n      new Option('-p, --predicate', 'Generate types for Predicates')\n        .conflicts(['contract', 'script'])\n        .implies({ contract: undefined, script: undefined })\n    )\n    .option('-S, --silent', 'Omit output messages')\n    .action(runCliAction);\n}\n\nexport function run(params: { argv: string[]; programName: string }) {\n  const program = new Command();\n\n  const { argv, programName } = params;\n\n  program.name(programName);\n  program.version(versions.FUELS);\n  program.usage(`-i ../out/*-abi.json -o ./generated/`);\n\n  configureCliOptions(program);\n\n  program.parse(argv);\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { readFileSync, writeFileSync } from 'fs';\nimport { globSync } from 'glob';\nimport mkdirp from 'mkdirp';\nimport { basename } from 'path';\nimport rimraf from 'rimraf';\n\nimport { AbiTypeGen } from './AbiTypeGen';\nimport type { ProgramTypeEnum } from './types/enums/ProgramTypeEnum';\nimport type { IFile } from './types/interfaces/IFile';\nimport { collectBinFilepaths } from './utils/collectBinFilePaths';\nimport { collectStorageSlotsFilepaths } from './utils/collectStorageSlotsFilePaths';\n\nexport interface IGenerateFilesParams {\n  cwd: string;\n  filepaths?: string[];\n  inputs?: string[];\n  output: string;\n  silent?: boolean;\n  programType: ProgramTypeEnum;\n}\n\nexport function runTypegen(params: IGenerateFilesParams) {\n  const { cwd, inputs, output, silent, programType, filepaths: inputFilepaths } = params;\n\n  const cwdBasename = basename(cwd);\n\n  function log(...args: unknown[]) {\n    if (!silent) {\n      process.stdout.write(`${args.join(' ')}\\n`);\n    }\n  }\n\n  /*\n    Assembling files array and expanding globals if needed\n  */\n  let filepaths: string[] = [];\n\n  if (!inputFilepaths?.length && inputs?.length) {\n    filepaths = inputs.flatMap((i) => globSync(i, { cwd }));\n  } else if (inputFilepaths?.length) {\n    filepaths = inputFilepaths;\n  } else {\n    throw new FuelError(\n      ErrorCode.MISSING_REQUIRED_PARAMETER,\n      `At least one parameter should be supplied: 'input' or 'filepaths'.`\n    );\n  }\n\n  /*\n    Assembling file paths x contents\n  */\n  const abiFiles = filepaths.map((filepath) => {\n    const abi: IFile = {\n      path: filepath,\n      contents: readFileSync(filepath, 'utf-8'),\n    };\n    return abi;\n  });\n\n  if (!abiFiles.length) {\n    throw new FuelError(ErrorCode.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);\n  }\n\n  const binFiles = collectBinFilepaths({ filepaths, programType });\n\n  const storageSlotsFiles = collectStorageSlotsFilepaths({ filepaths, programType });\n\n  /*\n    Starting the engine\n  */\n  const abiTypeGen = new AbiTypeGen({\n    outputDir: output,\n    abiFiles,\n    binFiles,\n    storageSlotsFiles,\n    programType,\n  });\n\n  /*\n    Generating files\n  */\n  log('Generating files..\\n');\n\n  mkdirp.sync(`${output}/factories`);\n\n  abiTypeGen.files.forEach((file) => {\n    rimraf.sync(file.path);\n    writeFileSync(file.path, file.contents);\n    const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, 'm');\n    log(` - ${file.path.replace(trimPathRegex, '')}`);\n  });\n\n  log('\\nDone.âš¡');\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { Abi } from './abi/Abi';\nimport { ProgramTypeEnum } from './types/enums/ProgramTypeEnum';\nimport type { IFile } from './types/interfaces/IFile';\nimport { assembleContracts } from './utils/assembleContracts';\nimport { assemblePredicates } from './utils/assemblePredicates';\nimport { assembleScripts } from './utils/assembleScripts';\nimport { validateBinFile } from './utils/validateBinFile';\n\n/*\n  Manages many instances of Abi\n*/\nexport class AbiTypeGen {\n  public readonly abis: Abi[];\n  public readonly abiFiles: IFile[];\n  public readonly binFiles: IFile[];\n  public readonly storageSlotsFiles: IFile[];\n  public readonly outputDir: string;\n\n  public readonly files: IFile[];\n\n  constructor(params: {\n    abiFiles: IFile[];\n    binFiles: IFile[];\n    storageSlotsFiles: IFile[];\n    outputDir: string;\n    programType: ProgramTypeEnum;\n  }) {\n    const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles } = params;\n\n    this.outputDir = outputDir;\n\n    this.abiFiles = abiFiles;\n    this.binFiles = binFiles;\n    this.storageSlotsFiles = storageSlotsFiles;\n\n    // Creates a `Abi` for each abi file\n    this.abis = this.abiFiles.map((abiFile) => {\n      const binFilepath = abiFile.path.replace('-abi.json', '.bin');\n      const relatedBinFile = this.binFiles.find(({ path }) => path === binFilepath);\n\n      const storageSlotFilepath = abiFile.path.replace('-abi.json', '-storage_slots.json');\n      const relatedStorageSlotsFile = this.storageSlotsFiles.find(\n        ({ path }) => path === storageSlotFilepath\n      );\n\n      if (!relatedBinFile) {\n        validateBinFile({\n          abiFilepath: abiFile.path,\n          binExists: !!relatedBinFile,\n          binFilepath,\n          programType,\n        });\n      }\n\n      const abi = new Abi({\n        filepath: abiFile.path,\n        rawContents: JSON.parse(abiFile.contents as string),\n        hexlifiedBinContents: relatedBinFile?.contents,\n        storageSlotsContents: relatedStorageSlotsFile?.contents,\n        outputDir,\n        programType,\n      });\n\n      return abi;\n    });\n\n    // Assemble list of files to be written to disk\n    this.files = this.getAssembledFiles({ programType });\n  }\n\n  private getAssembledFiles(params: { programType: ProgramTypeEnum }): IFile[] {\n    const { abis, outputDir } = this;\n    const { programType } = params;\n\n    switch (programType) {\n      case ProgramTypeEnum.CONTRACT:\n        return assembleContracts({ abis, outputDir });\n      case ProgramTypeEnum.SCRIPT:\n        return assembleScripts({ abis, outputDir });\n      case ProgramTypeEnum.PREDICATE:\n        return assemblePredicates({ abis, outputDir });\n      default:\n        throw new FuelError(\n          ErrorCode.INVALID_INPUT_PARAMETERS,\n          `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(\n            ProgramTypeEnum\n          )}`\n        );\n    }\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { normalizeString } from '@fuel-ts/utils';\n\nimport type { ProgramTypeEnum } from '../types/enums/ProgramTypeEnum';\nimport type { IConfigurable } from '../types/interfaces/IConfigurable';\nimport type { IFunction } from '../types/interfaces/IFunction';\nimport type { IRawAbi } from '../types/interfaces/IRawAbi';\nimport type { IType } from '../types/interfaces/IType';\nimport { parseConfigurables } from '../utils/parseConfigurables';\nimport { parseFunctions } from '../utils/parseFunctions';\nimport { parseTypes } from '../utils/parseTypes';\n\n/*\n  Manages many instances of Types and Functions\n*/\nexport class Abi {\n  public name: string;\n  public programType: ProgramTypeEnum;\n\n  public filepath: string;\n  public outputDir: string;\n\n  public commonTypesInUse: string[] = [];\n\n  public rawContents: IRawAbi;\n  public hexlifiedBinContents?: string;\n  public storageSlotsContents?: string;\n\n  public types: IType[];\n  public functions: IFunction[];\n  public configurables: IConfigurable[];\n\n  constructor(params: {\n    filepath: string;\n    programType: ProgramTypeEnum;\n    rawContents: IRawAbi;\n    hexlifiedBinContents?: string;\n    storageSlotsContents?: string;\n    outputDir: string;\n  }) {\n    const {\n      filepath,\n      outputDir,\n      rawContents,\n      hexlifiedBinContents,\n      programType,\n      storageSlotsContents,\n    } = params;\n\n    const abiNameRegex = /([^/]+)-abi\\.json$/m;\n    const abiName = filepath.match(abiNameRegex);\n\n    const couldNotParseName = !abiName || abiName.length === 0;\n\n    if (couldNotParseName) {\n      throw new FuelError(\n        ErrorCode.PARSE_FAILED,\n        `Could not parse name from ABI file: ${filepath}.`\n      );\n    }\n\n    const name = `${normalizeString(abiName[1])}Abi`;\n\n    this.name = name;\n    this.programType = programType;\n\n    this.filepath = filepath;\n    this.rawContents = rawContents;\n    this.hexlifiedBinContents = hexlifiedBinContents;\n    this.storageSlotsContents = storageSlotsContents;\n    this.outputDir = outputDir;\n\n    const { types, functions, configurables } = this.parse();\n\n    this.types = types;\n    this.functions = functions;\n    this.configurables = configurables;\n\n    this.computeCommonTypesInUse();\n  }\n\n  parse() {\n    const {\n      types: rawAbiTypes,\n      functions: rawAbiFunctions,\n      configurables: rawAbiConfigurables,\n    } = this.rawContents;\n\n    const types = parseTypes({ rawAbiTypes });\n    const functions = parseFunctions({ rawAbiFunctions, types });\n    const configurables = parseConfigurables({ rawAbiConfigurables, types });\n\n    return {\n      types,\n      functions,\n      configurables,\n    };\n  }\n\n  computeCommonTypesInUse() {\n    const customTypesTable: Record<string, string> = {\n      option: 'Option',\n      enum: 'Enum',\n      vector: 'Vec',\n    };\n\n    this.commonTypesInUse = [];\n\n    Object.keys(customTypesTable).forEach((typeName) => {\n      const isInUse = !!this.types.find((t) => t.name === typeName);\n\n      if (isInUse) {\n        const commonTypeLabel: string = customTypesTable[typeName];\n        this.commonTypesInUse.push(commonTypeLabel);\n      }\n    });\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { IType } from '../types/interfaces/IType';\n\nexport function findType(params: { types: IType[]; typeId: number }) {\n  const { types, typeId } = params;\n\n  const foundType = types.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);\n\n  if (!foundType) {\n    throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);\n  }\n\n  // ensure type attributes is always parsed\n  foundType.parseComponentsAttributes({ types });\n\n  return foundType;\n}\n","import type { IConfigurable } from '../../types/interfaces/IConfigurable';\nimport type { IRawAbiConfigurable } from '../../types/interfaces/IRawAbiConfigurable';\nimport type { IType } from '../../types/interfaces/IType';\nimport { findType } from '../../utils/findType';\n\nexport class Configurable implements IConfigurable {\n  public name: string;\n  public type: IType;\n  public rawAbiConfigurable: IRawAbiConfigurable;\n\n  constructor(params: { types: IType[]; rawAbiConfigurable: IRawAbiConfigurable }) {\n    const { types, rawAbiConfigurable } = params;\n\n    this.name = rawAbiConfigurable.name;\n    this.rawAbiConfigurable = rawAbiConfigurable;\n    this.type = findType({ types, typeId: rawAbiConfigurable.configurableType.type });\n  }\n}\n","import { Configurable } from '../abi/configurable/Configurable';\nimport type { IRawAbiConfigurable } from '../types/interfaces/IRawAbiConfigurable';\nimport type { IType } from '../types/interfaces/IType';\n\nexport function makeConfigurable(params: {\n  types: IType[];\n  rawAbiConfigurable: IRawAbiConfigurable;\n}) {\n  const { types, rawAbiConfigurable } = params;\n  return new Configurable({ types, rawAbiConfigurable });\n}\n","import type { IConfigurable } from '../types/interfaces/IConfigurable';\nimport type { IRawAbiConfigurable } from '../types/interfaces/IRawAbiConfigurable';\nimport type { IType } from '../types/interfaces/IType';\n\nimport { makeConfigurable } from './makeConfigurable';\n\nexport function parseConfigurables(params: {\n  types: IType[];\n  rawAbiConfigurables: IRawAbiConfigurable[];\n}) {\n  const { types, rawAbiConfigurables } = params;\n\n  const configurables: IConfigurable[] = rawAbiConfigurables.map((rawAbiConfigurable) =>\n    makeConfigurable({ types, rawAbiConfigurable })\n  );\n\n  return configurables;\n}\n","import type { TargetEnum } from '../types/enums/TargetEnum';\nimport type { IRawAbiTypeComponent } from '../types/interfaces/IRawAbiType';\nimport type { IType } from '../types/interfaces/IType';\n\nimport { findType } from './findType';\n\n/*\n  Recursively parses the given `typeArguments` node\n*/\nexport function parseTypeArguments(params: {\n  types: IType[];\n  target: TargetEnum;\n  typeArguments: IRawAbiTypeComponent[];\n  parentTypeId?: number;\n}): string {\n  const { types, typeArguments, parentTypeId, target } = params;\n\n  const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n\n  const buffer: string[] = [];\n\n  let parentType: IType | undefined;\n  let parentLabel: string | undefined;\n\n  if (parentTypeId !== undefined) {\n    parentType = findType({ types, typeId: parentTypeId });\n    parentLabel = parentType.attributes[attributeKey];\n  }\n\n  // loop through all `typeArgument` items\n  typeArguments.forEach((typeArgument) => {\n    let currentLabel: string;\n\n    const currentTypeId = typeArgument.type;\n\n    try {\n      const currentType = findType({ types, typeId: currentTypeId });\n      currentLabel = currentType.attributes[attributeKey];\n    } catch (_err) {\n      // used for functions without output\n      currentLabel = 'void';\n    }\n\n    if (typeArgument.typeArguments) {\n      // recursively process nested `typeArguments`\n      const nestedParsed = parseTypeArguments({\n        types,\n        target,\n        parentTypeId: typeArgument.type,\n        typeArguments: typeArgument.typeArguments,\n      });\n\n      buffer.push(nestedParsed);\n    } else {\n      buffer.push(`${currentLabel}`);\n    }\n  });\n\n  let output = buffer.join(', ');\n\n  if (parentLabel) {\n    output = `${parentLabel}<${output}>`;\n  }\n\n  return output;\n}\n","import type { IFunction, IRawAbiFunction, IFunctionAttributes } from '../../index';\nimport { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { findType } from '../../utils/findType';\nimport { parseTypeArguments } from '../../utils/parseTypeArguments';\n\nexport class Function implements IFunction {\n  public name: string;\n  public types: IType[];\n  public rawAbiFunction: IRawAbiFunction;\n  public attributes: IFunctionAttributes;\n\n  constructor(params: { types: IType[]; rawAbiFunction: IRawAbiFunction }) {\n    this.rawAbiFunction = params.rawAbiFunction;\n    this.types = params.types;\n    this.name = params.rawAbiFunction.name;\n\n    this.attributes = {\n      inputs: this.bundleInputTypes(),\n      output: this.bundleOutputTypes(),\n      prefixedInputs: this.bundleInputTypes(true),\n    };\n  }\n\n  bundleInputTypes(shouldPrefixParams: boolean = false) {\n    const { types } = this;\n\n    // loop through all inputs\n    const inputs = this.rawAbiFunction.inputs.map((input) => {\n      const { name, type: typeId, typeArguments } = input;\n\n      const type = findType({ types, typeId });\n\n      let typeDecl: string;\n\n      if (typeArguments) {\n        // recursively process child `typeArguments`\n        typeDecl = parseTypeArguments({\n          types,\n          target: TargetEnum.INPUT,\n          parentTypeId: typeId,\n          typeArguments,\n        });\n      } else {\n        // or just collect type declaration\n        typeDecl = type.attributes.inputLabel;\n      }\n\n      // assemble it in `[key: string]: <Type>` fashion\n      if (shouldPrefixParams) {\n        return `${name}: ${typeDecl}`;\n      }\n\n      return typeDecl;\n    });\n\n    return inputs.join(', ');\n  }\n\n  bundleOutputTypes() {\n    return parseTypeArguments({\n      types: this.types,\n      target: TargetEnum.OUTPUT,\n      typeArguments: [this.rawAbiFunction.output],\n    });\n  }\n\n  getDeclaration() {\n    const { name } = this;\n    const { prefixedInputs, output } = this.attributes;\n    const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output}>`;\n    return decl;\n  }\n}\n","import { Function } from '../abi/functions/Function';\nimport type { IRawAbiFunction } from '../types/interfaces/IRawAbiFunction';\nimport type { IType } from '../types/interfaces/IType';\n\nexport function makeFunction(params: { types: IType[]; rawAbiFunction: IRawAbiFunction }) {\n  const { types, rawAbiFunction } = params;\n  return new Function({ types, rawAbiFunction });\n}\n","import type { IFunction } from '../types/interfaces/IFunction';\nimport type { IRawAbiFunction } from '../types/interfaces/IRawAbiFunction';\nimport type { IType } from '../types/interfaces/IType';\n\nimport { makeFunction } from './makeFunction';\n\nexport function parseFunctions(params: { types: IType[]; rawAbiFunctions: IRawAbiFunction[] }) {\n  const { types, rawAbiFunctions } = params;\n  const functions: IFunction[] = rawAbiFunctions.map((rawAbiFunction) =>\n    makeFunction({ types, rawAbiFunction })\n  );\n  return functions;\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { IRawAbiTypeRoot } from '../types/interfaces/IRawAbiType';\n\nimport { supportedTypes } from './supportedTypes';\n\nexport function makeType(params: { rawAbiType: IRawAbiTypeRoot }) {\n  const { rawAbiType } = params;\n  const { type } = rawAbiType;\n\n  const TypeClass = supportedTypes.find((tc) => tc.isSuitableFor({ type }));\n\n  if (!TypeClass) {\n    throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Type not supported: ${type}`);\n  }\n\n  return new TypeClass(params);\n}\n","import type { IRawAbiTypeRoot } from '../../types/interfaces/IRawAbiType';\nimport type { ITypeAttributes } from '../../types/interfaces/IType';\n\nexport class AType {\n  public rawAbiType: IRawAbiTypeRoot;\n  public attributes: ITypeAttributes;\n  public requiredFuelsMembersImports: string[];\n\n  constructor(params: { rawAbiType: IRawAbiTypeRoot }) {\n    this.rawAbiType = params.rawAbiType;\n    this.attributes = {\n      inputLabel: 'unknown',\n      outputLabel: 'unknown',\n    };\n    this.requiredFuelsMembersImports = [];\n  }\n}\n","import { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { findType } from '../../utils/findType';\nimport { parseTypeArguments } from '../../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class ArrayType extends AType implements IType {\n  // Note: the array length expressed in '; 2]' could be any length\n  public static swayType = '[_; 2]';\n\n  public name = 'array';\n\n  static MATCH_REGEX: RegExp = /^\\[_; ([0-9]+)\\]$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return ArrayType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(params: { types: IType[] }) {\n    const { types } = params;\n    const { type } = this.rawAbiType;\n\n    // array length will be used to generated a fixed-length array type\n    const arrayLen = Number(type.match(ArrayType.MATCH_REGEX)?.[1]);\n\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n\n    this.rawAbiType.components?.forEach((component) => {\n      const { type: typeId, typeArguments } = component;\n\n      if (!typeArguments) {\n        // if component has no type arguments, read its attributes and voilÃ \n        const { attributes } = findType({ types, typeId });\n\n        inputs.push(attributes.inputLabel);\n        outputs.push(attributes.outputLabel);\n      } else {\n        // otherwise process child `typeArguments` recursively\n        const inputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.INPUT,\n        });\n\n        const outputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.OUTPUT,\n        });\n\n        inputs.push(inputLabel);\n        outputs.push(outputLabel);\n      }\n    });\n\n    // fixed-length array, based on `arrayLen`\n    const inputTypes = Array(arrayLen).fill(inputs[0]).join(', ');\n    const outputTypes = Array(arrayLen).fill(outputs[0]).join(', ');\n\n    this.attributes = {\n      inputLabel: `[${inputTypes}]`,\n      outputLabel: `[${outputTypes}]`,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class StrType extends AType implements IType {\n  // Note: the str length expressed in '[3]' could be any length\n  public static swayType = 'str[3]';\n\n  public name = 'str';\n\n  static MATCH_REGEX: RegExp = /^str\\[(.+)\\]$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return StrType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: 'string',\n      outputLabel: 'string',\n    };\n    return this.attributes;\n  }\n}\n","import { StrType } from './StrType';\n\nexport class B256Type extends StrType {\n  public static swayType = 'b256';\n\n  public name = 'b256';\n\n  static MATCH_REGEX = /^b256$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return B256Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import { B256Type } from './B256Type';\n\nexport class B512Type extends B256Type {\n  public static swayType = 'struct B512';\n\n  public name = 'b512';\n\n  static MATCH_REGEX = /^struct B512$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return B512Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class BoolType extends AType implements IType {\n  public static swayType = 'bool';\n\n  public name = 'bool';\n\n  static MATCH_REGEX: RegExp = /^bool$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return BoolType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: 'boolean',\n      outputLabel: 'boolean',\n    };\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { ArrayType } from './ArrayType';\n\nexport class BytesType extends ArrayType {\n  public static swayType = 'struct Bytes';\n\n  public name = 'bytes';\n\n  static MATCH_REGEX: RegExp = /^struct Bytes/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return BytesType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const capitalizedName = 'Bytes';\n\n    this.attributes = {\n      inputLabel: capitalizedName,\n      outputLabel: capitalizedName,\n    };\n\n    this.requiredFuelsMembersImports = [capitalizedName];\n\n    return this.attributes;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { IRawAbiTypeRoot } from '../types/interfaces/IRawAbiType';\n\nexport function extractStructName(params: { rawAbiType: IRawAbiTypeRoot; regex: RegExp }) {\n  const { rawAbiType, regex } = params;\n\n  const match = rawAbiType.type.match(params.regex)?.[1];\n\n  if (!match) {\n    let errorMessage = `Couldn't extract struct name with: '${regex}'.\\n\\n`;\n    errorMessage += `Check your JSON ABI.\\n\\n[source]\\n`;\n    errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;\n\n    throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);\n  }\n\n  return match;\n}\n","import type { IRawAbiTypeComponent } from '../../index';\nimport type { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { extractStructName } from '../../utils/extractStructName';\nimport { findType } from '../../utils/findType';\n\nimport { AType } from './AType';\n\nexport class EnumType extends AType implements IType {\n  public static swayType = 'enum MyEnumName';\n\n  public name = 'enum';\n\n  static MATCH_REGEX: RegExp = /^enum (.+)$/m;\n  static IGNORE_REGEX: RegExp = /^enum Option$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = EnumType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = EnumType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const structName = this.getStructName();\n\n    this.attributes = {\n      structName,\n      inputLabel: `${structName}Input`,\n      outputLabel: `${structName}Output`,\n    };\n\n    return this.attributes;\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: EnumType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public getNativeEnum(params: { types: IType[] }) {\n    const { types } = params;\n\n    const typeHash: { [key: number]: IType['rawAbiType'] } = types.reduce(\n      (hash, row) => ({\n        ...hash,\n        [row.rawAbiType.typeId]: row,\n      }),\n      {}\n    );\n\n    const { components } = this.rawAbiType;\n\n    // `components` array guaranteed to always exist for structs/enums\n    const enumComponents = components as IRawAbiTypeComponent[];\n\n    if (!enumComponents.every(({ type }) => !typeHash[type])) {\n      return undefined;\n    }\n\n    return enumComponents.map(({ name }) => `${name} = '${name}'`).join(', ');\n  }\n\n  public getStructContents(params: { types: IType[]; target: TargetEnum }) {\n    const { types, target } = params;\n\n    const { components } = this.rawAbiType;\n\n    // `components` array guaranteed to always exist for structs/enums\n    const enumComponents = components as IRawAbiTypeComponent[];\n\n    const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n\n    const contents = enumComponents.map((component) => {\n      const { name, type: typeId } = component;\n\n      if (typeId === 0) {\n        return `${name}: []`;\n      }\n\n      const { attributes } = findType({ types, typeId });\n      return `${name}: ${attributes[attributeKey]}`;\n    });\n\n    return contents.join(', ');\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class EvmAddressType extends AType implements IType {\n  public static swayType = 'struct EvmAddress';\n\n  public name = 'evmAddress';\n\n  static MATCH_REGEX: RegExp = /^struct EvmAddress$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return EvmAddressType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const capitalizedName = 'EvmAddress';\n\n    this.attributes = {\n      inputLabel: capitalizedName,\n      outputLabel: capitalizedName,\n    };\n\n    this.requiredFuelsMembersImports = [capitalizedName];\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\nimport { extractStructName } from '../../utils/extractStructName';\n\nimport { AType } from './AType';\n\nexport class GenericType extends AType implements IType {\n  public static swayType = 'generic T';\n\n  public name = 'generic';\n\n  static MATCH_REGEX: RegExp = /^generic ([^\\s]+)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return GenericType.MATCH_REGEX.test(params.type);\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: GenericType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const label = this.getStructName();\n\n    this.attributes = {\n      inputLabel: label,\n      outputLabel: label,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class OptionType extends AType implements IType {\n  public static swayType = 'enum Option';\n\n  public name = 'option';\n\n  static MATCH_REGEX: RegExp = /^enum Option$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return OptionType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `Option`,\n      outputLabel: `Option`,\n    };\n    return this.attributes;\n  }\n}\n","import type { IRawAbiTypeRoot } from '../../index';\nimport type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class U8Type extends AType implements IType {\n  public static swayType = 'u8';\n\n  public name = 'u8';\n\n  public static MATCH_REGEX: RegExp = /^u8$/m;\n\n  constructor(params: { rawAbiType: IRawAbiTypeRoot }) {\n    super(params);\n    this.attributes = {\n      inputLabel: `BigNumberish`,\n      outputLabel: `number`,\n    };\n    this.requiredFuelsMembersImports = [this.attributes.inputLabel];\n  }\n\n  static isSuitableFor(params: { type: string }) {\n    return U8Type.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U64Type extends U8Type implements IType {\n  public static swayType = 'u64';\n\n  public name = 'u64';\n\n  public static MATCH_REGEX: RegExp = /^u64$/m;\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `BigNumberish`,\n      outputLabel: `BN`,\n    };\n    this.requiredFuelsMembersImports = Object.values(this.attributes);\n    return this.attributes;\n  }\n\n  static isSuitableFor(params: { type: string }) {\n    return U64Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U64Type } from './U64Type';\n\nexport class RawUntypedPtr extends U64Type implements IType {\n  public static swayType = 'raw untyped ptr';\n\n  public name = 'rawUntypedPtr';\n\n  public static MATCH_REGEX: RegExp = /^raw untyped ptr$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return RawUntypedPtr.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { ArrayType } from './ArrayType';\n\nexport class RawUntypedSlice extends ArrayType {\n  public static swayType = 'raw untyped slice';\n\n  public name = 'rawUntypedSlice';\n\n  public static MATCH_REGEX: RegExp = /^raw untyped slice$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return RawUntypedSlice.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const capitalizedName = 'RawSlice';\n\n    this.attributes = {\n      inputLabel: capitalizedName,\n      outputLabel: capitalizedName,\n    };\n\n    this.requiredFuelsMembersImports = [capitalizedName];\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class StdStringType extends AType implements IType {\n  public static swayType = 'struct String';\n\n  public name = 'stdString';\n\n  static MATCH_REGEX: RegExp = /^struct String/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return StdStringType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const capitalizedName = 'StdString';\n\n    this.attributes = {\n      inputLabel: capitalizedName,\n      outputLabel: capitalizedName,\n    };\n\n    this.requiredFuelsMembersImports = [capitalizedName];\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { AType } from './AType';\n\nexport class StrSliceType extends AType implements IType {\n  public static swayType = 'str';\n\n  public name = 'strSlice';\n\n  static MATCH_REGEX: RegExp = /^str$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return StrSliceType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: 'StrSlice',\n      outputLabel: 'StrSlice',\n    };\n    return this.attributes;\n  }\n}\n","import type { IRawAbiTypeComponent } from '../../index';\nimport type { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { extractStructName } from '../../utils/extractStructName';\nimport { findType } from '../../utils/findType';\nimport { parseTypeArguments } from '../../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class StructType extends AType implements IType {\n  public static swayType = 'struct MyStruct';\n\n  public name = 'struct';\n\n  static MATCH_REGEX: RegExp = /^struct (.+)$/m;\n  static IGNORE_REGEX: RegExp = /^struct (Vec|RawVec|EvmAddress|Bytes|String)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = StructType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = StructType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    const structName = this.getStructName();\n\n    this.attributes = {\n      structName,\n      inputLabel: `${structName}Input`,\n      outputLabel: `${structName}Output`,\n    };\n\n    return this.attributes;\n  }\n\n  public getStructName() {\n    const name = extractStructName({\n      rawAbiType: this.rawAbiType,\n      regex: StructType.MATCH_REGEX,\n    });\n    return name;\n  }\n\n  public getStructContents(params: { types: IType[]; target: TargetEnum }) {\n    const { types, target } = params;\n    const { components } = this.rawAbiType;\n\n    // `components` array guaranteed to always exist for structs/enums\n    const structComponents = components as IRawAbiTypeComponent[];\n\n    // loop through all components\n    const members = structComponents.map((component) => {\n      const { name, type: typeId, typeArguments } = component;\n\n      const type = findType({ types, typeId });\n\n      let typeDecl: string;\n\n      if (typeArguments) {\n        // recursively process child `typeArguments`\n        typeDecl = parseTypeArguments({\n          types,\n          target,\n          parentTypeId: typeId,\n          typeArguments,\n        });\n      } else {\n        // or just collect type declaration\n        const attributeKey: 'inputLabel' | 'outputLabel' = `${target}Label`;\n        typeDecl = type.attributes[attributeKey];\n      }\n\n      // assemble it in `[key: string]: <Type>` fashion\n      return `${name}: ${typeDecl}`;\n    });\n\n    return members.join(', ');\n  }\n\n  public getStructDeclaration(params: { types: IType[] }) {\n    const { types } = params;\n    const { typeParameters } = this.rawAbiType;\n\n    if (typeParameters) {\n      const structs = typeParameters.map((typeId) => findType({ types, typeId }));\n\n      const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);\n\n      return `<${labels.join(', ')}>`;\n    }\n\n    return '';\n  }\n}\n","import { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\nimport { findType } from '../../utils/findType';\nimport { parseTypeArguments } from '../../utils/parseTypeArguments';\n\nimport { AType } from './AType';\n\nexport class TupleType extends AType implements IType {\n  // Note: a tuple can have more/less than 3x items (like the one bellow)\n  public static swayType = '(_, _, _)';\n\n  public name = 'tupple';\n\n  static MATCH_REGEX: RegExp = /^\\([_,\\s]+\\)$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return TupleType.MATCH_REGEX.test(params.type);\n  }\n\n  public parseComponentsAttributes(params: { types: IType[] }) {\n    const { types } = params;\n\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n\n    this.rawAbiType.components?.forEach((component) => {\n      const { type: typeId, typeArguments } = component;\n\n      if (!typeArguments) {\n        // if component has no type arguments, read its attributes and voilÃ \n        const { attributes } = findType({ types, typeId });\n\n        inputs.push(attributes.inputLabel);\n        outputs.push(attributes.outputLabel);\n      } else {\n        // otherwise process child `typeArguments` recursively\n        const inputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.INPUT,\n        });\n\n        const outputLabel = parseTypeArguments({\n          types,\n          typeArguments,\n          parentTypeId: typeId,\n          target: TargetEnum.OUTPUT,\n        });\n\n        inputs.push(inputLabel);\n        outputs.push(outputLabel);\n      }\n    });\n\n    this.attributes = {\n      inputLabel: `[${inputs.join(', ')}]`,\n      outputLabel: `[${outputs.join(', ')}]`,\n    };\n\n    return this.attributes;\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U16Type extends U8Type implements IType {\n  public static swayType = 'u16';\n\n  public name = 'u16';\n\n  public static MATCH_REGEX: RegExp = /^u16$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return U16Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U64Type } from './U64Type';\n\nexport class U256Type extends U64Type implements IType {\n  public static swayType = 'u256';\n\n  public name = 'u256';\n\n  public static MATCH_REGEX: RegExp = /^u256$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return U256Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { U8Type } from './U8Type';\n\nexport class U32Type extends U8Type implements IType {\n  public static swayType = 'u32';\n\n  public name = 'u32';\n\n  public static MATCH_REGEX: RegExp = /^u32$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    return U32Type.MATCH_REGEX.test(params.type);\n  }\n}\n","import type { IType } from '../../types/interfaces/IType';\n\nimport { ArrayType } from './ArrayType';\n\nexport class VectorType extends ArrayType {\n  public static swayType = 'struct Vec';\n\n  public name = 'vector';\n\n  static MATCH_REGEX: RegExp = /^struct Vec/m;\n  static IGNORE_REGEX: RegExp = /^struct RawVec$/m;\n\n  static isSuitableFor(params: { type: string }) {\n    const isAMatch = VectorType.MATCH_REGEX.test(params.type);\n    const shouldBeIgnored = VectorType.IGNORE_REGEX.test(params.type);\n    return isAMatch && !shouldBeIgnored;\n  }\n\n  public parseComponentsAttributes(_params: { types: IType[] }) {\n    this.attributes = {\n      inputLabel: `Vec`,\n      outputLabel: `Vec`,\n    };\n    return this.attributes;\n  }\n}\n","import { ArrayType } from '../abi/types/ArrayType';\nimport { B256Type } from '../abi/types/B256Type';\nimport { B512Type } from '../abi/types/B512Type';\nimport { BoolType } from '../abi/types/BoolType';\nimport { BytesType } from '../abi/types/BytesType';\nimport { EnumType } from '../abi/types/EnumType';\nimport { EvmAddressType } from '../abi/types/EvmAddressType';\nimport { GenericType } from '../abi/types/GenericType';\nimport { OptionType } from '../abi/types/OptionType';\nimport { RawUntypedPtr } from '../abi/types/RawUntypedPtr';\nimport { RawUntypedSlice } from '../abi/types/RawUntypedSlice';\nimport { StdStringType } from '../abi/types/StdStringType';\nimport { StrSliceType } from '../abi/types/StrSliceType';\nimport { StrType } from '../abi/types/StrType';\nimport { StructType } from '../abi/types/StructType';\nimport { TupleType } from '../abi/types/TupleType';\nimport { U16Type } from '../abi/types/U16Type';\nimport { U256Type } from '../abi/types/U256Type';\nimport { U32Type } from '../abi/types/U32Type';\nimport { U64Type } from '../abi/types/U64Type';\nimport { U8Type } from '../abi/types/U8Type';\nimport { VectorType } from '../abi/types/VectorType';\n\nexport const supportedTypes = [\n  ArrayType,\n  B256Type,\n  B512Type,\n  BoolType,\n  BytesType,\n  EnumType,\n  GenericType,\n  OptionType,\n  RawUntypedPtr,\n  RawUntypedSlice,\n  StdStringType,\n  StrType,\n  StrSliceType,\n  StructType,\n  TupleType,\n  U16Type,\n  U32Type,\n  U64Type,\n  U256Type,\n  U8Type,\n  VectorType,\n  EvmAddressType,\n];\n","export function shouldSkipAbiType(params: { type: string }) {\n  const ignoreList = ['()', 'struct RawVec'];\n  const shouldSkip = ignoreList.indexOf(params.type) >= 0;\n  return shouldSkip;\n}\n","import type { IRawAbiTypeRoot } from '../types/interfaces/IRawAbiType';\nimport type { IType } from '../types/interfaces/IType';\n\nimport { makeType } from './makeType';\nimport { shouldSkipAbiType } from './shouldSkipAbiType';\n\nexport function parseTypes(params: { rawAbiTypes: IRawAbiTypeRoot[] }) {\n  const types: IType[] = [];\n\n  // First we parse all ROOT nodes\n  params.rawAbiTypes.forEach((rawAbiType) => {\n    const { type } = rawAbiType;\n    const skip = shouldSkipAbiType({ type });\n    if (!skip) {\n      const parsedType = makeType({ rawAbiType });\n      types.push(parsedType);\n    }\n  });\n\n  // Then we parse all their components' [attributes]\n  types.forEach((type) => {\n    type.parseComponentsAttributes({ types });\n  });\n\n  return types;\n}\n","export enum ProgramTypeEnum {\n  CONTRACT = 'contract',\n  SCRIPT = 'script',\n  PREDICATE = 'predicate',\n}\n","import { join } from 'path';\n\nimport type { Abi } from '../abi/Abi';\nimport type { IFile } from '../index';\nimport { renderCommonTemplate } from '../templates/common/common';\nimport { renderIndexTemplate } from '../templates/common/index';\nimport { renderBytecodeTemplate } from '../templates/contract/bytecode';\nimport { renderDtsTemplate } from '../templates/contract/dts';\nimport { renderFactoryTemplate } from '../templates/contract/factory';\n\n/**\n * Render all Contract-related templates and returns\n * an array of `IFile` with them all. For here on,\n * the only thing missing is to write them to disk.\n */\nexport function assembleContracts(params: { abis: Abi[]; outputDir: string }) {\n  const { abis, outputDir } = params;\n\n  const files: IFile[] = [];\n  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);\n\n  abis.forEach((abi) => {\n    const { name } = abi;\n\n    const dtsFilepath = `${outputDir}/${name}.d.ts`;\n    const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;\n    const hexBinFilePath = `${outputDir}/${name}.hex.ts`;\n\n    const dts: IFile = {\n      path: dtsFilepath,\n      contents: renderDtsTemplate({ abi }),\n    };\n\n    const factory: IFile = {\n      path: factoryFilepath,\n      contents: renderFactoryTemplate({ abi }),\n    };\n\n    const hexBinFile: IFile = {\n      path: hexBinFilePath,\n      contents: renderBytecodeTemplate({\n        hexlifiedBytecode: abi.hexlifiedBinContents as string,\n      }),\n    };\n\n    files.push(dts);\n    files.push(factory);\n    files.push(hexBinFile);\n  });\n\n  // Includes index file\n  const indexFile: IFile = {\n    path: `${outputDir}/index.ts`,\n    contents: renderIndexTemplate({ abis }),\n  };\n\n  files.push(indexFile);\n\n  // Conditionally includes `common.d.ts` file if needed\n  if (usesCommonTypes) {\n    const commonsFilepath = join(outputDir, 'common.d.ts');\n    const file: IFile = {\n      path: commonsFilepath,\n      contents: renderCommonTemplate(),\n    };\n    files.push(file);\n  }\n\n  return files;\n}\n","import { versions } from '@fuel-ts/versions';\nimport { compile } from 'handlebars';\n\nimport headerTemplate from './common/_header.hbs';\n\n/*\n  Renders the given template w/ the given data, while injecting common\n  header for disabling lint rules and annotating Fuel component's versions.\n*/\nexport function renderHbsTemplate(params: { template: string; data?: Record<string, unknown> }) {\n  const { data, template } = params;\n\n  const options = {\n    strict: true,\n    noEscape: true,\n  };\n\n  const renderTemplate = compile(template, options);\n  const renderHeaderTemplate = compile(headerTemplate, options);\n\n  const text = renderTemplate({\n    ...data,\n    header: renderHeaderTemplate(versions),\n  });\n\n  return text.replace(/[\\n]{3,}/gm, '\\n\\n');\n}\n","import { renderHbsTemplate } from '../renderHbsTemplate';\n\nimport commonTemplate from './common.hbs';\n\nexport function renderCommonTemplate() {\n  const text = renderHbsTemplate({ template: commonTemplate });\n  return text;\n}\n","import type { Abi } from '../../abi/Abi';\nimport { ProgramTypeEnum } from '../../types/enums/ProgramTypeEnum';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\n\nimport indexTemplate from './index.hbs';\n\nexport function renderIndexTemplate(params: { abis: Abi[] }) {\n  const { abis } = params;\n\n  const isGeneratingContracts = abis[0].programType === ProgramTypeEnum.CONTRACT;\n  const isGeneratingPredicates = abis[0].programType === ProgramTypeEnum.PREDICATE;\n\n  const text = renderHbsTemplate({\n    template: indexTemplate,\n    data: { abis, isGeneratingContracts, isGeneratingPredicates },\n  });\n\n  return text;\n}\n","import type { BytesLike } from '@fuel-ts/interfaces';\n\nimport { renderHbsTemplate } from '../renderHbsTemplate';\n\nimport bytecodeTemplate from './bytecode.hbs';\n\nexport function renderBytecodeTemplate(params: { hexlifiedBytecode: BytesLike }) {\n  const text = renderHbsTemplate({\n    template: bytecodeTemplate,\n    data: {\n      hexlifiedBytecode: params.hexlifiedBytecode,\n    },\n  });\n\n  return text;\n}\n","import type { IConfigurable } from '../../types/interfaces/IConfigurable';\n\nexport function formatConfigurables(params: { configurables: IConfigurable[] }) {\n  const { configurables } = params;\n\n  const formattedConfigurables = configurables.map((c) => {\n    const {\n      name,\n      type: {\n        attributes: { inputLabel },\n      },\n    } = c;\n\n    return {\n      configurableName: name,\n      configurableType: inputLabel,\n    };\n  });\n\n  return { formattedConfigurables };\n}\n","import type { EnumType } from '../../abi/types/EnumType';\nimport { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\n\nexport function formatEnums(params: { types: IType[] }) {\n  const { types } = params;\n\n  const enums = types\n    .filter((t) => t.name === 'enum')\n    .map((t) => {\n      const et = t as EnumType; // only enums here\n      const structName = et.getStructName();\n      const inputValues = et.getStructContents({ types, target: TargetEnum.INPUT });\n      const outputValues = et.getStructContents({ types, target: TargetEnum.OUTPUT });\n      const inputNativeValues = et.getNativeEnum({ types });\n      const outputNativeValues = et.getNativeEnum({ types });\n\n      return {\n        structName,\n        inputValues,\n        outputValues,\n        recycleRef: inputValues === outputValues, // reduces duplication\n        inputNativeValues,\n        outputNativeValues,\n      };\n    });\n\n  return { enums };\n}\n","import { uniq } from 'ramda';\n\nimport type { IType } from '../../types/interfaces/IType';\n\nconst caseInsensitiveSort = (a: string, b: string) =>\n  a.toLowerCase().localeCompare(b.toLowerCase());\n\nexport function formatImports(params: { types: IType[]; baseMembers?: string[] }) {\n  const { types, baseMembers = [] } = params;\n\n  const members = types.flatMap((t) => t.requiredFuelsMembersImports);\n  const imports = uniq(baseMembers.concat(members).sort(caseInsensitiveSort));\n\n  return {\n    imports: imports.length ? imports : undefined,\n  };\n}\n","import type { StructType } from '../../abi/types/StructType';\nimport { TargetEnum } from '../../types/enums/TargetEnum';\nimport type { IType } from '../../types/interfaces/IType';\n\nexport function formatStructs(params: { types: IType[] }) {\n  const { types } = params;\n\n  const structs = types\n    .filter((t) => t.name === 'struct')\n    .map((t) => {\n      const st = t as StructType; // only structs here\n      const structName = st.getStructName();\n      const inputValues = st.getStructContents({ types, target: TargetEnum.INPUT });\n      const outputValues = st.getStructContents({ types, target: TargetEnum.OUTPUT });\n      const typeAnnotations = st.getStructDeclaration({ types });\n      return {\n        structName,\n        typeAnnotations,\n        inputValues,\n        outputValues,\n        recycleRef: inputValues === outputValues, // reduces duplication\n      };\n    });\n\n  return { structs };\n}\n","import type { Abi } from '../../abi/Abi';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\nimport { formatConfigurables } from '../utils/formatConfigurables';\nimport { formatEnums } from '../utils/formatEnums';\nimport { formatImports } from '../utils/formatImports';\nimport { formatStructs } from '../utils/formatStructs';\n\nimport dtsTemplate from './dts.hbs';\n\nexport function renderDtsTemplate(params: { abi: Abi }) {\n  const { name: capitalizedName, types, functions, commonTypesInUse, configurables } = params.abi;\n\n  /*\n    First we format all attributes\n  */\n  const functionsTypedefs = functions.map((f) => f.getDeclaration());\n\n  const functionsFragments = functions.map((f) => f.name);\n\n  const encoders = functions.map((f) => ({\n    functionName: f.name,\n    input: f.attributes.inputs,\n  }));\n\n  const decoders = functions.map((f) => ({\n    functionName: f.name,\n  }));\n\n  const { enums } = formatEnums({ types });\n  const { structs } = formatStructs({ types });\n  const { imports } = formatImports({\n    types,\n    baseMembers: [\n      'Interface',\n      'FunctionFragment',\n      'DecodedValue',\n      'Contract',\n      'BytesLike',\n      'InvokeFunction',\n    ],\n  });\n  const { formattedConfigurables } = formatConfigurables({ configurables });\n\n  /*\n    And finally render template\n  */\n  const text = renderHbsTemplate({\n    template: dtsTemplate,\n    data: {\n      capitalizedName,\n      commonTypesInUse: commonTypesInUse.join(', '),\n      functionsTypedefs,\n      functionsFragments,\n      encoders,\n      decoders,\n      structs,\n      enums,\n      imports,\n      formattedConfigurables,\n    },\n  });\n\n  return text;\n}\n","import type { Abi } from '../../abi/Abi';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\n\nimport factoryTemplate from './factory.hbs';\n\nexport function renderFactoryTemplate(params: { abi: Abi }) {\n  const { name: capitalizedName, rawContents, storageSlotsContents } = params.abi;\n  const abiJsonString = JSON.stringify(rawContents, null, 2);\n  const storageSlotsJsonString = storageSlotsContents ?? '[]';\n\n  const text = renderHbsTemplate({\n    template: factoryTemplate,\n    data: { capitalizedName, abiJsonString, storageSlotsJsonString },\n  });\n\n  return text;\n}\n","import { join } from 'path';\n\nimport type { Abi } from '../abi/Abi';\nimport type { IFile } from '../index';\nimport { renderCommonTemplate } from '../templates/common/common';\nimport { renderIndexTemplate } from '../templates/common/index';\nimport { renderFactoryTemplate } from '../templates/predicate/factory';\n\n/**\n * Render all Predicate-related templates and returns\n * an array of `IFile` with them all. For here on,\n * the only thing missing is to write them to disk.\n */\nexport function assemblePredicates(params: { abis: Abi[]; outputDir: string }) {\n  const { abis, outputDir } = params;\n\n  const files: IFile[] = [];\n  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);\n\n  abis.forEach((abi) => {\n    const { name } = abi;\n\n    const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;\n\n    const factory: IFile = {\n      path: factoryFilepath,\n      contents: renderFactoryTemplate({ abi }),\n    };\n\n    files.push(factory);\n  });\n\n  // Includes index file\n  const indexFile: IFile = {\n    path: `${outputDir}/index.ts`,\n    contents: renderIndexTemplate({ abis }),\n  };\n\n  files.push(indexFile);\n\n  // Conditionally includes `common.d.ts` file if needed\n  if (usesCommonTypes) {\n    const commonsFilepath = join(outputDir, 'common.d.ts');\n    const file: IFile = {\n      path: commonsFilepath,\n      contents: renderCommonTemplate(),\n    };\n    files.push(file);\n  }\n\n  return files;\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { Abi } from '../../abi/Abi';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\nimport { formatConfigurables } from '../utils/formatConfigurables';\nimport { formatEnums } from '../utils/formatEnums';\nimport { formatImports } from '../utils/formatImports';\nimport { formatStructs } from '../utils/formatStructs';\n\nimport factoryTemplate from './factory.hbs';\n\nexport function renderFactoryTemplate(params: { abi: Abi }) {\n  const { abi } = params;\n\n  const { types, configurables } = abi;\n\n  const {\n    rawContents,\n    name: capitalizedName,\n    hexlifiedBinContents: hexlifiedBinString,\n  } = params.abi;\n\n  const abiJsonString = JSON.stringify(rawContents, null, 2);\n\n  const func = abi.functions.find((f) => f.name === 'main');\n\n  if (!func) {\n    throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);\n  }\n\n  const { enums } = formatEnums({ types });\n  const { structs } = formatStructs({ types });\n  const { imports } = formatImports({\n    types,\n    baseMembers: ['Predicate', 'Provider', 'InputValue'],\n  });\n  const { formattedConfigurables } = formatConfigurables({ configurables });\n\n  const { prefixedInputs: inputs, output } = func.attributes;\n\n  const text = renderHbsTemplate({\n    template: factoryTemplate,\n    data: {\n      inputs,\n      output,\n      structs,\n      enums,\n      abiJsonString,\n      hexlifiedBinString,\n      capitalizedName,\n      imports,\n      formattedConfigurables,\n    },\n  });\n\n  return text;\n}\n","import { join } from 'path';\n\nimport type { Abi } from '../abi/Abi';\nimport type { IFile } from '../index';\nimport { renderCommonTemplate } from '../templates/common/common';\nimport { renderIndexTemplate } from '../templates/common/index';\nimport { renderFactoryTemplate } from '../templates/script/factory';\n\n/**\n * Render all Script-related templates and returns\n * an array of `IFile` with them all. For here on,\n * the only thing missing is to write them to disk.\n */\nexport function assembleScripts(params: { abis: Abi[]; outputDir: string }) {\n  const { abis, outputDir } = params;\n\n  const files: IFile[] = [];\n  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);\n\n  abis.forEach((abi) => {\n    const { name } = abi;\n\n    const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;\n\n    const factory: IFile = {\n      path: factoryFilepath,\n      contents: renderFactoryTemplate({ abi }),\n    };\n\n    files.push(factory);\n  });\n\n  // Includes index file\n  const indexFile: IFile = {\n    path: `${outputDir}/index.ts`,\n    contents: renderIndexTemplate({ abis }),\n  };\n\n  files.push(indexFile);\n\n  // Conditionally includes `common.d.ts` file if needed\n  if (usesCommonTypes) {\n    const commonsFilepath = join(outputDir, 'common.d.ts');\n    const file: IFile = {\n      path: commonsFilepath,\n      contents: renderCommonTemplate(),\n    };\n    files.push(file);\n  }\n\n  return files;\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { Abi } from '../../abi/Abi';\nimport { renderHbsTemplate } from '../renderHbsTemplate';\nimport { formatConfigurables } from '../utils/formatConfigurables';\nimport { formatEnums } from '../utils/formatEnums';\nimport { formatImports } from '../utils/formatImports';\nimport { formatStructs } from '../utils/formatStructs';\n\nimport factoryTemplate from './factory.hbs';\n\nexport function renderFactoryTemplate(params: { abi: Abi }) {\n  const { abi } = params;\n\n  const { types, configurables } = abi;\n\n  const {\n    rawContents,\n    name: capitalizedName,\n    hexlifiedBinContents: hexlifiedBinString,\n  } = params.abi;\n\n  const abiJsonString = JSON.stringify(rawContents, null, 2);\n\n  const func = abi.functions.find((f) => f.name === 'main');\n\n  if (!func) {\n    throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);\n  }\n\n  const { enums } = formatEnums({ types });\n  const { structs } = formatStructs({ types });\n  const { imports } = formatImports({ types, baseMembers: ['Script', 'Account'] });\n  const { formattedConfigurables } = formatConfigurables({ configurables });\n\n  const { prefixedInputs: inputs, output } = func.attributes;\n\n  const text = renderHbsTemplate({\n    template: factoryTemplate,\n    data: {\n      inputs,\n      output,\n      structs,\n      enums,\n      abiJsonString,\n      hexlifiedBinString,\n      capitalizedName,\n      imports,\n      formattedConfigurables,\n    },\n  });\n\n  return text;\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { ProgramTypeEnum } from '../types/enums/ProgramTypeEnum';\n\nconst upperFirst = (s: string): string => s[0].toUpperCase() + s.slice(1);\n\nexport function validateBinFile(params: {\n  abiFilepath: string;\n  binFilepath: string;\n  binExists: boolean;\n  programType: ProgramTypeEnum;\n}) {\n  const { abiFilepath, binFilepath, binExists, programType } = params;\n\n  const isScript = programType === ProgramTypeEnum.SCRIPT;\n\n  if (!binExists && isScript) {\n    throw new FuelError(\n      ErrorCode.BIN_FILE_NOT_FOUND,\n      [\n        `Could not find BIN file for counterpart ${upperFirst(programType)} ABI.`,\n        `  - ABI: ${abiFilepath}`,\n        `  - BIN: ${binFilepath}`,\n        programType,\n      ].join('\\n')\n    );\n  }\n}\n","import { hexlify } from '@fuel-ts/utils';\nimport { existsSync, readFileSync } from 'fs';\n\nimport type { ProgramTypeEnum } from '../types/enums/ProgramTypeEnum';\nimport type { IFile } from '../types/interfaces/IFile';\n\nimport { validateBinFile } from './validateBinFile';\n\nexport const collectBinFilepaths = (params: {\n  filepaths: string[];\n  programType: ProgramTypeEnum;\n}) => {\n  const { filepaths, programType } = params;\n\n  // validate and collect bin filepaths for Scripts and/or Predicates\n  const binFiles = filepaths.map((abiFilepath) => {\n    const binFilepath = abiFilepath.replace('-abi.json', '.bin');\n    const binExists = existsSync(binFilepath);\n\n    validateBinFile({ abiFilepath, binFilepath, binExists, programType });\n\n    const bin: IFile = {\n      path: binFilepath,\n      contents: hexlify(readFileSync(binFilepath)),\n    };\n\n    return bin;\n  });\n\n  return binFiles;\n};\n","import { existsSync, readFileSync } from 'fs';\n\nimport { ProgramTypeEnum } from '../types/enums/ProgramTypeEnum';\nimport type { IFile } from '../types/interfaces/IFile';\n\nexport const collectStorageSlotsFilepaths = (params: {\n  filepaths: string[];\n  programType: ProgramTypeEnum;\n}) => {\n  const { filepaths, programType } = params;\n\n  // collect filepaths for storage slots JSON files\n  const storageSlotsFiles: IFile[] = [];\n\n  // abort unless we're dealing with contract types\n  if (programType !== ProgramTypeEnum.CONTRACT) {\n    return storageSlotsFiles;\n  }\n\n  filepaths.forEach((abiFilepath) => {\n    const storageSlotsFilepath = abiFilepath.replace('-abi.json', '-storage_slots.json');\n    const storageSlotsExists = existsSync(storageSlotsFilepath);\n\n    if (storageSlotsExists) {\n      const storageSlots: IFile = {\n        path: storageSlotsFilepath,\n        contents: readFileSync(storageSlotsFilepath, 'utf-8'),\n      };\n\n      storageSlotsFiles.push(storageSlots);\n    }\n  });\n\n  return storageSlotsFiles;\n};\n","#!/usr/bin/env node\nimport { run } from './cli';\n\nrun({\n  argv: process.argv,\n  programName: 'fuels-typegen',\n});\n"],"mappings":"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","names":["versions","ErrorCode","FuelError","readFileSync","ErrorCode","FuelError","ErrorCode","FuelError","ErrorCode","FuelError","ErrorCode","FuelError","FuelError","ErrorCode","FuelError","ErrorCode","ProgramTypeEnum","common_default","join","ErrorCode","FuelError","renderFactoryTemplate","FuelError","ErrorCode","factory_default","renderFactoryTemplate","join","join","ErrorCode","FuelError","renderFactoryTemplate","FuelError","ErrorCode","factory_default","renderFactoryTemplate","join","ErrorCode","FuelError","FuelError","ErrorCode","FuelError","ErrorCode","existsSync","readFileSync","existsSync","readFileSync","FuelError","ErrorCode","readFileSync","versions"]}