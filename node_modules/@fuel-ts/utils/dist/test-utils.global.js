"use strict";
(() => {
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });

  // src/test-utils/getForcProject.ts
  var import_fs = __require("fs");
  var import_path = __require("path");

  // ../versions/dist/index.mjs
  function getBuiltinVersions() {
    return {
      FORC: "0.49.3",
      FUEL_CORE: "0.22.1",
      FUELS: "0.79.0"
    };
  }
  var versions = getBuiltinVersions();

  // ../errors/dist/index.mjs
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
    ErrorCode2["NO_ABIS_FOUND"] = "no-abis-found";
    ErrorCode2["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
    ErrorCode2["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
    ErrorCode2["INVALID_COMPONENT"] = "invalid-component";
    ErrorCode2["FRAGMENT_NOT_FOUND"] = "fragment-not-found";
    ErrorCode2["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
    ErrorCode2["TYPE_NOT_FOUND"] = "type-not-found";
    ErrorCode2["TYPE_NOT_SUPPORTED"] = "type-not-supported";
    ErrorCode2["INVALID_DECODE_VALUE"] = "invalid-decode-value";
    ErrorCode2["JSON_ABI_ERROR"] = "json-abi-error";
    ErrorCode2["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
    ErrorCode2["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
    ErrorCode2["CODER_NOT_FOUND"] = "coder-not-found";
    ErrorCode2["INVALID_DATA"] = "invalid-data";
    ErrorCode2["FUNCTION_NOT_FOUND"] = "function-not-found";
    ErrorCode2["UNSUPPORTED_ENCODING_VERSION"] = "unsupported-encoding-version";
    ErrorCode2["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
    ErrorCode2["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
    ErrorCode2["INVALID_B256_ADDRESS"] = "invalid-b256-address";
    ErrorCode2["INVALID_URL"] = "invalid-url";
    ErrorCode2["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
    ErrorCode2["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
    ErrorCode2["MISSING_PROVIDER"] = "missing-provider";
    ErrorCode2["INVALID_PROVIDER"] = "invalid-provider";
    ErrorCode2["CONNECTION_REFUSED"] = "connection-refused";
    ErrorCode2["INVALID_PUBLIC_KEY"] = "invalid-public-key";
    ErrorCode2["INSUFFICIENT_BALANCE"] = "insufficient-balance";
    ErrorCode2["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
    ErrorCode2["HD_WALLET_ERROR"] = "hd-wallet-error";
    ErrorCode2["MISSING_CONNECTOR"] = "missing-connector";
    ErrorCode2["PARSE_FAILED"] = "parse-failed";
    ErrorCode2["ENCODE_ERROR"] = "encode-error";
    ErrorCode2["DECODE_ERROR"] = "decode-error";
    ErrorCode2["INVALID_CREDENTIALS"] = "invalid-credentials";
    ErrorCode2["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
    ErrorCode2["INVALID_TTL"] = "invalid-ttl";
    ErrorCode2["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
    ErrorCode2["NOT_IMPLEMENTED"] = "not-implemented";
    ErrorCode2["NOT_SUPPORTED"] = "not-supported";
    ErrorCode2["CONVERTING_FAILED"] = "converting-error";
    ErrorCode2["ELEMENT_NOT_FOUND"] = "element-not-found";
    ErrorCode2["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
    ErrorCode2["INVALID_REQUEST"] = "invalid-request";
    ErrorCode2["UNEXPECTED_HEX_VALUE"] = "unexpected-hex-value";
    ErrorCode2["INVALID_TRANSFER_AMOUNT"] = "invalid-transfer-amount";
    ErrorCode2["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
    ErrorCode2["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
    ErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
    ErrorCode2["TRANSACTION_FAILED"] = "transaction-failed";
    ErrorCode2["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
    ErrorCode2["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
    ErrorCode2["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
    ErrorCode2["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
    ErrorCode2["INVALID_TRANSACTION_TYPE"] = "invalid-transaction-type";
    ErrorCode2["TRANSACTION_ERROR"] = "transaction-error";
    ErrorCode2["INVALID_POLICY_TYPE"] = "invalid-policy-type";
    ErrorCode2["DUPLICATED_POLICY"] = "duplicated-policy";
    ErrorCode2["TRANSACTION_SQUEEZED_OUT"] = "transaction-squeezed-out";
    ErrorCode2["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
    ErrorCode2["INVALID_WORD_LIST"] = "invalid-word-list";
    ErrorCode2["INVALID_MNEMONIC"] = "invalid-mnemonic";
    ErrorCode2["INVALID_ENTROPY"] = "invalid-entropy";
    ErrorCode2["INVALID_SEED"] = "invalid-seed";
    ErrorCode2["INVALID_CHECKSUM"] = "invalid-checksum";
    ErrorCode2["INVALID_PASSWORD"] = "invalid-password";
    ErrorCode2["ACCOUNT_REQUIRED"] = "account-required";
    ErrorCode2["UNLOCKED_WALLET_REQUIRED"] = "unlocked-wallet-required";
    ErrorCode2["LATEST_BLOCK_UNAVAILABLE"] = "latest-block-unavailable";
    ErrorCode2["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
    ErrorCode2["UNSUPPORTED_FUEL_CLIENT_VERSION"] = "unsupported-fuel-client-version";
    ErrorCode2["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
    ErrorCode2["INVALID_MULTICALL"] = "invalid-multicall";
    ErrorCode2["SCRIPT_REVERTED"] = "script-reverted";
    ErrorCode2["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
    ErrorCode2["STREAM_PARSING_ERROR"] = "stream-parsing-error";
    return ErrorCode2;
  })(ErrorCode || {});
  var _FuelError = class extends Error {
    VERSIONS = versions;
    static parse(e) {
      const error = e;
      if (error.code === void 0) {
        throw new _FuelError(
          "parse-failed",
          "Failed to parse the error object. The required 'code' property is missing."
        );
      }
      const enumValues = Object.values(ErrorCode);
      const codeIsKnown = enumValues.includes(error.code);
      if (!codeIsKnown) {
        throw new _FuelError(
          "parse-failed",
          `Unknown error code: ${error.code}. Accepted codes: ${enumValues.join(", ")}.`
        );
      }
      return new _FuelError(error.code, error.message);
    }
    code;
    constructor(code, message) {
      super(message);
      this.code = code;
      this.name = "FuelError";
    }
    toObject() {
      const { code, name, message, VERSIONS } = this;
      return { code, name, message, VERSIONS };
    }
  };
  var FuelError = _FuelError;
  __publicField(FuelError, "CODES", ErrorCode);

  // src/utils/arrayify.ts
  var arrayify = (value) => {
    if (value instanceof Uint8Array) {
      return new Uint8Array(value);
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    throw new FuelError(ErrorCode.PARSE_FAILED, "invalid BytesLike value");
  };

  // src/utils/hexlify.ts
  var HexCharacters = "0123456789abcdef";
  function hexlify(data) {
    const bytes = arrayify(data);
    let result = "0x";
    for (let i = 0; i < bytes.length; i++) {
      const v = bytes[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }

  // src/utils/normalizeString.ts
  var normalizeString = (str) => {
    const transformations = [
      (s) => s.replace(/\s+/g, "-"),
      // spaces to -
      (s) => s.replace(/\./g, "-"),
      // dots to -
      (s) => s.replace(/_/g, "-"),
      // underscore to -
      (s) => s.replace(/-[a-z]/g, (match) => match.slice(-1).toUpperCase()),
      // delete '-' and capitalize the letter after them
      (s) => s.replace(/-/g, ""),
      // delete any '-' left
      (s) => s.replace(/^\d+/, ""),
      // removes leading digits
      (s) => s[0].toUpperCase() + s.slice(1)
      // capitalize first letter
    ];
    const output = transformations.reduce((s, t) => t(s), str);
    if (output === "") {
      const errMsg = `The provided string '${str}' results in an empty output after`.concat(
        ` normalization, therefore, it can't normalize string.`
      );
      throw new FuelError(ErrorCode.PARSE_FAILED, errMsg);
    }
    return output;
  };

  // src/utils/date-time.ts
  var TAI64_LEAP_SECONDS = 37;
  var TAI64_UNIX_OFFSET = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);

  // src/test-utils/getForcProject.ts
  var getProjectBuildDir = (params) => (0, import_path.join)(params.projectDir, "out", params.build);
  var getProjectReleaseDir = (params) => (0, import_path.join)(params.projectDir, "out", params.build);
  var getProjectTempDir = (params) => (0, import_path.join)(getProjectBuildDir(params), "__temp__");
  var getProjectAbiPath = (params) => (0, import_path.join)(getProjectBuildDir(params), `${params.projectName}-abi.json`);
  var getProjectBinPath = (params) => (0, import_path.join)(getProjectBuildDir(params), `${params.projectName}.bin`);
  var getProjectStorageSlotsPath = (params) => (0, import_path.join)(getProjectBuildDir(params), `${params.projectName}-storage_slots.json`);
  var getProjectAbiName = (params) => `${params.projectName}-abi`;
  var getProjectNormalizedName = (params) => normalizeString(params.projectName);
  var getProjectAbi = (params) => {
    const projectPath = getProjectAbiPath(params);
    const abiContents = JSON.parse((0, import_fs.readFileSync)(projectPath, "utf-8"));
    return abiContents;
  };
  var getProjectStorageSlots = (params) => {
    const storageSlotsFilePath = getProjectStorageSlotsPath(params);
    if (!(0, import_fs.existsSync)(storageSlotsFilePath)) {
      return [];
    }
    const storageSlots = JSON.parse((0, import_fs.readFileSync)(storageSlotsFilePath, "utf-8"));
    return storageSlots;
  };
  var getForcProject = (params) => {
    const buildDir = getProjectBuildDir(params);
    const tempDir = getProjectTempDir(params);
    const binPath = getProjectBinPath(params);
    const binHexlified = hexlify((0, import_fs.readFileSync)(binPath));
    const abiPath = getProjectAbiPath(params);
    const abiName = getProjectAbiName(params);
    const abiContents = getProjectAbi(params);
    const normalizedName = getProjectNormalizedName(params);
    const storageSlots = getProjectStorageSlots(params);
    const inputGlobal = `${buildDir}/*-abi.json`;
    return {
      name: params.projectName,
      storageSlots,
      normalizedName,
      buildDir,
      tempDir,
      binPath,
      binHexlified,
      abiPath,
      abiName,
      abiContents,
      inputGlobal
    };
  };

  // src/test-utils/expectToBeInRange.ts
  var expectToBeInRange = (params) => {
    const { value, min, max } = params;
    if (value >= min && value <= max) {
      return true;
    }
    throw new Error(`Expected value: '${value}' to be within range: '${min}-${max}'`);
  };

  // src/test-utils/constants.ts
  var ASSET_A = "0x0101010101010101010101010101010101010101010101010101010101010101";
  var ASSET_B = "0x0202020202020202020202020202020202020202020202020202020202020202";
})();
//# sourceMappingURL=test-utils.global.js.map