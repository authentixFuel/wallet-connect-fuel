{"version":3,"sources":["../src/test-utils.ts","../src/test-utils/getForcProject.ts","../src/utils/arrayify.ts","../src/utils/hexlify.ts","../src/utils/normalizeString.ts","../src/utils/date-time.ts","../src/test-utils/expectToBeInRange.ts","../src/test-utils/constants.ts"],"sourcesContent":["export * from './test-utils/getForcProject';\nexport * from './test-utils/expectToBeInRange';\nexport * from './test-utils/constants';\n","import { existsSync, readFileSync } from 'fs';\nimport { join } from 'path';\n\nimport { hexlify } from '../index';\nimport { normalizeString } from '../utils/normalizeString';\n\ninterface IGetForcProjectParams {\n  projectDir: string;\n  projectName: string;\n  build: 'debug' | 'release';\n}\n\nexport const getProjectBuildDir = (params: IGetForcProjectParams) =>\n  join(params.projectDir, 'out', params.build);\nexport const getProjectReleaseDir = (params: IGetForcProjectParams) =>\n  join(params.projectDir, 'out', params.build);\nexport const getProjectTempDir = (params: IGetForcProjectParams) =>\n  join(getProjectBuildDir(params), '__temp__');\n\nexport const getProjectAbiPath = (params: IGetForcProjectParams) =>\n  join(getProjectBuildDir(params), `${params.projectName}-abi.json`);\n\nexport const getProjectBinPath = (params: IGetForcProjectParams) =>\n  join(getProjectBuildDir(params), `${params.projectName}.bin`);\n\nexport const getProjectStorageSlotsPath = (params: IGetForcProjectParams) =>\n  join(getProjectBuildDir(params), `${params.projectName}-storage_slots.json`);\n\nexport const getProjectAbiName = (params: IGetForcProjectParams) => `${params.projectName}-abi`;\n\nexport const getProjectNormalizedName = (params: IGetForcProjectParams) =>\n  normalizeString(params.projectName);\n\nexport const getProjectAbi = (params: IGetForcProjectParams) => {\n  const projectPath = getProjectAbiPath(params);\n  const abiContents = JSON.parse(readFileSync(projectPath, 'utf-8'));\n  return abiContents;\n};\n\nexport const getProjectStorageSlots = (params: IGetForcProjectParams) => {\n  const storageSlotsFilePath = getProjectStorageSlotsPath(params);\n  if (!existsSync(storageSlotsFilePath)) {\n    return [];\n  }\n  const storageSlots = JSON.parse(readFileSync(storageSlotsFilePath, 'utf-8'));\n  return storageSlots;\n};\n\nexport const getForcProject = <T = unknown>(params: IGetForcProjectParams) => {\n  const buildDir = getProjectBuildDir(params);\n  const tempDir = getProjectTempDir(params);\n  const binPath = getProjectBinPath(params);\n  const binHexlified = hexlify(readFileSync(binPath));\n  const abiPath = getProjectAbiPath(params);\n  const abiName = getProjectAbiName(params);\n  const abiContents: T = getProjectAbi(params);\n  const normalizedName = getProjectNormalizedName(params);\n  const storageSlots: Array<{\n    key: string;\n    value: string;\n  }> = getProjectStorageSlots(params);\n\n  const inputGlobal = `${buildDir}/*-abi.json`;\n\n  return {\n    name: params.projectName,\n    storageSlots,\n    normalizedName,\n    buildDir,\n    tempDir,\n    binPath,\n    binHexlified,\n    abiPath,\n    abiName,\n    abiContents,\n    inputGlobal,\n  };\n};\n","import { FuelError, ErrorCode } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\n\n/**\n * Converts a bytes-like value to a `Uint8Array`.\n *\n * @param value - the value to convert to a Uint8Array\n * @returns the Uint8Array\n */\nexport const arrayify = (value: BytesLike): Uint8Array => {\n  // Return buffers as a new byte array\n  if (value instanceof Uint8Array) {\n    return new Uint8Array(value);\n  }\n\n  if (typeof value === 'string' && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n    const result = new Uint8Array((value.length - 2) / 2);\n    let offset = 2;\n    for (let i = 0; i < result.length; i++) {\n      result[i] = parseInt(value.substring(offset, offset + 2), 16);\n      offset += 2;\n    }\n    return result;\n  }\n\n  throw new FuelError(ErrorCode.PARSE_FAILED, 'invalid BytesLike value');\n};\n","import type { BytesLike } from '@fuel-ts/interfaces';\n\nimport { arrayify } from './arrayify';\n\nconst HexCharacters: string = '0123456789abcdef';\n\n/**\n *  Returns a hex representation of the inputted bytes.\n */\nexport function hexlify(data: BytesLike): string {\n  const bytes = arrayify(data);\n\n  let result = '0x';\n  for (let i = 0; i < bytes.length; i++) {\n    const v = bytes[i];\n    result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n  }\n  return result;\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\n/**\n * Converts `some.string-value` into `SomeStringValue`.\n *\n * Examples:\n *  my-simple.test —— MySimpleTest\n *  myFile.ts —— MyFileTs\n *  my-abi.json —— MyAbiJson\n */\nexport const normalizeString = (str: string): string => {\n  const transformations: ((s: string) => string)[] = [\n    (s) => s.replace(/\\s+/g, '-'), // spaces to -\n    (s) => s.replace(/\\./g, '-'), // dots to -\n    (s) => s.replace(/_/g, '-'), // underscore to -\n    (s) => s.replace(/-[a-z]/g, (match) => match.slice(-1).toUpperCase()), // delete '-' and capitalize the letter after them\n    (s) => s.replace(/-/g, ''), // delete any '-' left\n    (s) => s.replace(/^\\d+/, ''), // removes leading digits\n    (s) => s[0].toUpperCase() + s.slice(1), // capitalize first letter\n  ];\n\n  const output = transformations.reduce((s, t) => t(s), str);\n\n  if (output === '') {\n    const errMsg = `The provided string '${str}' results in an empty output after`.concat(\n      ` normalization, therefore, it can't normalize string.`\n    );\n    throw new FuelError(ErrorCode.PARSE_FAILED, errMsg);\n  }\n\n  return output;\n};\n","/**\n * Tai64 timestamp.\n */\ntype Tai64Timestamp = string;\n\n/**\n * This constant is used to calculate the offset between the Unix epoch and the TAI64 epoch.\n * It allows for a **rough** conversion between the two time formats.\n *\n * // Value expires on:  28 June 2024\n * {@link https://data.iana.org/time-zones/data/leap-seconds.list}\n * {@link https://github.com/hl2/tai64/blob/master/src/leapSeconds.ts}\n */\nconst TAI64_LEAP_SECONDS: number = 37;\n\n/**\n * Tai64 (Temps Atomique International) is a time format\n *\n * The offset between the Unix epoch and the TAI64 epoch.\n * The TAI64 epoch is 2^62 nanoseconds after the Unix epoch (+ the offset of \"leap seconds\" relevant to the date).\n *\n * {@link https://cr.yp.to/libtai/tai64.html}\n * {@link https://cr.yp.to/proto/tai64.txt}\n */\nconst TAI64_UNIX_OFFSET: bigint = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);\n\n/**\n * Converts milliseconds to seconds and vice versa.\n *\n * @param ms - milliseconds to convert\n * @returns seconds\n */\nconst msToSeconds = (ms: number): number => Math.floor(ms / 1000);\n\n/**\n * Converts seconds to milliseconds and vice versa.\n *\n * @param seconds - seconds to convert\n * @returns milliseconds\n */\nconst secondsToMs = (seconds: number): number => seconds * 1000;\n\n/**\n * Converts Tai64 (seconds) time units to UNIX (seconds) time units.\n *\n * @param tai64 - Tai64 timestamp\n * @returns Unix seconds timestamp\n */\nconst tai64ToUnixSeconds = (tai64: Tai64Timestamp): number =>\n  Number(BigInt(tai64) - TAI64_UNIX_OFFSET);\n\n/**\n * Converts Unix (seconds) to Tai64 (seconds).\n *\n * @param unixSeconds - unix seconds timestamp\n * @returns Tai64 timestamp\n */\nconst unixSecondsToTai64 = (unixSeconds: number): string =>\n  String(BigInt(unixSeconds) + TAI64_UNIX_OFFSET);\n\n/**\n * Helper to convert Tai64 (seconds) time units to UNIX (milliseconds) time units and vice.\n *\n * @param tai64 - Tai64 timestamp\n * @returns Unix milliseconds timestamp\n */\nconst tai64ToUnixMilliseconds = (tai64: Tai64Timestamp): number =>\n  secondsToMs(tai64ToUnixSeconds(tai64));\n\n/**\n * This class is used to represent a date and time in the Tai64 format.\n *\n * ```typescript\n * import { DateTime } from 'fuels';\n *\n * // Constants\n * const tai64 = '4611686020108779340';\n * const unixMilliseconds = 1681391398000;\n * const seconds = 1681391398;\n *\n * // Instantiation\n * let date: DateTime = DateTime.now();\n * date = DateTime.fromTai64(tai64);\n * date = DateTime.fromUnixMilliseconds(unixMilliseconds);\n * date = DateTime.fromUnixSeconds(seconds);\n *\n * // Utility functions\n * tai64.toTai64() // '4611686020108779340'\n * milliseconds.toUnixMilliseconds() // 1681391398000\n * seconds.toUnixSeconds() // 1681391398\n *\n * // All date methods are available\n * const now: Date = DateTime.now();\n * now.toISOString(); // '2023-04-13T13:09:58.000Z'\n * now.getTime(); // 1681391398000\n * ```\n */\nexport class DateTime extends Date implements Date {\n  static TAI64_NULL: Tai64Timestamp = '';\n\n  /**\n   * Generates a new DateTime instance from a Tai64 timestamp.\n   *\n   * @param tai64 - Tai64 timestamp\n   * @returns a new DateTime instance\n   */\n  static fromTai64(tai64: Tai64Timestamp): DateTime {\n    return new DateTime(tai64ToUnixMilliseconds(tai64));\n  }\n\n  /**\n   * @param unixMilliseconds - unix milliseconds timestamp\n   * @returns a new DateTime instance\n   */\n  static fromUnixMilliseconds(unixMilliseconds: number): DateTime {\n    return new DateTime(unixMilliseconds);\n  }\n\n  /**\n   * @param unixSeconds - unix seconds timestamp\n   * @returns a new DateTime instance\n   */\n  static fromUnixSeconds(unixSeconds: number): DateTime {\n    return new DateTime(secondsToMs(unixSeconds));\n  }\n\n  /**\n   * Hide the constructor to prevent direct instantiation.\n   */\n  private constructor(date: Date | number | string) {\n    super(date);\n  }\n\n  /**\n   * Returns the Tai64 timestamp.\n   *\n   * @returns the Tai64 timestamp\n   */\n  toTai64(): Tai64Timestamp {\n    return unixSecondsToTai64(this.toUnixSeconds());\n  }\n\n  /**\n   * @returns the unix milliseconds timestamp\n   */\n  toUnixMilliseconds(): number {\n    return this.getTime();\n  }\n\n  /**\n   * @returns the unix seconds timestamp\n   */\n  toUnixSeconds(): number {\n    return msToSeconds(this.getTime());\n  }\n}\n","export const expectToBeInRange = (params: { value: number; min: number; max: number }) => {\n  const { value, min, max } = params;\n  if (value >= min && value <= max) {\n    return true;\n  }\n\n  throw new Error(`Expected value: '${value}' to be within range: '${min}-${max}'`);\n};\n","export const ASSET_A: string = '0x0101010101010101010101010101010101010101010101010101010101010101';\nexport const ASSET_B: string = '0x0202020202020202020202020202020202020202020202020202020202020202';\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,gBAAyC;AACzC,kBAAqB;;;ACDrB,oBAAqC;AAS9B,IAAM,WAAW,CAAC,UAAiC;AAExD,MAAI,iBAAiB,YAAY;AAC/B,WAAO,IAAI,WAAW,KAAK;AAAA,EAC7B;AAEA,MAAI,OAAO,UAAU,YAAY,MAAM,MAAM,0BAA0B,GAAG;AACxE,UAAM,SAAS,IAAI,YAAY,MAAM,SAAS,KAAK,CAAC;AACpD,QAAI,SAAS;AACb,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,aAAO,CAAC,IAAI,SAAS,MAAM,UAAU,QAAQ,SAAS,CAAC,GAAG,EAAE;AAC5D,gBAAU;AAAA,IACZ;AACA,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,wBAAU,wBAAU,cAAc,yBAAyB;AACvE;;;ACtBA,IAAM,gBAAwB;AAKvB,SAAS,QAAQ,MAAyB;AAC/C,QAAM,QAAQ,SAAS,IAAI;AAE3B,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,IAAI,MAAM,CAAC;AACjB,cAAU,eAAe,IAAI,QAAS,CAAC,IAAI,cAAc,IAAI,EAAI;AAAA,EACnE;AACA,SAAO;AACT;;;AClBA,IAAAA,iBAAqC;AAU9B,IAAM,kBAAkB,CAAC,QAAwB;AACtD,QAAM,kBAA6C;AAAA,IACjD,CAAC,MAAM,EAAE,QAAQ,QAAQ,GAAG;AAAA;AAAA,IAC5B,CAAC,MAAM,EAAE,QAAQ,OAAO,GAAG;AAAA;AAAA,IAC3B,CAAC,MAAM,EAAE,QAAQ,MAAM,GAAG;AAAA;AAAA,IAC1B,CAAC,MAAM,EAAE,QAAQ,WAAW,CAAC,UAAU,MAAM,MAAM,EAAE,EAAE,YAAY,CAAC;AAAA;AAAA,IACpE,CAAC,MAAM,EAAE,QAAQ,MAAM,EAAE;AAAA;AAAA,IACzB,CAAC,MAAM,EAAE,QAAQ,QAAQ,EAAE;AAAA;AAAA,IAC3B,CAAC,MAAM,EAAE,CAAC,EAAE,YAAY,IAAI,EAAE,MAAM,CAAC;AAAA;AAAA,EACvC;AAEA,QAAM,SAAS,gBAAgB,OAAO,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,GAAG;AAEzD,MAAI,WAAW,IAAI;AACjB,UAAM,SAAS,wBAAwB,wCAAwC;AAAA,MAC7E;AAAA,IACF;AACA,UAAM,IAAI,yBAAU,yBAAU,cAAc,MAAM;AAAA,EACpD;AAEA,SAAO;AACT;;;AClBA,IAAM,qBAA6B;AAWnC,IAAM,oBAA4B,OAAO,KAAK,EAAE,IAAI,OAAO,kBAAkB;;;AJZtE,IAAM,qBAAqB,CAAC,eACjC,kBAAK,OAAO,YAAY,OAAO,OAAO,KAAK;AACtC,IAAM,uBAAuB,CAAC,eACnC,kBAAK,OAAO,YAAY,OAAO,OAAO,KAAK;AACtC,IAAM,oBAAoB,CAAC,eAChC,kBAAK,mBAAmB,MAAM,GAAG,UAAU;AAEtC,IAAM,oBAAoB,CAAC,eAChC,kBAAK,mBAAmB,MAAM,GAAG,GAAG,OAAO,sBAAsB;AAE5D,IAAM,oBAAoB,CAAC,eAChC,kBAAK,mBAAmB,MAAM,GAAG,GAAG,OAAO,iBAAiB;AAEvD,IAAM,6BAA6B,CAAC,eACzC,kBAAK,mBAAmB,MAAM,GAAG,GAAG,OAAO,gCAAgC;AAEtE,IAAM,oBAAoB,CAAC,WAAkC,GAAG,OAAO;AAEvE,IAAM,2BAA2B,CAAC,WACvC,gBAAgB,OAAO,WAAW;AAE7B,IAAM,gBAAgB,CAAC,WAAkC;AAC9D,QAAM,cAAc,kBAAkB,MAAM;AAC5C,QAAM,cAAc,KAAK,UAAM,wBAAa,aAAa,OAAO,CAAC;AACjE,SAAO;AACT;AAEO,IAAM,yBAAyB,CAAC,WAAkC;AACvE,QAAM,uBAAuB,2BAA2B,MAAM;AAC9D,MAAI,KAAC,sBAAW,oBAAoB,GAAG;AACrC,WAAO,CAAC;AAAA,EACV;AACA,QAAM,eAAe,KAAK,UAAM,wBAAa,sBAAsB,OAAO,CAAC;AAC3E,SAAO;AACT;AAEO,IAAM,iBAAiB,CAAc,WAAkC;AAC5E,QAAM,WAAW,mBAAmB,MAAM;AAC1C,QAAM,UAAU,kBAAkB,MAAM;AACxC,QAAM,UAAU,kBAAkB,MAAM;AACxC,QAAM,eAAe,YAAQ,wBAAa,OAAO,CAAC;AAClD,QAAM,UAAU,kBAAkB,MAAM;AACxC,QAAM,UAAU,kBAAkB,MAAM;AACxC,QAAM,cAAiB,cAAc,MAAM;AAC3C,QAAM,iBAAiB,yBAAyB,MAAM;AACtD,QAAM,eAGD,uBAAuB,MAAM;AAElC,QAAM,cAAc,GAAG;AAEvB,SAAO;AAAA,IACL,MAAM,OAAO;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AK7EO,IAAM,oBAAoB,CAAC,WAAwD;AACxF,QAAM,EAAE,OAAO,KAAK,IAAI,IAAI;AAC5B,MAAI,SAAS,OAAO,SAAS,KAAK;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,MAAM,oBAAoB,+BAA+B,OAAO,MAAM;AAClF;;;ACPO,IAAM,UAAkB;AACxB,IAAM,UAAkB;","names":["import_errors"]}