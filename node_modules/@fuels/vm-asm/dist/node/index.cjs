'use strict';

let wasm$1;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }
let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
/**
*Adds two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function add(dst, lhs, rhs) {
    const ret = wasm$1.add(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ANDs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function and(dst, lhs, rhs) {
    const ret = wasm$1.and(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Divides two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function div(dst, lhs, rhs) {
    const ret = wasm$1.div(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for equality.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function eq(dst, lhs, rhs) {
    const ret = wasm$1.eq(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Raises one register to the power of another.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function exp(dst, lhs, rhs) {
    const ret = wasm$1.exp(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for greater-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function gt(dst, lhs, rhs) {
    const ret = wasm$1.gt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for less-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function lt(dst, lhs, rhs) {
    const ret = wasm$1.lt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*The integer logarithm of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mlog(dst, lhs, rhs) {
    const ret = wasm$1.mlog(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*The integer root of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mroo(dst, lhs, rhs) {
    const ret = wasm$1.mroo(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Modulo remainder of two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mod_(dst, lhs, rhs) {
    const ret = wasm$1.mod_(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Copy from one register to another.
* @param {number} dst
* @param {number} src
* @returns {Instruction}
*/
function move_(dst, src) {
    const ret = wasm$1.move_(dst, src);
    return Instruction.__wrap(ret);
}

/**
*Multiplies two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mul(dst, lhs, rhs) {
    const ret = wasm$1.mul(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise NOT a register.
* @param {number} dst
* @param {number} arg
* @returns {Instruction}
*/
function not(dst, arg) {
    const ret = wasm$1.not(dst, arg);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function or(dst, lhs, rhs) {
    const ret = wasm$1.or(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Left shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function sll(dst, lhs, rhs) {
    const ret = wasm$1.sll(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Right shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function srl(dst, lhs, rhs) {
    const ret = wasm$1.srl(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Subtracts two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function sub(dst, lhs, rhs) {
    const ret = wasm$1.sub(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise XORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function xor(dst, lhs, rhs) {
    const ret = wasm$1.xor(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide with arbitrary precision intermediate step.
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function mldv(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*Return from context.
* @param {number} value
* @returns {Instruction}
*/
function ret(value) {
    const ret = wasm$1.ret(value);
    return Instruction.__wrap(ret);
}

/**
*Return from context with data.
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
function retd(addr, len) {
    const ret = wasm$1.retd(addr, len);
    return Instruction.__wrap(ret);
}

/**
*Allocate a number of bytes from the heap.
* @param {number} bytes
* @returns {Instruction}
*/
function aloc(bytes) {
    const ret = wasm$1.aloc(bytes);
    return Instruction.__wrap(ret);
}

/**
*Clear a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} len
* @returns {Instruction}
*/
function mcl(dst_addr, len) {
    const ret = wasm$1.mcl(dst_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Copy a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function mcp(dst_addr, src_addr, len) {
    const ret = wasm$1.mcp(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Compare bytes in memory.
* @param {number} result
* @param {number} lhs_addr
* @param {number} rhs_addr
* @param {number} len
* @returns {Instruction}
*/
function meq(result, lhs_addr, rhs_addr, len) {
    const ret = wasm$1.meq(result, lhs_addr, rhs_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get block header hash for height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
function bhsh(dst, heigth) {
    const ret = wasm$1.bhsh(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
*Get current block height.
* @param {number} dst
* @returns {Instruction}
*/
function bhei(dst) {
    const ret = wasm$1.bhei(dst);
    return Instruction.__wrap(ret);
}

/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
function burn(amount, sub_id_addr) {
    const ret = wasm$1.burn(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Call a contract.
* @param {number} target_struct
* @param {number} fwd_coins
* @param {number} asset_id_addr
* @param {number} fwd_gas
* @returns {Instruction}
*/
function call(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
    const ret = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
    return Instruction.__wrap(ret);
}

/**
*Copy contract code for a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
function ccp(dst_addr, contract_id_addr, offset, len) {
    const ret = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
*Get code root of a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function croo(dst_addr, contract_id_addr) {
    const ret = wasm$1.croo(dst_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Get code size of a contract.
* @param {number} dst
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function csiz(dst, contract_id_addr) {
    const ret = wasm$1.csiz(dst, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Get current block proposer's address.
* @param {number} dst
* @returns {Instruction}
*/
function cb(dst) {
    const ret = wasm$1.cb(dst);
    return Instruction.__wrap(ret);
}

/**
*Load a contract's code as executable.
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
function ldc(contract_id_addr, offset, len) {
    const ret = wasm$1.ldc(contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
*Log an event.
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
function log(a, b, c, d) {
    const ret = wasm$1.log(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
*Log data.
* @param {number} a
* @param {number} b
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
function logd(a, b, addr, len) {
    const ret = wasm$1.logd(a, b, addr, len);
    return Instruction.__wrap(ret);
}

/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
function mint(amount, sub_id_addr) {
    const ret = wasm$1.mint(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Halt execution, reverting state changes and returning a value.
* @param {number} value
* @returns {Instruction}
*/
function rvrt(value) {
    const ret = wasm$1.rvrt(value);
    return Instruction.__wrap(ret);
}

/**
*Clear a series of slots from contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} lenq
* @returns {Instruction}
*/
function scwq(key_addr, status, lenq) {
    const ret = wasm$1.scwq(key_addr, status, lenq);
    return Instruction.__wrap(ret);
}

/**
*Load a word from contract storage.
* @param {number} dst
* @param {number} status
* @param {number} key_addr
* @returns {Instruction}
*/
function srw(dst, status, key_addr) {
    const ret = wasm$1.srw(dst, status, key_addr);
    return Instruction.__wrap(ret);
}

/**
*Load a series of 32 byte slots from contract storage.
* @param {number} dst_addr
* @param {number} status
* @param {number} key_addr
* @param {number} lenq
* @returns {Instruction}
*/
function srwq(dst_addr, status, key_addr, lenq) {
    const ret = wasm$1.srwq(dst_addr, status, key_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
*Store a word in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} value
* @returns {Instruction}
*/
function sww(key_addr, status, value) {
    const ret = wasm$1.sww(key_addr, status, value);
    return Instruction.__wrap(ret);
}

/**
*Store a series of 32 byte slots in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} src_addr
* @param {number} lenq
* @returns {Instruction}
*/
function swwq(key_addr, status, src_addr, lenq) {
    const ret = wasm$1.swwq(key_addr, status, src_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
*Transfer coins to a contract unconditionally.
* @param {number} contract_id_addr
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
function tr(contract_id_addr, amount, asset_id_addr) {
    const ret = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Transfer coins to a variable output.
* @param {number} contract_id_addr
* @param {number} output_index
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
function tro(contract_id_addr, output_index, amount, asset_id_addr) {
    const ret = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function eck1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function ecr1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*Verify ED25519 public key and signature match a 32-byte message.
* @param {number} pub_key_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function ed19(pub_key_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ed19(pub_key_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*The keccak-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function k256(dst_addr, src_addr, len) {
    const ret = wasm$1.k256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*The SHA-2-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function s256(dst_addr, src_addr, len) {
    const ret = wasm$1.s256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get timestamp of block at given height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
function time(dst, heigth) {
    const ret = wasm$1.time(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
*Performs no operation.
* @returns {Instruction}
*/
function noop() {
    const ret = wasm$1.noop();
    return Instruction.__wrap(ret);
}

/**
*Set flag register to a register.
* @param {number} value
* @returns {Instruction}
*/
function flag(value) {
    const ret = wasm$1.flag(value);
    return Instruction.__wrap(ret);
}

/**
*Get the balance of contract of an asset ID.
* @param {number} dst
* @param {number} asset_id_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function bal(dst, asset_id_addr, contract_id_addr) {
    const ret = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Dynamic jump.
* @param {number} abs_target
* @returns {Instruction}
*/
function jmp(abs_target) {
    const ret = wasm$1.jmp(abs_target);
    return Instruction.__wrap(ret);
}

/**
*Conditional dynamic jump.
* @param {number} abs_target
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function jne(abs_target, lhs, rhs) {
    const ret = wasm$1.jne(abs_target, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Send a message to recipient address with call abi, coins, and output.
* @param {number} recipient_addr
* @param {number} data_addr
* @param {number} data_len
* @param {number} coins
* @returns {Instruction}
*/
function smo(recipient_addr, data_addr, data_len, coins) {
    const ret = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
    return Instruction.__wrap(ret);
}

/**
*Adds a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function addi(dst, lhs, rhs) {
    const ret = wasm$1.addi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ANDs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function andi(dst, lhs, rhs) {
    const ret = wasm$1.andi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Divides a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function divi(dst, lhs, rhs) {
    const ret = wasm$1.divi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Raises one register to the power of an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function expi(dst, lhs, rhs) {
    const ret = wasm$1.expi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Modulo remainder of a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function modi(dst, lhs, rhs) {
    const ret = wasm$1.modi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Multiplies a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function muli(dst, lhs, rhs) {
    const ret = wasm$1.muli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function ori(dst, lhs, rhs) {
    const ret = wasm$1.ori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Left shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function slli(dst, lhs, rhs) {
    const ret = wasm$1.slli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Right shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function srli(dst, lhs, rhs) {
    const ret = wasm$1.srli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Subtracts a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function subi(dst, lhs, rhs) {
    const ret = wasm$1.subi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise XORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function xori(dst, lhs, rhs) {
    const ret = wasm$1.xori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Conditional jump.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} abs_target
* @returns {Instruction}
*/
function jnei(cond_lhs, cond_rhs, abs_target) {
    const ret = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
    return Instruction.__wrap(ret);
}

/**
*A byte is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
function lb(dst, addr, offset) {
    const ret = wasm$1.lb(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
*A word is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
function lw(dst, addr, offset) {
    const ret = wasm$1.lw(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
*Write the least significant byte of a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
function sb(addr, value, offset) {
    const ret = wasm$1.sb(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
*Write a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
function sw(addr, value, offset) {
    const ret = wasm$1.sw(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
*Copy an immediate number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function mcpi(dst_addr, src_addr, len) {
    const ret = wasm$1.mcpi(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get transaction fields.
* @param {number} dst
* @param {number} arg
* @param {number} selector
* @returns {Instruction}
*/
function gtf(dst, arg, selector) {
    const ret = wasm$1.gtf(dst, arg, selector);
    return Instruction.__wrap(ret);
}

/**
*Clear an immediate number of bytes in memory.
* @param {number} addr
* @param {number} count
* @returns {Instruction}
*/
function mcli(addr, count) {
    const ret = wasm$1.mcli(addr, count);
    return Instruction.__wrap(ret);
}

/**
*Get metadata from memory.
* @param {number} dst
* @param {number} selector
* @returns {Instruction}
*/
function gm(dst, selector) {
    const ret = wasm$1.gm(dst, selector);
    return Instruction.__wrap(ret);
}

/**
*Copy immediate value into a register
* @param {number} dst
* @param {number} val
* @returns {Instruction}
*/
function movi(dst, val) {
    const ret = wasm$1.movi(dst, val);
    return Instruction.__wrap(ret);
}

/**
*Conditional jump against zero.
* @param {number} cond_nz
* @param {number} abs_target
* @returns {Instruction}
*/
function jnzi(cond_nz, abs_target) {
    const ret = wasm$1.jnzi(cond_nz, abs_target);
    return Instruction.__wrap(ret);
}

/**
*Unconditional dynamic relative jump forwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jmpf(dynamic, fixed) {
    const ret = wasm$1.jmpf(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Unconditional dynamic relative jump backwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jmpb(dynamic, fixed) {
    const ret = wasm$1.jmpb(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnzf(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzf(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnzb(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzb(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Jump.
* @param {number} abs_target
* @returns {Instruction}
*/
function ji(abs_target) {
    const ret = wasm$1.ji(abs_target);
    return Instruction.__wrap(ret);
}

/**
*Extend the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
function cfei(amount) {
    const ret = wasm$1.cfei(amount);
    return Instruction.__wrap(ret);
}

/**
*Shrink the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
function cfsi(amount) {
    const ret = wasm$1.cfsi(amount);
    return Instruction.__wrap(ret);
}

/**
*Extend the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
function cfe(amount) {
    const ret = wasm$1.cfe(amount);
    return Instruction.__wrap(ret);
}

/**
*Shrink the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
function cfs(amount) {
    const ret = wasm$1.cfs(amount);
    return Instruction.__wrap(ret);
}

/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function pshl(bitmask) {
    const ret = wasm$1.pshl(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function pshh(bitmask) {
    const ret = wasm$1.pshh(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function popl(bitmask) {
    const ret = wasm$1.popl(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function poph(bitmask) {
    const ret = wasm$1.poph(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Compare 128bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Compare 256bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Simple 128bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Simple 256bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Multiply 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Multiply 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Divide 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wddv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wddv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Divide 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqdv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqdv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function wdmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function wqmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*AddMod 128bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wdam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*AddMod 256bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wqam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*MulMod 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wdmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*MulMod 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wqmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*Call external function
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
function ecal(a, b, c, d) {
    const ret = wasm$1.ecal(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {GMArgs} args
* @returns {Instruction}
*/
function gm_args(ra, args) {
    const ret = wasm$1.gm_args(ra, args);
    return Instruction.__wrap(ret);
}

/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {GTFArgs} args
* @returns {Instruction}
*/
function gtf_args(ra, rb, args) {
    const ret = wasm$1.gtf_args(ra, rb, args);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
function wdcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
function wqcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
function wdop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
function wqop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
function wdml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
function wqml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
function wddv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wddv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
function wqdv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqdv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
    }
    return cachedInt32Memory0;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
*r" Argument list for GM (get metadata) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
const GMArgs = Object.freeze({
/**
*r" Get if caller is external.
*/
IsCallerExternal:1,"1":"IsCallerExternal",
/**
*r" Get caller's contract ID.
*/
GetCaller:2,"2":"GetCaller",
/**
*r" Get index of current predicate.
*/
GetVerifyingPredicate:3,"3":"GetVerifyingPredicate",
/**
*r" Get the Chain ID this VM is operating within
*/
GetChainId:4,"4":"GetChainId", });
/**
*r" Argument list for GTF (get tx fields) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
const GTFArgs = Object.freeze({
/**
*r" Set `$rA` to `tx.type`
*/
Type:1,"1":"Type",
/**
*r" Set `$rA` to `tx.scriptGasLimit`
*/
ScriptGasLimit:2,"2":"ScriptGasLimit",
/**
*r" Set `$rA` to `tx.scriptLength`
*/
ScriptLength:3,"3":"ScriptLength",
/**
*r" Set `$rA` to `tx.scriptDataLength`
*/
ScriptDataLength:4,"4":"ScriptDataLength",
/**
*r" Set `$rA` to `tx.inputsCount`
*/
ScriptInputsCount:5,"5":"ScriptInputsCount",
/**
*r" Set `$rA` to `tx.outputsCount`
*/
ScriptOutputsCount:6,"6":"ScriptOutputsCount",
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
ScriptWitnessesCount:7,"7":"ScriptWitnessesCount",
/**
*r" Set `$rA` to `Memory address of tx.receiptsRoot`
*/
ScriptReceiptsRoot:8,"8":"ScriptReceiptsRoot",
/**
*r" Set `$rA` to `Memory address of tx.script`
*/
Script:9,"9":"Script",
/**
*r" Set `$rA` to `Memory address of tx.scriptData`
*/
ScriptData:10,"10":"ScriptData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
ScriptInputAtIndex:11,"11":"ScriptInputAtIndex",
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
ScriptOutputAtIndex:12,"12":"ScriptOutputAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
ScriptWitnessAtIndex:13,"13":"ScriptWitnessAtIndex",
/**
*r" Set `$rA` to `tx.bytecodeLength`
*/
CreateBytecodeLength:256,"256":"CreateBytecodeLength",
/**
*r" Set `$rA` to `tx.bytecodeWitnessIndex`
*/
CreateBytecodeWitnessIndex:257,"257":"CreateBytecodeWitnessIndex",
/**
*r" Set `$rA` to `tx.storageSlotsCount`
*/
CreateStorageSlotsCount:258,"258":"CreateStorageSlotsCount",
/**
*r" Set `$rA` to `tx.inputsCount`
*/
CreateInputsCount:259,"259":"CreateInputsCount",
/**
*r" Set `$rA` to `tx.outputsCount`
*/
CreateOutputsCount:260,"260":"CreateOutputsCount",
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
CreateWitnessesCount:261,"261":"CreateWitnessesCount",
/**
*r" Set `$rA` to `Memory address of tx.salt`
*/
CreateSalt:262,"262":"CreateSalt",
/**
*r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
*/
CreateStorageSlotAtIndex:263,"263":"CreateStorageSlotAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
CreateInputAtIndex:264,"264":"CreateInputAtIndex",
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
CreateOutputAtIndex:265,"265":"CreateOutputAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
CreateWitnessAtIndex:266,"266":"CreateWitnessAtIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].type`
*/
InputType:512,"512":"InputType",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
InputCoinTxId:513,"513":"InputCoinTxId",
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
InputCoinOutputIndex:514,"514":"InputCoinOutputIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
*/
InputCoinOwner:515,"515":"InputCoinOwner",
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
InputCoinAmount:516,"516":"InputCoinAmount",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
*/
InputCoinAssetId:517,"517":"InputCoinAssetId",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
*/
InputCoinTxPointer:518,"518":"InputCoinTxPointer",
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
InputCoinWitnessIndex:519,"519":"InputCoinWitnessIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].maturity`
*/
InputCoinMaturity:520,"520":"InputCoinMaturity",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
InputCoinPredicateLength:521,"521":"InputCoinPredicateLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
InputCoinPredicateDataLength:522,"522":"InputCoinPredicateDataLength",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
InputCoinPredicate:523,"523":"InputCoinPredicate",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
InputCoinPredicateData:524,"524":"InputCoinPredicateData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
InputCoinPredicateGasUsed:525,"525":"InputCoinPredicateGasUsed",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
InputContractTxId:544,"544":"InputContractTxId",
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
InputContractOutputIndex:545,"545":"InputContractOutputIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].balanceRoot`
*/
InputContractBalanceRoot:546,"546":"InputContractBalanceRoot",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].stateRoot`
*/
InputContractStateRoot:547,"547":"InputContractStateRoot",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
*/
InputContractTxPointer:548,"548":"InputContractTxPointer",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
*/
InputContractId:549,"549":"InputContractId",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
*/
InputMessageSender:576,"576":"InputMessageSender",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
*/
InputMessageRecipient:577,"577":"InputMessageRecipient",
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
InputMessageAmount:578,"578":"InputMessageAmount",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
*/
InputMessageNonce:579,"579":"InputMessageNonce",
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
InputMessageWitnessIndex:580,"580":"InputMessageWitnessIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].dataLength`
*/
InputMessageDataLength:581,"581":"InputMessageDataLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
InputMessagePredicateLength:582,"582":"InputMessagePredicateLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
InputMessagePredicateDataLength:583,"583":"InputMessagePredicateDataLength",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
*/
InputMessageData:584,"584":"InputMessageData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
InputMessagePredicate:585,"585":"InputMessagePredicate",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
InputMessagePredicateData:586,"586":"InputMessagePredicateData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
InputMessagePredicateGasUsed:587,"587":"InputMessagePredicateGasUsed",
/**
*r" Set `$rA` to `tx.outputs[$rB].type`
*/
OutputType:768,"768":"OutputType",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
*/
OutputCoinTo:769,"769":"OutputCoinTo",
/**
*r" Set `$rA` to `tx.outputs[$rB].amount`
*/
OutputCoinAmount:770,"770":"OutputCoinAmount",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
*/
OutputCoinAssetId:771,"771":"OutputCoinAssetId",
/**
*r" Set `$rA` to `tx.outputs[$rB].inputIndex`
*/
OutputContractInputIndex:772,"772":"OutputContractInputIndex",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].balanceRoot`
*/
OutputContractBalanceRoot:773,"773":"OutputContractBalanceRoot",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
*/
OutputContractStateRoot:774,"774":"OutputContractStateRoot",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
*/
OutputContractCreatedContractId:775,"775":"OutputContractCreatedContractId",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
*/
OutputContractCreatedStateRoot:776,"776":"OutputContractCreatedStateRoot",
/**
*r" Set `$rA` to `tx.witnesses[$rB].dataLength`
*/
WitnessDataLength:1024,"1024":"WitnessDataLength",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
*/
WitnessData:1025,"1025":"WitnessData",
/**
*r" Set `$rA` to `tx.policyTypes`
*/
PolicyTypes:1280,"1280":"PolicyTypes",
/**
*r" Set `$rA` to `tx.policies[0x00].gasPrice`
*/
PolicyGasPrice:1281,"1281":"PolicyGasPrice",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
*/
PolicyWitnessLimit:1282,"1282":"PolicyWitnessLimit",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
*/
PolicyMaturity:1283,"1283":"PolicyMaturity",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
*/
PolicyMaxFee:1284,"1284":"PolicyMaxFee", });
/**
* Comparison mode used by WDCM and WQCM instructions.
*/
const CompareMode = Object.freeze({
/**
* Equality (`==`)
*/
EQ:0,"0":"EQ",
/**
* Inequality (`!=`)
*/
NE:1,"1":"NE",
/**
* Less than (`<`)
*/
LT:2,"2":"LT",
/**
* Greater than (`>`)
*/
GT:3,"3":"GT",
/**
* Less than or equals (`>=`)
*/
LTE:4,"4":"LTE",
/**
* Greater than or equals (`>=`)
*/
GTE:5,"5":"GTE",
/**
* Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
*/
LZC:6,"6":"LZC", });
/**
*r" Panic reason representation for the interpreter.
*/
const PanicReason = Object.freeze({
/**
*r" The byte can't be mapped to any known `PanicReason`.
*/
UnknownPanicReason:0,"0":"UnknownPanicReason",
/**
*r" Found `RVRT` instruction.
*/
Revert:1,"1":"Revert",
/**
*r" Execution ran out of gas.
*/
OutOfGas:2,"2":"OutOfGas",
/**
*r" The transaction validity is violated.
*/
TransactionValidity:3,"3":"TransactionValidity",
/**
*r" Attempt to write outside interpreter memory boundaries.
*/
MemoryOverflow:4,"4":"MemoryOverflow",
/**
*r" Overflow while executing arithmetic operation.
*r" These errors are ignored using the WRAPPING flag.
*/
ArithmeticOverflow:5,"5":"ArithmeticOverflow",
/**
*r" Designed contract was not found in the storage.
*/
ContractNotFound:6,"6":"ContractNotFound",
/**
*r" Memory ownership rules are violated.
*/
MemoryOwnership:7,"7":"MemoryOwnership",
/**
*r" The asset ID balance isn't enough for the instruction.
*/
NotEnoughBalance:8,"8":"NotEnoughBalance",
/**
*r" The interpreter is expected to be in internal context.
*/
ExpectedInternalContext:9,"9":"ExpectedInternalContext",
/**
*r" The queried asset ID was not found in the state.
*/
AssetIdNotFound:10,"10":"AssetIdNotFound",
/**
*r" The provided input is not found in the transaction.
*/
InputNotFound:11,"11":"InputNotFound",
/**
*r" The provided output is not found in the transaction.
*/
OutputNotFound:12,"12":"OutputNotFound",
/**
*r" The provided witness is not found in the transaction.
*/
WitnessNotFound:13,"13":"WitnessNotFound",
/**
*r" The transaction maturity is not valid for this request.
*/
TransactionMaturity:14,"14":"TransactionMaturity",
/**
*r" The metadata identifier is invalid.
*/
InvalidMetadataIdentifier:15,"15":"InvalidMetadataIdentifier",
/**
*r" The call structure is not valid.
*/
MalformedCallStructure:16,"16":"MalformedCallStructure",
/**
*r" The provided register does not allow write operations.
*/
ReservedRegisterNotWritable:17,"17":"ReservedRegisterNotWritable",
/**
*r" The execution resulted in an erroneous state of the interpreter.
*/
InvalidFlags:18,"18":"InvalidFlags",
/**
*r" The provided immediate value is not valid for this instruction.
*/
InvalidImmediateValue:19,"19":"InvalidImmediateValue",
/**
*r" The provided transaction input is not of type `Coin`.
*/
ExpectedCoinInput:20,"20":"ExpectedCoinInput",
/**
*r" `ECAL` instruction failed.
*/
EcalError:21,"21":"EcalError",
/**
*r" Two segments of the interpreter memory should not intersect for write operations.
*/
MemoryWriteOverlap:22,"22":"MemoryWriteOverlap",
/**
*r" The requested contract is not listed in the transaction inputs.
*/
ContractNotInInputs:23,"23":"ContractNotInInputs",
/**
*r" The internal asset ID balance overflowed with the provided instruction.
*/
InternalBalanceOverflow:24,"24":"InternalBalanceOverflow",
/**
*r" The maximum allowed contract size is violated.
*/
ContractMaxSize:25,"25":"ContractMaxSize",
/**
*r" This instruction expects the stack area to be unallocated for this call.
*/
ExpectedUnallocatedStack:26,"26":"ExpectedUnallocatedStack",
/**
*r" The maximum allowed number of static contracts was reached for this transaction.
*/
MaxStaticContractsReached:27,"27":"MaxStaticContractsReached",
/**
*r" The requested transfer amount cannot be zero.
*/
TransferAmountCannotBeZero:28,"28":"TransferAmountCannotBeZero",
/**
*r" The provided transaction output should be of type `Variable`.
*/
ExpectedOutputVariable:29,"29":"ExpectedOutputVariable",
/**
*r" The expected context of the stack parent is internal.
*/
ExpectedParentInternalContext:30,"30":"ExpectedParentInternalContext",
/**
*r" The predicate returned non `1`. The `1` means successful verification
*r" of the predicate, all other values means unsuccessful.
*/
PredicateReturnedNonOne:31,"31":"PredicateReturnedNonOne",
/**
*r" The contract ID is already deployed and can't be overwritten.
*/
ContractIdAlreadyDeployed:32,"32":"ContractIdAlreadyDeployed",
/**
*r" The loaded contract mismatch expectations.
*/
ContractMismatch:33,"33":"ContractMismatch",
/**
*r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
*/
MessageDataTooLong:34,"34":"MessageDataTooLong",
/**
*r" Mathematically invalid arguments where given to an arithmetic instruction.
*r" For instance, division by zero produces this.
*r" These errors are ignored using the UNSAFEMATH flag.
*/
ArithmeticError:35,"35":"ArithmeticError",
/**
*r" The contract instruction is not allowed in predicates.
*/
ContractInstructionNotAllowed:36,"36":"ContractInstructionNotAllowed",
/**
*r" Transfer of zero coins is not allowed.
*/
TransferZeroCoins:37,"37":"TransferZeroCoins",
/**
*r" Attempted to execute an invalid instruction
*/
InvalidInstruction:38,"38":"InvalidInstruction",
/**
*r" Memory outside $is..$ssp range is not executable
*/
MemoryNotExecutable:39,"39":"MemoryNotExecutable",
/**
*r" The policy is not set.
*/
PolicyIsNotSet:40,"40":"PolicyIsNotSet",
/**
*r" The policy is not found across policies.
*/
PolicyNotFound:41,"41":"PolicyNotFound",
/**
*r" Receipt context is full
*/
TooManyReceipts:42,"42":"TooManyReceipts",
/**
*r" Balance of a contract overflowed
*/
BalanceOverflow:43,"43":"BalanceOverflow",
/**
*r" Block height value is invalid, typically because it is too large
*/
InvalidBlockHeight:44,"44":"InvalidBlockHeight",
/**
*r" Attempt to use sequential memory instructions with too large slot count,
*r" typically because it cannot fit into usize
*/
TooManySlots:45,"45":"TooManySlots", });
/**
* The operation performed by WDOP and WQOP instructions, determined as
*/
const MathOp = Object.freeze({
/**
* Add
*/
ADD:0,"0":"ADD",
/**
* Subtract
*/
SUB:1,"1":"SUB",
/**
* Invert bits (discards rhs)
*/
NOT:2,"2":"NOT",
/**
* Bitwise or
*/
OR:3,"3":"OR",
/**
* Bitwise exclusive or
*/
XOR:4,"4":"XOR",
/**
* Bitwise and
*/
AND:5,"5":"AND",
/**
* Shift left
*/
SHL:6,"6":"SHL",
/**
* Shift right
*/
SHR:7,"7":"SHR", });
/**
*Adds two registers.
*/
class ADD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_add_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Adds a register and an immediate value.
*/
class ADDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_addi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Allocate a number of bytes from the heap.
*/
class ALOC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_aloc_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} bytes
    */
    constructor(bytes) {
        _assertClass(bytes, RegId);
        var ptr0 = bytes.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise ANDs two registers.
*/
class AND {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_and_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise ANDs a register and an immediate value.
*/
class ANDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_andi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Get the balance of contract of an asset ID.
*/
class BAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bal_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} asset_id_addr
    * @param {RegId} contract_id_addr
    */
    constructor(dst, asset_id_addr, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr1 = asset_id_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr2 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get current block height.
*/
class BHEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get block header hash for height.
*/
class BHSH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhsh_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} heigth
    */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
class BURN {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_burn_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    * @param {RegId} sub_id_addr
    */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Call a contract.
*/
class CALL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_call_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} target_struct
    * @param {RegId} fwd_coins
    * @param {RegId} asset_id_addr
    * @param {RegId} fwd_gas
    */
    constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        _assertClass(target_struct, RegId);
        var ptr0 = target_struct.__destroy_into_raw();
        _assertClass(fwd_coins, RegId);
        var ptr1 = fwd_coins.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        _assertClass(fwd_gas, RegId);
        var ptr3 = fwd_gas.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get current block proposer's address.
*/
class CB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Copy contract code for a contract.
*/
class CCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ccp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} contract_id_addr
    * @param {RegId} offset
    * @param {RegId} len
    */
    constructor(dst_addr, contract_id_addr, offset, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Extend the current call frame's stack
*/
class CFE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfe_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Extend the current call frame's stack by an immediate value.
*/
class CFEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} amount
    */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Shrink the current call frame's stack
*/
class CFS {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfs_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Shrink the current call frame's stack by an immediate value.
*/
class CFSI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfsi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} amount
    */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Get code root of a contract.
*/
class CROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_croo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} contract_id_addr
    */
    constructor(dst_addr, contract_id_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get code size of a contract.
*/
class CSIZ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_csiz_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} contract_id_addr
    */
    constructor(dst, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
* Arguments for WDCM and WQCM instructions.
*/
class CompareArgs {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompareArgs.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compareargs_free(ptr);
    }
    /**
    * Comparison mode
    * @returns {CompareMode}
    */
    get mode() {
        const ret = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
        return ret;
    }
    /**
    * Comparison mode
    * @param {CompareMode} arg0
    */
    set mode(arg0) {
        wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
    * Convert to immediate value.
    * @returns {Imm06}
    */
    to_imm() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.compareargs_to_imm(ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
    * @param {Imm06} bits
    * @returns {CompareArgs | undefined}
    */
    static from_imm(bits) {
        _assertClass(bits, Imm06);
        var ptr0 = bits.__destroy_into_raw();
        const ret = wasm$1.compareargs_from_imm(ptr0);
        return ret === 0 ? undefined : CompareArgs.__wrap(ret);
    }
}
/**
*Divides two registers.
*/
class DIV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_div_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Divides a register and an immediate value.
*/
class DIVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
* Additional arguments for WMDV and WDDV instructions.
*/
class DivArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divargs_free(ptr);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}
/**
*Call external function
*/
class ECAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecal_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} c
    * @param {RegId} d
    */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message.
*/
class ECK1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eck1_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message.
*/
class ECR1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecr1_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Verify ED25519 public key and signature match a 32-byte message.
*/
class ED19 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ed19_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} pub_key_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(pub_key_addr, sig_addr, msg_hash_addr) {
        _assertClass(pub_key_addr, RegId);
        var ptr0 = pub_key_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Compares two registers for equality.
*/
class EQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Raises one register to the power of another.
*/
class EXP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_exp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Raises one register to the power of an immediate value.
*/
class EXPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_expi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Set flag register to a register.
*/
class FLAG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_flag_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get metadata from memory.
*/
class GM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {Imm18} selector
    */
    constructor(dst, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(selector, Imm18);
        var ptr1 = selector.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
    /**
    * Construct a `GM` instruction from its arguments.
    * @param {RegId} ra
    * @param {GMArgs} args
    * @returns {GM}
    */
    static from_args(ra, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        const ret = wasm$1.gm_from_args(ptr0, args);
        return GM.__wrap(ret);
    }
}
/**
*Compares two registers for greater-than.
*/
class GT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get transaction fields.
*/
class GTF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GTF.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gtf_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} arg
    * @param {Imm12} selector
    */
    constructor(dst, arg, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(selector, Imm12);
        var ptr2 = selector.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
    /**
    * Construct a `GTF` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {GTFArgs} args
    * @returns {GTF}
    */
    static from_args(ra, rb, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        const ret = wasm$1.gtf_from_args(ptr0, ptr1, args);
        return GTF.__wrap(ret);
    }
}
/**
* Represents a 6-bit immediate value, guaranteed to be masked by construction.
*/
class Imm06 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm06.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm06_free(ptr);
    }
}
/**
* Represents a 12-bit immediate value, guaranteed to be masked by construction.
*/
class Imm12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm12.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm12_free(ptr);
    }
}
/**
* Represents a 18-bit immediate value, guaranteed to be masked by construction.
*/
class Imm18 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm18.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm18_free(ptr);
    }
}
/**
* Represents a 24-bit immediate value, guaranteed to be masked by construction.
*/
class Imm24 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm24.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm24_free(ptr);
    }
}
/**
* Representation of a single instruction for the interpreter.
*
* The opcode is represented in the tag (variant), or may be retrieved in the
* form of an `Opcode` byte using the `opcode` method.
*
* The register and immediate data associated with the instruction is represented
* within an inner unit type wrapper around the 3 remaining bytes.
*/
class Instruction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Instruction.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_instruction_free(ptr);
    }
    /**
    * Convenience method for converting to bytes
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_free(r0, r1 * 1, 1);
            return v1;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Size of an instruction in bytes
    * @returns {number}
    */
    static size() {
        const ret = wasm$1.instruction_size();
        return ret >>> 0;
    }
}
/**
*Jump.
*/
class JI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ji_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} abs_target
    */
    constructor(abs_target) {
        _assertClass(abs_target, Imm24);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Dynamic jump.
*/
class JMP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} abs_target
    */
    constructor(abs_target) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Unconditional dynamic relative jump backwards, with a constant offset.
*/
class JMPB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dynamic
    * @param {Imm18} fixed
    */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*Unconditional dynamic relative jump forwards, with a constant offset.
*/
class JMPF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpf_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dynamic
    * @param {Imm18} fixed
    */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*Conditional dynamic jump.
*/
class JNE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jne_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} abs_target
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(abs_target, lhs, rhs) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
*/
class JNEB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jneb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {RegId} dynamic
    * @param {Imm06} fixed
    */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}
/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
*/
class JNEF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnef_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {RegId} dynamic
    * @param {Imm06} fixed
    */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}
/**
*Conditional jump.
*/
class JNEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {Imm12} abs_target
    */
    constructor(cond_lhs, cond_rhs, abs_target) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(abs_target, Imm12);
        var ptr2 = abs_target.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
*/
class JNZB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {RegId} dynamic
    * @param {Imm12} fixed
    */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
*/
class JNZF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzf_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {RegId} dynamic
    * @param {Imm12} fixed
    */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Conditional jump against zero.
*/
class JNZI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {Imm18} abs_target
    */
    constructor(cond_nz, abs_target) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(abs_target, Imm18);
        var ptr1 = abs_target.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*The keccak-256 hash of a slice.
*/
class K256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_k256_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*A byte is loaded from the specified address offset by an immediate value.
*/
class LB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} addr
    * @param {Imm12} offset
    */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Load a contract's code as executable.
*/
class LDC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ldc_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} offset
    * @param {RegId} len
    */
    constructor(contract_id_addr, offset, len) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr1 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Log an event.
*/
class LOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_log_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} c
    * @param {RegId} d
    */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Log data.
*/
class LOGD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_logd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} addr
    * @param {RegId} len
    */
    constructor(a, b, addr, len) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr2 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Compares two registers for less-than.
*/
class LT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*A word is loaded from the specified address offset by an immediate value.
*/
class LW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} addr
    * @param {Imm12} offset
    */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Clear a variable number of bytes in memory.
*/
class MCL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} len
    */
    constructor(dst_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Clear an immediate number of bytes in memory.
*/
class MCLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {Imm18} count
    */
    constructor(addr, count) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(count, Imm18);
        var ptr1 = count.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*Copy a variable number of bytes in memory.
*/
class MCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Copy an immediate number of bytes in memory.
*/
class MCPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcpi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {Imm12} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, Imm12);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Compare bytes in memory.
*/
class MEQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_meq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} result
    * @param {RegId} lhs_addr
    * @param {RegId} rhs_addr
    * @param {RegId} len
    */
    constructor(result, lhs_addr, rhs_addr, len) {
        _assertClass(result, RegId);
        var ptr0 = result.__destroy_into_raw();
        _assertClass(lhs_addr, RegId);
        var ptr1 = lhs_addr.__destroy_into_raw();
        _assertClass(rhs_addr, RegId);
        var ptr2 = rhs_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
class MINT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mint_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    * @param {RegId} sub_id_addr
    */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Fused multiply-divide with arbitrary precision intermediate step.
*/
class MLDV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mldv_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*The integer logarithm of a register.
*/
class MLOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mlog_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Modulo remainder of two registers.
*/
class MOD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mod_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Modulo remainder of a register and an immediate value.
*/
class MODI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_modi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Copy from one register to another.
*/
class MOVE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_move_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} src
    */
    constructor(dst, src) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(src, RegId);
        var ptr1 = src.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Copy immediate value into a register
*/
class MOVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_movi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {Imm18} val
    */
    constructor(dst, val) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(val, Imm18);
        var ptr1 = val.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}
/**
*The integer root of a register.
*/
class MROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mroo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Multiplies two registers.
*/
class MUL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mul_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Multiplies a register and an immediate value.
*/
class MULI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_muli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
* Additional arguments for WDOP and WQOP instructions.
*/
class MathArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mathargs_free(ptr);
    }
    /**
    * The operation to perform
    * @returns {MathOp}
    */
    get op() {
        const ret = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
        return ret;
    }
    /**
    * The operation to perform
    * @param {MathOp} arg0
    */
    set op(arg0) {
        wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}
/**
* Additional arguments for WDML and WQML instructions.
*/
class MulArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mulargs_free(ptr);
    }
    /**
    * Load LHSS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_lhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load LHSS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_lhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_mulargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_mulargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}
/**
*Performs no operation.
*/
class NOOP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_noop_free(ptr);
    }
    /**
    * Construct the instruction.
    */
    constructor() {
        const ret = wasm$1.noop_new_typescript();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
/**
*Bitwise NOT a register.
*/
class NOT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_not_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} arg
    */
    constructor(dst, arg) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise ORs two registers.
*/
class OR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_or_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise ORs a register and an immediate value.
*/
class ORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ori_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
*/
class POPH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_poph_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
*/
class POPL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_popl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
*/
class PSHH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshh_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
*/
class PSHL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}
/**
* Describe a panic reason with the instruction that generated it
*/
class PanicInstruction {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_panicinstruction_free(ptr);
    }
    /**
    * Represents an error described by a reason and an instruction.
    * @param {PanicReason} reason
    * @param {number} instruction
    */
    constructor(reason, instruction) {
        const ret = wasm$1.panicinstruction_error_typescript(reason, instruction);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Underlying panic reason
    * @returns {PanicReason}
    */
    reason() {
        const ret = wasm$1.panicinstruction_reason(this.__wbg_ptr);
        return ret;
    }
    /**
    * Underlying instruction
    * @returns {number}
    */
    instruction() {
        const ret = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
        return ret >>> 0;
    }
}
/**
*Return from context.
*/
class RET {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ret_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Return from context with data.
*/
class RETD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_retd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} len
    */
    constructor(addr, len) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Halt execution, reverting state changes and returning a value.
*/
class RVRT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_rvrt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
* Represents a 6-bit register ID, guaranteed to be masked by construction.
*/
class RegId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegId.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_regid_free(ptr);
    }
    /**
    * Construct a register ID from the given value.
    *
    * Returns `None` if the value is outside the 6-bit value range.
    * @param {number} u
    * @returns {RegId | undefined}
    */
    static new_checked(u) {
        const ret = wasm$1.regid_new_checked(u);
        return ret === 0 ? undefined : RegId.__wrap(ret);
    }
    /**
    * Received balance for this context.
    * @returns {RegId}
    */
    static bal() {
        const ret = wasm$1.regid_bal();
        return RegId.__wrap(ret);
    }
    /**
    * Remaining gas in the context.
    * @returns {RegId}
    */
    static cgas() {
        const ret = wasm$1.regid_cgas();
        return RegId.__wrap(ret);
    }
    /**
    * Error codes for particular operations.
    * @returns {RegId}
    */
    static err() {
        const ret = wasm$1.regid_err();
        return RegId.__wrap(ret);
    }
    /**
    * Flags register.
    * @returns {RegId}
    */
    static flag() {
        const ret = wasm$1.regid_flag();
        return RegId.__wrap(ret);
    }
    /**
    * Frame pointer. Memory address of beginning of current call frame.
    * @returns {RegId}
    */
    static fp() {
        const ret = wasm$1.regid_fp();
        return RegId.__wrap(ret);
    }
    /**
    * Remaining gas globally.
    * @returns {RegId}
    */
    static ggas() {
        const ret = wasm$1.regid_ggas();
        return RegId.__wrap(ret);
    }
    /**
    * Heap pointer. Memory address below the current bottom of the heap (points to free
    * memory).
    * @returns {RegId}
    */
    static hp() {
        const ret = wasm$1.regid_hp();
        return RegId.__wrap(ret);
    }
    /**
    * Instructions start. Pointer to the start of the currently-executing code.
    * @returns {RegId}
    */
    static is() {
        const ret = wasm$1.regid_is();
        return RegId.__wrap(ret);
    }
    /**
    * Contains overflow/underflow of addition, subtraction, and multiplication.
    * @returns {RegId}
    */
    static of() {
        const ret = wasm$1.regid_of();
        return RegId.__wrap(ret);
    }
    /**
    * Contains one (1), for convenience.
    * @returns {RegId}
    */
    static one() {
        const ret = wasm$1.regid_one();
        return RegId.__wrap(ret);
    }
    /**
    * The program counter. Memory address of the current instruction.
    * @returns {RegId}
    */
    static pc() {
        const ret = wasm$1.regid_pc();
        return RegId.__wrap(ret);
    }
    /**
    * Return value or pointer.
    * @returns {RegId}
    */
    static ret() {
        const ret = wasm$1.regid_ret();
        return RegId.__wrap(ret);
    }
    /**
    * Return value length in bytes.
    * @returns {RegId}
    */
    static retl() {
        const ret = wasm$1.regid_retl();
        return RegId.__wrap(ret);
    }
    /**
    * Stack pointer. Memory address on top of current writable stack area (points to
    * free memory).
    * @returns {RegId}
    */
    static sp() {
        const ret = wasm$1.regid_sp();
        return RegId.__wrap(ret);
    }
    /**
    * Stack start pointer. Memory address of bottom of current writable stack area.
    * @returns {RegId}
    */
    static spp() {
        const ret = wasm$1.regid_spp();
        return RegId.__wrap(ret);
    }
    /**
    * Smallest writable register.
    * @returns {RegId}
    */
    static writable() {
        const ret = wasm$1.regid_writable();
        return RegId.__wrap(ret);
    }
    /**
    * Contains zero (0), for convenience.
    * @returns {RegId}
    */
    static zero() {
        const ret = wasm$1.regid_zero();
        return RegId.__wrap(ret);
    }
    /**
    * Construct a register ID from the given value.
    *
    * The given value will be masked to 6 bits.
    * @param {number} u
    */
    constructor(u) {
        const ret = wasm$1.regid_new_typescript(u);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * A const alternative to the `Into<u8>` implementation.
    * @returns {number}
    */
    to_u8() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.regid_to_u8(ptr);
        return ret;
    }
}
/**
*The SHA-2-256 hash of a slice.
*/
class S256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_s256_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Write the least significant byte of a register to memory.
*/
class SB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} value
    * @param {Imm12} offset
    */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Clear a series of slots from contract storage.
*/
class SCWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_scwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} lenq
    */
    constructor(key_addr, status, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr2 = lenq.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Left shifts a register by a register.
*/
class SLL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sll_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Left shifts a register by an immediate value.
*/
class SLLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_slli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Send a message to recipient address with call abi, coins, and output.
*/
class SMO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_smo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} recipient_addr
    * @param {RegId} data_addr
    * @param {RegId} data_len
    * @param {RegId} coins
    */
    constructor(recipient_addr, data_addr, data_len, coins) {
        _assertClass(recipient_addr, RegId);
        var ptr0 = recipient_addr.__destroy_into_raw();
        _assertClass(data_addr, RegId);
        var ptr1 = data_addr.__destroy_into_raw();
        _assertClass(data_len, RegId);
        var ptr2 = data_len.__destroy_into_raw();
        _assertClass(coins, RegId);
        var ptr3 = coins.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Right shifts a register by a register.
*/
class SRL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Right shifts a register by an immediate value.
*/
class SRLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Load a word from contract storage.
*/
class SRW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} status
    * @param {RegId} key_addr
    */
    constructor(dst, status, key_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Load a series of 32 byte slots from contract storage.
*/
class SRWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} status
    * @param {RegId} key_addr
    * @param {RegId} lenq
    */
    constructor(dst_addr, status, key_addr, lenq) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Subtracts two registers.
*/
class SUB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sub_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Subtracts a register and an immediate value.
*/
class SUBI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_subi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Write a register to memory.
*/
class SW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} value
    * @param {Imm12} offset
    */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}
/**
*Store a word in contract storage.
*/
class SWW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sww_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} value
    */
    constructor(key_addr, status, value) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr2 = value.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Store a series of 32 byte slots in contract storage.
*/
class SWWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_swwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} src_addr
    * @param {RegId} lenq
    */
    constructor(key_addr, status, src_addr, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr2 = src_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Get timestamp of block at given height.
*/
class TIME {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_time_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} heigth
    */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Transfer coins to a contract unconditionally.
*/
class TR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tr_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} amount
    * @param {RegId} asset_id_addr
    */
    constructor(contract_id_addr, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr1 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Transfer coins to a variable output.
*/
class TRO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tro_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} output_index
    * @param {RegId} amount
    * @param {RegId} asset_id_addr
    */
    constructor(contract_id_addr, output_index, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(output_index, RegId);
        var ptr1 = output_index.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr2 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr3 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*AddMod 128bit
*/
class WDAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdam_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} add_lhs
    * @param {RegId} add_rhs
    * @param {RegId} modulo
    */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Compare 128bit integers
*/
class WDCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDCM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdcm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WDCM` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {CompareArgs} args
    * @returns {WDCM}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDCM.__wrap(ret);
    }
}
/**
*Divide 128bit
*/
class WDDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDDV.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wddv_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WDDV` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {DivArgs} args
    * @returns {WDDV}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDDV.__wrap(ret);
    }
}
/**
*Fused multiply-divide 128bit
*/
class WDMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Multiply 128bit
*/
class WDML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDML.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdml_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WDML` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MulArgs} args
    * @returns {WDML}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDML.__wrap(ret);
    }
}
/**
*MulMod 128bit
*/
class WDMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} modulo
    */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Simple 128bit operations
*/
class WDOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDOP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdop_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WDOP` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MathArgs} args
    * @returns {WDOP}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDOP.__wrap(ret);
    }
}
/**
*AddMod 256bit
*/
class WQAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqam_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} add_lhs
    * @param {RegId} add_rhs
    * @param {RegId} modulo
    */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Compare 256bit integers
*/
class WQCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQCM.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqcm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WQCM` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {CompareArgs} args
    * @returns {WQCM}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQCM.__wrap(ret);
    }
}
/**
*Divide 256bit
*/
class WQDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQDV.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqdv_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WQDV` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {DivArgs} args
    * @returns {WQDV}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQDV.__wrap(ret);
    }
}
/**
*Fused multiply-divide 256bit
*/
class WQMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Multiply 256bit
*/
class WQML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQML.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqml_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WQML` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MulArgs} args
    * @returns {WQML}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQML.__wrap(ret);
    }
}
/**
*MulMod 256bit
*/
class WQMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} modulo
    */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Simple 256bit operations
*/
class WQOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQOP.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqop_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct a `WQOP` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MathArgs} args
    * @returns {WQOP}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQOP.__wrap(ret);
    }
}
/**
*Bitwise XORs two registers.
*/
class XOR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xor_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}
/**
*Bitwise XORs a register and an immediate value.
*/
class XORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xori_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_finalize_init(instance, module) {
    wasm$1 = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedInt32Memory0 = null;
    cachedUint8Memory0 = null;


    return wasm$1;
}

function initSync(module) {
    if (wasm$1 !== undefined) return wasm$1;

    const imports = __wbg_get_imports();

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(input) {
    if (wasm$1 !== undefined) return wasm$1;
    const imports = __wbg_get_imports();

    const { instance, module } = await __wbg_load(await input, imports);

    return __wbg_finalize_init(instance, module);
}

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function wasm(imports){return _loadWasmModule(1, null, 'AGFzbQEAAAABTw1gA39/fwF/YAF/AX9gAn9/AX9gBH9/f38Bf2ACf38AYAABf2ABfwBgBX9/f39/AX9gA39/fwBgAABgAn5/AX9gBX9/f39/AGAEf39/fwACGAEDd2JnEF9fd2JpbmRnZW5fdGhyb3cABAOBAv8BAQYCBAECAgoDAwMDAwMDAwMDBgQDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAUDAwMDAgICAgICAwMDAwMDAwMDAwMDAwMDAwMDBAMBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICwAADAACAAICAgICAgICAgICAgIEAQEBAQEBAQEBAQEBAQEBAQQBAQEBBAUJAgEABAYEBAMFCQQGBAEEAQIFBQUFBQUFBQUFBQUFBQUFBQEBBAYBAQYIBAYBAQQCCAECBAQEBAECAQEEAQICAgIBBAkJAQEBAQQAAgIBAQUGAggCAwMCBwAHAAECBwcHBAUBcAEXFwUDAQARBgkBfwFBgIDAAAsH803BBQZtZW1vcnkCAA5fX3diZ19hZGRfZnJlZQDFARJhZGRfbmV3X3R5cGVzY3JpcHQAdAZhZGRfcmEAmgEGYWRkX3JiAIsBBmFkZF9yYwCMAQNhZGQAcQNhbmQAVQNkaXYAVgJlcQBXA2V4cABYAmd0AFkCbHQAWgRtbG9nAFsEbXJvbwBcBG1vZF8AXQVtb3ZlXwB6A211bABeA25vdAB7Am9yAF8Dc2xsAGADc3JsAGEDc3ViAGIDeG9yAGMEbWxkdgA6A3JldACPAQRyZXRkAHwTYWxvY19uZXdfdHlwZXNjcmlwdACcAQRhbG9jAJABA21jbAB9A21jcABkA21lcQA7E2Joc2hfbmV3X3R5cGVzY3JpcHQAhAEEYmhzaAB+BGJoZWkAkQEEYnVybgB/E2NhbGxfbmV3X3R5cGVzY3JpcHQATQdjYWxsX3JkAJsBBGNhbGwAPANjY3AAPQRjcm9vAIABBGNzaXoAgQECY2IAkgEDbGRjAGUDbG9nAD4EbG9nZAA/BG1pbnQAggEEcnZydACTAQRzY3dxAGYDc3J3AGcEc3J3cQBAA3N3dwBoBHN3d3EAQQJ0cgBpA3RybwBCBGVjazEAagRlY3IxAGsEZWQxOQBsBGsyNTYAbQRzMjU2AG4EdGltZQCDARNub29wX25ld190eXBlc2NyaXB0AKgBBG5vb3AAngEEZmxhZwCUAQNiYWwAbwNqbXAAlQEDam5lAHADc21vAEMTYWRkaV9uZXdfdHlwZXNjcmlwdAB3CmFkZGlfaW1tMTIAjgEEYWRkaQAbBGFuZGkAHARkaXZpAB0EZXhwaQAeBG1vZGkAHwRtdWxpACADb3JpACEEc2xsaQAiBHNybGkAIwRzdWJpACQEeG9yaQAlBGpuZWkAJgJsYgAnAmx3ACgCc2IAKQJzdwAqBG1jcGkAKwNndGYALARtY2xpADQRZ21fbmV3X3R5cGVzY3JpcHQAhQEIZ21faW1tMTgAiQECZ20ANQRtb3ZpADYEam56aQA3BGptcGYAOARqbXBiADkEam56ZgAtBGpuemIALgRqbmVmAAkEam5lYgAKAmppAE4TY2ZlaV9uZXdfdHlwZXNjcmlwdACNAQpjZmVpX2ltbTI0AIgBBGNmZWkATwRjZnNpAFADY2ZlAJYBA2NmcwCXAQRwc2hsAFEEcHNoaABSBHBvcGwAUwRwb3BoAFQEd2RjbQALBHdxY20ADAR3ZG9wAA0Ed3FvcAAOBHdkbWwADwR3cW1sABAEd2RkdgARBHdxZHYAEgR3ZG1kAEQEd3FtZABFBHdkYW0ARgR3cWFtAEcEd2RtbQBIBHdxbW0ASQRlY2FsAEoTYW5kaV9uZXdfdHlwZXNjcmlwdAB3E2RpdmlfbmV3X3R5cGVzY3JpcHQAdxNleHBpX25ld190eXBlc2NyaXB0AHcTbW9kaV9uZXdfdHlwZXNjcmlwdAB3E211bGlfbmV3X3R5cGVzY3JpcHQAdxJvcmlfbmV3X3R5cGVzY3JpcHQAdxNzbGxpX25ld190eXBlc2NyaXB0AHcTc3JsaV9uZXdfdHlwZXNjcmlwdAB3E3N1YmlfbmV3X3R5cGVzY3JpcHQAdxN4b3JpX25ld190eXBlc2NyaXB0AHcTam5laV9uZXdfdHlwZXNjcmlwdAB3EWxiX25ld190eXBlc2NyaXB0AHcRbHdfbmV3X3R5cGVzY3JpcHQAdxFzYl9uZXdfdHlwZXNjcmlwdAB3EXN3X25ld190eXBlc2NyaXB0AHcTbWNwaV9uZXdfdHlwZXNjcmlwdAB3Emd0Zl9uZXdfdHlwZXNjcmlwdAB3E2puemZfbmV3X3R5cGVzY3JpcHQAdxNqbnpiX25ld190eXBlc2NyaXB0AHcGYW5kX3JjAIwBBmRpdl9yYwCMAQVlcV9yYwCMAQZleHBfcmMAjAEFZ3RfcmMAjAEFbHRfcmMAjAEHbWxvZ19yYwCMAQdtcm9vX3JjAIwBBm1vZF9yYwCMAQZtdWxfcmMAjAEFb3JfcmMAjAEGc2xsX3JjAIwBBnNybF9yYwCMAQZzdWJfcmMAjAEGeG9yX3JjAIwBB21sZHZfcmMAjAEGbWNwX3JjAIwBBm1lcV9yYwCMAQdjYWxsX3JjAIwBBmNjcF9yYwCMAQZsZGNfcmMAjAEGbG9nX3JjAIwBB2xvZ2RfcmMAjAEHc2N3cV9yYwCMAQZzcndfcmMAjAEHc3J3cV9yYwCMAQZzd3dfcmMAjAEHc3d3cV9yYwCMAQV0cl9yYwCMAQZ0cm9fcmMAjAEHZWNrMV9yYwCMAQdlY3IxX3JjAIwBB2VkMTlfcmMAjAEHazI1Nl9yYwCMAQdzMjU2X3JjAIwBBmJhbF9yYwCMAQZqbmVfcmMAjAEGc21vX3JjAIwBB2puZWZfcmMAjAEHam5lYl9yYwCMAQd3ZGNtX3JjAIwBB3dxY21fcmMAjAEHd2RvcF9yYwCMAQd3cW9wX3JjAIwBB3dkbWxfcmMAjAEHd3FtbF9yYwCMAQd3ZGR2X3JjAIwBB3dxZHZfcmMAjAEHd2RtZF9yYwCMAQd3cW1kX3JjAIwBB3dkYW1fcmMAjAEHd3FhbV9yYwCMAQd3ZG1tX3JjAIwBB3dxbW1fcmMAjAEHZWNhbF9yYwCMARNtbGR2X25ld190eXBlc2NyaXB0AE0SbWVxX25ld190eXBlc2NyaXB0AE0SY2NwX25ld190eXBlc2NyaXB0AE0SbG9nX25ld190eXBlc2NyaXB0AE0TbG9nZF9uZXdfdHlwZXNjcmlwdABNE3Nyd3FfbmV3X3R5cGVzY3JpcHQATRNzd3dxX25ld190eXBlc2NyaXB0AE0SdHJvX25ld190eXBlc2NyaXB0AE0Sc21vX25ld190eXBlc2NyaXB0AE0Tam5lZl9uZXdfdHlwZXNjcmlwdABNE2puZWJfbmV3X3R5cGVzY3JpcHQATRN3ZGNtX25ld190eXBlc2NyaXB0AE0Td3FjbV9uZXdfdHlwZXNjcmlwdABNE3dkb3BfbmV3X3R5cGVzY3JpcHQATRN3cW9wX25ld190eXBlc2NyaXB0AE0Td2RtbF9uZXdfdHlwZXNjcmlwdABNE3dxbWxfbmV3X3R5cGVzY3JpcHQATRN3ZGR2X25ld190eXBlc2NyaXB0AE0Td3Fkdl9uZXdfdHlwZXNjcmlwdABNE3dkbWRfbmV3X3R5cGVzY3JpcHQATRN3cW1kX25ld190eXBlc2NyaXB0AE0Td2RhbV9uZXdfdHlwZXNjcmlwdABNE3dxYW1fbmV3X3R5cGVzY3JpcHQATRN3ZG1tX25ld190eXBlc2NyaXB0AE0Td3FtbV9uZXdfdHlwZXNjcmlwdABNE2VjYWxfbmV3X3R5cGVzY3JpcHQATQZhbmRfcmIAiwEGZGl2X3JiAIsBBWVxX3JiAIsBBmV4cF9yYgCLAQVndF9yYgCLAQVsdF9yYgCLAQdtbG9nX3JiAIsBB21yb29fcmIAiwEGbW9kX3JiAIsBB21vdmVfcmIAiwEGbXVsX3JiAIsBBm5vdF9yYgCLAQVvcl9yYgCLAQZzbGxfcmIAiwEGc3JsX3JiAIsBBnN1Yl9yYgCLAQZ4b3JfcmIAiwEHbWxkdl9yYgCLAQdyZXRkX3JiAIsBBm1jbF9yYgCLAQZtY3BfcmIAiwEGbWVxX3JiAIsBB2Joc2hfcmIAiwEHYnVybl9yYgCLAQdjYWxsX3JiAIsBBmNjcF9yYgCLAQdjcm9vX3JiAIsBB2NzaXpfcmIAiwEGbGRjX3JiAIsBBmxvZ19yYgCLAQdsb2dkX3JiAIsBB21pbnRfcmIAiwEHc2N3cV9yYgCLAQZzcndfcmIAiwEHc3J3cV9yYgCLAQZzd3dfcmIAiwEHc3d3cV9yYgCLAQV0cl9yYgCLAQZ0cm9fcmIAiwEHZWNrMV9yYgCLAQdlY3IxX3JiAIsBB2VkMTlfcmIAiwEHazI1Nl9yYgCLAQdzMjU2X3JiAIsBB3RpbWVfcmIAiwEGYmFsX3JiAIsBBmpuZV9yYgCLAQZzbW9fcmIAiwEHYWRkaV9yYgCLAQdhbmRpX3JiAIsBB2RpdmlfcmIAiwEHZXhwaV9yYgCLAQdtb2RpX3JiAIsBB211bGlfcmIAiwEGb3JpX3JiAIsBB3NsbGlfcmIAiwEHc3JsaV9yYgCLAQdzdWJpX3JiAIsBB3hvcmlfcmIAiwEHam5laV9yYgCLAQVsYl9yYgCLAQVsd19yYgCLAQVzYl9yYgCLAQVzd19yYgCLAQdtY3BpX3JiAIsBBmd0Zl9yYgCLAQdqbnpmX3JiAIsBB2puemJfcmIAiwEHam5lZl9yYgCLAQdqbmViX3JiAIsBB3dkY21fcmIAiwEHd3FjbV9yYgCLAQd3ZG9wX3JiAIsBB3dxb3BfcmIAiwEHd2RtbF9yYgCLAQd3cW1sX3JiAIsBB3dkZHZfcmIAiwEHd3Fkdl9yYgCLAQd3ZG1kX3JiAIsBB3dxbWRfcmIAiwEHd2RhbV9yYgCLAQd3cWFtX3JiAIsBB3dkbW1fcmIAiwEHd3FtbV9yYgCLAQdlY2FsX3JiAIsBEm5vdF9uZXdfdHlwZXNjcmlwdACEARNyZXRkX25ld190eXBlc2NyaXB0AIQBE21vdmVfbmV3X3R5cGVzY3JpcHQAhAESbWNsX25ld190eXBlc2NyaXB0AIQBE2J1cm5fbmV3X3R5cGVzY3JpcHQAhAETY3Jvb19uZXdfdHlwZXNjcmlwdACEARNjc2l6X25ld190eXBlc2NyaXB0AIQBE21pbnRfbmV3X3R5cGVzY3JpcHQAhAETdGltZV9uZXdfdHlwZXNjcmlwdACEAQptY2xpX2ltbTE4AIkBCm1vdmlfaW1tMTgAiQEKam56aV9pbW0xOACJAQpqbXBmX2ltbTE4AIkBCmptcGJfaW1tMTgAiQEIamlfaW1tMjQAiAEKY2ZzaV9pbW0yNACIAQpwc2hsX2ltbTI0AIgBCnBzaGhfaW1tMjQAiAEKcG9wbF9pbW0yNACIAQpwb3BoX2ltbTI0AIgBCmFuZGlfaW1tMTIAjgEKZGl2aV9pbW0xMgCOAQpleHBpX2ltbTEyAI4BCm1vZGlfaW1tMTIAjgEKbXVsaV9pbW0xMgCOAQlvcmlfaW1tMTIAjgEKc2xsaV9pbW0xMgCOAQpzcmxpX2ltbTEyAI4BCnN1YmlfaW1tMTIAjgEKeG9yaV9pbW0xMgCOAQpqbmVpX2ltbTEyAI4BCGxiX2ltbTEyAI4BCGx3X2ltbTEyAI4BCHNiX2ltbTEyAI4BCHN3X2ltbTEyAI4BCm1jcGlfaW1tMTIAjgEJZ3RmX2ltbTEyAI4BCmpuemZfaW1tMTIAjgEKam56Yl9pbW0xMgCOARNtY2xpX25ld190eXBlc2NyaXB0AIUBE21vdmlfbmV3X3R5cGVzY3JpcHQAhQETam56aV9uZXdfdHlwZXNjcmlwdACFARNqbXBmX25ld190eXBlc2NyaXB0AIUBE2ptcGJfbmV3X3R5cGVzY3JpcHQAhQEGYW5kX3JhAJoBBmRpdl9yYQCaAQVlcV9yYQCaAQZleHBfcmEAmgEFZ3RfcmEAmgEFbHRfcmEAmgEHbWxvZ19yYQCaAQdtcm9vX3JhAJoBBm1vZF9yYQCaAQdtb3ZlX3JhAJoBBm11bF9yYQCaAQZub3RfcmEAmgEFb3JfcmEAmgEGc2xsX3JhAJoBBnNybF9yYQCaAQZzdWJfcmEAmgEGeG9yX3JhAJoBB21sZHZfcmEAmgEGcmV0X3JhAJoBB3JldGRfcmEAmgEHYWxvY19yYQCaAQZtY2xfcmEAmgEGbWNwX3JhAJoBBm1lcV9yYQCaAQdiaHNoX3JhAJoBB2JoZWlfcmEAmgEHYnVybl9yYQCaAQdjYWxsX3JhAJoBBmNjcF9yYQCaAQdjcm9vX3JhAJoBB2NzaXpfcmEAmgEFY2JfcmEAmgEGbGRjX3JhAJoBBmxvZ19yYQCaAQdsb2dkX3JhAJoBB21pbnRfcmEAmgEHcnZydF9yYQCaAQdzY3dxX3JhAJoBBnNyd19yYQCaAQdzcndxX3JhAJoBBnN3d19yYQCaAQdzd3dxX3JhAJoBBXRyX3JhAJoBBnRyb19yYQCaAQdlY2sxX3JhAJoBB2VjcjFfcmEAmgEHZWQxOV9yYQCaAQdrMjU2X3JhAJoBB3MyNTZfcmEAmgEHdGltZV9yYQCaAQdmbGFnX3JhAJoBBmJhbF9yYQCaAQZqbXBfcmEAmgEGam5lX3JhAJoBBnNtb19yYQCaAQdhZGRpX3JhAJoBB2FuZGlfcmEAmgEHZGl2aV9yYQCaAQdleHBpX3JhAJoBB21vZGlfcmEAmgEHbXVsaV9yYQCaAQZvcmlfcmEAmgEHc2xsaV9yYQCaAQdzcmxpX3JhAJoBB3N1YmlfcmEAmgEHeG9yaV9yYQCaAQdqbmVpX3JhAJoBBWxiX3JhAJoBBWx3X3JhAJoBBXNiX3JhAJoBBXN3X3JhAJoBB21jcGlfcmEAmgEGZ3RmX3JhAJoBB21jbGlfcmEAmgEFZ21fcmEAmgEHbW92aV9yYQCaAQdqbnppX3JhAJoBB2ptcGZfcmEAmgEHam1wYl9yYQCaAQdqbnpmX3JhAJoBB2puemJfcmEAmgEHam5lZl9yYQCaAQdqbmViX3JhAJoBBmNmZV9yYQCaAQZjZnNfcmEAmgEHd2RjbV9yYQCaAQd3cWNtX3JhAJoBB3dkb3BfcmEAmgEHd3FvcF9yYQCaAQd3ZG1sX3JhAJoBB3dxbWxfcmEAmgEHd2Rkdl9yYQCaAQd3cWR2X3JhAJoBB3dkbWRfcmEAmgEHd3FtZF9yYQCaAQd3ZGFtX3JhAJoBB3dxYW1fcmEAmgEHd2RtbV9yYQCaAQd3cW1tX3JhAJoBB2VjYWxfcmEAmgESYW5kX25ld190eXBlc2NyaXB0AHQSZGl2X25ld190eXBlc2NyaXB0AHQRZXFfbmV3X3R5cGVzY3JpcHQAdBJleHBfbmV3X3R5cGVzY3JpcHQAdBFndF9uZXdfdHlwZXNjcmlwdAB0EWx0X25ld190eXBlc2NyaXB0AHQTbWxvZ19uZXdfdHlwZXNjcmlwdAB0E21yb29fbmV3X3R5cGVzY3JpcHQAdBJtb2RfbmV3X3R5cGVzY3JpcHQAdBJtdWxfbmV3X3R5cGVzY3JpcHQAdBFvcl9uZXdfdHlwZXNjcmlwdAB0EnNsbF9uZXdfdHlwZXNjcmlwdAB0EnNybF9uZXdfdHlwZXNjcmlwdAB0EnN1Yl9uZXdfdHlwZXNjcmlwdAB0Enhvcl9uZXdfdHlwZXNjcmlwdAB0Em1jcF9uZXdfdHlwZXNjcmlwdAB0EmxkY19uZXdfdHlwZXNjcmlwdAB0E3Njd3FfbmV3X3R5cGVzY3JpcHQAdBJzcndfbmV3X3R5cGVzY3JpcHQAdBJzd3dfbmV3X3R5cGVzY3JpcHQAdBF0cl9uZXdfdHlwZXNjcmlwdAB0E2VjazFfbmV3X3R5cGVzY3JpcHQAdBNlY3IxX25ld190eXBlc2NyaXB0AHQTZWQxOV9uZXdfdHlwZXNjcmlwdAB0E2syNTZfbmV3X3R5cGVzY3JpcHQAdBNzMjU2X25ld190eXBlc2NyaXB0AHQSYmFsX25ld190eXBlc2NyaXB0AHQSam5lX25ld190eXBlc2NyaXB0AHQHbWxkdl9yZACbAQZtZXFfcmQAmwEGY2NwX3JkAJsBBmxvZ19yZACbAQdsb2dkX3JkAJsBB3Nyd3FfcmQAmwEHc3d3cV9yZACbAQZ0cm9fcmQAmwEGc21vX3JkAJsBCmpuZWZfaW1tMDYAmwEKam5lYl9pbW0wNgCbAQp3ZGNtX2ltbTA2AJsBCndxY21faW1tMDYAmwEKd2RvcF9pbW0wNgCbAQp3cW9wX2ltbTA2AJsBCndkbWxfaW1tMDYAmwEKd3FtbF9pbW0wNgCbAQp3ZGR2X2ltbTA2AJsBCndxZHZfaW1tMDYAmwEHd2RtZF9yZACbAQd3cW1kX3JkAJsBB3dkYW1fcmQAmwEHd3FhbV9yZACbAQd3ZG1tX3JkAJsBB3dxbW1fcmQAmwEHZWNhbF9yZACbARFqaV9uZXdfdHlwZXNjcmlwdACNARNjZnNpX25ld190eXBlc2NyaXB0AI0BE3BzaGxfbmV3X3R5cGVzY3JpcHQAjQETcHNoaF9uZXdfdHlwZXNjcmlwdACNARNwb3BsX25ld190eXBlc2NyaXB0AI0BE3BvcGhfbmV3X3R5cGVzY3JpcHQAjQEOX193YmdfYW5kX2ZyZWUAxQEOX193YmdfZGl2X2ZyZWUAxQENX193YmdfZXFfZnJlZQDFAQ5fX3diZ19leHBfZnJlZQDFAQ1fX3diZ19ndF9mcmVlAMUBDV9fd2JnX2x0X2ZyZWUAxQEPX193YmdfbWxvZ19mcmVlAMUBD19fd2JnX21yb29fZnJlZQDFAQ5fX3diZ19tb2RfZnJlZQDFAQ9fX3diZ19tb3ZlX2ZyZWUAxQEOX193YmdfbXVsX2ZyZWUAxQEOX193Ymdfbm90X2ZyZWUAxQENX193Ymdfb3JfZnJlZQDFAQ5fX3diZ19zbGxfZnJlZQDFAQ5fX3diZ19zcmxfZnJlZQDFAQ5fX3diZ19zdWJfZnJlZQDFAQ5fX3diZ194b3JfZnJlZQDFAQ9fX3diZ19tbGR2X2ZyZWUAxQEOX193YmdfcmV0X2ZyZWUAxQEPX193YmdfcmV0ZF9mcmVlAMUBD19fd2JnX2Fsb2NfZnJlZQDFAQ5fX3diZ19tY2xfZnJlZQDFAQ5fX3diZ19tY3BfZnJlZQDFAQ5fX3diZ19tZXFfZnJlZQDFAQ9fX3diZ19iaHNoX2ZyZWUAxQEPX193YmdfYmhlaV9mcmVlAMUBD19fd2JnX2J1cm5fZnJlZQDFAQ9fX3diZ19jYWxsX2ZyZWUAxQEOX193YmdfY2NwX2ZyZWUAxQEPX193YmdfY3Jvb19mcmVlAMUBD19fd2JnX2NzaXpfZnJlZQDFAQ1fX3diZ19jYl9mcmVlAMUBDl9fd2JnX2xkY19mcmVlAMUBDl9fd2JnX2xvZ19mcmVlAMUBD19fd2JnX2xvZ2RfZnJlZQDFAQ9fX3diZ19taW50X2ZyZWUAxQEPX193YmdfcnZydF9mcmVlAMUBD19fd2JnX3Njd3FfZnJlZQDFAQ5fX3diZ19zcndfZnJlZQDFAQ9fX3diZ19zcndxX2ZyZWUAxQEOX193Ymdfc3d3X2ZyZWUAxQEPX193Ymdfc3d3cV9mcmVlAMUBDV9fd2JnX3RyX2ZyZWUAxQEOX193YmdfdHJvX2ZyZWUAxQEPX193YmdfZWNrMV9mcmVlAMUBD19fd2JnX2VjcjFfZnJlZQDFAQ9fX3diZ19lZDE5X2ZyZWUAxQEPX193YmdfazI1Nl9mcmVlAMUBD19fd2JnX3MyNTZfZnJlZQDFAQ9fX3diZ190aW1lX2ZyZWUAxQEPX193Ymdfbm9vcF9mcmVlAMUBD19fd2JnX2ZsYWdfZnJlZQDFAQ5fX3diZ19iYWxfZnJlZQDFAQ5fX3diZ19qbXBfZnJlZQDFAQ5fX3diZ19qbmVfZnJlZQDFAQ5fX3diZ19zbW9fZnJlZQDFAQ9fX3diZ19hZGRpX2ZyZWUAxQEPX193YmdfYW5kaV9mcmVlAMUBD19fd2JnX2RpdmlfZnJlZQDFAQ9fX3diZ19leHBpX2ZyZWUAxQEPX193YmdfbW9kaV9mcmVlAMUBD19fd2JnX211bGlfZnJlZQDFAQ5fX3diZ19vcmlfZnJlZQDFAQ9fX3diZ19zbGxpX2ZyZWUAxQEPX193Ymdfc3JsaV9mcmVlAMUBD19fd2JnX3N1YmlfZnJlZQDFAQ9fX3diZ194b3JpX2ZyZWUAxQEPX193Ymdfam5laV9mcmVlAMUBDV9fd2JnX2xiX2ZyZWUAxQENX193YmdfbHdfZnJlZQDFAQ1fX3diZ19zYl9mcmVlAMUBDV9fd2JnX3N3X2ZyZWUAxQEPX193YmdfbWNwaV9mcmVlAMUBDl9fd2JnX2d0Zl9mcmVlAMUBD19fd2JnX21jbGlfZnJlZQDFAQ1fX3diZ19nbV9mcmVlAMUBD19fd2JnX21vdmlfZnJlZQDFAQ9fX3diZ19qbnppX2ZyZWUAxQEPX193Ymdfam1wZl9mcmVlAMUBD19fd2JnX2ptcGJfZnJlZQDFAQ9fX3diZ19qbnpmX2ZyZWUAxQEPX193Ymdfam56Yl9mcmVlAMUBD19fd2JnX2puZWZfZnJlZQDFAQ9fX3diZ19qbmViX2ZyZWUAxQENX193YmdfamlfZnJlZQDFAQ9fX3diZ19jZmVpX2ZyZWUAxQEPX193YmdfY2ZzaV9mcmVlAMUBDl9fd2JnX2NmZV9mcmVlAMUBDl9fd2JnX2Nmc19mcmVlAMUBD19fd2JnX3BzaGxfZnJlZQDFAQ9fX3diZ19wc2hoX2ZyZWUAxQEPX193YmdfcG9wbF9mcmVlAMUBD19fd2JnX3BvcGhfZnJlZQDFAQ9fX3diZ193ZGNtX2ZyZWUAxQEPX193Ymdfd3FjbV9mcmVlAMUBD19fd2JnX3dkb3BfZnJlZQDFAQ9fX3diZ193cW9wX2ZyZWUAxQEPX193Ymdfd2RtbF9mcmVlAMUBD19fd2JnX3dxbWxfZnJlZQDFAQ9fX3diZ193ZGR2X2ZyZWUAxQEPX193Ymdfd3Fkdl9mcmVlAMUBD19fd2JnX3dkbWRfZnJlZQDFAQ9fX3diZ193cW1kX2ZyZWUAxQEPX193Ymdfd2RhbV9mcmVlAMUBD19fd2JnX3dxYW1fZnJlZQDFAQ9fX3diZ193ZG1tX2ZyZWUAxQEPX193Ymdfd3FtbV9mcmVlAMUBD19fd2JnX2VjYWxfZnJlZQDFARJyZXRfbmV3X3R5cGVzY3JpcHQAnAETYmhlaV9uZXdfdHlwZXNjcmlwdACcARFjYl9uZXdfdHlwZXNjcmlwdACcARNydnJ0X25ld190eXBlc2NyaXB0AJwBE2ZsYWdfbmV3X3R5cGVzY3JpcHQAnAESam1wX25ld190eXBlc2NyaXB0AJwBEmNmZV9uZXdfdHlwZXNjcmlwdACcARJjZnNfbmV3X3R5cGVzY3JpcHQAnAEWX193YmdfY29tcGFyZWFyZ3NfZnJlZQDFARpfX3diZ19nZXRfY29tcGFyZWFyZ3NfbW9kZQDCARpfX3diZ19zZXRfY29tcGFyZWFyZ3NfbW9kZQClASJfX3diZ19nZXRfY29tcGFyZWFyZ3NfaW5kaXJlY3RfcmhzAMYBIl9fd2JnX3NldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMArgESY29tcGFyZWFyZ3NfdG9faW1tAJkBFGNvbXBhcmVhcmdzX2Zyb21faW1tAIoBFV9fd2JnX2dldF9tYXRoYXJnc19vcADCARVfX3diZ19zZXRfbWF0aGFyZ3Nfb3AApgEeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfcmhzAMIBHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X3JocwCsARtfX3diZ19wYW5pY2luc3RydWN0aW9uX2ZyZWUAxQEhcGFuaWNpbnN0cnVjdGlvbl9lcnJvcl90eXBlc2NyaXB0AKABF3BhbmljaW5zdHJ1Y3Rpb25fcmVhc29uAMMBHHBhbmljaW5zdHJ1Y3Rpb25faW5zdHJ1Y3Rpb24AxwEfX193Ymdfc2V0X21hdGhhcmdzX2luZGlyZWN0X3JocwCuAR5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9saHMArgEeX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAK4BH19fd2JnX2dldF9tYXRoYXJnc19pbmRpcmVjdF9yaHMAxgEeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfbGhzAMYBHl9fd2JnX2dldF9kaXZhcmdzX2luZGlyZWN0X3JocwDGARNfX3diZ19tYXRoYXJnc19mcmVlAMUBEl9fd2JnX211bGFyZ3NfZnJlZQDFARJfX3diZ19kaXZhcmdzX2ZyZWUAxQEQX193YmdfaW1tMDZfZnJlZQDFARFyZWdpZF9uZXdfY2hlY2tlZAChAQlyZWdpZF9iYWwAsQEKcmVnaWRfY2dhcwCyAQlyZWdpZF9lcnIAswEKcmVnaWRfZmxhZwC0AQhyZWdpZF9mcAC1AQpyZWdpZF9nZ2FzALYBCHJlZ2lkX2hwALcBCHJlZ2lkX2lzALgBCHJlZ2lkX29mALkBCXJlZ2lkX29uZQC6AQhyZWdpZF9wYwC7AQlyZWdpZF9yZXQAvAEKcmVnaWRfcmV0bAC9AQhyZWdpZF9zcAC+AQlyZWdpZF9zcHAAvwEOcmVnaWRfd3JpdGFibGUAwAEKcmVnaWRfemVybwDBARRyZWdpZF9uZXdfdHlwZXNjcmlwdACtAQtyZWdpZF90b191OACvARBfX3diZ19yZWdpZF9mcmVl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AGovAAA7AAAgAkECayAHIARB5ABsa0H//wNxQQF0QeSLwABqLwAAOwAAIANBBGshAyAAQv/B1y9WIA4hAA0ACwsgDqciAkHjAEsEQCADQQJrIgMgBkEJamogDqciAiACQf//A3FB5ABuIgJB5ABsa0H//wNxQQF0QeSLwABqLwAAOwAACwJAIAJBCk8EQCADQQJrIgMgBkEJamogAkEBdEHki8AAai8AADsAAAwBCyADQQFrIgMgBkEJamogAkEwajoAAAsCfyAGQQlqIANqIQlBK0GAgMQAIAEiAigCHCIBQQFxIgQbIQcgBEEnIANrIgpqIQNBnIvAAEEAIAFBBHEbIQQCQAJAIAIoAgBFBEBBASEBIAIoAhQiAyACKAIYIgIgByAEEKcBDQEMAgsgAyACKAIEIgVPBEBBASEBIAIoAhQiAyACKAIYIgIgByAEEKcBDQEMAgsgAUEIcQRAIAIoAhAhDCACQTA2AhAgAi0AICENQQEhASACQQE6ACAgAigCFCIIIAIoAhgiCyAHIAQQpwENASAFIANrQQFqIQECQANAIAFBAWsiAUUNASAIQTAgCygCEBECAEUNAAtBAQwEC0EBIQEgCCAJIAogCygCDBEAAA0BIAIgDToAICACIAw2AhBBACEBDAELIAUgA2shAwJAAkACQCACLQAgIgFBAWsOAwABAAILIAMhAUEAIQMMAQsgA0EBdiEBIANBAWpBAXYhAwsgAUEBaiEBIAJBGGooAgAhBSACKAIQIQggAigCFCECAkADQCABQQFrIgFFDQEgAiAIIAUoAhARAgBFDQALQQEMAwtBASEBIAIgBSAHIAQQpwENACACIAkgCiAFKAIMEQAADQBBACEBA0BBACABIANGDQMaIAFBAWohASACIAggBSgCEBECAEUNAAsgAUEBayADSQwCCyABDAELIAMgCSAKIAIoAgwRAAALIAZBMGokAAsQACAAIAEgAiADQdMAEPcBCxAAIAAgASACIANB1AAQ9wELEAAgACABIAIgA0HeABD3AQsQACAAIAEgAiADQd8AEPcBCxAAIAAgASACIANB4AAQ9wELEAAgACABIAIgA0HhABD3AQsQACAAIAEgAiADQeIAEPcBCxAAIAAgASACIANB4wAQ9wELEAAgACABIAIgA0HkABD3AQsQACAAIAEgAiADQeUAEPcBC7sC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', imports)}

async function initWasm () {
  return await __wbg_init(wasm());
}

/**
 * calling it right away for pre-caching
 * the wasm async initialization at startup
 */
initWasm();

exports.ADD = ADD;
exports.ADDI = ADDI;
exports.ALOC = ALOC;
exports.AND = AND;
exports.ANDI = ANDI;
exports.BAL = BAL;
exports.BHEI = BHEI;
exports.BHSH = BHSH;
exports.BURN = BURN;
exports.CALL = CALL;
exports.CB = CB;
exports.CCP = CCP;
exports.CFE = CFE;
exports.CFEI = CFEI;
exports.CFS = CFS;
exports.CFSI = CFSI;
exports.CROO = CROO;
exports.CSIZ = CSIZ;
exports.CompareArgs = CompareArgs;
exports.CompareMode = CompareMode;
exports.DIV = DIV;
exports.DIVI = DIVI;
exports.DivArgs = DivArgs;
exports.ECAL = ECAL;
exports.ECK1 = ECK1;
exports.ECR1 = ECR1;
exports.ED19 = ED19;
exports.EQ = EQ;
exports.EXP = EXP;
exports.EXPI = EXPI;
exports.FLAG = FLAG;
exports.GM = GM;
exports.GMArgs = GMArgs;
exports.GT = GT;
exports.GTF = GTF;
exports.GTFArgs = GTFArgs;
exports.Imm06 = Imm06;
exports.Imm12 = Imm12;
exports.Imm18 = Imm18;
exports.Imm24 = Imm24;
exports.Instruction = Instruction;
exports.JI = JI;
exports.JMP = JMP;
exports.JMPB = JMPB;
exports.JMPF = JMPF;
exports.JNE = JNE;
exports.JNEB = JNEB;
exports.JNEF = JNEF;
exports.JNEI = JNEI;
exports.JNZB = JNZB;
exports.JNZF = JNZF;
exports.JNZI = JNZI;
exports.K256 = K256;
exports.LB = LB;
exports.LDC = LDC;
exports.LOG = LOG;
exports.LOGD = LOGD;
exports.LT = LT;
exports.LW = LW;
exports.MCL = MCL;
exports.MCLI = MCLI;
exports.MCP = MCP;
exports.MCPI = MCPI;
exports.MEQ = MEQ;
exports.MINT = MINT;
exports.MLDV = MLDV;
exports.MLOG = MLOG;
exports.MOD = MOD;
exports.MODI = MODI;
exports.MOVE = MOVE;
exports.MOVI = MOVI;
exports.MROO = MROO;
exports.MUL = MUL;
exports.MULI = MULI;
exports.MathArgs = MathArgs;
exports.MathOp = MathOp;
exports.MulArgs = MulArgs;
exports.NOOP = NOOP;
exports.NOT = NOT;
exports.OR = OR;
exports.ORI = ORI;
exports.POPH = POPH;
exports.POPL = POPL;
exports.PSHH = PSHH;
exports.PSHL = PSHL;
exports.PanicInstruction = PanicInstruction;
exports.PanicReason = PanicReason;
exports.RET = RET;
exports.RETD = RETD;
exports.RVRT = RVRT;
exports.RegId = RegId;
exports.S256 = S256;
exports.SB = SB;
exports.SCWQ = SCWQ;
exports.SLL = SLL;
exports.SLLI = SLLI;
exports.SMO = SMO;
exports.SRL = SRL;
exports.SRLI = SRLI;
exports.SRW = SRW;
exports.SRWQ = SRWQ;
exports.SUB = SUB;
exports.SUBI = SUBI;
exports.SW = SW;
exports.SWW = SWW;
exports.SWWQ = SWWQ;
exports.TIME = TIME;
exports.TR = TR;
exports.TRO = TRO;
exports.WDAM = WDAM;
exports.WDCM = WDCM;
exports.WDDV = WDDV;
exports.WDMD = WDMD;
exports.WDML = WDML;
exports.WDMM = WDMM;
exports.WDOP = WDOP;
exports.WQAM = WQAM;
exports.WQCM = WQCM;
exports.WQDV = WQDV;
exports.WQMD = WQMD;
exports.WQML = WQML;
exports.WQMM = WQMM;
exports.WQOP = WQOP;
exports.XOR = XOR;
exports.XORI = XORI;
exports.add = add;
exports.addi = addi;
exports.aloc = aloc;
exports.and = and;
exports.andi = andi;
exports.bal = bal;
exports.bhei = bhei;
exports.bhsh = bhsh;
exports.burn = burn;
exports.call = call;
exports.cb = cb;
exports.ccp = ccp;
exports.cfe = cfe;
exports.cfei = cfei;
exports.cfs = cfs;
exports.cfsi = cfsi;
exports.croo = croo;
exports.csiz = csiz;
exports.div = div;
exports.divi = divi;
exports.ecal = ecal;
exports.eck1 = eck1;
exports.ecr1 = ecr1;
exports.ed19 = ed19;
exports.eq = eq;
exports.exp = exp;
exports.expi = expi;
exports.flag = flag;
exports.gm = gm;
exports.gm_args = gm_args;
exports.gt = gt;
exports.gtf = gtf;
exports.gtf_args = gtf_args;
exports.initSync = initSync;
exports.initWasm = initWasm;
exports.ji = ji;
exports.jmp = jmp;
exports.jmpb = jmpb;
exports.jmpf = jmpf;
exports.jne = jne;
exports.jneb = jneb;
exports.jnef = jnef;
exports.jnei = jnei;
exports.jnzb = jnzb;
exports.jnzf = jnzf;
exports.jnzi = jnzi;
exports.k256 = k256;
exports.lb = lb;
exports.ldc = ldc;
exports.log = log;
exports.logd = logd;
exports.lt = lt;
exports.lw = lw;
exports.mcl = mcl;
exports.mcli = mcli;
exports.mcp = mcp;
exports.mcpi = mcpi;
exports.meq = meq;
exports.mint = mint;
exports.mldv = mldv;
exports.mlog = mlog;
exports.mod_ = mod_;
exports.modi = modi;
exports.move_ = move_;
exports.movi = movi;
exports.mroo = mroo;
exports.mul = mul;
exports.muli = muli;
exports.noop = noop;
exports.not = not;
exports.or = or;
exports.ori = ori;
exports.poph = poph;
exports.popl = popl;
exports.pshh = pshh;
exports.pshl = pshl;
exports.ret = ret;
exports.retd = retd;
exports.rvrt = rvrt;
exports.s256 = s256;
exports.sb = sb;
exports.scwq = scwq;
exports.sll = sll;
exports.slli = slli;
exports.smo = smo;
exports.srl = srl;
exports.srli = srli;
exports.srw = srw;
exports.srwq = srwq;
exports.sub = sub;
exports.subi = subi;
exports.sw = sw;
exports.sww = sww;
exports.swwq = swwq;
exports.time = time;
exports.tr = tr;
exports.tro = tro;
exports.wdam = wdam;
exports.wdcm = wdcm;
exports.wdcm_args = wdcm_args;
exports.wddv = wddv;
exports.wddv_args = wddv_args;
exports.wdmd = wdmd;
exports.wdml = wdml;
exports.wdml_args = wdml_args;
exports.wdmm = wdmm;
exports.wdop = wdop;
exports.wdop_args = wdop_args;
exports.wqam = wqam;
exports.wqcm = wqcm;
exports.wqcm_args = wqcm_args;
exports.wqdv = wqdv;
exports.wqdv_args = wqdv_args;
exports.wqmd = wqmd;
exports.wqml = wqml;
exports.wqml_args = wqml_args;
exports.wqmm = wqmm;
exports.wqop = wqop;
exports.wqop_args = wqop_args;
exports.xor = xor;
exports.xori = xori;
