/* tslint:disable */
/* eslint-disable */
/**
*Adds two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function add(dst: number, lhs: number, rhs: number): Instruction;
/**
*Bitwise ANDs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function and(dst: number, lhs: number, rhs: number): Instruction;
/**
*Divides two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function div(dst: number, lhs: number, rhs: number): Instruction;
/**
*Compares two registers for equality.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function eq(dst: number, lhs: number, rhs: number): Instruction;
/**
*Raises one register to the power of another.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function exp(dst: number, lhs: number, rhs: number): Instruction;
/**
*Compares two registers for greater-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function gt(dst: number, lhs: number, rhs: number): Instruction;
/**
*Compares two registers for less-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function lt(dst: number, lhs: number, rhs: number): Instruction;
/**
*The integer logarithm of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function mlog(dst: number, lhs: number, rhs: number): Instruction;
/**
*The integer root of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function mroo(dst: number, lhs: number, rhs: number): Instruction;
/**
*Modulo remainder of two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function mod_(dst: number, lhs: number, rhs: number): Instruction;
/**
*Copy from one register to another.
* @param {number} dst
* @param {number} src
* @returns {Instruction}
*/
declare function move_(dst: number, src: number): Instruction;
/**
*Multiplies two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function mul(dst: number, lhs: number, rhs: number): Instruction;
/**
*Bitwise NOT a register.
* @param {number} dst
* @param {number} arg
* @returns {Instruction}
*/
declare function not(dst: number, arg: number): Instruction;
/**
*Bitwise ORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function or(dst: number, lhs: number, rhs: number): Instruction;
/**
*Left shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function sll(dst: number, lhs: number, rhs: number): Instruction;
/**
*Right shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function srl(dst: number, lhs: number, rhs: number): Instruction;
/**
*Subtracts two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function sub(dst: number, lhs: number, rhs: number): Instruction;
/**
*Bitwise XORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function xor(dst: number, lhs: number, rhs: number): Instruction;
/**
*Fused multiply-divide with arbitrary precision intermediate step.
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
declare function mldv(dst: number, mul_lhs: number, mul_rhs: number, divisor: number): Instruction;
/**
*Return from context.
* @param {number} value
* @returns {Instruction}
*/
declare function ret(value: number): Instruction;
/**
*Return from context with data.
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
declare function retd(addr: number, len: number): Instruction;
/**
*Allocate a number of bytes from the heap.
* @param {number} bytes
* @returns {Instruction}
*/
declare function aloc(bytes: number): Instruction;
/**
*Clear a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} len
* @returns {Instruction}
*/
declare function mcl(dst_addr: number, len: number): Instruction;
/**
*Copy a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
declare function mcp(dst_addr: number, src_addr: number, len: number): Instruction;
/**
*Compare bytes in memory.
* @param {number} result
* @param {number} lhs_addr
* @param {number} rhs_addr
* @param {number} len
* @returns {Instruction}
*/
declare function meq(result: number, lhs_addr: number, rhs_addr: number, len: number): Instruction;
/**
*Get block header hash for height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
declare function bhsh(dst: number, heigth: number): Instruction;
/**
*Get current block height.
* @param {number} dst
* @returns {Instruction}
*/
declare function bhei(dst: number): Instruction;
/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
declare function burn(amount: number, sub_id_addr: number): Instruction;
/**
*Call a contract.
* @param {number} target_struct
* @param {number} fwd_coins
* @param {number} asset_id_addr
* @param {number} fwd_gas
* @returns {Instruction}
*/
declare function call(target_struct: number, fwd_coins: number, asset_id_addr: number, fwd_gas: number): Instruction;
/**
*Copy contract code for a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
declare function ccp(dst_addr: number, contract_id_addr: number, offset: number, len: number): Instruction;
/**
*Get code root of a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
declare function croo(dst_addr: number, contract_id_addr: number): Instruction;
/**
*Get code size of a contract.
* @param {number} dst
* @param {number} contract_id_addr
* @returns {Instruction}
*/
declare function csiz(dst: number, contract_id_addr: number): Instruction;
/**
*Get current block proposer's address.
* @param {number} dst
* @returns {Instruction}
*/
declare function cb(dst: number): Instruction;
/**
*Load a contract's code as executable.
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
declare function ldc(contract_id_addr: number, offset: number, len: number): Instruction;
/**
*Log an event.
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
declare function log(a: number, b: number, c: number, d: number): Instruction;
/**
*Log data.
* @param {number} a
* @param {number} b
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
declare function logd(a: number, b: number, addr: number, len: number): Instruction;
/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
declare function mint(amount: number, sub_id_addr: number): Instruction;
/**
*Halt execution, reverting state changes and returning a value.
* @param {number} value
* @returns {Instruction}
*/
declare function rvrt(value: number): Instruction;
/**
*Clear a series of slots from contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} lenq
* @returns {Instruction}
*/
declare function scwq(key_addr: number, status: number, lenq: number): Instruction;
/**
*Load a word from contract storage.
* @param {number} dst
* @param {number} status
* @param {number} key_addr
* @returns {Instruction}
*/
declare function srw(dst: number, status: number, key_addr: number): Instruction;
/**
*Load a series of 32 byte slots from contract storage.
* @param {number} dst_addr
* @param {number} status
* @param {number} key_addr
* @param {number} lenq
* @returns {Instruction}
*/
declare function srwq(dst_addr: number, status: number, key_addr: number, lenq: number): Instruction;
/**
*Store a word in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} value
* @returns {Instruction}
*/
declare function sww(key_addr: number, status: number, value: number): Instruction;
/**
*Store a series of 32 byte slots in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} src_addr
* @param {number} lenq
* @returns {Instruction}
*/
declare function swwq(key_addr: number, status: number, src_addr: number, lenq: number): Instruction;
/**
*Transfer coins to a contract unconditionally.
* @param {number} contract_id_addr
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
declare function tr(contract_id_addr: number, amount: number, asset_id_addr: number): Instruction;
/**
*Transfer coins to a variable output.
* @param {number} contract_id_addr
* @param {number} output_index
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
declare function tro(contract_id_addr: number, output_index: number, amount: number, asset_id_addr: number): Instruction;
/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
declare function eck1(dst_addr: number, sig_addr: number, msg_hash_addr: number): Instruction;
/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
declare function ecr1(dst_addr: number, sig_addr: number, msg_hash_addr: number): Instruction;
/**
*Verify ED25519 public key and signature match a 32-byte message.
* @param {number} pub_key_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
declare function ed19(pub_key_addr: number, sig_addr: number, msg_hash_addr: number): Instruction;
/**
*The keccak-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
declare function k256(dst_addr: number, src_addr: number, len: number): Instruction;
/**
*The SHA-2-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
declare function s256(dst_addr: number, src_addr: number, len: number): Instruction;
/**
*Get timestamp of block at given height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
declare function time(dst: number, heigth: number): Instruction;
/**
*Performs no operation.
* @returns {Instruction}
*/
declare function noop(): Instruction;
/**
*Set flag register to a register.
* @param {number} value
* @returns {Instruction}
*/
declare function flag(value: number): Instruction;
/**
*Get the balance of contract of an asset ID.
* @param {number} dst
* @param {number} asset_id_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
declare function bal(dst: number, asset_id_addr: number, contract_id_addr: number): Instruction;
/**
*Dynamic jump.
* @param {number} abs_target
* @returns {Instruction}
*/
declare function jmp(abs_target: number): Instruction;
/**
*Conditional dynamic jump.
* @param {number} abs_target
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function jne(abs_target: number, lhs: number, rhs: number): Instruction;
/**
*Send a message to recipient address with call abi, coins, and output.
* @param {number} recipient_addr
* @param {number} data_addr
* @param {number} data_len
* @param {number} coins
* @returns {Instruction}
*/
declare function smo(recipient_addr: number, data_addr: number, data_len: number, coins: number): Instruction;
/**
*Adds a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function addi(dst: number, lhs: number, rhs: number): Instruction;
/**
*Bitwise ANDs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function andi(dst: number, lhs: number, rhs: number): Instruction;
/**
*Divides a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function divi(dst: number, lhs: number, rhs: number): Instruction;
/**
*Raises one register to the power of an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function expi(dst: number, lhs: number, rhs: number): Instruction;
/**
*Modulo remainder of a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function modi(dst: number, lhs: number, rhs: number): Instruction;
/**
*Multiplies a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function muli(dst: number, lhs: number, rhs: number): Instruction;
/**
*Bitwise ORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function ori(dst: number, lhs: number, rhs: number): Instruction;
/**
*Left shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function slli(dst: number, lhs: number, rhs: number): Instruction;
/**
*Right shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function srli(dst: number, lhs: number, rhs: number): Instruction;
/**
*Subtracts a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function subi(dst: number, lhs: number, rhs: number): Instruction;
/**
*Bitwise XORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
declare function xori(dst: number, lhs: number, rhs: number): Instruction;
/**
*Conditional jump.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} abs_target
* @returns {Instruction}
*/
declare function jnei(cond_lhs: number, cond_rhs: number, abs_target: number): Instruction;
/**
*A byte is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
declare function lb(dst: number, addr: number, offset: number): Instruction;
/**
*A word is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
declare function lw(dst: number, addr: number, offset: number): Instruction;
/**
*Write the least significant byte of a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
declare function sb(addr: number, value: number, offset: number): Instruction;
/**
*Write a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
declare function sw(addr: number, value: number, offset: number): Instruction;
/**
*Copy an immediate number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
declare function mcpi(dst_addr: number, src_addr: number, len: number): Instruction;
/**
*Get transaction fields.
* @param {number} dst
* @param {number} arg
* @param {number} selector
* @returns {Instruction}
*/
declare function gtf(dst: number, arg: number, selector: number): Instruction;
/**
*Clear an immediate number of bytes in memory.
* @param {number} addr
* @param {number} count
* @returns {Instruction}
*/
declare function mcli(addr: number, count: number): Instruction;
/**
*Get metadata from memory.
* @param {number} dst
* @param {number} selector
* @returns {Instruction}
*/
declare function gm(dst: number, selector: number): Instruction;
/**
*Copy immediate value into a register
* @param {number} dst
* @param {number} val
* @returns {Instruction}
*/
declare function movi(dst: number, val: number): Instruction;
/**
*Conditional jump against zero.
* @param {number} cond_nz
* @param {number} abs_target
* @returns {Instruction}
*/
declare function jnzi(cond_nz: number, abs_target: number): Instruction;
/**
*Unconditional dynamic relative jump forwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
declare function jmpf(dynamic: number, fixed: number): Instruction;
/**
*Unconditional dynamic relative jump backwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
declare function jmpb(dynamic: number, fixed: number): Instruction;
/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
declare function jnzf(cond_nz: number, dynamic: number, fixed: number): Instruction;
/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
declare function jnzb(cond_nz: number, dynamic: number, fixed: number): Instruction;
/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
declare function jnef(cond_lhs: number, cond_rhs: number, dynamic: number, fixed: number): Instruction;
/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
declare function jneb(cond_lhs: number, cond_rhs: number, dynamic: number, fixed: number): Instruction;
/**
*Jump.
* @param {number} abs_target
* @returns {Instruction}
*/
declare function ji(abs_target: number): Instruction;
/**
*Extend the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
declare function cfei(amount: number): Instruction;
/**
*Shrink the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
declare function cfsi(amount: number): Instruction;
/**
*Extend the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
declare function cfe(amount: number): Instruction;
/**
*Shrink the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
declare function cfs(amount: number): Instruction;
/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
declare function pshl(bitmask: number): Instruction;
/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
declare function pshh(bitmask: number): Instruction;
/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
declare function popl(bitmask: number): Instruction;
/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
declare function poph(bitmask: number): Instruction;
/**
*Compare 128bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
declare function wdcm(dst: number, lhs: number, rhs: number, flags: number): Instruction;
/**
*Compare 256bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
declare function wqcm(dst: number, lhs: number, rhs: number, flags: number): Instruction;
/**
*Simple 128bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
declare function wdop(dst: number, lhs: number, rhs: number, flags: number): Instruction;
/**
*Simple 256bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
declare function wqop(dst: number, lhs: number, rhs: number, flags: number): Instruction;
/**
*Multiply 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
declare function wdml(dst: number, lhs: number, rhs: number, flags: number): Instruction;
/**
*Multiply 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
declare function wqml(dst: number, lhs: number, rhs: number, flags: number): Instruction;
/**
*Divide 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
declare function wddv(dst: number, lhs: number, rhs: number, flags: number): Instruction;
/**
*Divide 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
declare function wqdv(dst: number, lhs: number, rhs: number, flags: number): Instruction;
/**
*Fused multiply-divide 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
declare function wdmd(dst: number, mul_lhs: number, mul_rhs: number, divisor: number): Instruction;
/**
*Fused multiply-divide 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
declare function wqmd(dst: number, mul_lhs: number, mul_rhs: number, divisor: number): Instruction;
/**
*AddMod 128bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
declare function wdam(dst: number, add_lhs: number, add_rhs: number, modulo: number): Instruction;
/**
*AddMod 256bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
declare function wqam(dst: number, add_lhs: number, add_rhs: number, modulo: number): Instruction;
/**
*MulMod 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
declare function wdmm(dst: number, mul_lhs: number, mul_rhs: number, modulo: number): Instruction;
/**
*MulMod 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
declare function wqmm(dst: number, mul_lhs: number, mul_rhs: number, modulo: number): Instruction;
/**
*Call external function
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
declare function ecal(a: number, b: number, c: number, d: number): Instruction;
/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {GMArgs} args
* @returns {Instruction}
*/
declare function gm_args(ra: number, args: GMArgs): Instruction;
/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {GTFArgs} args
* @returns {Instruction}
*/
declare function gtf_args(ra: number, rb: number, args: GTFArgs): Instruction;
/**
* Construct a `WDCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
declare function wdcm_args(ra: number, rb: number, rc: number, args: CompareArgs): Instruction;
/**
* Construct a `WQCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
declare function wqcm_args(ra: number, rb: number, rc: number, args: CompareArgs): Instruction;
/**
* Construct a `WDOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
declare function wdop_args(ra: number, rb: number, rc: number, args: MathArgs): Instruction;
/**
* Construct a `WQOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
declare function wqop_args(ra: number, rb: number, rc: number, args: MathArgs): Instruction;
/**
* Construct a `WDML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
declare function wdml_args(ra: number, rb: number, rc: number, args: MulArgs): Instruction;
/**
* Construct a `WQML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
declare function wqml_args(ra: number, rb: number, rc: number, args: MulArgs): Instruction;
/**
* Construct a `WDDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
declare function wddv_args(ra: number, rb: number, rc: number, args: DivArgs): Instruction;
/**
* Construct a `WQDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
declare function wqdv_args(ra: number, rb: number, rc: number, args: DivArgs): Instruction;
/**
*r" Argument list for GM (get metadata) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
declare enum GMArgs {
/**
*r" Get if caller is external.
*/
  IsCallerExternal = 1,
/**
*r" Get caller's contract ID.
*/
  GetCaller = 2,
/**
*r" Get index of current predicate.
*/
  GetVerifyingPredicate = 3,
/**
*r" Get the Chain ID this VM is operating within
*/
  GetChainId = 4,
}
/**
*r" Argument list for GTF (get tx fields) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
declare enum GTFArgs {
/**
*r" Set `$rA` to `tx.type`
*/
  Type = 1,
/**
*r" Set `$rA` to `tx.scriptGasLimit`
*/
  ScriptGasLimit = 2,
/**
*r" Set `$rA` to `tx.scriptLength`
*/
  ScriptLength = 3,
/**
*r" Set `$rA` to `tx.scriptDataLength`
*/
  ScriptDataLength = 4,
/**
*r" Set `$rA` to `tx.inputsCount`
*/
  ScriptInputsCount = 5,
/**
*r" Set `$rA` to `tx.outputsCount`
*/
  ScriptOutputsCount = 6,
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
  ScriptWitnessesCount = 7,
/**
*r" Set `$rA` to `Memory address of tx.receiptsRoot`
*/
  ScriptReceiptsRoot = 8,
/**
*r" Set `$rA` to `Memory address of tx.script`
*/
  Script = 9,
/**
*r" Set `$rA` to `Memory address of tx.scriptData`
*/
  ScriptData = 10,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
  ScriptInputAtIndex = 11,
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
  ScriptOutputAtIndex = 12,
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
  ScriptWitnessAtIndex = 13,
/**
*r" Set `$rA` to `tx.bytecodeLength`
*/
  CreateBytecodeLength = 256,
/**
*r" Set `$rA` to `tx.bytecodeWitnessIndex`
*/
  CreateBytecodeWitnessIndex = 257,
/**
*r" Set `$rA` to `tx.storageSlotsCount`
*/
  CreateStorageSlotsCount = 258,
/**
*r" Set `$rA` to `tx.inputsCount`
*/
  CreateInputsCount = 259,
/**
*r" Set `$rA` to `tx.outputsCount`
*/
  CreateOutputsCount = 260,
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
  CreateWitnessesCount = 261,
/**
*r" Set `$rA` to `Memory address of tx.salt`
*/
  CreateSalt = 262,
/**
*r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
*/
  CreateStorageSlotAtIndex = 263,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
  CreateInputAtIndex = 264,
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
  CreateOutputAtIndex = 265,
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
  CreateWitnessAtIndex = 266,
/**
*r" Set `$rA` to `tx.inputs[$rB].type`
*/
  InputType = 512,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
  InputCoinTxId = 513,
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
  InputCoinOutputIndex = 514,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
*/
  InputCoinOwner = 515,
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
  InputCoinAmount = 516,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
*/
  InputCoinAssetId = 517,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
*/
  InputCoinTxPointer = 518,
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
  InputCoinWitnessIndex = 519,
/**
*r" Set `$rA` to `tx.inputs[$rB].maturity`
*/
  InputCoinMaturity = 520,
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
  InputCoinPredicateLength = 521,
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
  InputCoinPredicateDataLength = 522,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
  InputCoinPredicate = 523,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
  InputCoinPredicateData = 524,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
  InputCoinPredicateGasUsed = 525,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
  InputContractTxId = 544,
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
  InputContractOutputIndex = 545,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].balanceRoot`
*/
  InputContractBalanceRoot = 546,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].stateRoot`
*/
  InputContractStateRoot = 547,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
*/
  InputContractTxPointer = 548,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
*/
  InputContractId = 549,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
*/
  InputMessageSender = 576,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
*/
  InputMessageRecipient = 577,
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
  InputMessageAmount = 578,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
*/
  InputMessageNonce = 579,
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
  InputMessageWitnessIndex = 580,
/**
*r" Set `$rA` to `tx.inputs[$rB].dataLength`
*/
  InputMessageDataLength = 581,
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
  InputMessagePredicateLength = 582,
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
  InputMessagePredicateDataLength = 583,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
*/
  InputMessageData = 584,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
  InputMessagePredicate = 585,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
  InputMessagePredicateData = 586,
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
  InputMessagePredicateGasUsed = 587,
/**
*r" Set `$rA` to `tx.outputs[$rB].type`
*/
  OutputType = 768,
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
*/
  OutputCoinTo = 769,
/**
*r" Set `$rA` to `tx.outputs[$rB].amount`
*/
  OutputCoinAmount = 770,
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
*/
  OutputCoinAssetId = 771,
/**
*r" Set `$rA` to `tx.outputs[$rB].inputIndex`
*/
  OutputContractInputIndex = 772,
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].balanceRoot`
*/
  OutputContractBalanceRoot = 773,
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
*/
  OutputContractStateRoot = 774,
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
*/
  OutputContractCreatedContractId = 775,
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
*/
  OutputContractCreatedStateRoot = 776,
/**
*r" Set `$rA` to `tx.witnesses[$rB].dataLength`
*/
  WitnessDataLength = 1024,
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
*/
  WitnessData = 1025,
/**
*r" Set `$rA` to `tx.policyTypes`
*/
  PolicyTypes = 1280,
/**
*r" Set `$rA` to `tx.policies[0x00].gasPrice`
*/
  PolicyGasPrice = 1281,
/**
*r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
*/
  PolicyWitnessLimit = 1282,
/**
*r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
*/
  PolicyMaturity = 1283,
/**
*r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
*/
  PolicyMaxFee = 1284,
}
/**
* Comparison mode used by WDCM and WQCM instructions.
*/
declare enum CompareMode {
/**
* Equality (`==`)
*/
  EQ = 0,
/**
* Inequality (`!=`)
*/
  NE = 1,
/**
* Less than (`<`)
*/
  LT = 2,
/**
* Greater than (`>`)
*/
  GT = 3,
/**
* Less than or equals (`>=`)
*/
  LTE = 4,
/**
* Greater than or equals (`>=`)
*/
  GTE = 5,
/**
* Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
*/
  LZC = 6,
}
/**
*r" Panic reason representation for the interpreter.
*/
declare enum PanicReason {
/**
*r" The byte can't be mapped to any known `PanicReason`.
*/
  UnknownPanicReason = 0,
/**
*r" Found `RVRT` instruction.
*/
  Revert = 1,
/**
*r" Execution ran out of gas.
*/
  OutOfGas = 2,
/**
*r" The transaction validity is violated.
*/
  TransactionValidity = 3,
/**
*r" Attempt to write outside interpreter memory boundaries.
*/
  MemoryOverflow = 4,
/**
*r" Overflow while executing arithmetic operation.
*r" These errors are ignored using the WRAPPING flag.
*/
  ArithmeticOverflow = 5,
/**
*r" Designed contract was not found in the storage.
*/
  ContractNotFound = 6,
/**
*r" Memory ownership rules are violated.
*/
  MemoryOwnership = 7,
/**
*r" The asset ID balance isn't enough for the instruction.
*/
  NotEnoughBalance = 8,
/**
*r" The interpreter is expected to be in internal context.
*/
  ExpectedInternalContext = 9,
/**
*r" The queried asset ID was not found in the state.
*/
  AssetIdNotFound = 10,
/**
*r" The provided input is not found in the transaction.
*/
  InputNotFound = 11,
/**
*r" The provided output is not found in the transaction.
*/
  OutputNotFound = 12,
/**
*r" The provided witness is not found in the transaction.
*/
  WitnessNotFound = 13,
/**
*r" The transaction maturity is not valid for this request.
*/
  TransactionMaturity = 14,
/**
*r" The metadata identifier is invalid.
*/
  InvalidMetadataIdentifier = 15,
/**
*r" The call structure is not valid.
*/
  MalformedCallStructure = 16,
/**
*r" The provided register does not allow write operations.
*/
  ReservedRegisterNotWritable = 17,
/**
*r" The execution resulted in an erroneous state of the interpreter.
*/
  InvalidFlags = 18,
/**
*r" The provided immediate value is not valid for this instruction.
*/
  InvalidImmediateValue = 19,
/**
*r" The provided transaction input is not of type `Coin`.
*/
  ExpectedCoinInput = 20,
/**
*r" `ECAL` instruction failed.
*/
  EcalError = 21,
/**
*r" Two segments of the interpreter memory should not intersect for write operations.
*/
  MemoryWriteOverlap = 22,
/**
*r" The requested contract is not listed in the transaction inputs.
*/
  ContractNotInInputs = 23,
/**
*r" The internal asset ID balance overflowed with the provided instruction.
*/
  InternalBalanceOverflow = 24,
/**
*r" The maximum allowed contract size is violated.
*/
  ContractMaxSize = 25,
/**
*r" This instruction expects the stack area to be unallocated for this call.
*/
  ExpectedUnallocatedStack = 26,
/**
*r" The maximum allowed number of static contracts was reached for this transaction.
*/
  MaxStaticContractsReached = 27,
/**
*r" The requested transfer amount cannot be zero.
*/
  TransferAmountCannotBeZero = 28,
/**
*r" The provided transaction output should be of type `Variable`.
*/
  ExpectedOutputVariable = 29,
/**
*r" The expected context of the stack parent is internal.
*/
  ExpectedParentInternalContext = 30,
/**
*r" The predicate returned non `1`. The `1` means successful verification
*r" of the predicate, all other values means unsuccessful.
*/
  PredicateReturnedNonOne = 31,
/**
*r" The contract ID is already deployed and can't be overwritten.
*/
  ContractIdAlreadyDeployed = 32,
/**
*r" The loaded contract mismatch expectations.
*/
  ContractMismatch = 33,
/**
*r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
*/
  MessageDataTooLong = 34,
/**
*r" Mathematically invalid arguments where given to an arithmetic instruction.
*r" For instance, division by zero produces this.
*r" These errors are ignored using the UNSAFEMATH flag.
*/
  ArithmeticError = 35,
/**
*r" The contract instruction is not allowed in predicates.
*/
  ContractInstructionNotAllowed = 36,
/**
*r" Transfer of zero coins is not allowed.
*/
  TransferZeroCoins = 37,
/**
*r" Attempted to execute an invalid instruction
*/
  InvalidInstruction = 38,
/**
*r" Memory outside $is..$ssp range is not executable
*/
  MemoryNotExecutable = 39,
/**
*r" The policy is not set.
*/
  PolicyIsNotSet = 40,
/**
*r" The policy is not found across policies.
*/
  PolicyNotFound = 41,
/**
*r" Receipt context is full
*/
  TooManyReceipts = 42,
/**
*r" Balance of a contract overflowed
*/
  BalanceOverflow = 43,
/**
*r" Block height value is invalid, typically because it is too large
*/
  InvalidBlockHeight = 44,
/**
*r" Attempt to use sequential memory instructions with too large slot count,
*r" typically because it cannot fit into usize
*/
  TooManySlots = 45,
}
/**
* The operation performed by WDOP and WQOP instructions, determined as
*/
declare enum MathOp {
/**
* Add
*/
  ADD = 0,
/**
* Subtract
*/
  SUB = 1,
/**
* Invert bits (discards rhs)
*/
  NOT = 2,
/**
* Bitwise or
*/
  OR = 3,
/**
* Bitwise exclusive or
*/
  XOR = 4,
/**
* Bitwise and
*/
  AND = 5,
/**
* Shift left
*/
  SHL = 6,
/**
* Shift right
*/
  SHR = 7,
}
/**
*Adds two registers.
*/
declare class ADD {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Adds a register and an immediate value.
*/
declare class ADDI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Allocate a number of bytes from the heap.
*/
declare class ALOC {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} bytes
*/
  constructor(bytes: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
*Bitwise ANDs two registers.
*/
declare class AND {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Bitwise ANDs a register and an immediate value.
*/
declare class ANDI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Get the balance of contract of an asset ID.
*/
declare class BAL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} asset_id_addr
* @param {RegId} contract_id_addr
*/
  constructor(dst: RegId, asset_id_addr: RegId, contract_id_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Get current block height.
*/
declare class BHEI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
*/
  constructor(dst: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
*Get block header hash for height.
*/
declare class BHSH {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} heigth
*/
  constructor(dst: RegId, heigth: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
declare class BURN {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} amount
* @param {RegId} sub_id_addr
*/
  constructor(amount: RegId, sub_id_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Call a contract.
*/
declare class CALL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} target_struct
* @param {RegId} fwd_coins
* @param {RegId} asset_id_addr
* @param {RegId} fwd_gas
*/
  constructor(target_struct: RegId, fwd_coins: RegId, asset_id_addr: RegId, fwd_gas: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Get current block proposer's address.
*/
declare class CB {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
*/
  constructor(dst: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
*Copy contract code for a contract.
*/
declare class CCP {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} contract_id_addr
* @param {RegId} offset
* @param {RegId} len
*/
  constructor(dst_addr: RegId, contract_id_addr: RegId, offset: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Extend the current call frame's stack
*/
declare class CFE {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} amount
*/
  constructor(amount: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
*Extend the current call frame's stack by an immediate value.
*/
declare class CFEI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {Imm24} amount
*/
  constructor(amount: Imm24);
/**
* Access the 24-bit immediate value.
* @returns {Imm24}
*/
  imm24(): Imm24;
}
/**
*Shrink the current call frame's stack
*/
declare class CFS {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} amount
*/
  constructor(amount: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
*Shrink the current call frame's stack by an immediate value.
*/
declare class CFSI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {Imm24} amount
*/
  constructor(amount: Imm24);
/**
* Access the 24-bit immediate value.
* @returns {Imm24}
*/
  imm24(): Imm24;
}
/**
*Get code root of a contract.
*/
declare class CROO {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} contract_id_addr
*/
  constructor(dst_addr: RegId, contract_id_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Get code size of a contract.
*/
declare class CSIZ {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} contract_id_addr
*/
  constructor(dst: RegId, contract_id_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
* Arguments for WDCM and WQCM instructions.
*/
declare class CompareArgs {
  free(): void;
/**
* Convert to immediate value.
* @returns {Imm06}
*/
  to_imm(): Imm06;
/**
* Construct from `Imm06`. Returns `None` if the value has reserved flags set.
* @param {Imm06} bits
* @returns {CompareArgs | undefined}
*/
  static from_imm(bits: Imm06): CompareArgs | undefined;
/**
* Load RHS from register if true, otherwise zero-extend register value
*/
  indirect_rhs: boolean;
/**
* Comparison mode
*/
  mode: CompareMode;
}
/**
*Divides two registers.
*/
declare class DIV {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Divides a register and an immediate value.
*/
declare class DIVI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
* Additional arguments for WMDV and WDDV instructions.
*/
declare class DivArgs {
  free(): void;
/**
* Load RHS from register if true, otherwise zero-extend register value
*/
  indirect_rhs: boolean;
}
/**
*Call external function
*/
declare class ECAL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} a
* @param {RegId} b
* @param {RegId} c
* @param {RegId} d
*/
  constructor(a: RegId, b: RegId, c: RegId, d: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message.
*/
declare class ECK1 {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} sig_addr
* @param {RegId} msg_hash_addr
*/
  constructor(dst_addr: RegId, sig_addr: RegId, msg_hash_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message.
*/
declare class ECR1 {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} sig_addr
* @param {RegId} msg_hash_addr
*/
  constructor(dst_addr: RegId, sig_addr: RegId, msg_hash_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Verify ED25519 public key and signature match a 32-byte message.
*/
declare class ED19 {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} pub_key_addr
* @param {RegId} sig_addr
* @param {RegId} msg_hash_addr
*/
  constructor(pub_key_addr: RegId, sig_addr: RegId, msg_hash_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Compares two registers for equality.
*/
declare class EQ {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Raises one register to the power of another.
*/
declare class EXP {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Raises one register to the power of an immediate value.
*/
declare class EXPI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Set flag register to a register.
*/
declare class FLAG {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} value
*/
  constructor(value: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
*Get metadata from memory.
*/
declare class GM {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {Imm18} selector
*/
  constructor(dst: RegId, selector: Imm18);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the 18-bit immediate value.
* @returns {Imm18}
*/
  imm18(): Imm18;
/**
* Construct a `GM` instruction from its arguments.
* @param {RegId} ra
* @param {GMArgs} args
* @returns {GM}
*/
  static from_args(ra: RegId, args: GMArgs): GM;
}
/**
*Compares two registers for greater-than.
*/
declare class GT {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Get transaction fields.
*/
declare class GTF {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} arg
* @param {Imm12} selector
*/
  constructor(dst: RegId, arg: RegId, selector: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
/**
* Construct a `GTF` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {GTFArgs} args
* @returns {GTF}
*/
  static from_args(ra: RegId, rb: RegId, args: GTFArgs): GTF;
}
/**
* Represents a 6-bit immediate value, guaranteed to be masked by construction.
*/
declare class Imm06 {
  free(): void;
}
/**
* Represents a 12-bit immediate value, guaranteed to be masked by construction.
*/
declare class Imm12 {
  free(): void;
}
/**
* Represents a 18-bit immediate value, guaranteed to be masked by construction.
*/
declare class Imm18 {
  free(): void;
}
/**
* Represents a 24-bit immediate value, guaranteed to be masked by construction.
*/
declare class Imm24 {
  free(): void;
}
/**
* Representation of a single instruction for the interpreter.
*
* The opcode is represented in the tag (variant), or may be retrieved in the
* form of an `Opcode` byte using the `opcode` method.
*
* The register and immediate data associated with the instruction is represented
* within an inner unit type wrapper around the 3 remaining bytes.
*/
declare class Instruction {
  free(): void;
/**
* Convenience method for converting to bytes
* @returns {Uint8Array}
*/
  to_bytes(): Uint8Array;
/**
* Size of an instruction in bytes
* @returns {number}
*/
  static size(): number;
}
/**
*Jump.
*/
declare class JI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {Imm24} abs_target
*/
  constructor(abs_target: Imm24);
/**
* Access the 24-bit immediate value.
* @returns {Imm24}
*/
  imm24(): Imm24;
}
/**
*Dynamic jump.
*/
declare class JMP {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} abs_target
*/
  constructor(abs_target: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
*Unconditional dynamic relative jump backwards, with a constant offset.
*/
declare class JMPB {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dynamic
* @param {Imm18} fixed
*/
  constructor(dynamic: RegId, fixed: Imm18);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the 18-bit immediate value.
* @returns {Imm18}
*/
  imm18(): Imm18;
}
/**
*Unconditional dynamic relative jump forwards, with a constant offset.
*/
declare class JMPF {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dynamic
* @param {Imm18} fixed
*/
  constructor(dynamic: RegId, fixed: Imm18);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the 18-bit immediate value.
* @returns {Imm18}
*/
  imm18(): Imm18;
}
/**
*Conditional dynamic jump.
*/
declare class JNE {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} abs_target
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(abs_target: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
*/
declare class JNEB {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} cond_lhs
* @param {RegId} cond_rhs
* @param {RegId} dynamic
* @param {Imm06} fixed
*/
  constructor(cond_lhs: RegId, cond_rhs: RegId, dynamic: RegId, fixed: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
}
/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
*/
declare class JNEF {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} cond_lhs
* @param {RegId} cond_rhs
* @param {RegId} dynamic
* @param {Imm06} fixed
*/
  constructor(cond_lhs: RegId, cond_rhs: RegId, dynamic: RegId, fixed: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
}
/**
*Conditional jump.
*/
declare class JNEI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} cond_lhs
* @param {RegId} cond_rhs
* @param {Imm12} abs_target
*/
  constructor(cond_lhs: RegId, cond_rhs: RegId, abs_target: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
*/
declare class JNZB {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} cond_nz
* @param {RegId} dynamic
* @param {Imm12} fixed
*/
  constructor(cond_nz: RegId, dynamic: RegId, fixed: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
*/
declare class JNZF {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} cond_nz
* @param {RegId} dynamic
* @param {Imm12} fixed
*/
  constructor(cond_nz: RegId, dynamic: RegId, fixed: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Conditional jump against zero.
*/
declare class JNZI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} cond_nz
* @param {Imm18} abs_target
*/
  constructor(cond_nz: RegId, abs_target: Imm18);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the 18-bit immediate value.
* @returns {Imm18}
*/
  imm18(): Imm18;
}
/**
*The keccak-256 hash of a slice.
*/
declare class K256 {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} src_addr
* @param {RegId} len
*/
  constructor(dst_addr: RegId, src_addr: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*A byte is loaded from the specified address offset by an immediate value.
*/
declare class LB {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} addr
* @param {Imm12} offset
*/
  constructor(dst: RegId, addr: RegId, offset: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Load a contract's code as executable.
*/
declare class LDC {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} contract_id_addr
* @param {RegId} offset
* @param {RegId} len
*/
  constructor(contract_id_addr: RegId, offset: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Log an event.
*/
declare class LOG {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} a
* @param {RegId} b
* @param {RegId} c
* @param {RegId} d
*/
  constructor(a: RegId, b: RegId, c: RegId, d: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Log data.
*/
declare class LOGD {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} a
* @param {RegId} b
* @param {RegId} addr
* @param {RegId} len
*/
  constructor(a: RegId, b: RegId, addr: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Compares two registers for less-than.
*/
declare class LT {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*A word is loaded from the specified address offset by an immediate value.
*/
declare class LW {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} addr
* @param {Imm12} offset
*/
  constructor(dst: RegId, addr: RegId, offset: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Clear a variable number of bytes in memory.
*/
declare class MCL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} len
*/
  constructor(dst_addr: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Clear an immediate number of bytes in memory.
*/
declare class MCLI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} addr
* @param {Imm18} count
*/
  constructor(addr: RegId, count: Imm18);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the 18-bit immediate value.
* @returns {Imm18}
*/
  imm18(): Imm18;
}
/**
*Copy a variable number of bytes in memory.
*/
declare class MCP {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} src_addr
* @param {RegId} len
*/
  constructor(dst_addr: RegId, src_addr: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Copy an immediate number of bytes in memory.
*/
declare class MCPI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} src_addr
* @param {Imm12} len
*/
  constructor(dst_addr: RegId, src_addr: RegId, len: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Compare bytes in memory.
*/
declare class MEQ {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} result
* @param {RegId} lhs_addr
* @param {RegId} rhs_addr
* @param {RegId} len
*/
  constructor(result: RegId, lhs_addr: RegId, rhs_addr: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
declare class MINT {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} amount
* @param {RegId} sub_id_addr
*/
  constructor(amount: RegId, sub_id_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Fused multiply-divide with arbitrary precision intermediate step.
*/
declare class MLDV {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} mul_lhs
* @param {RegId} mul_rhs
* @param {RegId} divisor
*/
  constructor(dst: RegId, mul_lhs: RegId, mul_rhs: RegId, divisor: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*The integer logarithm of a register.
*/
declare class MLOG {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Modulo remainder of two registers.
*/
declare class MOD {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Modulo remainder of a register and an immediate value.
*/
declare class MODI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Copy from one register to another.
*/
declare class MOVE {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} src
*/
  constructor(dst: RegId, src: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Copy immediate value into a register
*/
declare class MOVI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {Imm18} val
*/
  constructor(dst: RegId, val: Imm18);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the 18-bit immediate value.
* @returns {Imm18}
*/
  imm18(): Imm18;
}
/**
*The integer root of a register.
*/
declare class MROO {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Multiplies two registers.
*/
declare class MUL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Multiplies a register and an immediate value.
*/
declare class MULI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
* Additional arguments for WDOP and WQOP instructions.
*/
declare class MathArgs {
  free(): void;
/**
* Load RHS from register if true, otherwise zero-extend register value
*/
  indirect_rhs: boolean;
/**
* The operation to perform
*/
  op: MathOp;
}
/**
* Additional arguments for WDML and WQML instructions.
*/
declare class MulArgs {
  free(): void;
/**
* Load LHSS from register if true, otherwise zero-extend register value
*/
  indirect_lhs: boolean;
/**
* Load RHS from register if true, otherwise zero-extend register value
*/
  indirect_rhs: boolean;
}
/**
*Performs no operation.
*/
declare class NOOP {
  free(): void;
/**
* Construct the instruction.
*/
  constructor();
}
/**
*Bitwise NOT a register.
*/
declare class NOT {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} arg
*/
  constructor(dst: RegId, arg: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Bitwise ORs two registers.
*/
declare class OR {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Bitwise ORs a register and an immediate value.
*/
declare class ORI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
*/
declare class POPH {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {Imm24} bitmask
*/
  constructor(bitmask: Imm24);
/**
* Access the 24-bit immediate value.
* @returns {Imm24}
*/
  imm24(): Imm24;
}
/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
*/
declare class POPL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {Imm24} bitmask
*/
  constructor(bitmask: Imm24);
/**
* Access the 24-bit immediate value.
* @returns {Imm24}
*/
  imm24(): Imm24;
}
/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
*/
declare class PSHH {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {Imm24} bitmask
*/
  constructor(bitmask: Imm24);
/**
* Access the 24-bit immediate value.
* @returns {Imm24}
*/
  imm24(): Imm24;
}
/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
*/
declare class PSHL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {Imm24} bitmask
*/
  constructor(bitmask: Imm24);
/**
* Access the 24-bit immediate value.
* @returns {Imm24}
*/
  imm24(): Imm24;
}
/**
* Describe a panic reason with the instruction that generated it
*/
declare class PanicInstruction {
  free(): void;
/**
* Represents an error described by a reason and an instruction.
* @param {PanicReason} reason
* @param {number} instruction
*/
  constructor(reason: PanicReason, instruction: number);
/**
* Underlying panic reason
* @returns {PanicReason}
*/
  reason(): PanicReason;
/**
* Underlying instruction
* @returns {number}
*/
  instruction(): number;
}
/**
*Return from context.
*/
declare class RET {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} value
*/
  constructor(value: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
*Return from context with data.
*/
declare class RETD {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} addr
* @param {RegId} len
*/
  constructor(addr: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Halt execution, reverting state changes and returning a value.
*/
declare class RVRT {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} value
*/
  constructor(value: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
}
/**
* Represents a 6-bit register ID, guaranteed to be masked by construction.
*/
declare class RegId {
  free(): void;
/**
* Construct a register ID from the given value.
*
* Returns `None` if the value is outside the 6-bit value range.
* @param {number} u
* @returns {RegId | undefined}
*/
  static new_checked(u: number): RegId | undefined;
/**
* Received balance for this context.
* @returns {RegId}
*/
  static bal(): RegId;
/**
* Remaining gas in the context.
* @returns {RegId}
*/
  static cgas(): RegId;
/**
* Error codes for particular operations.
* @returns {RegId}
*/
  static err(): RegId;
/**
* Flags register.
* @returns {RegId}
*/
  static flag(): RegId;
/**
* Frame pointer. Memory address of beginning of current call frame.
* @returns {RegId}
*/
  static fp(): RegId;
/**
* Remaining gas globally.
* @returns {RegId}
*/
  static ggas(): RegId;
/**
* Heap pointer. Memory address below the current bottom of the heap (points to free
* memory).
* @returns {RegId}
*/
  static hp(): RegId;
/**
* Instructions start. Pointer to the start of the currently-executing code.
* @returns {RegId}
*/
  static is(): RegId;
/**
* Contains overflow/underflow of addition, subtraction, and multiplication.
* @returns {RegId}
*/
  static of(): RegId;
/**
* Contains one (1), for convenience.
* @returns {RegId}
*/
  static one(): RegId;
/**
* The program counter. Memory address of the current instruction.
* @returns {RegId}
*/
  static pc(): RegId;
/**
* Return value or pointer.
* @returns {RegId}
*/
  static ret(): RegId;
/**
* Return value length in bytes.
* @returns {RegId}
*/
  static retl(): RegId;
/**
* Stack pointer. Memory address on top of current writable stack area (points to
* free memory).
* @returns {RegId}
*/
  static sp(): RegId;
/**
* Stack start pointer. Memory address of bottom of current writable stack area.
* @returns {RegId}
*/
  static spp(): RegId;
/**
* Smallest writable register.
* @returns {RegId}
*/
  static writable(): RegId;
/**
* Contains zero (0), for convenience.
* @returns {RegId}
*/
  static zero(): RegId;
/**
* Construct a register ID from the given value.
*
* The given value will be masked to 6 bits.
* @param {number} u
*/
  constructor(u: number);
/**
* A const alternative to the `Into<u8>` implementation.
* @returns {number}
*/
  to_u8(): number;
}
/**
*The SHA-2-256 hash of a slice.
*/
declare class S256 {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} src_addr
* @param {RegId} len
*/
  constructor(dst_addr: RegId, src_addr: RegId, len: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Write the least significant byte of a register to memory.
*/
declare class SB {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} addr
* @param {RegId} value
* @param {Imm12} offset
*/
  constructor(addr: RegId, value: RegId, offset: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Clear a series of slots from contract storage.
*/
declare class SCWQ {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} key_addr
* @param {RegId} status
* @param {RegId} lenq
*/
  constructor(key_addr: RegId, status: RegId, lenq: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Left shifts a register by a register.
*/
declare class SLL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Left shifts a register by an immediate value.
*/
declare class SLLI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Send a message to recipient address with call abi, coins, and output.
*/
declare class SMO {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} recipient_addr
* @param {RegId} data_addr
* @param {RegId} data_len
* @param {RegId} coins
*/
  constructor(recipient_addr: RegId, data_addr: RegId, data_len: RegId, coins: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Right shifts a register by a register.
*/
declare class SRL {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Right shifts a register by an immediate value.
*/
declare class SRLI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Load a word from contract storage.
*/
declare class SRW {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} status
* @param {RegId} key_addr
*/
  constructor(dst: RegId, status: RegId, key_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Load a series of 32 byte slots from contract storage.
*/
declare class SRWQ {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst_addr
* @param {RegId} status
* @param {RegId} key_addr
* @param {RegId} lenq
*/
  constructor(dst_addr: RegId, status: RegId, key_addr: RegId, lenq: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Subtracts two registers.
*/
declare class SUB {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Subtracts a register and an immediate value.
*/
declare class SUBI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Write a register to memory.
*/
declare class SW {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} addr
* @param {RegId} value
* @param {Imm12} offset
*/
  constructor(addr: RegId, value: RegId, offset: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}
/**
*Store a word in contract storage.
*/
declare class SWW {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} key_addr
* @param {RegId} status
* @param {RegId} value
*/
  constructor(key_addr: RegId, status: RegId, value: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Store a series of 32 byte slots in contract storage.
*/
declare class SWWQ {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} key_addr
* @param {RegId} status
* @param {RegId} src_addr
* @param {RegId} lenq
*/
  constructor(key_addr: RegId, status: RegId, src_addr: RegId, lenq: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Get timestamp of block at given height.
*/
declare class TIME {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} heigth
*/
  constructor(dst: RegId, heigth: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
}
/**
*Transfer coins to a contract unconditionally.
*/
declare class TR {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} contract_id_addr
* @param {RegId} amount
* @param {RegId} asset_id_addr
*/
  constructor(contract_id_addr: RegId, amount: RegId, asset_id_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Transfer coins to a variable output.
*/
declare class TRO {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} contract_id_addr
* @param {RegId} output_index
* @param {RegId} amount
* @param {RegId} asset_id_addr
*/
  constructor(contract_id_addr: RegId, output_index: RegId, amount: RegId, asset_id_addr: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*AddMod 128bit
*/
declare class WDAM {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} add_lhs
* @param {RegId} add_rhs
* @param {RegId} modulo
*/
  constructor(dst: RegId, add_lhs: RegId, add_rhs: RegId, modulo: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Compare 128bit integers
*/
declare class WDCM {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
* @param {Imm06} flags
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId, flags: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
/**
* Construct a `WDCM` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {RegId} rc
* @param {CompareArgs} args
* @returns {WDCM}
*/
  static from_args(ra: RegId, rb: RegId, rc: RegId, args: CompareArgs): WDCM;
}
/**
*Divide 128bit
*/
declare class WDDV {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
* @param {Imm06} flags
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId, flags: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
/**
* Construct a `WDDV` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {RegId} rc
* @param {DivArgs} args
* @returns {WDDV}
*/
  static from_args(ra: RegId, rb: RegId, rc: RegId, args: DivArgs): WDDV;
}
/**
*Fused multiply-divide 128bit
*/
declare class WDMD {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} mul_lhs
* @param {RegId} mul_rhs
* @param {RegId} divisor
*/
  constructor(dst: RegId, mul_lhs: RegId, mul_rhs: RegId, divisor: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Multiply 128bit
*/
declare class WDML {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
* @param {Imm06} flags
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId, flags: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
/**
* Construct a `WDML` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {RegId} rc
* @param {MulArgs} args
* @returns {WDML}
*/
  static from_args(ra: RegId, rb: RegId, rc: RegId, args: MulArgs): WDML;
}
/**
*MulMod 128bit
*/
declare class WDMM {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} mul_lhs
* @param {RegId} mul_rhs
* @param {RegId} modulo
*/
  constructor(dst: RegId, mul_lhs: RegId, mul_rhs: RegId, modulo: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Simple 128bit operations
*/
declare class WDOP {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
* @param {Imm06} flags
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId, flags: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
/**
* Construct a `WDOP` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {RegId} rc
* @param {MathArgs} args
* @returns {WDOP}
*/
  static from_args(ra: RegId, rb: RegId, rc: RegId, args: MathArgs): WDOP;
}
/**
*AddMod 256bit
*/
declare class WQAM {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} add_lhs
* @param {RegId} add_rhs
* @param {RegId} modulo
*/
  constructor(dst: RegId, add_lhs: RegId, add_rhs: RegId, modulo: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Compare 256bit integers
*/
declare class WQCM {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
* @param {Imm06} flags
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId, flags: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
/**
* Construct a `WQCM` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {RegId} rc
* @param {CompareArgs} args
* @returns {WQCM}
*/
  static from_args(ra: RegId, rb: RegId, rc: RegId, args: CompareArgs): WQCM;
}
/**
*Divide 256bit
*/
declare class WQDV {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
* @param {Imm06} flags
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId, flags: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
/**
* Construct a `WQDV` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {RegId} rc
* @param {DivArgs} args
* @returns {WQDV}
*/
  static from_args(ra: RegId, rb: RegId, rc: RegId, args: DivArgs): WQDV;
}
/**
*Fused multiply-divide 256bit
*/
declare class WQMD {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} mul_lhs
* @param {RegId} mul_rhs
* @param {RegId} divisor
*/
  constructor(dst: RegId, mul_lhs: RegId, mul_rhs: RegId, divisor: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Multiply 256bit
*/
declare class WQML {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
* @param {Imm06} flags
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId, flags: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
/**
* Construct a `WQML` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {RegId} rc
* @param {MulArgs} args
* @returns {WQML}
*/
  static from_args(ra: RegId, rb: RegId, rc: RegId, args: MulArgs): WQML;
}
/**
*MulMod 256bit
*/
declare class WQMM {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} mul_lhs
* @param {RegId} mul_rhs
* @param {RegId} modulo
*/
  constructor(dst: RegId, mul_lhs: RegId, mul_rhs: RegId, modulo: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the ID for register D.
* @returns {RegId}
*/
  rd(): RegId;
}
/**
*Simple 256bit operations
*/
declare class WQOP {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
* @param {Imm06} flags
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId, flags: Imm06);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
/**
* Access the 6-bit immediate value.
* @returns {Imm06}
*/
  imm06(): Imm06;
/**
* Construct a `WQOP` instruction from its arguments.
* @param {RegId} ra
* @param {RegId} rb
* @param {RegId} rc
* @param {MathArgs} args
* @returns {WQOP}
*/
  static from_args(ra: RegId, rb: RegId, rc: RegId, args: MathArgs): WQOP;
}
/**
*Bitwise XORs two registers.
*/
declare class XOR {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {RegId} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: RegId);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the ID for register C.
* @returns {RegId}
*/
  rc(): RegId;
}
/**
*Bitwise XORs a register and an immediate value.
*/
declare class XORI {
  free(): void;
/**
* Construct the instruction from its parts.
* @param {RegId} dst
* @param {RegId} lhs
* @param {Imm12} rhs
*/
  constructor(dst: RegId, lhs: RegId, rhs: Imm12);
/**
* Access the ID for register A.
* @returns {RegId}
*/
  ra(): RegId;
/**
* Access the ID for register B.
* @returns {RegId}
*/
  rb(): RegId;
/**
* Access the 12-bit immediate value.
* @returns {Imm12}
*/
  imm12(): Imm12;
}

type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly __wbg_add_free: (a: number) => void;
  readonly add_new_typescript: (a: number, b: number, c: number) => number;
  readonly add_ra: (a: number) => number;
  readonly add_rb: (a: number) => number;
  readonly add_rc: (a: number) => number;
  readonly add: (a: number, b: number, c: number) => number;
  readonly and: (a: number, b: number, c: number) => number;
  readonly div: (a: number, b: number, c: number) => number;
  readonly eq: (a: number, b: number, c: number) => number;
  readonly exp: (a: number, b: number, c: number) => number;
  readonly gt: (a: number, b: number, c: number) => number;
  readonly lt: (a: number, b: number, c: number) => number;
  readonly mlog: (a: number, b: number, c: number) => number;
  readonly mroo: (a: number, b: number, c: number) => number;
  readonly mod_: (a: number, b: number, c: number) => number;
  readonly move_: (a: number, b: number) => number;
  readonly mul: (a: number, b: number, c: number) => number;
  readonly not: (a: number, b: number) => number;
  readonly or: (a: number, b: number, c: number) => number;
  readonly sll: (a: number, b: number, c: number) => number;
  readonly srl: (a: number, b: number, c: number) => number;
  readonly sub: (a: number, b: number, c: number) => number;
  readonly xor: (a: number, b: number, c: number) => number;
  readonly mldv: (a: number, b: number, c: number, d: number) => number;
  readonly ret: (a: number) => number;
  readonly retd: (a: number, b: number) => number;
  readonly aloc_new_typescript: (a: number) => number;
  readonly aloc: (a: number) => number;
  readonly mcl: (a: number, b: number) => number;
  readonly mcp: (a: number, b: number, c: number) => number;
  readonly meq: (a: number, b: number, c: number, d: number) => number;
  readonly bhsh_new_typescript: (a: number, b: number) => number;
  readonly bhsh: (a: number, b: number) => number;
  readonly bhei: (a: number) => number;
  readonly burn: (a: number, b: number) => number;
  readonly call_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly call_rd: (a: number) => number;
  readonly call: (a: number, b: number, c: number, d: number) => number;
  readonly ccp: (a: number, b: number, c: number, d: number) => number;
  readonly croo: (a: number, b: number) => number;
  readonly csiz: (a: number, b: number) => number;
  readonly cb: (a: number) => number;
  readonly ldc: (a: number, b: number, c: number) => number;
  readonly log: (a: number, b: number, c: number, d: number) => number;
  readonly logd: (a: number, b: number, c: number, d: number) => number;
  readonly mint: (a: number, b: number) => number;
  readonly rvrt: (a: number) => number;
  readonly scwq: (a: number, b: number, c: number) => number;
  readonly srw: (a: number, b: number, c: number) => number;
  readonly srwq: (a: number, b: number, c: number, d: number) => number;
  readonly sww: (a: number, b: number, c: number) => number;
  readonly swwq: (a: number, b: number, c: number, d: number) => number;
  readonly tr: (a: number, b: number, c: number) => number;
  readonly tro: (a: number, b: number, c: number, d: number) => number;
  readonly eck1: (a: number, b: number, c: number) => number;
  readonly ecr1: (a: number, b: number, c: number) => number;
  readonly ed19: (a: number, b: number, c: number) => number;
  readonly k256: (a: number, b: number, c: number) => number;
  readonly s256: (a: number, b: number, c: number) => number;
  readonly time: (a: number, b: number) => number;
  readonly noop_new_typescript: () => number;
  readonly noop: () => number;
  readonly flag: (a: number) => number;
  readonly bal: (a: number, b: number, c: number) => number;
  readonly jmp: (a: number) => number;
  readonly jne: (a: number, b: number, c: number) => number;
  readonly smo: (a: number, b: number, c: number, d: number) => number;
  readonly addi_new_typescript: (a: number, b: number, c: number) => number;
  readonly addi_imm12: (a: number) => number;
  readonly addi: (a: number, b: number, c: number) => number;
  readonly andi: (a: number, b: number, c: number) => number;
  readonly divi: (a: number, b: number, c: number) => number;
  readonly expi: (a: number, b: number, c: number) => number;
  readonly modi: (a: number, b: number, c: number) => number;
  readonly muli: (a: number, b: number, c: number) => number;
  readonly ori: (a: number, b: number, c: number) => number;
  readonly slli: (a: number, b: number, c: number) => number;
  readonly srli: (a: number, b: number, c: number) => number;
  readonly subi: (a: number, b: number, c: number) => number;
  readonly xori: (a: number, b: number, c: number) => number;
  readonly jnei: (a: number, b: number, c: number) => number;
  readonly lb: (a: number, b: number, c: number) => number;
  readonly lw: (a: number, b: number, c: number) => number;
  readonly sb: (a: number, b: number, c: number) => number;
  readonly sw: (a: number, b: number, c: number) => number;
  readonly mcpi: (a: number, b: number, c: number) => number;
  readonly gtf: (a: number, b: number, c: number) => number;
  readonly mcli: (a: number, b: number) => number;
  readonly gm_new_typescript: (a: number, b: number) => number;
  readonly gm_imm18: (a: number) => number;
  readonly gm: (a: number, b: number) => number;
  readonly movi: (a: number, b: number) => number;
  readonly jnzi: (a: number, b: number) => number;
  readonly jmpf: (a: number, b: number) => number;
  readonly jmpb: (a: number, b: number) => number;
  readonly jnzf: (a: number, b: number, c: number) => number;
  readonly jnzb: (a: number, b: number, c: number) => number;
  readonly jnef: (a: number, b: number, c: number, d: number) => number;
  readonly jneb: (a: number, b: number, c: number, d: number) => number;
  readonly ji: (a: number) => number;
  readonly cfei_new_typescript: (a: number) => number;
  readonly cfei_imm24: (a: number) => number;
  readonly cfei: (a: number) => number;
  readonly cfsi: (a: number) => number;
  readonly cfe: (a: number) => number;
  readonly cfs: (a: number) => number;
  readonly pshl: (a: number) => number;
  readonly pshh: (a: number) => number;
  readonly popl: (a: number) => number;
  readonly poph: (a: number) => number;
  readonly wdcm: (a: number, b: number, c: number, d: number) => number;
  readonly wqcm: (a: number, b: number, c: number, d: number) => number;
  readonly wdop: (a: number, b: number, c: number, d: number) => number;
  readonly wqop: (a: number, b: number, c: number, d: number) => number;
  readonly wdml: (a: number, b: number, c: number, d: number) => number;
  readonly wqml: (a: number, b: number, c: number, d: number) => number;
  readonly wddv: (a: number, b: number, c: number, d: number) => number;
  readonly wqdv: (a: number, b: number, c: number, d: number) => number;
  readonly wdmd: (a: number, b: number, c: number, d: number) => number;
  readonly wqmd: (a: number, b: number, c: number, d: number) => number;
  readonly wdam: (a: number, b: number, c: number, d: number) => number;
  readonly wqam: (a: number, b: number, c: number, d: number) => number;
  readonly wdmm: (a: number, b: number, c: number, d: number) => number;
  readonly wqmm: (a: number, b: number, c: number, d: number) => number;
  readonly ecal: (a: number, b: number, c: number, d: number) => number;
  readonly andi_new_typescript: (a: number, b: number, c: number) => number;
  readonly divi_new_typescript: (a: number, b: number, c: number) => number;
  readonly expi_new_typescript: (a: number, b: number, c: number) => number;
  readonly modi_new_typescript: (a: number, b: number, c: number) => number;
  readonly muli_new_typescript: (a: number, b: number, c: number) => number;
  readonly ori_new_typescript: (a: number, b: number, c: number) => number;
  readonly slli_new_typescript: (a: number, b: number, c: number) => number;
  readonly srli_new_typescript: (a: number, b: number, c: number) => number;
  readonly subi_new_typescript: (a: number, b: number, c: number) => number;
  readonly xori_new_typescript: (a: number, b: number, c: number) => number;
  readonly jnei_new_typescript: (a: number, b: number, c: number) => number;
  readonly lb_new_typescript: (a: number, b: number, c: number) => number;
  readonly lw_new_typescript: (a: number, b: number, c: number) => number;
  readonly sb_new_typescript: (a: number, b: number, c: number) => number;
  readonly sw_new_typescript: (a: number, b: number, c: number) => number;
  readonly mcpi_new_typescript: (a: number, b: number, c: number) => number;
  readonly gtf_new_typescript: (a: number, b: number, c: number) => number;
  readonly jnzf_new_typescript: (a: number, b: number, c: number) => number;
  readonly jnzb_new_typescript: (a: number, b: number, c: number) => number;
  readonly and_rc: (a: number) => number;
  readonly div_rc: (a: number) => number;
  readonly eq_rc: (a: number) => number;
  readonly exp_rc: (a: number) => number;
  readonly gt_rc: (a: number) => number;
  readonly lt_rc: (a: number) => number;
  readonly mlog_rc: (a: number) => number;
  readonly mroo_rc: (a: number) => number;
  readonly mod_rc: (a: number) => number;
  readonly mul_rc: (a: number) => number;
  readonly or_rc: (a: number) => number;
  readonly sll_rc: (a: number) => number;
  readonly srl_rc: (a: number) => number;
  readonly sub_rc: (a: number) => number;
  readonly xor_rc: (a: number) => number;
  readonly mldv_rc: (a: number) => number;
  readonly mcp_rc: (a: number) => number;
  readonly meq_rc: (a: number) => number;
  readonly call_rc: (a: number) => number;
  readonly ccp_rc: (a: number) => number;
  readonly ldc_rc: (a: number) => number;
  readonly log_rc: (a: number) => number;
  readonly logd_rc: (a: number) => number;
  readonly scwq_rc: (a: number) => number;
  readonly srw_rc: (a: number) => number;
  readonly srwq_rc: (a: number) => number;
  readonly sww_rc: (a: number) => number;
  readonly swwq_rc: (a: number) => number;
  readonly tr_rc: (a: number) => number;
  readonly tro_rc: (a: number) => number;
  readonly eck1_rc: (a: number) => number;
  readonly ecr1_rc: (a: number) => number;
  readonly ed19_rc: (a: number) => number;
  readonly k256_rc: (a: number) => number;
  readonly s256_rc: (a: number) => number;
  readonly bal_rc: (a: number) => number;
  readonly jne_rc: (a: number) => number;
  readonly smo_rc: (a: number) => number;
  readonly jnef_rc: (a: number) => number;
  readonly jneb_rc: (a: number) => number;
  readonly wdcm_rc: (a: number) => number;
  readonly wqcm_rc: (a: number) => number;
  readonly wdop_rc: (a: number) => number;
  readonly wqop_rc: (a: number) => number;
  readonly wdml_rc: (a: number) => number;
  readonly wqml_rc: (a: number) => number;
  readonly wddv_rc: (a: number) => number;
  readonly wqdv_rc: (a: number) => number;
  readonly wdmd_rc: (a: number) => number;
  readonly wqmd_rc: (a: number) => number;
  readonly wdam_rc: (a: number) => number;
  readonly wqam_rc: (a: number) => number;
  readonly wdmm_rc: (a: number) => number;
  readonly wqmm_rc: (a: number) => number;
  readonly ecal_rc: (a: number) => number;
  readonly mldv_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly meq_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly ccp_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly log_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly logd_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly srwq_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly swwq_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly tro_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly smo_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly jnef_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly jneb_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wdcm_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wqcm_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wdop_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wqop_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wdml_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wqml_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wddv_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wqdv_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wdmd_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wqmd_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wdam_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wqam_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wdmm_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly wqmm_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly ecal_new_typescript: (a: number, b: number, c: number, d: number) => number;
  readonly and_rb: (a: number) => number;
  readonly div_rb: (a: number) => number;
  readonly eq_rb: (a: number) => number;
  readonly exp_rb: (a: number) => number;
  readonly gt_rb: (a: number) => number;
  readonly lt_rb: (a: number) => number;
  readonly mlog_rb: (a: number) => number;
  readonly mroo_rb: (a: number) => number;
  readonly mod_rb: (a: number) => number;
  readonly move_rb: (a: number) => number;
  readonly mul_rb: (a: number) => number;
  readonly not_rb: (a: number) => number;
  readonly or_rb: (a: number) => number;
  readonly sll_rb: (a: number) => number;
  readonly srl_rb: (a: number) => number;
  readonly sub_rb: (a: number) => number;
  readonly xor_rb: (a: number) => number;
  readonly mldv_rb: (a: number) => number;
  readonly retd_rb: (a: number) => number;
  readonly mcl_rb: (a: number) => number;
  readonly mcp_rb: (a: number) => number;
  readonly meq_rb: (a: number) => number;
  readonly bhsh_rb: (a: number) => number;
  readonly burn_rb: (a: number) => number;
  readonly call_rb: (a: number) => number;
  readonly ccp_rb: (a: number) => number;
  readonly croo_rb: (a: number) => number;
  readonly csiz_rb: (a: number) => number;
  readonly ldc_rb: (a: number) => number;
  readonly log_rb: (a: number) => number;
  readonly logd_rb: (a: number) => number;
  readonly mint_rb: (a: number) => number;
  readonly scwq_rb: (a: number) => number;
  readonly srw_rb: (a: number) => number;
  readonly srwq_rb: (a: number) => number;
  readonly sww_rb: (a: number) => number;
  readonly swwq_rb: (a: number) => number;
  readonly tr_rb: (a: number) => number;
  readonly tro_rb: (a: number) => number;
  readonly eck1_rb: (a: number) => number;
  readonly ecr1_rb: (a: number) => number;
  readonly ed19_rb: (a: number) => number;
  readonly k256_rb: (a: number) => number;
  readonly s256_rb: (a: number) => number;
  readonly time_rb: (a: number) => number;
  readonly bal_rb: (a: number) => number;
  readonly jne_rb: (a: number) => number;
  readonly smo_rb: (a: number) => number;
  readonly addi_rb: (a: number) => number;
  readonly andi_rb: (a: number) => number;
  readonly divi_rb: (a: number) => number;
  readonly expi_rb: (a: number) => number;
  readonly modi_rb: (a: number) => number;
  readonly muli_rb: (a: number) => number;
  readonly ori_rb: (a: number) => number;
  readonly slli_rb: (a: number) => number;
  readonly srli_rb: (a: number) => number;
  readonly subi_rb: (a: number) => number;
  readonly xori_rb: (a: number) => number;
  readonly jnei_rb: (a: number) => number;
  readonly lb_rb: (a: number) => number;
  readonly lw_rb: (a: number) => number;
  readonly sb_rb: (a: number) => number;
  readonly sw_rb: (a: number) => number;
  readonly mcpi_rb: (a: number) => number;
  readonly gtf_rb: (a: number) => number;
  readonly jnzf_rb: (a: number) => number;
  readonly jnzb_rb: (a: number) => number;
  readonly jnef_rb: (a: number) => number;
  readonly jneb_rb: (a: number) => number;
  readonly wdcm_rb: (a: number) => number;
  readonly wqcm_rb: (a: number) => number;
  readonly wdop_rb: (a: number) => number;
  readonly wqop_rb: (a: number) => number;
  readonly wdml_rb: (a: number) => number;
  readonly wqml_rb: (a: number) => number;
  readonly wddv_rb: (a: number) => number;
  readonly wqdv_rb: (a: number) => number;
  readonly wdmd_rb: (a: number) => number;
  readonly wqmd_rb: (a: number) => number;
  readonly wdam_rb: (a: number) => number;
  readonly wqam_rb: (a: number) => number;
  readonly wdmm_rb: (a: number) => number;
  readonly wqmm_rb: (a: number) => number;
  readonly ecal_rb: (a: number) => number;
  readonly not_new_typescript: (a: number, b: number) => number;
  readonly retd_new_typescript: (a: number, b: number) => number;
  readonly move_new_typescript: (a: number, b: number) => number;
  readonly mcl_new_typescript: (a: number, b: number) => number;
  readonly burn_new_typescript: (a: number, b: number) => number;
  readonly croo_new_typescript: (a: number, b: number) => number;
  readonly csiz_new_typescript: (a: number, b: number) => number;
  readonly mint_new_typescript: (a: number, b: number) => number;
  readonly time_new_typescript: (a: number, b: number) => number;
  readonly mcli_imm18: (a: number) => number;
  readonly movi_imm18: (a: number) => number;
  readonly jnzi_imm18: (a: number) => number;
  readonly jmpf_imm18: (a: number) => number;
  readonly jmpb_imm18: (a: number) => number;
  readonly ji_imm24: (a: number) => number;
  readonly cfsi_imm24: (a: number) => number;
  readonly pshl_imm24: (a: number) => number;
  readonly pshh_imm24: (a: number) => number;
  readonly popl_imm24: (a: number) => number;
  readonly poph_imm24: (a: number) => number;
  readonly andi_imm12: (a: number) => number;
  readonly divi_imm12: (a: number) => number;
  readonly expi_imm12: (a: number) => number;
  readonly modi_imm12: (a: number) => number;
  readonly muli_imm12: (a: number) => number;
  readonly ori_imm12: (a: number) => number;
  readonly slli_imm12: (a: number) => number;
  readonly srli_imm12: (a: number) => number;
  readonly subi_imm12: (a: number) => number;
  readonly xori_imm12: (a: number) => number;
  readonly jnei_imm12: (a: number) => number;
  readonly lb_imm12: (a: number) => number;
  readonly lw_imm12: (a: number) => number;
  readonly sb_imm12: (a: number) => number;
  readonly sw_imm12: (a: number) => number;
  readonly mcpi_imm12: (a: number) => number;
  readonly gtf_imm12: (a: number) => number;
  readonly jnzf_imm12: (a: number) => number;
  readonly jnzb_imm12: (a: number) => number;
  readonly mcli_new_typescript: (a: number, b: number) => number;
  readonly movi_new_typescript: (a: number, b: number) => number;
  readonly jnzi_new_typescript: (a: number, b: number) => number;
  readonly jmpf_new_typescript: (a: number, b: number) => number;
  readonly jmpb_new_typescript: (a: number, b: number) => number;
  readonly and_ra: (a: number) => number;
  readonly div_ra: (a: number) => number;
  readonly eq_ra: (a: number) => number;
  readonly exp_ra: (a: number) => number;
  readonly gt_ra: (a: number) => number;
  readonly lt_ra: (a: number) => number;
  readonly mlog_ra: (a: number) => number;
  readonly mroo_ra: (a: number) => number;
  readonly mod_ra: (a: number) => number;
  readonly move_ra: (a: number) => number;
  readonly mul_ra: (a: number) => number;
  readonly not_ra: (a: number) => number;
  readonly or_ra: (a: number) => number;
  readonly sll_ra: (a: number) => number;
  readonly srl_ra: (a: number) => number;
  readonly sub_ra: (a: number) => number;
  readonly xor_ra: (a: number) => number;
  readonly mldv_ra: (a: number) => number;
  readonly ret_ra: (a: number) => number;
  readonly retd_ra: (a: number) => number;
  readonly aloc_ra: (a: number) => number;
  readonly mcl_ra: (a: number) => number;
  readonly mcp_ra: (a: number) => number;
  readonly meq_ra: (a: number) => number;
  readonly bhsh_ra: (a: number) => number;
  readonly bhei_ra: (a: number) => number;
  readonly burn_ra: (a: number) => number;
  readonly call_ra: (a: number) => number;
  readonly ccp_ra: (a: number) => number;
  readonly croo_ra: (a: number) => number;
  readonly csiz_ra: (a: number) => number;
  readonly cb_ra: (a: number) => number;
  readonly ldc_ra: (a: number) => number;
  readonly log_ra: (a: number) => number;
  readonly logd_ra: (a: number) => number;
  readonly mint_ra: (a: number) => number;
  readonly rvrt_ra: (a: number) => number;
  readonly scwq_ra: (a: number) => number;
  readonly srw_ra: (a: number) => number;
  readonly srwq_ra: (a: number) => number;
  readonly sww_ra: (a: number) => number;
  readonly swwq_ra: (a: number) => number;
  readonly tr_ra: (a: number) => number;
  readonly tro_ra: (a: number) => number;
  readonly eck1_ra: (a: number) => number;
  readonly ecr1_ra: (a: number) => number;
  readonly ed19_ra: (a: number) => number;
  readonly k256_ra: (a: number) => number;
  readonly s256_ra: (a: number) => number;
  readonly time_ra: (a: number) => number;
  readonly flag_ra: (a: number) => number;
  readonly bal_ra: (a: number) => number;
  readonly jmp_ra: (a: number) => number;
  readonly jne_ra: (a: number) => number;
  readonly smo_ra: (a: number) => number;
  readonly addi_ra: (a: number) => number;
  readonly andi_ra: (a: number) => number;
  readonly divi_ra: (a: number) => number;
  readonly expi_ra: (a: number) => number;
  readonly modi_ra: (a: number) => number;
  readonly muli_ra: (a: number) => number;
  readonly ori_ra: (a: number) => number;
  readonly slli_ra: (a: number) => number;
  readonly srli_ra: (a: number) => number;
  readonly subi_ra: (a: number) => number;
  readonly xori_ra: (a: number) => number;
  readonly jnei_ra: (a: number) => number;
  readonly lb_ra: (a: number) => number;
  readonly lw_ra: (a: number) => number;
  readonly sb_ra: (a: number) => number;
  readonly sw_ra: (a: number) => number;
  readonly mcpi_ra: (a: number) => number;
  readonly gtf_ra: (a: number) => number;
  readonly mcli_ra: (a: number) => number;
  readonly gm_ra: (a: number) => number;
  readonly movi_ra: (a: number) => number;
  readonly jnzi_ra: (a: number) => number;
  readonly jmpf_ra: (a: number) => number;
  readonly jmpb_ra: (a: number) => number;
  readonly jnzf_ra: (a: number) => number;
  readonly jnzb_ra: (a: number) => number;
  readonly jnef_ra: (a: number) => number;
  readonly jneb_ra: (a: number) => number;
  readonly cfe_ra: (a: number) => number;
  readonly cfs_ra: (a: number) => number;
  readonly wdcm_ra: (a: number) => number;
  readonly wqcm_ra: (a: number) => number;
  readonly wdop_ra: (a: number) => number;
  readonly wqop_ra: (a: number) => number;
  readonly wdml_ra: (a: number) => number;
  readonly wqml_ra: (a: number) => number;
  readonly wddv_ra: (a: number) => number;
  readonly wqdv_ra: (a: number) => number;
  readonly wdmd_ra: (a: number) => number;
  readonly wqmd_ra: (a: number) => number;
  readonly wdam_ra: (a: number) => number;
  readonly wqam_ra: (a: number) => number;
  readonly wdmm_ra: (a: number) => number;
  readonly wqmm_ra: (a: number) => number;
  readonly ecal_ra: (a: number) => number;
  readonly and_new_typescript: (a: number, b: number, c: number) => number;
  readonly div_new_typescript: (a: number, b: number, c: number) => number;
  readonly eq_new_typescript: (a: number, b: number, c: number) => number;
  readonly exp_new_typescript: (a: number, b: number, c: number) => number;
  readonly gt_new_typescript: (a: number, b: number, c: number) => number;
  readonly lt_new_typescript: (a: number, b: number, c: number) => number;
  readonly mlog_new_typescript: (a: number, b: number, c: number) => number;
  readonly mroo_new_typescript: (a: number, b: number, c: number) => number;
  readonly mod_new_typescript: (a: number, b: number, c: number) => number;
  readonly mul_new_typescript: (a: number, b: number, c: number) => number;
  readonly or_new_typescript: (a: number, b: number, c: number) => number;
  readonly sll_new_typescript: (a: number, b: number, c: number) => number;
  readonly srl_new_typescript: (a: number, b: number, c: number) => number;
  readonly sub_new_typescript: (a: number, b: number, c: number) => number;
  readonly xor_new_typescript: (a: number, b: number, c: number) => number;
  readonly mcp_new_typescript: (a: number, b: number, c: number) => number;
  readonly ldc_new_typescript: (a: number, b: number, c: number) => number;
  readonly scwq_new_typescript: (a: number, b: number, c: number) => number;
  readonly srw_new_typescript: (a: number, b: number, c: number) => number;
  readonly sww_new_typescript: (a: number, b: number, c: number) => number;
  readonly tr_new_typescript: (a: number, b: number, c: number) => number;
  readonly eck1_new_typescript: (a: number, b: number, c: number) => number;
  readonly ecr1_new_typescript: (a: number, b: number, c: number) => number;
  readonly ed19_new_typescript: (a: number, b: number, c: number) => number;
  readonly k256_new_typescript: (a: number, b: number, c: number) => number;
  readonly s256_new_typescript: (a: number, b: number, c: number) => number;
  readonly bal_new_typescript: (a: number, b: number, c: number) => number;
  readonly jne_new_typescript: (a: number, b: number, c: number) => number;
  readonly mldv_rd: (a: number) => number;
  readonly meq_rd: (a: number) => number;
  readonly ccp_rd: (a: number) => number;
  readonly log_rd: (a: number) => number;
  readonly logd_rd: (a: number) => number;
  readonly srwq_rd: (a: number) => number;
  readonly swwq_rd: (a: number) => number;
  readonly tro_rd: (a: number) => number;
  readonly smo_rd: (a: number) => number;
  readonly jnef_imm06: (a: number) => number;
  readonly jneb_imm06: (a: number) => number;
  readonly wdcm_imm06: (a: number) => number;
  readonly wqcm_imm06: (a: number) => number;
  readonly wdop_imm06: (a: number) => number;
  readonly wqop_imm06: (a: number) => number;
  readonly wdml_imm06: (a: number) => number;
  readonly wqml_imm06: (a: number) => number;
  readonly wddv_imm06: (a: number) => number;
  readonly wqdv_imm06: (a: number) => number;
  readonly wdmd_rd: (a: number) => number;
  readonly wqmd_rd: (a: number) => number;
  readonly wdam_rd: (a: number) => number;
  readonly wqam_rd: (a: number) => number;
  readonly wdmm_rd: (a: number) => number;
  readonly wqmm_rd: (a: number) => number;
  readonly ecal_rd: (a: number) => number;
  readonly ji_new_typescript: (a: number) => number;
  readonly cfsi_new_typescript: (a: number) => number;
  readonly pshl_new_typescript: (a: number) => number;
  readonly pshh_new_typescript: (a: number) => number;
  readonly popl_new_typescript: (a: number) => number;
  readonly poph_new_typescript: (a: number) => number;
  readonly __wbg_and_free: (a: number) => void;
  readonly __wbg_div_free: (a: number) => void;
  readonly __wbg_eq_free: (a: number) => void;
  readonly __wbg_exp_free: (a: number) => void;
  readonly __wbg_gt_free: (a: number) => void;
  readonly __wbg_lt_free: (a: number) => void;
  readonly __wbg_mlog_free: (a: number) => void;
  readonly __wbg_mroo_free: (a: number) => void;
  readonly __wbg_mod_free: (a: number) => void;
  readonly __wbg_move_free: (a: number) => void;
  readonly __wbg_mul_free: (a: number) => void;
  readonly __wbg_not_free: (a: number) => void;
  readonly __wbg_or_free: (a: number) => void;
  readonly __wbg_sll_free: (a: number) => void;
  readonly __wbg_srl_free: (a: number) => void;
  readonly __wbg_sub_free: (a: number) => void;
  readonly __wbg_xor_free: (a: number) => void;
  readonly __wbg_mldv_free: (a: number) => void;
  readonly __wbg_ret_free: (a: number) => void;
  readonly __wbg_retd_free: (a: number) => void;
  readonly __wbg_aloc_free: (a: number) => void;
  readonly __wbg_mcl_free: (a: number) => void;
  readonly __wbg_mcp_free: (a: number) => void;
  readonly __wbg_meq_free: (a: number) => void;
  readonly __wbg_bhsh_free: (a: number) => void;
  readonly __wbg_bhei_free: (a: number) => void;
  readonly __wbg_burn_free: (a: number) => void;
  readonly __wbg_call_free: (a: number) => void;
  readonly __wbg_ccp_free: (a: number) => void;
  readonly __wbg_croo_free: (a: number) => void;
  readonly __wbg_csiz_free: (a: number) => void;
  readonly __wbg_cb_free: (a: number) => void;
  readonly __wbg_ldc_free: (a: number) => void;
  readonly __wbg_log_free: (a: number) => void;
  readonly __wbg_logd_free: (a: number) => void;
  readonly __wbg_mint_free: (a: number) => void;
  readonly __wbg_rvrt_free: (a: number) => void;
  readonly __wbg_scwq_free: (a: number) => void;
  readonly __wbg_srw_free: (a: number) => void;
  readonly __wbg_srwq_free: (a: number) => void;
  readonly __wbg_sww_free: (a: number) => void;
  readonly __wbg_swwq_free: (a: number) => void;
  readonly __wbg_tr_free: (a: number) => void;
  readonly __wbg_tro_free: (a: number) => void;
  readonly __wbg_eck1_free: (a: number) => void;
  readonly __wbg_ecr1_free: (a: number) => void;
  readonly __wbg_ed19_free: (a: number) => void;
  readonly __wbg_k256_free: (a: number) => void;
  readonly __wbg_s256_free: (a: number) => void;
  readonly __wbg_time_free: (a: number) => void;
  readonly __wbg_noop_free: (a: number) => void;
  readonly __wbg_flag_free: (a: number) => void;
  readonly __wbg_bal_free: (a: number) => void;
  readonly __wbg_jmp_free: (a: number) => void;
  readonly __wbg_jne_free: (a: number) => void;
  readonly __wbg_smo_free: (a: number) => void;
  readonly __wbg_addi_free: (a: number) => void;
  readonly __wbg_andi_free: (a: number) => void;
  readonly __wbg_divi_free: (a: number) => void;
  readonly __wbg_expi_free: (a: number) => void;
  readonly __wbg_modi_free: (a: number) => void;
  readonly __wbg_muli_free: (a: number) => void;
  readonly __wbg_ori_free: (a: number) => void;
  readonly __wbg_slli_free: (a: number) => void;
  readonly __wbg_srli_free: (a: number) => void;
  readonly __wbg_subi_free: (a: number) => void;
  readonly __wbg_xori_free: (a: number) => void;
  readonly __wbg_jnei_free: (a: number) => void;
  readonly __wbg_lb_free: (a: number) => void;
  readonly __wbg_lw_free: (a: number) => void;
  readonly __wbg_sb_free: (a: number) => void;
  readonly __wbg_sw_free: (a: number) => void;
  readonly __wbg_mcpi_free: (a: number) => void;
  readonly __wbg_gtf_free: (a: number) => void;
  readonly __wbg_mcli_free: (a: number) => void;
  readonly __wbg_gm_free: (a: number) => void;
  readonly __wbg_movi_free: (a: number) => void;
  readonly __wbg_jnzi_free: (a: number) => void;
  readonly __wbg_jmpf_free: (a: number) => void;
  readonly __wbg_jmpb_free: (a: number) => void;
  readonly __wbg_jnzf_free: (a: number) => void;
  readonly __wbg_jnzb_free: (a: number) => void;
  readonly __wbg_jnef_free: (a: number) => void;
  readonly __wbg_jneb_free: (a: number) => void;
  readonly __wbg_ji_free: (a: number) => void;
  readonly __wbg_cfei_free: (a: number) => void;
  readonly __wbg_cfsi_free: (a: number) => void;
  readonly __wbg_cfe_free: (a: number) => void;
  readonly __wbg_cfs_free: (a: number) => void;
  readonly __wbg_pshl_free: (a: number) => void;
  readonly __wbg_pshh_free: (a: number) => void;
  readonly __wbg_popl_free: (a: number) => void;
  readonly __wbg_poph_free: (a: number) => void;
  readonly __wbg_wdcm_free: (a: number) => void;
  readonly __wbg_wqcm_free: (a: number) => void;
  readonly __wbg_wdop_free: (a: number) => void;
  readonly __wbg_wqop_free: (a: number) => void;
  readonly __wbg_wdml_free: (a: number) => void;
  readonly __wbg_wqml_free: (a: number) => void;
  readonly __wbg_wddv_free: (a: number) => void;
  readonly __wbg_wqdv_free: (a: number) => void;
  readonly __wbg_wdmd_free: (a: number) => void;
  readonly __wbg_wqmd_free: (a: number) => void;
  readonly __wbg_wdam_free: (a: number) => void;
  readonly __wbg_wqam_free: (a: number) => void;
  readonly __wbg_wdmm_free: (a: number) => void;
  readonly __wbg_wqmm_free: (a: number) => void;
  readonly __wbg_ecal_free: (a: number) => void;
  readonly ret_new_typescript: (a: number) => number;
  readonly bhei_new_typescript: (a: number) => number;
  readonly cb_new_typescript: (a: number) => number;
  readonly rvrt_new_typescript: (a: number) => number;
  readonly flag_new_typescript: (a: number) => number;
  readonly jmp_new_typescript: (a: number) => number;
  readonly cfe_new_typescript: (a: number) => number;
  readonly cfs_new_typescript: (a: number) => number;
  readonly __wbg_compareargs_free: (a: number) => void;
  readonly __wbg_get_compareargs_mode: (a: number) => number;
  readonly __wbg_set_compareargs_mode: (a: number, b: number) => void;
  readonly __wbg_get_compareargs_indirect_rhs: (a: number) => number;
  readonly __wbg_set_compareargs_indirect_rhs: (a: number, b: number) => void;
  readonly compareargs_to_imm: (a: number) => number;
  readonly compareargs_from_imm: (a: number) => number;
  readonly __wbg_get_mathargs_op: (a: number) => number;
  readonly __wbg_set_mathargs_op: (a: number, b: number) => void;
  readonly __wbg_get_mulargs_indirect_rhs: (a: number) => number;
  readonly __wbg_set_mulargs_indirect_rhs: (a: number, b: number) => void;
  readonly __wbg_panicinstruction_free: (a: number) => void;
  readonly panicinstruction_error_typescript: (a: number, b: number) => number;
  readonly panicinstruction_reason: (a: number) => number;
  readonly panicinstruction_instruction: (a: number) => number;
  readonly __wbg_set_mathargs_indirect_rhs: (a: number, b: number) => void;
  readonly __wbg_set_mulargs_indirect_lhs: (a: number, b: number) => void;
  readonly __wbg_set_divargs_indirect_rhs: (a: number, b: number) => void;
  readonly __wbg_get_mathargs_indirect_rhs: (a: number) => number;
  readonly __wbg_get_mulargs_indirect_lhs: (a: number) => number;
  readonly __wbg_get_divargs_indirect_rhs: (a: number) => number;
  readonly __wbg_mathargs_free: (a: number) => void;
  readonly __wbg_mulargs_free: (a: number) => void;
  readonly __wbg_divargs_free: (a: number) => void;
  readonly __wbg_imm06_free: (a: number) => void;
  readonly regid_new_checked: (a: number) => number;
  readonly regid_bal: () => number;
  readonly regid_cgas: () => number;
  readonly regid_err: () => number;
  readonly regid_flag: () => number;
  readonly regid_fp: () => number;
  readonly regid_ggas: () => number;
  readonly regid_hp: () => number;
  readonly regid_is: () => number;
  readonly regid_of: () => number;
  readonly regid_one: () => number;
  readonly regid_pc: () => number;
  readonly regid_ret: () => number;
  readonly regid_retl: () => number;
  readonly regid_sp: () => number;
  readonly regid_spp: () => number;
  readonly regid_writable: () => number;
  readonly regid_zero: () => number;
  readonly regid_new_typescript: (a: number) => number;
  readonly regid_to_u8: (a: number) => number;
  readonly __wbg_regid_free: (a: number) => void;
  readonly __wbg_imm12_free: (a: number) => void;
  readonly __wbg_imm18_free: (a: number) => void;
  readonly __wbg_imm24_free: (a: number) => void;
  readonly gm_from_args: (a: number, b: number) => number;
  readonly gtf_from_args: (a: number, b: number, c: number) => number;
  readonly gm_args: (a: number, b: number) => number;
  readonly gtf_args: (a: number, b: number, c: number) => number;
  readonly wdcm_from_args: (a: number, b: number, c: number, d: number) => number;
  readonly wdop_from_args: (a: number, b: number, c: number, d: number) => number;
  readonly wdml_from_args: (a: number, b: number, c: number, d: number) => number;
  readonly wddv_from_args: (a: number, b: number, c: number, d: number) => number;
  readonly wdcm_args: (a: number, b: number, c: number, d: number) => number;
  readonly wqcm_args: (a: number, b: number, c: number, d: number) => number;
  readonly wdop_args: (a: number, b: number, c: number, d: number) => number;
  readonly wqop_args: (a: number, b: number, c: number, d: number) => number;
  readonly wdml_args: (a: number, b: number, c: number, d: number) => number;
  readonly wqml_args: (a: number, b: number, c: number, d: number) => number;
  readonly wddv_args: (a: number, b: number, c: number, d: number) => number;
  readonly wqdv_args: (a: number, b: number, c: number, d: number) => number;
  readonly __wbg_instruction_free: (a: number) => void;
  readonly instruction_to_bytes: (a: number, b: number) => void;
  readonly instruction_size: () => number;
  readonly wqml_from_args: (a: number, b: number, c: number, d: number) => number;
  readonly wqcm_from_args: (a: number, b: number, c: number, d: number) => number;
  readonly wqop_from_args: (a: number, b: number, c: number, d: number) => number;
  readonly wqdv_from_args: (a: number, b: number, c: number, d: number) => number;
  readonly __wbindgen_add_to_stack_pointer: (a: number) => number;
  readonly __wbindgen_free: (a: number, b: number, c: number) => void;
}

type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {SyncInitInput} module
*
* @returns {InitOutput}
*/
declare function initSync(module: SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {InitInput | Promise<InitInput>} module_or_path
*
* @returns {Promise<InitOutput>}
*/
declare function __wbg_init (module_or_path?: InitInput | Promise<InitInput>): Promise<InitOutput>;

export { ADD, ADDI, ALOC, AND, ANDI, BAL, BHEI, BHSH, BURN, CALL, CB, CCP, CFE, CFEI, CFS, CFSI, CROO, CSIZ, CompareArgs, CompareMode, DIV, DIVI, DivArgs, ECAL, ECK1, ECR1, ED19, EQ, EXP, EXPI, FLAG, GM, GMArgs, GT, GTF, GTFArgs, Imm06, Imm12, Imm18, Imm24, InitInput, InitOutput, Instruction, JI, JMP, JMPB, JMPF, JNE, JNEB, JNEF, JNEI, JNZB, JNZF, JNZI, K256, LB, LDC, LOG, LOGD, LT, LW, MCL, MCLI, MCP, MCPI, MEQ, MINT, MLDV, MLOG, MOD, MODI, MOVE, MOVI, MROO, MUL, MULI, MathArgs, MathOp, MulArgs, NOOP, NOT, OR, ORI, POPH, POPL, PSHH, PSHL, PanicInstruction, PanicReason, RET, RETD, RVRT, RegId, S256, SB, SCWQ, SLL, SLLI, SMO, SRL, SRLI, SRW, SRWQ, SUB, SUBI, SW, SWW, SWWQ, SyncInitInput, TIME, TR, TRO, WDAM, WDCM, WDDV, WDMD, WDML, WDMM, WDOP, WQAM, WQCM, WQDV, WQMD, WQML, WQMM, WQOP, XOR, XORI, add, addi, aloc, and, andi, bal, bhei, bhsh, burn, call, cb, ccp, cfe, cfei, cfs, cfsi, croo, csiz, __wbg_init as default, div, divi, ecal, eck1, ecr1, ed19, eq, exp, expi, flag, gm, gm_args, gt, gtf, gtf_args, initSync, ji, jmp, jmpb, jmpf, jne, jneb, jnef, jnei, jnzb, jnzf, jnzi, k256, lb, ldc, log, logd, lt, lw, mcl, mcli, mcp, mcpi, meq, mint, mldv, mlog, mod_, modi, move_, movi, mroo, mul, muli, noop, not, or, ori, poph, popl, pshh, pshl, ret, retd, rvrt, s256, sb, scwq, sll, slli, smo, srl, srli, srw, srwq, sub, subi, sw, sww, swwq, time, tr, tro, wdam, wdcm, wdcm_args, wddv, wddv_args, wdmd, wdml, wdml_args, wdmm, wdop, wdop_args, wqam, wqcm, wqcm_args, wqdv, wqdv_args, wqmd, wqml, wqml_args, wqmm, wqop, wqop_args, xor, xori };
